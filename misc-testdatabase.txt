# Format is testid followed by a single space, followed by the actual test case

FSL-UT-FB-0010 autorun-fb.sh
FSL-UT-FB-0020 Execute a GUI application (Qtopia with Qt/Embedded)
FSL-UT-FB-0030 cat image.bin > /dev/fb0

FSL-UT-PF-0010 autorun-pf.sh

FSL-UT-MMC-0010 autorun-mmc.sh
FSL-UT-MMC-0020 dd if=/dev/zero of=/dev/mmcblk0 bs=1024 count=5
FSL-UT-MMC-0030 dd if=file_name of=/dev/mmcblk0
FSL-UT-MMC-0040 dd if=/dev/mmcblk0 of=output_file bs=1024 count=1
FSL-UT-MMC-0050 fdisk /dev/mmcblk0; fdisk -l /dev/mmcblk0;     
#Create the partitions on the card

FSL-UT-MMC-0060 mkfs.ext2 /dev/mmcblk0p1; mkfs.minix /dev/mmcblk0p1 no_blocks
#Format the card using mkfs.minix or mkfs.ext2,

FSL-UT-MMC-0070 mkdir /mnt/mmc_part1; mount -t ext2 /dev/mmcblk0p1 /mnt/mmc_part1; umount /mnt/mmc_part1
#Mount and Un-mount the file system

FSL-UT-MU-0010 autorun-mu.sh

FSL-UT-OPROFILE-0010 autorun-oprofile.sh
FSL-UT-OPROFILE-0020 opcontrol --event=ETMEXTOUT[0]:12cache_event_count --event=DREQ:1000

FSL-UT-PMIC-0010 autorun-pmic.sh
FSL-UT-PMIC-Protocol-0010 pmic_testapp -T S_IT_U
FSL-UT-PMIC-ADC-0010 pmic_testapp_adc -T CONV
FSL-UT-PMIC-ADC-0020 pmic_testapp_adc -T MON
FSL-UT-PMIC-Power-MOD-0010 mxc_pmic_power_testmod.ko
FSL-UT-PMIC-Power-0010 pmic_testapp_power -T 1
FSL-UT-PMIC-Power-0020 pmic_testapp_power -T 2
FSL-UT-PMIC-Power-0030 pmic_testapp_power -T 3
FSL-UT-PMIC-Power-0040 pmic_testapp_power -T 1
#not running pmic_testapp_battery -T 6 as it hangs, TODO FIX
FSL-UT-PMIC-Battery-0010 pmic_testapp_battery -T 6
FSL-UT-PMIC-Light-0010 pmic_testapp_light
				choose option:  5; 6; 7

# (PMIC_SC55112) Zeus only		
FSL-UT-PMIC-SC55112_Light-0010 pmic_sc55112_light_test/pmic_sc55112_light_test.out
					   choose option: 1,1,6

FSL-UT-PMIC-SC55112_Light-0020 pmic_sc55112_light_test/pmic_sc55112_light_test.out
					   choose option: 1,2,3

FSL-UT-PMIC-RTC-0010 pmic_testapp_rtc -T TEST

FSL-UT-RNG-0010 autorun-rng.sh
FSL-UT-RNG-0020 rng_test -S
FSL-UT-RNG-0030 rng_test -Rn
FSL-UT-RNG-0040 rng_test -Wn:v
FSL-UT-RNG-0050 rng_test -E n
FSL-UT-RNG-0060 rng_test -Ok -E n
FSL-UT-RNG-0070 rng_test -Zv
FSL-UT-RNG-0080 rng_test -Ok -Zv

FSL-UT-RTC-0010 autorun-rtc.sh

FSL-UT-SAHARA-0010 autorun-sahara.sh
#User Space

FSL-UT-SAHARA-0020 echo TacFghmrsw > /dev/shwtest
#Kernel Space

FSL-UT-SCC-0010 autorun-scc.sh

FSL-UT-RTIC-0010 mxc_security_test.out
root@freescale /unit_tests/modules$ insmod mxc_rtic_test.ko
root@freescale /unit_tests/modules$ cd ..
root@freescale /unit_tests$ cd mxc_security_test/
root@freescale /unit_tests/mxc_security_test$ ls
mxc_security_test.out
root@freescale /unit_tests/mxc_security_test$ ./mxc_security_test.out
========> Testing MXC security driver <========
Select the following security module to be tested:
1. HAC
2. RTIC
3. Exit
Enter your option:

For One time Hashing select option 1
For Run time hashing go for Option 2 after hardware reset.
For runtime Error check go for option 3 after hardware Reset.

FSL-UT-RTIC-0020 autorun-rtic.sh

FSL-UT-HACC-0010 autorun-hacc.sh

FSL-UT-V4L2-0010 autorun-v4l2.sh
FSL-UT-V4L2-overaly-sdc-0010 mxc_v4l2_overlay.out -iw 640 -ih 480 -it 0 -il 0 -ow 160 -oh 160 -ot 20 -ol 20 -r 0 -t 50 -d 0 -fg -fr 30
FSL-UT-V4L2-overlay-sdc-0020 mxc_v4l2_overlay.out -iw 640 -ih 480 -it 0 -il 0 -ow 160 -oh 160 -ot 20 -ol 20 -r 4 -t 50 -d 0 -fr 30
FSL-UT-V4L2-overlay-adc-0010 mxc_v4l2_overlay.out -iw 640 -ih 480 -it 0 -il 0 -ow 120 -oh 120 -ot 40 -ol 40 -r 0 -t 50 -d 1 -fg -fr 30
FSL-UT-V4L2-overlay-adc-0020 mxc_v4l2_overlay.out -iw 640 -ih 480 -it 0 -il 0 -ow 120 -oh 120 -ot 40 -ol 40 -r 4 -t 50 -d 1 -fg -fr 30
FSL-UT-V4L2-capture-0010 mxc_v4l2_capture.out -w 352 -h 288 -r 0 -c 50 -fr 30 test.yuv
FSL-UT-V4L2-capture-0020 mxc_v4l2_still.out -w 640 -h 480 -f YUV422P
FSL-UT-V4L2-output-0010 mxc_v4l2_output.out -iw 352 -ih 288 -ow 176 -oh 144 -r 0 -fr 20 test.yuv
FSL-UT-IPU-PostFilter-SDC-0010 mxc_mpeg4dec_test.out -ow width -oh height -d 3 test.mp4
FSL-UT-IPU-PostFilter-ADC-0020 mxc_mpeg4dec_test.out -ow width -oh height -d 0 test.mp4


FSL-UT-WDOG-0010 autorun-wdog.sh
FSL-UT-WDOG-0020 wdog_test.out 0
FSL-UT-WDOG-0030 wdog_test.out 1
FSL-UT-WDOG-0040 wdog_test.out 2
FSL-UT-WDOG-0050 wdog_test.out 3
FSL-UT-WDOG-0060 wdog_test.out 4
FSL-UT-WDOG-0070 wdt_driver_test.out 1 2 0 &
FSL-UT-WDOG-0080 wdt_driver_test.out 2 1 0 &


FSL-UT-FIRI-0010 autorun-firi.sh
FSL-UT-FIRI-0020
Below are the steps to test Fast IrDA using IrLAN on the board.
On one board:
modprobe irda
cp /lib/modules/2.6.18.1/kernel/net/irda/irlan/irlan.ko .
cp /lib/modules/2.6.18.1/kernel/drivers/net/irda/mxc_ir.ko .
insmod irlan.ko access=2
ifconfig irlan0 10.0.0.1 netmask 255.255.255.0 broadcast 10.0.0.255
insmod mxc_ir.ko
ifconfig irda0 up
echo 1 > /proc/sys/net/irda/discovery
ping 10.0.0.2

On the other board:
modprobe irda
cp /lib/modules/2.6.18.1/kernel/net/irda/irlan/irlan.ko .
cp /lib/modules/2.6.18.1/kernel/drivers/net/irda/mxc_ir.ko .
insmod irlan.ko access=2
ifconfig irlan0 10.0.0.2 netmask 255.255.255.0 broadcast 10.0.0.255
insmod mxc_ir.ko
ifconfig irda0 up
echo 1 > /proc/sys/net/irda/discovery
telnet 10.0.0.1

FSL-UT-UART-EXT-0010 ls >/dev/tts/0; ls >/dev/tts/1
#Redirect the output of a shell command to another UART.

FSL-UT-UART-EXT-0020 /bin/sh </dev/tts/1 >/dev/tts/1 2>/dev/tts/1 &
FSL-UT-UART-EXT-0030 exec -b 0x800000 -l 0x200000 -c "rw root=/dev/nfs nfsroot=10.193.100.211:/
			        home/r65130/rootdisk/mx21 console=ttyS0,115200"
#Boot up with external uart as console

FSL-UT-UART-EXT-0040 stty -F /dev/ttymxc/0 115200; cat >/dev/ttymxc/0
#Transmission/Reception of text/binary file

FSL-UT-UART-EXT-0050
Test for different baud rates/stop/parity bitsUse uart1 as console, use "stty" with different
baud rates/stop/parity bits to /dev/tts/0, use "cat >/dev/tts/0" or "cat
/dev/tts/0" to test if can receive and transmit data.

FSL-UT-UART-EXT-0060
Redirect the output of a shell command to another UARTUse command "stty -F
/dev/ttymxc/0 115200" to uart1, and then use ls >/dev/ttymxc/0 -- the output
should be printed on UART1s window.

FSL-UT-UART-MXC-0010 
Redirect the output of a shell command to another UART. Ensure both ends are using the same
baud rate and other port settings.
stty -F /dev/ttymxc/1 115200 -- set the baud rate of UART 2 to 115200
ls >/dev/ttymxc/1 -- the output should be printed on UART2s window

FSL-UT-UART-MXC-0020 
Start a shell in the background and redirect its standard input, standard output and standard error
to a different UART port
sh </dev/ttymxc/2 >/dev/ttymxc/2 2>/dev/ttymxc/2

FSL-UT-UART-MXC-0030 
Type the following command on the linux console
cat /dev/ttymxc/0
On the board, connect UART 1 to a serial port on your PC. Open a Hyperterminal window that is
connected to this serial port. Type characters in the Hyperterminal window. These characters
should be printed by the cat application in the console window. Text files should also be transferred
(Transfer->Send Text File). The contents of this file should be received by the cat received through
UART 1. Note that this test will not pass for serial ports which have the UART DMA
Enable/Disable (UARTx_DMA_ENABLE) configuration option set to 1 as the port will be operating
in a raw mode where the character input is not being parsed. This is expected behavior.

#test all internal MXC UART Ports (ttymxc/0..ttymxc/XX)
FSL-UT-UART-MXC-0040 mxc_uart_test.out /dev/ttymxc1  


FSL-UT-USB-ARC-HOST-PTP-0010
How to build?
enter ptp directory. Make the PTP driver module.
make CROSS_COMPILE=${CROSS_COMPILE}
Output: usbstillimage.ko
ct ptp/test
make CROSS_COMPILE=${CROSS_COMPILE}
Ouput: ptp_test
Material: One Digital Camera (DC). Set the DCs USB mode to PTP mode.
Step:
1. modprobe ehci-hcd
2. insmod usbstillimage.ko
3. Power on DC, and connect it to the board with USB cable.
4. Download the ptp_test to the board.
chmod 777 ptp_test
./ptp_test
If this function is not used, unload the following drivers
rmmod usbstillimage
rmmod ehci-hcd
	Display: Please input command:
	0: Exit
	1: Display device information
	2: Display storage information
	3: Display file information
	4: Get file
	5: Get file thumbnail
	6: Send a file
	7: Set file protection
	8: Delete file
	9: Format storage

input '1' and press Enter. It will display the device list and display the detailed device information such as
the manufacturer/model/serial number/operations supported.

press '2' and press Enter. It will display the detailed information of all the storage media in the device.

press '3' and press Enter. It will display the detailed information of all the files (objects) in the device. The
file ID for each file may be seen. This file ID can be used in the followed file test.

press '4' and press Enter. It will ask you to input the ID of the file to get. Just input the hex value (no '0x'
prefix needed), press Enter. It will start to get the file/object from the device, and save it to test.jpg in the
current directory on the platform. For robust test, unplug the device during the file reading process. It will
show some error message, but will not crash. Notice that you cannot get a directory, such as 'MISC'.

press '5' and press Enter. It will ask you to input the ID of the file to get the thumbnail. Just input the hex
value (no '0x' prefix needed), press Enter. It will start to get the file/object thumbnail from the device, and
save it to thumb.jpg in the current directory on the platform. For robust test, unplug the device during the
file reading process. It will show some error message but will not crash.

press '6' and press Enter. It will ask you to input the name of the source file to be sent from the platform to
the device. Just enter the files full path and name and press Enter.

Then it will ask you to input the directory handle where the file is to be put. The folder is the object with
the object Association Type 1. Choose a folder, for example "DCIM", input its object handle, and press
Enter. It will start to send the file.

To keep the best compatibility, the file will be forced into the picture format. This means that the device
will treat it as a picture file and arrange another sequence file name for it, not the source file name. After
it finishes sending the file, press "3" to show all the files, and see that a new file has been added.

If the device is unplugged during the write process, the driver will not crash, but sometimes the storage
information on the target device will be damaged. This is because of a design limitation of the target
device. Under Windows XP/2000 a USB device may not be unplugged when it is writing. Therefore, it is
recommended that the device not be unplugged during the write process.

press '7' and press Enter. It will ask you to input the ID of the file to set/clear file protection. Just input the
hex value (no '0x' prefix needed), press Enter. It will ask you to input the clear or set command. Press '1'
and press Enter to set file protection (or press '0' and press Enter to clear file protection).

press '8' and press Enter. It will ask you to input the ID of the file to delete. Just input the hex value (no '0x'
prefix needed), press Enter. It will try to delete the file. If the file is protected, it will show the delete fail
information.

press '9' and press Enter. It will ask you to input the ID of the storage to format. Just input the hex value
(no '0x' prefix needed) and press Enter. It will try to format the target storage media.
To quit the test, input 0 and press Enter.

Notes: Some DCs only support read operation and dont support write operation. On this type of DC steps
6 - 9 cant be executed, and the DC wont be able to send a file, set file protection, delete a file or format
storage.


FSL-UT-USB-ARC-HOST-MSC-0020
Step:
1. modprobe ehci-hcd
2. mkdir /mnt/udisk
3. Plug in a U-disk
4. cat /proc/partitions, e.g.
major minor #blocks name
31 0 256 mtdblock0
8 16 127744 sdb
find partitions with a major that is 8, this example , the sdb is U-disk partition.
5. mount -t vfat /dev/sdb /mnt/udisk
If this function is not used, unload the following drivers
umount /mnt/udisk
rmmod ehci-hcd

FSL-UT-USB-ARC-HOST-HID-0030
Material: USB mouse or USB keyboard.
Step:
1.modprobe ehci-hcd
2.modprobe usbhid
Insert USB mouse or USB keyboard.
3. ./evtest /dev/input/event2
If this function is not used, unload the following drivers.
rmmod usbhid
rmmod ehci-hcd
Notes:
1. For i.MX31, set:
USB support --> USB Human Interface Device (full HID) support. Select it as a module.
CONFIG_USB_HID=m
USB support --> HID input layer support. Select as built in. CONFIG_USB_HIDINPUT = y.
then
modprobe ehci-hcd
insmod usbhid.ko
2. About evtest tools, find evtest.c and compile under the current platform.
The evtest tool is a popular Linux open source tool, and can be found on the internet.


FSL-UT-USB-ARC-Peripheral-MSC-0010
If the NAND Flash is to be used as a USB peripheral:
1. Plug a NAND Flash card into the board.
2.Boot the board.
3.Select a NAND Flash "data/user" partition as USB peripheral, e.g.
/dev/mtdblock/8.
Assume this partition is 100MB size. Perform the following action only once.
4.dd bs=1M count=100 if=/dev/zero of=/dev/mtdblock/8
If using it as a U-disk, skip this step.
5.modprobe arcotg_udc
6.modprobe g_file_storage file="/dev/mtdblock/8"
Connect the board to the PC with a USB cable.
7. The PC should recognize the U-disk.
If this is the first time it has been used, it will have to be formatted.
On a PC, enter Computer Management tools, storage-> Disk Management. Following the PC tutor, get a
raw disk, create a partition on it, and format it with FAT or FAT32.
8. Files can now be transferred between the PC and the board.
To use a partition of the hard disk as a U disk:
Step:
Get a raw hard disk, and connect it to the ATA interface of board.
1. dd if=/dev/zero of=/dev/hda bs=1M count=100
2. reboot this board.
3. modprobe arcotg_udc
4. modprobe g_file_storage file="/dev/hda"
5. Use the PC to create a partition table, and format every partition.
On a PC using Windows, open "Computer Management", enter storage -> Disk Management
Enter Initialize and Convert Disk Wizard. Everything should be set to the default.
Create a partition table using the PC with Windows.
After creating a partition table, input the "sync" command in the Linux console.
6. Reboot this board, and look at the partition table (fdisk -l )
root@10 ~$ fdisk -l
Disk /dev/hda: 20.0 GB, 20003880960 bytes
255 heads, 63 sectors/track, 2432 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes
Device Boot Start End Blocks Id System
/dev/hda1 1 127 1020096 b W95 FAT32
/dev/hda2 128 2431 18506880 f W95 Ext'd (LBA)
/dev/hda5 128 254 1020096 6 FAT16
/dev/hda6 255 636 3068383+ b W95 FAT32
The above steps need to be done only once.
Each time it is used perform the following steps:
1. modprobe arcotg_udc
2. Set the hard disk partition as a USB disk.
modprobe g_file_storage file="/dev/hda"
3. Files may now be transferred between the PC and the board.
4. After finishing the file transfer, it can mounted
5. mount -t vfat /dev/hda6 /mnt/test
6. ls /mnt/test, everything here.
Notes:
1. Don't use the Linux format command (e.g. fdisk) to create a hard disk partition table. PC Windows must
be used to create it if one partition is to be used as a U disk.
2. Dont use this partition on the PC and the board at the same time.
3. If this function is not used, unload the following drivers
umount /mnt/test
rmmod g_file_storage
rmmod arcotg_udc


FSL-UT-USB-ARC-Peripheral-Ethernet-0020
Step:
1. modprobe arcotg_udc
2. modprobe g_ether
3. ifconfig usb0
4. ifconfig usb0 192.168.0.2 up
When first using the USB Ethernet, and the PC OS is Windows XP, a driver must be installed.
Use the BSP file: linux\Documentation\usb\linux.inf to install the driver.
5. On the PC (if running Windows), find a device named Linux USB Ethernet/RNDIS Gadget
Configure it with a fixed IP.
Press the right button on the mouse, and click on TCP/IP ' Properties '
Use the following IP address and settings:
192.168.0.1
255.255.255.0
192.168.0.1
Save these settings.
From the PC, ping 192.168.0.2.
If this function is not used, unload the following drivers
rmmod g_ether
rmmod arcotg_udc

To enable OTG HS: CONFIG_USB_EHCI_ARC_OTGHS = y
To enable OTG FS: CONFIG_USB_EHCI_ARC_OTGFS = y
1. For the i.MX27 board:
i.MX27 Hardware changes:
(1) If using High-Speed USB OTG (J9), remove RP11, RP12; then install RP3, RP4, RP5;
(2) If using Full-Speed USB OTG (J10), install RP11, RP12; then remove RP3, RP4, RP5;
Enable High-Speed USB HOST2 (J7), remove RP6, RP8; then install RP7, RP9. Remove R238, R239,
R240, R241, R246, R247, R248, R249.
Disable High-Speed USB HOST2 (J7), install RP6, RP8; then remove RP7, RP9. Install R238, R239,
R240, R241, R246, R247, R248, R249.
All these resistor packs are 0 Ohm.
i.MX27 Software changes:

Default, Host2 conflicts with CSPI2 and CSPI1,
To enable Host2, disable them by:
Device Drivers ---> SPI support, deselect this option.
2. For the i.MX31 ADS board
i.MX31 Hardware changes:
(1) If using High-Speed USB OTG (J1), remove U47,U48 IC;
(2) If using Full-Speed USB OTG (J2), install U47,U48 IC;
IC type is IDT74CBTLV3257Q.
All these resistor packs are 0 Ohm.
The USB Host2 port: pin conflicts with NAND Flash. If Host2 is to be used, remove the NAND Flash card
from board.


FSL-UT-USB-OTG-Peripherals-0010
The current USB-OTG release has support for the following peripherals:
1. Random Mouse function
2. Network Function
3. ACM Function
4. Mass Storage function
To test the Random Mouse function, use the default configurations.
1. After Linux boots up, connect the USB OTG cable to OTG transceiver of EVB and PC.
Notice that the PC mouse automatically moves randomly.
To run the Network function test, modify the .config as shown below:
1. Make menuconfig
2. Enter net-blan string to Composite Configuration (string), found in
Device Drivers->On-The-Go and USB Peripheral Support->Targeted Peripherals List ->
OTG Generic function->
OTG Generic Composite function options.
 Disable Random Mouse function.
 Select Network Function Driver.
 Enable MDLM-BLAN networking (Select Enable Older Network Protocols, Enable
MDLM-BLAN network, Append 32bit CRC and Support Vendor Requests to Configure
Network Interface).
 Save the config and build zImage.
3. Configure IP address, net mask, gateway to usbl0 using ifconfig.
The host PC should be installed with Belcarra USB LAN LINK Windows driver. Configure this
LAN link with IP address, net mask, gateway etc. Example ifconfig usbl0 10.0.0.2. Connect the
USB OTG cable to OTG transceiver of EVB and PC.
4. After configuring, test the network function using ping or telnet application.
To run an ACM function test, modify the .config as shown below:
1. make menuconfig
2. Enter acm-tty string to Composite Configuration (string), found in
Device Drivers->On-The-Go and USB Peripheral Support->Targeted Peripherals List->OTG
Generic function->OTG Generic Composite function options.
3. Disable the Random Mouse function.
4. Select an OTG ACM Function
5. Save the config and build zImage.
6. After Linux boots up, connect the USB OTG cable to OTG transceiver of EVB and PC.
The host PC should be installed with Microsoft WDM modem drivers configured to use with the
Belcarra ACM function driver.
7. Spawn a terminal on the ACM tty file by using the command getty -L ACM0 115200
vt100
8. Open hyperterminal at PC side with COM port created by the USB to serial class driver, you will
see the virtual console on it. Stop the hyperterminal before you un-plug the USB cable.
To run the Mass Storage function test, modify the .config as shown below:
1. make menuconfig
2. Enter msc string to Composite Configuration (string), found in
Device Drivers->On-The-Go and USB Peripheral Support->Targeted Peripherals List ->OTG
Generic function->OTG Generic Composite function options.
3. Disable the Random Mouse function.
4. Select a Mass Storage function
5. Save the config and build zImage.
After Linux boots up Now you will see an extra mass storage drive at PC side.
6. Run this command after downloading msc_admin to root directory ./msc_admin
msc_mount 1 0.
7. Connect the USB OTG cable to OTG transceiver of EVB and PC.
8. Now you can format and read/write to that drive.
To use the simulated block device method instead of ramdisk, replace step 6 with following steps:
1. Or use dd if=/dev/zero of=/root/sdloop bs=1024k count=16
2. losetup /dev/loop/0 /root/sdloop
3. msc_admin msc_mount 7 0


FSL-UT-USB-OTG-HOST-0020
The current USB-OTG release claims host support only for the ISP1301 USB transceiver, and it only
works as a kernel module. The only class driver supported now is the Belcarra LAN device. Here are the
steps:
1. Build the support for on-The-Go and USB Peripheral into the kernel.
2. Select Platform selection, either 1301 or MC13783 transceiver.
3. On-The-Go Options->
4. On the go or USB Device Configuration --->USB Peripheral or Host
5. Enable AutoStart.
6. OTG Fast Tracing
7. Targeted Peripherals List->
8. Integrate USBLAN into the kernel, OTG generic composite function option -> string to
net-blan.
9. Select OTG Network Function->select Network Function Driver, on OTG Network
Function
10. options->Select Enable MDLM-BLAN network, with the BLAN Network function
options->Select
11. Automatically configure the network interface.
12. Select support for host side USB build in kernel. Select support for Belcarra USBLAN networking
for USB in kernel. Set VID to 0x15ec and PID to 0xF001.
13. Connect the cable between the two MXC boards; mini-A on the host side and mini-B on the second
MXC board.
14. Do ifconfig, you will see usbl0 172.16.0.5
15. Go to the USB peripheral site, ifconfig usbl0 172.16.0.6
16. Do ping from both host and peripheral sites.

FSL-UT-USB-OTG-DualRole-0020
a kernel module. The only class driver supported now is the Belcarra LAN device.
To set up dual role support, follow these steps.
1. Build the support for on-The-Go and USB Peripheral into the kernel.
On-The-Go Options->
 On the go or USB Device Configuration --->OTG Device - can act as A or B Device
 Disable AutoStart.
Targeted Peripherals List - Repeat the peripheral network function test setup for usblan.
2. Select support for host side USB build in kernel, select support for Belcarra USBLAN networking
for USB in kernel, put the VID 0x15ec, PID 0xF001.
3. Connect in the cable between the two MXC boards, mini-A on the first board, mini-B on the second
MXC board.
4. Run the otg_admin application at both sides, type l for loading and followed by e for enabling.
The first board status should be a-idle, and the second board should be b-idle.
5. Type r on first board, the first board status will change to A-Device[host], the second board
will be B-Device[peripheral].
6. Run ifconfig. You will see usb0 10.0.0.1 on the first board and the second board ifconfig usbl0
10.0.0.2
7. Ping from both host and peripheral sites.
8. Now at the first board type r again, so both board status will become idle again. Then type r on the
second board, the first board status will become A-Device[peripheral] and second board
will be B-Device[host].
9. Run ifconfig, you will see usb0 10.0.0.1 on the second board and the first board ifconfig usbl0
10.0.0.2
10. Ping from both host and peripheral sites.


FSL-UT-LCDC-FB-0010
Framebuffer Tests:
 Redirecting an image directly to the background framebuffer device:
# cat image.bin > /dev/fb0
The panel to be enabled during Linux booting up can be specified by appending video options into the
kernel command line.
 Enable Sharp QVGA panel during Linux booting up. The kernel command line could be like:
noinitrd console=ttymxc0,115200 root=/dev/nfs
nfsroot=10.193.100.211:/rootdisk/ROOTFS rw init=/linuxrc ip=dhcp
video=mxcfb:Sharp-QVGA
 Enable NEC VGA panel during Linux booting up. The kernel command line could be like:
noinitrd console=ttymxc0,115200 root=/dev/nfs
nfsroot=10.193.100.211:/rootdisk/ROOTFS rw init=/linuxrc ip=dhcp video=mxcfb:NEC-VGA
 Enable PAL during Linux booting up. The kernel command line could be like:
noinitrd console=ttymxc0,115200 root=/dev/nfs
nfsroot=10.193.100.211:/rootdisk/ROOTFS rw init=/linuxrc ip=dhcp video=mxcfb:TV-PAL
 Enable NTSC during Linux booting up. The kernel command line could be like:
noinitrd console=ttymxc0,115200 root=/dev/nfs
nfsroot=10.193.100.211:/rootdisk/ROOTFS rw init=/linuxrc ip=dhcp video=mxcfb:TV-NTSC
If no video options are specified in kernel command line, the Sharp QVGA panel will be enabled by
default.

FSL-UT-TV-OUT-0010
Enable PAL during Linux booting up. The kernel command line could be like:
noinitrd console=ttymxc0,115200 root=/dev/nfs
nfsroot=10.193.100.211:/rootdisk/ROOTFS rw init=/linuxrc ip=dhcp video=mxcfb:TV-PAL

FSL-UT-TV-OUT-0020
Enable NTSC during Linux booting up. The kernel command line could be like:
noinitrd console=ttymxc0,115200 root=/dev/nfs
nfsroot=10.193.100.211:/rootdisk/ROOTFS rw init=/linuxrc ip=dhcp video=mxcfb:TV-NTSC

FSL-UT-TV-OUT-0030
Enable PAL mode:
#/unit_tests/mxc_fb_test/mxc_tvout_test.out -m p

FSL-UT-TV-OUT-0040
Enable NTSC mode:
#/unit_tests/mxc_fb_test/mxc_tvout_test.out -m n

FSL-UT-TV-OUT-0050
Enable TVout:
#/unit_tests/mxc_fb_test/mxc_tvout_test.out -e y

FSL-UT-TV-OUT-0060
Disable TVout:
#/unit_tests/mxc_fb_test/mxc_tvout_test.out -e n

FSL-UT-EMMA-overaly-0010 mxc_v4l2_overlay.out -iw 640 -ih 480 -it 0 -il 0 -ow 160 -oh 160 -ot 20 -ol 20 -t 50 -d 0 -fg -fr 30
FSL-UT-EMMA-overlay-0020 mxc_v4l2_overlay.out -iw 640 -ih 480 -ow 120 -oh 160 -t 50 -d 0 -r 4 -fr 30
FSL-UT-EMMA-capture-0010 mxc_v4l2_capture.out -w 352 -h 288 -c 50 -fr 30 test.yuv
FSL-UT-EMMA-capture-0020 mxc_v4l2_still.out -w 640 -h 480
FSL-UT-EMMA-output-0010 mxc_v4l2_output.out -iw 352 -ih 288 -ow 176 -oh 144 -d 0 -fg -fr 20 test.yuv

FSL-UT-HANTRO-PerfTest-0010
Hantro provides a unit test for the functions of Encoder kernel module and tested
Hantro API. The test application Perftest and the kernel module memalloc.ko are
distributed in the root filesystem as built binaries. These show up in the /root
directory of the root filesystem for the architecture supported hantro cif encoder
only. Once the kernel modules are properly loaded, the PerfTest application can be
invoked to encode a CIF yuv video stream file to MPEG4. The input file (not provided)
must be in the same directory as PerfTest (/root) and must be named stream.yuv. The
output file is named stream.mpeg4 and may be verified by playing it back on a host
PC using a suitable player such as mplayer (available by free download from
http://www.mplayerhq.hu). The test procedure is as follows:

root@10 ~$ insmod memalloc.ko
root@10 ~$ ./PerfTest

The stream.mpeg4 file, which is output, is stored in the /root directory.

FSL-UT-HANTRO-Stream-Enc-0010
The Test application named enctest along with above mentioned mxc_hmp4e.ko and memalloc.ko is
distributed in the root filesystem as built binary. It requires ten qcif and cif input YUV test streams for
p2sh3 test. Also seven input YUV test streams for p2sh7 test. Test procedure is as follows

Follow first two steps as mentioned above for PerfTest if you still not inserted mxc_hmp4e.ko and
memalloc.ko kernel modules.
Once the kernel modules are properly loaded, you must copy input YUV streams to same directory as
enctest test application with input YUV streams named as below
Ten QCIF YUV streams for P2SH3:
qcif_case1.yuv qcif_case61.yuv
qcif_case2.yuv qcif_case62.yuv
qcif_case3.yuv qcif_case63.yuv
qcif_case4.yuv qcif_case64.yuv
qcif_case5.yuv qcif_case65.yuv
Ten CIF YUV streams for P2SH3:
cif_case1.yuv cif_case61.yuv
cif_case2.yuv cif_case62.yuv
cif_case3.yuv cif_case63.yuv
cif_case4.yuv cif_case64.yuv
cif_case5.yuv cif_case65.yuv
Seven YUV streams for P2SH7:
p2sh7_case1.yuv
p2sh7_case2.yuv
p2sh7_case3.yuv
p2sh7_case4.yuv
p2sh7_case5.yuv
p2sh7_case6.yuv
p2sh7_case7.yuv
After getting all streams execute below command to get respective mpeg4 streams in the same directory
which can be verified in mpeg4 player(mplayer).
A home made test is called cam2mpeg4, which captures the camera stream and stores into
a mpeg4 file, the application source is under the
misc/source/test/mxc_mpeg4_enc_test/cam2mpeg4 directory.
cam2mpeg4 [width] [height] [number of frames] [frame rate] [filename]
The application will capture [number of frames] frames from the camera sensor and
pass it to the hantro encoder to generate a mpeg4 file called [filename] with size
defined by [width] and [height]. For example cam2mpeg4 352 288 50 30 test.mp4.

FSL-UT-VPU-LoopBack-0010 mxc_vpu_test.out -c codec.cfg.fifo.loopback.vga_to_qvga.h264

FSL-UT-VPU-LoopBack-0020 mxc_vpu_test.out -c codec.cfg.net.loopback.vga.h264
#Loopback demo through NET
The difference between <a> and <b> is the communication way. <a> is FIFO, while <b> is NET.

FSL-UT-VPU-LoopBack-0030 mxc_loopback_opt_test.out -c codec.cfg.opt.loopback.vga_to_qvga.h264
#Loopback demo (optimized version)

FSL-UT-VPU-StandAlone-Encode-0010 mxc_vpu_test.out -c codec.cfg.standalone.enc.vga.h264

FSL-UT-VPU-StandAlone-Decode-0020 mxc_vpu_test.out -c codec.cfg.standalone.dec.vga.h264

FSL-UT-VPU-RTP-ENCDEC-0010
RTP demo between two boards.
User could run by following commands on two different boards (or use do_test script)
./mxc_vpu_test.out -c codec.cfg.net.dec.vga.h264
./mxc_vpu_test.out -c codec.cfg.net.enc.vga.h264

FSL-UT-VPU-VGA-Panel-0010
VGA panel support
NEC VGA panel is supported both in kernel image and test program. By default, the kernel will use QVGA
panel. If user wants to use VGA panel, assign video=mxcfb:NEC-VGA in the kernel command line when
Linux boots up. At test program side, make sure the output size is suitable for LCD panel. Take QVGA
panel for example, if the bitstream resolution is 640x480, user can change out_ratio to be 4 or change
out_ratio to be 2 and rot_angle to be 90; otherwise, the program will give out error message Could
not start stream.

FSL-UT-MBX-Services-0010 /usr/local/bin/services_test
The MBX can be initialized using the rc.pvr script in the /etc/init.d directory. To load the drivers type
/etc/init.d/rc.pvr start on the HyperTerminal console.To unload the driver, type /etc/init.d/rc.pvr stop.

FSL-UT-MBX-EGL-0010 /usr/local/bin/egl_test 1000
No console messages are generated for egl_test. However, you should see two rotating triangles.


FSL-UT-ALSA-0010 aplay N M file.wav
Playback on stereo DAC:

FSL-UT-ALSA-0020 aplay N M D hw:0,1 file.wav
Playback on voice codec

FSL-UT-ALSA-0030 arecord r 8000 c 1 f S16_LE N M d 20 file.wav
ALSA recording

FSL-UT-ALSA-0040 alsamixer V all

FSL-UT-ALSA-0050 arecord -c 1 -f S16_LE -r 8000/16000 | aplay -D hw:0,1
Audio Loop Back

FSL-UT-OSS-Emulation-0010 check_audio.out 1 file.wav
Playback on stereo DAC:

FSL-UT-OSS-Emulation-0020 check_audio.out 0 file.wav
Playback on voice codec

FSL-UT-OSS-Emulation-0030 check_recording.out file.wav 2 100000 16000/8000 1
Use check_recording.out(in /unit_tests/mxc_sound_test)
./check_recording.out file.wav 2 num_bytes 8000/16000 c
2 -> Headset Mic
num_bytes is the number of bytes to be recorded at 8000/16000 sample rate with c channels. (c has to be 1
as only mono recording is supported)

FSL-UT-KEYPAD-0010 autorun-keypad.sh
FSL-UT-KEYPAD-0020 mxc_keyb_test.out
The test program does the following actions:
1. Opens event interface. The event interface in turn open MXC keypad driver
2. Does a read to test the key press and key release.
3. If the testing keypad is over key, press the END key to terminate the keypad testing.
4. Closes the device.
5. After running the below keypad application will print 2 messages for key press and key release.
For example if 1 is pressed on the keypad, the message appears as below,
6. KPP TEST APP: Pressed key is 1

FSL-UT-NOR-MTD-0010 
mkfs.jffs2 d jffs2 o fs.jffs2 e 0x20000 pad=0x400000

load -r -b 0x100000 fs.jffs2
fis write -f 0xa1b00000 -b 0x100000 -l 0x400000
fis create -l 0x400000 -f 0xa1b00000 -n myjffs2

for MX27:  fis write -f 0xc0000000 -b 0x100000 -l 0x400000
		fis create -l 0x400000 -f 0xc0000000 -n myjffs2

cd /tmp
mkdir jffs2
mount t jffs2 /dev/mtdblock/3 /tmp/jffs2

FSL-UT-NAND-MTD-0010 
1. Create a raw file containing a Jffs2 filesystem
$ mkfs.jffs2 -d /etc -o etc.jffs2 -e 0x4000 --pad=0x400000
2. Erase one of the NAND Flash partitions using flash_eraseall
$ flash_eraseall /dev/mtd/6
3. Write the Jffs2 image on to the NAND raw device
$ nandwrite /dev/mtd/6 etc.jffs2
4. Mount the NAND partition and read the files
$ mkdir -p /tmp/mtd/6
$ mount -t jffs2 /dev/mtdblock/6 /tmp/mtd/6
$ cd /tmp/mtd/6
$ find . # list all the files
$ find . -type f -exec cat {} \; >/dev/null # read all the files into /dev/null

FSL-UT-ETHERNET-0010 
ping OK
ftp OK (busybox 1.00)
dhcp OK
telnet OK
telnetd FAILED
nfs OK

FSL-UT-FEC-0010 
ping OK
ftp OK (busybox 1.00)
dhcp OK
telnet OK
telnetd FAILED
nfs OK

FSL-UT-SDMA-0010 /mxc_sdma_test/mxc_sdma_test.out
$cd unit_tests/modules/
$insmod mxc_sdma_mem_test.ko

FSL-UT-SDMA-TTY-0020 /mxc_sdma_tty_interactive_test/mxc_sdma_tty_interactive_test.out word1 word2 word3
Usage: sdma_tty_interactive_test <word1> <word2> <word3> ...
        The test will write all the words to sdma tty driver,
        read them back and print the read buffer on the terminal
        All the process will be done 10 times

FSL-UT-SDMA-0030 /mxc_sdma_tty_test/mxc_sdma_tty_test.out 0 or 1

FSL-UT-SDMA-0040 /mxc_sdma_tty_test/mxc_sdma_tty_test2.out 0 or 1
# Need a DSP image 

FSL-UT-UDMA-0010 /mxc_udma_test/mxc_udma_test.out 0 /*1D memory to memory dma is tested*/
$cd unit_tests/modules/
$insmod mxc_udma_testdriver.ko

FSL-UT-UDMA-0020 /mxc_udma_test/mxc_udma_test.out 1   /*1D memory to 2D memory dma is tested*/
FSL-UT-UDMA-0030 /mxc_udma_test/mxc_udma_test.out 5 3     /*chain buffer memory to memory dma is tested*/

FSL-UT-I2C-0010 
No testapp for I2C, run IPU or V4L tests

FSL-UT-1WIRE-0010 
If MXC 1-wire driver is successfully loaded, you will see the following entry,
/sys/devices/w1_bus_master1/23-00000051c3cb/eeprom
Open eeprom file and edit it. Save the file and power cycle or reset the board. Now, read back and same
file. If you see the contents then this verifies that MXC 1-wire driver has functioned correctly.

FSL-UT-1WIRE-0020 autorun-owire.sh

FSL-UT-IPC-0010 mxc_ipc_test.out -t 1
insmod /unit_tests/modules/ipctestmod.ko

FSL-UT-IPC-0020 mxc_ipc_test.out -t 2
FSL-UT-IPC-0030 mxc_ipc_test.out -t 3
FSL-UT-IPC-0040 mxc_ipc_test.out -t 4
FSL-UT-IPC-0050 mxc_ipc_test.out -t 5
FSL-UT-IPC-0060 mxc_ipc_test.out -t 6
FSL-UT-IPC-0070 mxc_ipc_test.out -t 8
FSL-UT-IPC-0080 mxc_ipc_test.out -t 20
FSL-UT-IPC-0090 mxc_ipc_test.out -t 21
FSL-UT-IPC-0100 mxc_ipc_test.out -t 22
FSL-UT-IPC-0110 mxc_ipc_test.out -t 23
FSL-UT-IPC-0120 mxc_ipc_test.out -t 24
FSL-UT-IPC-0130 mxc_ipc_test.out -t 25
FSL-UT-IPC-0140 mxc_ipc_test.out -t 26
FSL-UT-IPC-0150 mxc_ipc_test.out -t 27
FSL-UT-IPC-0160 mxc_ipc_test.out -t 28


FSL-UT-SSI-0010 
Please run ALSA tests


FSL-UT-PM-MX27-0010 
insmod mxc_pm_test.ko
./mxc_pm_test.out
root@freescale /unit_tests/mxc_pm_test$ ./mxc_pm_test.out
========== TESTING Low-level PM DRIVER ==========
Note that some option #'s may be skipped depending on platform.
So, enter the option number corresponding to each option correctly
Enter any of the following options:
1. Test Integer Scaling
2. Test PLL Scaling
3. Test Int/PLL Scaling (choice decided by PM driver)
4. Test Low Power Modes
5. Select CKOH output
9. Infinite loop cycling through operating points.
4
1. WAIT mode
2. DOZE mode
3. STOP mode
4. DSM mode
Enter a valid choice:
3
A key press will wake up the core for choice 3 (STOP mode).


FSL-UT-PM-MX31-0010 
insmod mxc_pm_test.ko
./mxc_pm_test.out
The actual frequency change or a voltage change request can only be measured and detected using an
oscilloscope.
The State Retention Mode can be tested only using DPM command, echo -n mem > /sys/power/state.
Unit-test cannot be used to test this mode.

FSL-UT-PM-MXC91131-0010 
insmod mxc_pm_test.ko
./mxc_pm_test.out

E.g.
Example 1:
root@(none) ~$ ./mxc_pm_test.out
========== TESTING Low-level PM DRIVER ==========
========== TESTING Low-level PM DRIVER ==========
Note that some option #'s may be skipped depending on platform.
So, enter the option number corresponding to each option correctly
Enter any of the following options:
1. Test Integer Scaling
2. Test PLL Scaling
3. Test Int/PLL Scaling (choice decided by PM driver)

Please note that option 3 is not available for MXC91331
4. Test Low Power Modes
5. Select CKOH output
6. Configure PMIC for High Voltage (Regs at 1.6V)
7. Configure PMIC for Low Voltage (Regs at 1.2V)
8. Configure PMIC for High & Low Voltage (Regs at 1.2 & 1.6V)

Please note that options 6,7,8 are not available for MXC91331
9. Infinite loop cycling through operating points.
Please note that option 9 is not available for MXC91331
8. Configure PMIC for High & Low Voltage (Regs at 1.2 & 1.6V)
3
Enter a valid ARM frequency:
532
You ============== INT/PLL Scale IOCTL ==============
have requested 532000000 Hz ARM Core frequency
root@(none) ~$ ./mxc_pm_test.out
========== TESTING Low-level PM DRIVER ==========
========== TESTING Low-level PM DRIVER ==========
Note that some option #'s may be skipped depending on platform.
So, enter the option number corresponding to each option correctly
Enter any of the following options:
1. Test Integer Scaling
2. Test PLL Scaling
3. Test Int/PLL Scaling (choice decided by PM driver)
Please note that option 3 is not available for MXC91331
4. Test Low Power Modes
5. Select CKOH output
6. Configure PMIC for High Voltage (Regs at 1.6V)
7. Configure PMIC for Low Voltage (Regs at 1.2V)
8. Configure PMIC for High & Low Voltage (Regs at 1.2 & 1.

Please note that options 6,7,8 are not available for MXC91331
9. Infinite loop cycling through operating points.
Please note that option 9 is not available for MXC91331
4
Enter low-power mode choice:
1. WAIT mode
2. STOP mode
3. DSM mode
Enter a valid choice:
2
============= Low-Power mode IOCTL ============
Testing low-power modes
To Test STOP mode
root@(none) ~$

 
FSL-UT-PM-MXC91221-0010 
insmod mxc_test.ko
./mxc_pm_test.out

E.g.
Example 1:root@freescale /unit_tests/mxc_pm_test$ ./mxc_pm_test.out
========== TESTING Low-level PM DRIVER ==========
Note that some option #'s may be skipped depending on platform.
So, enter the option number corresponding to each option correctly
Enter any of the following options:
1. Test Integer Scaling
2. Test PLL Scaling
3. Test Int/PLL Scaling (choice decided by PM driver)
4. Test Low Power Modes
5. Select CKOH output
4
Enter low-power mode choice:
1. WAIT mode
2. STOP mode
3. DSM mode
Enter a valid choice:
2
Testing low-power modes
============= Low-Power mode IOCTL ============
To Test STOP mode
Example 2:
root@freescale /unit_tests/mxc_pm_test$ ./mxc_pm_test.out
========== TESTING Low-level PM DRIVER ==========
Note that some option #'s may be skipped depending on platform.
So, enter the option number corresponding to each option correctly
Enter any of the following options:
1. Test Integer Scaling
2. Test PLL Scaling
3. Test Int/PLL Scaling (choice decided by PM driver)
4. Test Low Power Modes
5. Select CKOH output
4
Enter low-power mode choice:
1. WAIT mode
2. STOP mode
3. DSM mode
Enter a valid choice:
3
Testing low-power modes
============= Low-Power mode IOCTL ============
To Test DSM mode


FSL-UT-PM-MXC91231-0010 
insmod mxc_test.ko
./mxc_pm_test.out

E.g.
Example 1:
root@(none) ~$ ./mxc_pm_test.out [J
========== TESTING Low-level PM DRIVER ==========
Note that some option #'s may be skipped depending on platform.
So, enter the option number corresponding to each option correctly
Enter any of the following options:
1. Test Integer Scaling
2. Test PLL Scaling
3. Test Int/PLL Scaling (choice decided by PM driver)
Please note that option 3 is not available for MXC91331
4. Test Low Power Modes
5. Select CKOH output
6. Configure PMIC for High Voltage (Regs at 1.6V)
7. Configure PMIC for Low Voltage (Regs at 1.2V)
8. Configure PMIC for High & Low Voltage (Regs at 1.2 & 1.6V)
Please note that options 6,7,8 are not available for MXC91331
9. Infinite loop cycling through operating points.
Please note that option 9 is not available for MXC91331
3
Enter a valid ARM frequency:
532
You have requested 532000000 Hz ARM Core frequency
============== INT/PLL Scale IOCTL ==============
Calling INT/PLL Scaling
The result is 0
Note: in MXC91231 P1, the PLL will be set to 532MHz and the ARM frequency will be set to 266. This
is due to the SDRAMC issues discussed earlier. Also, keypad driver is now a TTY driver and therefore
there will not be any /dev entry for keypad which will give as error as Bad file descriptor but this will
not affect LLPM testing.
Example 2:
root@(none) ~$ ./mxc_pm_test.out [J
========== TESTING Low-level PM DRIVER ==========
Note that some option #'s may be skipped depending on platform.
So, enter the option number corresponding to each option correctly
Enter any of the following options:
1. Test Integer Scaling
2. Test PLL Scaling
3. Test Int/PLL Scaling (choice decided by PM driver)
Please note that option 3 is not available for MXC91331
4. Test Low Power Modes
5. Select CKOH output
6. Configure PMIC for High Voltage (Regs at 1.6V)
7. Configure PMIC for Low Voltage (Regs at 1.2V)
8. Configure PMIC for High & Low Voltage (Regs at 1.2 & 1.6V)
Please note that options 6,7,8 are not available for MXC91331
9. Infinite loop cycling through operating points.
Please note that option 9 is not available for MXC91331
4
Enter low-power mode choice (1,2,3):
1. WAIT mode
2. STOP mode
3. DSM mode
Enter a valid choice:
2
Testing low-power modes
============= Low-Power mode IOCTL ============
To Test STOP mode


FSL-UT-PM-MXC91321-0010 
insmod mxc_pm_test.ko
./mxc_pm_test.out

E.g.
Example 1:
root@(none) /unit_tests/module_test$ /unit_tests/mxc_pm_test/mxc_pm_test.out [J
========== TESTING Low-level PM DRIVER ==========
Note that some option #'s may be skipped depending on platform.
So, enter the option number corresponding to each option correctly
Enter any of the following options:
1. Test Integer Scaling
2. Test PLL Scaling
3. Test Int/PLL Scaling (choice decided by PM driver)
Please note that option 3 is not available for MXC91331
4. Test Low Power Modes
5. Select CKOH output
6. Configure PMIC for High Voltage (Regs at 1.6V)
7. Configure PMIC for Low Voltage (Regs at 1.2V)
8. Configure PMIC for High & Low Voltage (Regs at 1.2 & 1.6V)
Please note that options 6,7,8 are not available for MXC91331
9. Infinite loop cycling through operating points.
Please note that option 9 is not available for MXC91331
3
Enter a valid ARM frequency:
532
You have requested 532000000 Hz ARM Core frequency
============== INT/PLL Scale IOCTL ==============
The result is 0


FSL-UT-PM-MXC91331-0010 
insmod mxc_test.ko
./mxc_pm_test.out

E.g.
Example 1:
root@(none) ~$ ./mxc_pm_test.out
========== TESTING Low-level PM DRIVER ==========
Note that some option #'s may be skipped depending on platform.
So, enter the option number corresponding to each option correctly
Enter any of the following options:
1. Test Integer Scaling
2. Test PLL Scaling
3. Test Int/PLL Scaling (choice decided by PM driver)
4. Test Low Power Modes
5. Select CKOH output
1
Enter a valid ARM frequency:
400000000
Enter a valid AHB frequency:
100000000
Enter a valid IPG frequency:
50000000
You have requested 266000000 Hz ARM Core frequency
============== INT Scale IOCTL ==============
Calling Integer Scaling
The result is 0
root@(none) ~$
Example 2:

root@(none) ~$ ./mxc_pm_test.out
========== TESTING Low-level PM DRIVER ==========
Note that some option #'s may be skipped depending on platform.
So, enter the option number corresponding to each option correctly
Enter any of the following options:
1. Test Integer Scaling
2. Test PLL Scaling
3. Test Int/PLL Scaling (choice decided by PM driver)
4. Test Low Power Modes
5. Select CKOH output
1
Enter a valid ARM frequency:
100000000
Enter a valid AHB frequency:
100000000
Enter a valid IPG frequency:
50000000
You have requested 266000000 Hz ARM Core frequency
============== INT Scale IOCTL ==============
Calling Integer Scaling
The result is 0
root@(none) ~$



FSL-UT-DVFS-0010 
The driver can be tested using dptc_hi demo located at
LINUX2.6/misc/source/demo/dvfs_dptc_hi_demo/dvfs_dptc_hi.c. (Select Demo
Programs -> Available Demo Programs -> DVFS & DPTC Human Interface Demo option in
menuconfig).
The demo provides several options:
DPTC module status:
Enabled - 0
DVFS module status:
Enabled - 0
DPTC driver commands
1. Enable DPTCEnables DPTC. When DPTC is enabled, DPTC module status: Enabled - 1
appears above the menu.
2. Disable DPTCDisables DPTC. When DPTC is disabled, DPTC module status: Enabled - 0
appears above the menu.
3. Update DPTC driver translation tableUpdates the driver translation table. When it is chosen,
provide a file name for the new table.

4. Read DPTC driver translation tableDumps the table into a file. When it is chosen, provide an
output file name.
5. Set DPTC reference circuitsSets the reference circuit status. When it is chosen a number in
hexadecimal format should be provided. Only 4 LSBs are used, each bit corresponds to 1 of the 4
reference circuits. The number says which reference circuits should be enabled and which
reference circuits should be disabled.
6. Show DPTC log bufferShows the log buffer. The log buffer is a table with 2 columns: time point
and DPTC working point. It can be used to verify that DPTC changes the voltages when it is
enabled. The table updates automatically, until the key is pressed to exit from the menu.
7. Set DPTC working pointSets a DPTC working point. It can be used for debugging only, and is
activated only when DPTC is disabled. It updates the voltage according to new working point
number.
------------------------
DVFS driver commands
8. Enable DVFSEnables DVFS. When DVFS is enabled, DVFS module status: Enabled - 1
should appear above the menu.
9. Disable DVFSDisables DVFS. When DVFS is disabled, DVFS module status: Enabled - 0
should appear above the menu.
a) Set SW general purpose bitsWrites to SW general purpose bits. A number in hexadecimal format
should be provided. Only 4 LSBs will be used. These 4 bits will be written to register
b)Set WFI monitorEnables/disables WFI monitoring. If WFI monitoring is disabled, then DVFS will
take into account only general purpose bits.
c)Show frequencyDisplays current frequency.
------------------------
------------------------
q) QuitQuits the program.
For testing DPTC, use options 1 and 2 to enable/disable DPTC. Use option 6 to see that the voltage is
changing. Use option 5 to select reference circuits. Use option 3 and 4 to update and dump the driver
translation table.
For testing DVFS, use options 8 and 9 to enable/disable DVFS. Use option c to see that the frequency is
changing.


FSL-UT-DPTC-0010 
The driver can be tested using dptc_hi demo located at
LINUX2.6/misc/source/demo/dptc_hi_demo/dptc_hi.c. (Select Demo Programs ->
Available Demo Programs -> DPTC Human Interface Demo option in menuconfig).
The demo provides eight options, each based on a DPTC driver command:
1. 1) Enable DPTCEnables DPTC. When DPTC is enabled, DPTC module status: Enabled - 1
should appear above the menu.
2. 2) Disable DPTCDisables DPTC. When DPTC is disabled, DPTC module status: Enabled - 0
should appear above the menu
3. 3) Update DPTC driver translation tableUpdates the driver translation table. When it is chosen,
the file name with new table should be provided
4. 4) Read DPTC driver translation tableDumps the table to a file. When it is chosen, the output file
name should be provided.
5. 5) Set DPTC reference circuitsSets the reference circuit status. When it is chosen, a number in
hexadecimal format should be provided. Only 4 LSBs are used, each bit corresponds to one of the
four reference circuits. The number says which reference circuits should be enabled and which
reference circuits should be disabled.
6. 6) Show DPTC log bufferShows the log buffer. The log buffer shows a table with two columns:
time point and DPTC working point. It can be used to see that DPTC changes the voltages when it
is enabled. The table updates automatically, until some key is pressed to exit from the menu.
7. 7) Set DPTC working pointSets the DPTC working point. It can be used for debugging only. It
is working only when DPTC is disabled. It updates the voltage according to new working point
number.
8. 8) QuitQuits the program.
To test the driver, use Options 1 and 2 to enable/disable the DPTC. Use Option 6 to verify that the voltage
is changing. Use Option 5 to select reference circuits. Use Options 3 and 4 to update and dump the driver
translation table.


FSL-UT-DPTC-0020 
The driver can be tested using dptc_hi demo located at LINUX2.6/misc/source/demo/dptc_hi_demo/
dptc_hi.c. (Select Demo Programs -> Available Demo Programs -> DPTC Human Interface Demo option
in menuconfig).
This demo provides several options:
DPTC driver commands tested in the demo
 Enable DPTCEnables DPTC. When DPTC is enabled, DPTC module status: Enabled - 1
appears above the menu
 Disable DPTCDisables DPTC. When DPTC is disabled, DPTC module status: Enabled - 0
appears above the menu.
 Update DPTC driver translation tableUpdates the driver translation table. When this command
is chosen, a file name for the new table must be provided.
 Read DPTC driver translation tableDumps the table into a file. When this command is chosen,
the output file name must be provided.
 Set DPTC reference circuitsSets the reference circuit status. When this command is chosen, a
number in hexadecimal format must be provided. Only 4 LSBs are used, and each bit corresponds
to one of the four reference circuits. The number determines which reference circuits should be
enabled and which reference circuits should be disabled.
 Show DPTC log bufferShows the log buffer. The log buffer shows a table with two columns:
time point and DPTC working point. It can be used to determine how DPTC changes the voltages
when it is enabled. The table updates automatically, until some key is pressed to exit from the
menu.
 Set DPTC working pointSets the DPTC working point. It can be used for debugging only. It
works only when DPTC is disabled. It updates the voltage according to the new working point
number.
 Quitquits the program.
For testing whether the driver is working at all, use the enable and disable DPTC commands. Use the Show
DPTC Log Buffer command to see how the voltage is changing. Use the Set DPTC Reference Circuit
command to select reference circuits. Use the Update DPTC driver translation table command and the
Read DPTC driver translation table command to update and dump the driver translation table.


FSL-UT-MINIBOOT-0010 
Once the UART is enabled, successful test conditions can be verified by displaying messages on the
console.
 Test transmitter and receiver functions of the UART by entering data at the terminal and reprinting
it.
 Test the menu options selected by displaying the option on the terminal through the UART.
 Test the command line options by displaying the option on the terminal through the UART.
 Test the bad kernel by checking its CRC and displaying the message on the terminal through the
UART whether the CRC is a success or failure.
 Display the hexadecimal source address of the Linux kernel where it is located, and the destination
address from where it should execute.

FSL-UT-NANDBOOT-0010 

As this is boot code, once the UART is up, successful test conditions can be verified by displaying
messages on the console. Enable UNIT_TEST flag in source files to enable unit testing support.
 Testing transmitter and receiver functions of UART by entering data at the terminal and reprinting
it.
 Testing the menu options selected by displaying the option on the terminal through UART.
 Testing the command line options by displaying the option on the terminal through UART.
 Testing the bad kernel by checking its CRC and displaying the message on UART if successful or
failure. Displaying the hexadecimal source address of Linux kernel where it is located and
destination address from where it should execute.
