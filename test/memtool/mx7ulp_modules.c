#include "memtools_register_info.h"

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ADC_16FIFO_15_CMD_BUFFER
#endif

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_VERID.
static const field_t hw_adc_16fifo_15_cmd_buffer_verid[] =
{
    {
        "RES",
        "This read only field indicates the maximum accuracy supported by this "
        "implementation.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIFFEN",
        "This read only field indicates if differential operation is supported "
        "by this implementation.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MVI",
        "This read only field indicates if multiple Voltage Reference High inpu"
        "ts are supported by this implementation.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSW",
        "This read only field indicates if channel scaling is supported by this"
        " implementation.",
        4, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VR1RNGI",
        "This read only field indicates if a control bit is implemented for sel"
        "ecting the input voltage range on Voltage Reference Option 1.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IADCKI",
        "This read only field indicates if this implementation of the ADC block"
        " includes an internal clock source.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CALOFSI",
        "This read only field indicates if a calibration function and trimming "
        "control register are implemented.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read only field returns the minor version number for the module s"
        "pecification.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read only field returns the major version number for the module s"
        "pecification.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_PARAM.
static const field_t hw_adc_16fifo_15_cmd_buffer_param[] =
{
    {
        "TRIG_NUM",
        "Number of Triggers implemented.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FIFOSIZE",
        "The maximum number of conversion datawords that can be stored in the r"
        "esult FIFO before an overflow occurs.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CV_NUM",
        "Number of compare value registers implemented.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMD_NUM",
        "Number of command buffers implemented.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CTRL.
static const field_t hw_adc_16fifo_15_cmd_buffer_ctrl[] =
{
    {
        "ADCEN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        "Reset all ADC internal logic and registers, except the Control Registe"
        "r.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZEN",
        "Control system transition to Stop and Wait power modes while ADC is co"
        "nverting.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTFIFO",
        "",
        8, // LSB
        8, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_STAT.
static const field_t hw_adc_16fifo_15_cmd_buffer_stat[] =
{
    {
        "RDY",
        "Indicates when the number of valid datawords in the result FIFO is gre"
        "ater than the watermark level set in the FCTRL[FWMARK] bitfield.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FOF",
        "Indicates that more data has been written to the Result FIFO than it c"
        "an hold.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGACT",
        "TRGACT is a read-only status field indicating the trigger associated w"
        "ith the command actively being processed.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDACT",
        "CMDACT is a read-only status field indicating the command that is acti"
        "vely being processed.",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_IE.
static const field_t hw_adc_16fifo_15_cmd_buffer_ie[] =
{
    {
        "FWMIE",
        "Configures ADC to generate watermark interrupt requests when RDY flag "
        "is asserted.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FOFIE",
        "Configures ADC to generate overflow interrupt requests when FOF flag i"
        "s asserted.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_DE.
static const field_t hw_adc_16fifo_15_cmd_buffer_de[] =
{
    {
        "FWMDE",
        "Configures ADC to generate DMA requests when RDY flag is asserted.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CFG.
static const field_t hw_adc_16fifo_15_cmd_buffer_cfg[] =
{
    {
        "TPRICTRL",
        "This bitfield controls how higher priority triggers are handled.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWRSEL",
        "Configures the ADC for power and performance.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFSEL",
        "Selects the voltage reference high used for conversions.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUDLY",
        "When CFG[PWREN]=0b0, the ADC analog circuits are only powered while th"
        "e ADC is active and there is a counted delay defined by CFG[PUDLY] aft"
        "er an initial trigger transitions the ADC from its Idle state to allow"
        " time for the analog circuits to stabilize.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWREN",
        "Enables the ADC analog circuits.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_PAUSE.
static const field_t hw_adc_16fifo_15_cmd_buffer_pause[] =
{
    {
        "PAUSEDLY",
        "When PAUSEEN is set, the PAUSEDLY field controls the duration of pausi"
        "ng during command exection sequencing.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAUSEEN",
        "Enables the ADC pausing function.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_FCTRL.
static const field_t hw_adc_16fifo_15_cmd_buffer_fctrl[] =
{
    {
        "FCOUNT",
        "This read-only field indicates the number of datawords that are stored"
        " in the result FIFO.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FWMARK",
        "FWMARK is a programmable threshold setting.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_SWTRIG.
static const field_t hw_adc_16fifo_15_cmd_buffer_swtrig[] =
{
    {
        "SWT0",
        "Write 1 to SWT0 generates a trigger 0 event.",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "SWT1",
        "Write 1 to SWT1 generates a trigger 1 event.",
        1, // LSB
        1, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_TCTRL0.
static const field_t hw_adc_16fifo_15_cmd_buffer_tctrl0[] =
{
    {
        "HTEN",
        "Enable hardware trigger source to initiate conversion on the rising ed"
        "ge of the input trigger source.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPRI",
        "This bitfield sets the priority of the associated trigger source.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDLY",
        "Select the trigger delay duration to wait at the start of servicing a "
        "trigger event.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCMD",
        "Select the command from command buffer to execute upon detect of the a"
        "ssociated trigger event.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_TCTRL1.
static const field_t hw_adc_16fifo_15_cmd_buffer_tctrl1[] =
{
    {
        "HTEN",
        "Enable hardware trigger source to initiate conversion on the rising ed"
        "ge of the input trigger source.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPRI",
        "This bitfield sets the priority of the associated trigger source.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDLY",
        "Select the trigger delay duration to wait at the start of servicing a "
        "trigger event.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCMD",
        "Select the command from command buffer to execute upon detect of the a"
        "ssociated trigger event.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDL1.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdl1[] =
{
    {
        "ADCH",
        "Each ADCH channel selection has an associated A side and an associated"
        " B side input.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEL",
        "When DIFF=0b0, ABSEL selects the channel from either the A-side or B-s"
        "ide channel inputs.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIFF",
        "Configures the ADC to operate in differential mode or single-ended mod"
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSCALE",
        "Reduce the selected ADC analog channel input voltage level by a factor"
        ".",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDL2.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdl2[] =
{
    {
        "ADCH",
        "Each ADCH channel selection has an associated A side and an associated"
        " B side input.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEL",
        "When DIFF=0b0, ABSEL selects the channel from either the A-side or B-s"
        "ide channel inputs.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIFF",
        "Configures the ADC to operate in differential mode or single-ended mod"
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSCALE",
        "Reduce the selected ADC analog channel input voltage level by a factor"
        ".",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDL3.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdl3[] =
{
    {
        "ADCH",
        "Each ADCH channel selection has an associated A side and an associated"
        " B side input.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEL",
        "When DIFF=0b0, ABSEL selects the channel from either the A-side or B-s"
        "ide channel inputs.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIFF",
        "Configures the ADC to operate in differential mode or single-ended mod"
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSCALE",
        "Reduce the selected ADC analog channel input voltage level by a factor"
        ".",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDL4.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdl4[] =
{
    {
        "ADCH",
        "Each ADCH channel selection has an associated A side and an associated"
        " B side input.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEL",
        "When DIFF=0b0, ABSEL selects the channel from either the A-side or B-s"
        "ide channel inputs.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIFF",
        "Configures the ADC to operate in differential mode or single-ended mod"
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSCALE",
        "Reduce the selected ADC analog channel input voltage level by a factor"
        ".",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDL5.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdl5[] =
{
    {
        "ADCH",
        "Each ADCH channel selection has an associated A side and an associated"
        " B side input.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEL",
        "When DIFF=0b0, ABSEL selects the channel from either the A-side or B-s"
        "ide channel inputs.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIFF",
        "Configures the ADC to operate in differential mode or single-ended mod"
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSCALE",
        "Reduce the selected ADC analog channel input voltage level by a factor"
        ".",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDL6.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdl6[] =
{
    {
        "ADCH",
        "Each ADCH channel selection has an associated A side and an associated"
        " B side input.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEL",
        "When DIFF=0b0, ABSEL selects the channel from either the A-side or B-s"
        "ide channel inputs.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIFF",
        "Configures the ADC to operate in differential mode or single-ended mod"
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSCALE",
        "Reduce the selected ADC analog channel input voltage level by a factor"
        ".",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDL7.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdl7[] =
{
    {
        "ADCH",
        "Each ADCH channel selection has an associated A side and an associated"
        " B side input.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEL",
        "When DIFF=0b0, ABSEL selects the channel from either the A-side or B-s"
        "ide channel inputs.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIFF",
        "Configures the ADC to operate in differential mode or single-ended mod"
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSCALE",
        "Reduce the selected ADC analog channel input voltage level by a factor"
        ".",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDL8.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdl8[] =
{
    {
        "ADCH",
        "Each ADCH channel selection has an associated A side and an associated"
        " B side input.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEL",
        "When DIFF=0b0, ABSEL selects the channel from either the A-side or B-s"
        "ide channel inputs.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIFF",
        "Configures the ADC to operate in differential mode or single-ended mod"
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSCALE",
        "Reduce the selected ADC analog channel input voltage level by a factor"
        ".",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDL9.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdl9[] =
{
    {
        "ADCH",
        "Each ADCH channel selection has an associated A side and an associated"
        " B side input.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEL",
        "When DIFF=0b0, ABSEL selects the channel from either the A-side or B-s"
        "ide channel inputs.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIFF",
        "Configures the ADC to operate in differential mode or single-ended mod"
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSCALE",
        "Reduce the selected ADC analog channel input voltage level by a factor"
        ".",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDL10.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdl10[] =
{
    {
        "ADCH",
        "Each ADCH channel selection has an associated A side and an associated"
        " B side input.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEL",
        "When DIFF=0b0, ABSEL selects the channel from either the A-side or B-s"
        "ide channel inputs.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIFF",
        "Configures the ADC to operate in differential mode or single-ended mod"
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSCALE",
        "Reduce the selected ADC analog channel input voltage level by a factor"
        ".",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDL11.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdl11[] =
{
    {
        "ADCH",
        "Each ADCH channel selection has an associated A side and an associated"
        " B side input.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEL",
        "When DIFF=0b0, ABSEL selects the channel from either the A-side or B-s"
        "ide channel inputs.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIFF",
        "Configures the ADC to operate in differential mode or single-ended mod"
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSCALE",
        "Reduce the selected ADC analog channel input voltage level by a factor"
        ".",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDL12.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdl12[] =
{
    {
        "ADCH",
        "Each ADCH channel selection has an associated A side and an associated"
        " B side input.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEL",
        "When DIFF=0b0, ABSEL selects the channel from either the A-side or B-s"
        "ide channel inputs.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIFF",
        "Configures the ADC to operate in differential mode or single-ended mod"
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSCALE",
        "Reduce the selected ADC analog channel input voltage level by a factor"
        ".",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDL13.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdl13[] =
{
    {
        "ADCH",
        "Each ADCH channel selection has an associated A side and an associated"
        " B side input.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEL",
        "When DIFF=0b0, ABSEL selects the channel from either the A-side or B-s"
        "ide channel inputs.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIFF",
        "Configures the ADC to operate in differential mode or single-ended mod"
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSCALE",
        "Reduce the selected ADC analog channel input voltage level by a factor"
        ".",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDL14.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdl14[] =
{
    {
        "ADCH",
        "Each ADCH channel selection has an associated A side and an associated"
        " B side input.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEL",
        "When DIFF=0b0, ABSEL selects the channel from either the A-side or B-s"
        "ide channel inputs.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIFF",
        "Configures the ADC to operate in differential mode or single-ended mod"
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSCALE",
        "Reduce the selected ADC analog channel input voltage level by a factor"
        ".",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDL15.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdl15[] =
{
    {
        "ADCH",
        "Each ADCH channel selection has an associated A side and an associated"
        " B side input.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEL",
        "When DIFF=0b0, ABSEL selects the channel from either the A-side or B-s"
        "ide channel inputs.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIFF",
        "Configures the ADC to operate in differential mode or single-ended mod"
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSCALE",
        "Reduce the selected ADC analog channel input voltage level by a factor"
        ".",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDH1.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdh1[] =
{
    {
        "CMPEN",
        "After an ADC channel input is sampled and converted and any averaging "
        "iterations are performed, the CMDHa[CMPEN] field guides operation of t"
        "he automatic compare function to optionally only store when the compar"
        "e operation is true.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LWI",
        "When LWI is clear, the LOOP field selects the number of times the sele"
        "cted channel is converted consecutively.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "When programmed to 000 the minimum sample time of 3 ADCK cycles is sel"
        "ected.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Selects how many ADC conversions are averaged to create the ADC result"
        " (2AVGS).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Selects how many times this command executes (and stores conversion re"
        "sult to RESFIFO) before finish and transition to the next command or I"
        "dle state.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT",
        "Selects the next command to be executed after this command completes.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDH2.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdh2[] =
{
    {
        "CMPEN",
        "After an ADC channel input is sampled and converted and any averaging "
        "iterations are performed, the CMDHa[CMPEN] field guides operation of t"
        "he automatic compare function to optionally only store when the compar"
        "e operation is true.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LWI",
        "When LWI is clear, the LOOP field selects the number of times the sele"
        "cted channel is converted consecutively.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "When programmed to 000 the minimum sample time of 3 ADCK cycles is sel"
        "ected.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Selects how many ADC conversions are averaged to create the ADC result"
        " (2AVGS).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Selects how many times this command executes (and stores conversion re"
        "sult to RESFIFO) before finish and transition to the next command or I"
        "dle state.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT",
        "Selects the next command to be executed after this command completes.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDH3.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdh3[] =
{
    {
        "CMPEN",
        "After an ADC channel input is sampled and converted and any averaging "
        "iterations are performed, the CMDHa[CMPEN] field guides operation of t"
        "he automatic compare function to optionally only store when the compar"
        "e operation is true.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LWI",
        "When LWI is clear, the LOOP field selects the number of times the sele"
        "cted channel is converted consecutively.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "When programmed to 000 the minimum sample time of 3 ADCK cycles is sel"
        "ected.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Selects how many ADC conversions are averaged to create the ADC result"
        " (2AVGS).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Selects how many times this command executes (and stores conversion re"
        "sult to RESFIFO) before finish and transition to the next command or I"
        "dle state.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT",
        "Selects the next command to be executed after this command completes.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDH4.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdh4[] =
{
    {
        "CMPEN",
        "After an ADC channel input is sampled and converted and any averaging "
        "iterations are performed, the CMDHa[CMPEN] field guides operation of t"
        "he automatic compare function to optionally only store when the compar"
        "e operation is true.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LWI",
        "When LWI is clear, the LOOP field selects the number of times the sele"
        "cted channel is converted consecutively.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "When programmed to 000 the minimum sample time of 3 ADCK cycles is sel"
        "ected.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Selects how many ADC conversions are averaged to create the ADC result"
        " (2AVGS).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Selects how many times this command executes (and stores conversion re"
        "sult to RESFIFO) before finish and transition to the next command or I"
        "dle state.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT",
        "Selects the next command to be executed after this command completes.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDH5.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdh5[] =
{
    {
        "LWI",
        "When LWI is clear, the LOOP field selects the number of times the sele"
        "cted channel is converted consecutively.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "When programmed to 000 the minimum sample time of 3 ADCK cycles is sel"
        "ected.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Selects how many ADC conversions are averaged to create the ADC result"
        " (2AVGS).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Selects how many times this command executes (and stores conversion re"
        "sult to RESFIFO) before finish and transition to the next command or I"
        "dle state.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT",
        "Selects the next command to be executed after this command completes.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDH6.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdh6[] =
{
    {
        "LWI",
        "When LWI is clear, the LOOP field selects the number of times the sele"
        "cted channel is converted consecutively.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "When programmed to 000 the minimum sample time of 3 ADCK cycles is sel"
        "ected.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Selects how many ADC conversions are averaged to create the ADC result"
        " (2AVGS).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Selects how many times this command executes (and stores conversion re"
        "sult to RESFIFO) before finish and transition to the next command or I"
        "dle state.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT",
        "Selects the next command to be executed after this command completes.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDH7.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdh7[] =
{
    {
        "LWI",
        "When LWI is clear, the LOOP field selects the number of times the sele"
        "cted channel is converted consecutively.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "When programmed to 000 the minimum sample time of 3 ADCK cycles is sel"
        "ected.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Selects how many ADC conversions are averaged to create the ADC result"
        " (2AVGS).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Selects how many times this command executes (and stores conversion re"
        "sult to RESFIFO) before finish and transition to the next command or I"
        "dle state.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT",
        "Selects the next command to be executed after this command completes.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDH8.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdh8[] =
{
    {
        "LWI",
        "When LWI is clear, the LOOP field selects the number of times the sele"
        "cted channel is converted consecutively.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "When programmed to 000 the minimum sample time of 3 ADCK cycles is sel"
        "ected.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Selects how many ADC conversions are averaged to create the ADC result"
        " (2AVGS).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Selects how many times this command executes (and stores conversion re"
        "sult to RESFIFO) before finish and transition to the next command or I"
        "dle state.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT",
        "Selects the next command to be executed after this command completes.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDH9.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdh9[] =
{
    {
        "LWI",
        "When LWI is clear, the LOOP field selects the number of times the sele"
        "cted channel is converted consecutively.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "When programmed to 000 the minimum sample time of 3 ADCK cycles is sel"
        "ected.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Selects how many ADC conversions are averaged to create the ADC result"
        " (2AVGS).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Selects how many times this command executes (and stores conversion re"
        "sult to RESFIFO) before finish and transition to the next command or I"
        "dle state.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT",
        "Selects the next command to be executed after this command completes.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDH10.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdh10[] =
{
    {
        "LWI",
        "When LWI is clear, the LOOP field selects the number of times the sele"
        "cted channel is converted consecutively.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "When programmed to 000 the minimum sample time of 3 ADCK cycles is sel"
        "ected.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Selects how many ADC conversions are averaged to create the ADC result"
        " (2AVGS).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Selects how many times this command executes (and stores conversion re"
        "sult to RESFIFO) before finish and transition to the next command or I"
        "dle state.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT",
        "Selects the next command to be executed after this command completes.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDH11.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdh11[] =
{
    {
        "LWI",
        "When LWI is clear, the LOOP field selects the number of times the sele"
        "cted channel is converted consecutively.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "When programmed to 000 the minimum sample time of 3 ADCK cycles is sel"
        "ected.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Selects how many ADC conversions are averaged to create the ADC result"
        " (2AVGS).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Selects how many times this command executes (and stores conversion re"
        "sult to RESFIFO) before finish and transition to the next command or I"
        "dle state.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT",
        "Selects the next command to be executed after this command completes.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDH12.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdh12[] =
{
    {
        "LWI",
        "When LWI is clear, the LOOP field selects the number of times the sele"
        "cted channel is converted consecutively.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "When programmed to 000 the minimum sample time of 3 ADCK cycles is sel"
        "ected.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Selects how many ADC conversions are averaged to create the ADC result"
        " (2AVGS).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Selects how many times this command executes (and stores conversion re"
        "sult to RESFIFO) before finish and transition to the next command or I"
        "dle state.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT",
        "Selects the next command to be executed after this command completes.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDH13.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdh13[] =
{
    {
        "LWI",
        "When LWI is clear, the LOOP field selects the number of times the sele"
        "cted channel is converted consecutively.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "When programmed to 000 the minimum sample time of 3 ADCK cycles is sel"
        "ected.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Selects how many ADC conversions are averaged to create the ADC result"
        " (2AVGS).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Selects how many times this command executes (and stores conversion re"
        "sult to RESFIFO) before finish and transition to the next command or I"
        "dle state.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT",
        "Selects the next command to be executed after this command completes.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDH14.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdh14[] =
{
    {
        "LWI",
        "When LWI is clear, the LOOP field selects the number of times the sele"
        "cted channel is converted consecutively.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "When programmed to 000 the minimum sample time of 3 ADCK cycles is sel"
        "ected.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Selects how many ADC conversions are averaged to create the ADC result"
        " (2AVGS).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Selects how many times this command executes (and stores conversion re"
        "sult to RESFIFO) before finish and transition to the next command or I"
        "dle state.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT",
        "Selects the next command to be executed after this command completes.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CMDH15.
static const field_t hw_adc_16fifo_15_cmd_buffer_cmdh15[] =
{
    {
        "LWI",
        "When LWI is clear, the LOOP field selects the number of times the sele"
        "cted channel is converted consecutively.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "When programmed to 000 the minimum sample time of 3 ADCK cycles is sel"
        "ected.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Selects how many ADC conversions are averaged to create the ADC result"
        " (2AVGS).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Selects how many times this command executes (and stores conversion re"
        "sult to RESFIFO) before finish and transition to the next command or I"
        "dle state.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT",
        "Selects the next command to be executed after this command completes.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CV1.
static const field_t hw_adc_16fifo_15_cmd_buffer_cv1[] =
{
    {
        "CVL",
        "The compare function can be configured to check whether the result is "
        "less than, greater than, or if the result falls within or outside a ra"
        "nge determined by two compare values.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CVH",
        "The compare function can be configured to check whether the result is "
        "less than, greater than, or if the result falls within or outside a ra"
        "nge determined by two compare values.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CV2.
static const field_t hw_adc_16fifo_15_cmd_buffer_cv2[] =
{
    {
        "CVL",
        "The compare function can be configured to check whether the result is "
        "less than, greater than, or if the result falls within or outside a ra"
        "nge determined by two compare values.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CVH",
        "The compare function can be configured to check whether the result is "
        "less than, greater than, or if the result falls within or outside a ra"
        "nge determined by two compare values.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CV3.
static const field_t hw_adc_16fifo_15_cmd_buffer_cv3[] =
{
    {
        "CVL",
        "The compare function can be configured to check whether the result is "
        "less than, greater than, or if the result falls within or outside a ra"
        "nge determined by two compare values.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CVH",
        "The compare function can be configured to check whether the result is "
        "less than, greater than, or if the result falls within or outside a ra"
        "nge determined by two compare values.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_CV4.
static const field_t hw_adc_16fifo_15_cmd_buffer_cv4[] =
{
    {
        "CVL",
        "The compare function can be configured to check whether the result is "
        "less than, greater than, or if the result falls within or outside a ra"
        "nge determined by two compare values.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CVH",
        "The compare function can be configured to check whether the result is "
        "less than, greater than, or if the result falls within or outside a ra"
        "nge determined by two compare values.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_16FIFO_15_CMD_BUFFER_RESFIFO.
static const field_t hw_adc_16fifo_15_cmd_buffer_resfifo[] =
{
    {
        "D",
        "The formatting for the data in D is summarized in Data result register"
        " format description.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSRC",
        "Indicate the trigger source that initiated a conversion and generated "
        "this result.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOOPCNT",
        "Indicate the loop count value during command execution that generated "
        "this result.",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDSRC",
        "Indicate the command buffer being executed that generated this result.",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALID",
        "Indicate the FIFO entry is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a ADC_16FIFO_15_CMD_BUFFER module.
static const reg_t hw_adc_16fifo_15_cmd_buffer[] =
{
    {
        "VERID",
        "The Version ID register indicates the version integrated for this inst"
        "ance on the device and also indicates inclusion/exclusion of several o"
        "ptional features.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        9, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_verid
    },
    {
        "PARAM",
        "The Parameter register indicates the size of several variable integrat"
        "ion options for this instance on the device.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_param
    },
    {
        "CTRL",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_ctrl
    },
    {
        "STAT",
        "The Status Register provides the current status of the ADC module.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_stat
    },
    {
        "IE",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_ie
    },
    {
        "DE",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_de
    },
    {
        "CFG",
        "The Configuration Register controls ADC functions that are common to a"
        "ll commands.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cfg
    },
    {
        "PAUSE",
        "The Pause Register controls an optional inserted delay between convers"
        "ions.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_pause
    },
    {
        "FCTRL",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_fctrl
    },
    {
        "SWTRIG",
        "The Software Trigger Register (SWTRIG) is written to initiate software"
        " triggered conversions.",
        4, // Width in bytes
        0x00000034, // Base address offset
        false, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_swtrig
    },
    {
        "TCTRL0",
        "The Trigger Control (TCTRLa) register implements control fields associ"
        "ated with each implemented trigger source.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_tctrl0
    },
    {
        "TCTRL1",
        "The Trigger Control (TCTRLa) register implements control fields associ"
        "ated with each implemented trigger source.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_tctrl1
    },
    {
        "CMDL1",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdl1
    },
    {
        "CMDL2",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdl2
    },
    {
        "CMDL3",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdl3
    },
    {
        "CMDL4",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdl4
    },
    {
        "CMDL5",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdl5
    },
    {
        "CMDL6",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdl6
    },
    {
        "CMDL7",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdl7
    },
    {
        "CMDL8",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdl8
    },
    {
        "CMDL9",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdl9
    },
    {
        "CMDL10",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdl10
    },
    {
        "CMDL11",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdl11
    },
    {
        "CMDL12",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdl12
    },
    {
        "CMDL13",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdl13
    },
    {
        "CMDL14",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdl14
    },
    {
        "CMDL15",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdl15
    },
    {
        "CMDH1",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdh1
    },
    {
        "CMDH2",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdh2
    },
    {
        "CMDH3",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdh3
    },
    {
        "CMDH4",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdh4
    },
    {
        "CMDH5",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdh5
    },
    {
        "CMDH6",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdh6
    },
    {
        "CMDH7",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdh7
    },
    {
        "CMDH8",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdh8
    },
    {
        "CMDH9",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdh9
    },
    {
        "CMDH10",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdh10
    },
    {
        "CMDH11",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdh11
    },
    {
        "CMDH12",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdh12
    },
    {
        "CMDH13",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdh13
    },
    {
        "CMDH14",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdh14
    },
    {
        "CMDH15",
        "There are 15 command buffers (CMDa), each constructed from two 32-bit "
        "registers (CMDLa:CMDHa) that can be configured for different channel s"
        "elect and varying conversion options.",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cmdh15
    },
    {
        "CV1",
        "The compare value registers (CVa) contain values used to compare the c"
        "onversion result when the compare function is enabled.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cv1
    },
    {
        "CV2",
        "The compare value registers (CVa) contain values used to compare the c"
        "onversion result when the compare function is enabled.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cv2
    },
    {
        "CV3",
        "The compare value registers (CVa) contain values used to compare the c"
        "onversion result when the compare function is enabled.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cv3
    },
    {
        "CV4",
        "The compare value registers (CVa) contain values used to compare the c"
        "onversion result when the compare function is enabled.",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_cv4
    },
    {
        "RESFIFO",
        "The data result FIFO register (RESFIFO) is a 16 entry FIFO that stores"
        " the data result of ADC conversions.",
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_adc_16fifo_15_cmd_buffer_resfifo
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark AXBS
#endif

// Registers in a AXBS module.
static const reg_t hw_axbs[] =
{
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark CMP
#endif

// Bitfields in register CMP_VERID.
static const field_t hw_cmp_verid[] =
{
    {
        "FEATURE",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CMP_PARAM.
static const field_t hw_cmp_param[] =
{
    {
        "PARAM",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CMP_C0.
static const field_t hw_cmp_c0[] =
{
    {
        "HYSTCTR",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTER_CNT",
        "This field specifies the number of consecutive samples that must agree"
        " prior to the comparator ouput filter accepting a new output state.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN",
        "The EN bit enables the Analog Comparator Module.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPE",
        "The OPE bit enables the path from the comparator output to a selected "
        "pin.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COS",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVT",
        "This bit allows selecting the polarity of the analog comparator functi"
        "on.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PMODE",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WE",
        "If a write to this register attempts to set both SE and WE, then only "
        "Sampling mode is taking effect in MCU Run mode and the Round Robin Cyc"
        "ling(Trigger Mode) is enabled in MCU STOP mode.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "If a write to this register attempts to set both SE and WE, then only "
        "Sampling mode is taking effect in MCU Run mode and the Round Robin Cyc"
        "ling(Trigger Mode) is enabled in MCU STOP mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPR",
        "Specifies the sampling period, in bus clock cycles, of the comparator "
        "output filter, when C1[SE] = 0.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COUT",
        "Returns the current value of the Analog Comparator output, when read.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CFF",
        "Detects a falling-edge on COUT, when set, during normal operation.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CFR",
        "Detects a rising-edge on COUT, when set, during normal operation.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IEF",
        "Enables the CFF interrupt from the CMP.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IER",
        "Enables the CFR interrupt from the CMP.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAEN",
        "Enables the DMA transfer triggered from the CMP module.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKEN",
        "This bit is used to enable the link from CMP to DAC enables.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CMP_C1.
static const field_t hw_cmp_c1[] =
{
    {
        "VOSEL",
        "This bit selects an output voltage from one of 256 distinct levels.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMODE",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VRSEL",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DACEN",
        "This bit is used to enable the DAC.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DACOE",
        "This bit is used to enable the DAC output.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHN0",
        "Channel 0 of the input enable for the round-robin checker.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHN1",
        "Channel 1 of the input enable for the round-robin checker.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHN2",
        "Channel 2 of the input enable for the round-robin checker.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHN3",
        "Channel 3 of the input enable for the round-robin checker.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHN4",
        "Channel 4 of the input enable for the round-robin checker.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHN5",
        "Channel 5 of the input enable for the round-robin checker.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSEL",
        "These bits determine which input is selected for the negative mux.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSEL",
        "These bits determines which input is selected for the positive mux.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CMP_C2.
static const field_t hw_cmp_c2[] =
{
    {
        "ACON",
        "The result of the input comparison for channel n .",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INITMOD",
        "These values specify the round robin clock cycles used to determine th"
        "e comparator and DAC initialization delays specified by the datasheet.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NSAM",
        "For a given channel, this field specifies how many round-robin clock c"
        "ycles later the sample takes place.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH0F",
        "External Channel 0 input changed flag.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1F",
        "External Channel 1 input changed flag.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2F",
        "External Channel 2 input changed flag.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3F",
        "External Channel 3 input changed flag.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4F",
        "External Channel 4 input changed flag.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5F",
        "External Channel 5 input changed flag.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FXMXCH",
        "This field indicates which channel in the mux port is fixed in a given"
        " round-robin mode.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FXMP",
        "This bit is used to fix the analog mux port for the round-robin mode.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RRIE",
        "This bit enables the interrupt/wake-up when the comparison result chan"
        "ges for a given channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CMP_C3.
static const field_t hw_cmp_c3[] =
{
    {
        "ACPH2TC",
        "These values configures the analog comparator phase2 timing when RDIV "
        "is set to 1 which means the input volage level is above 1.8v.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACPH1TC",
        "These values configures the analog comparator phase1 timing when RDIV "
        "is set to 1 which means the input volage level is above 1.8v.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACSAT",
        "These values configures the analog comparator sampling timing(speicifi"
        "ed by the discrete mode clock period T which is selected by DMCS) in d"
        "iscrete mode.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMCS",
        "This bit is used to select the clock source in order to generate the r"
        "equiried timing for comparator to work in discrete mode.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDIVE",
        "This bit is used to enable the resistor divider for the inputs when th"
        "ey come from 3v domain and their values are above 1.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NCHCTEN",
        "This bit is used to enable the negative channel working in continuous "
        "mode.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCHCTEN",
        "This bit is used to enable the positive channel working in continuous "
        "mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a CMP module.
static const reg_t hw_cmp[] =
{
    {
        "VERID",
        "Access: Supervisor read only User read only",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_cmp_verid
    },
    {
        "PARAM",
        "Access: Supervisor read only User read only",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_cmp_param
    },
    {
        "C0",
        "Access: Supervisor read/write User read/write",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_cmp_c0
    },
    {
        "C1",
        "Access: Supervisor read/write User read/write",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_cmp_c1
    },
    {
        "C2",
        "Access: Supervisor read/write User read/write",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_cmp_c2
    },
    {
        "C3",
        "Access: Supervisor read/write User read/write",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_cmp_c3
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark CRC
#endif

// Bitfields in register CRC_DATA.
static const field_t hw_crc_data[] =
{
    {
        "LL",
        "When CTRL[WAS] is 1, values written to this field are part of the seed"
        " value.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LU",
        "When CTRL[WAS] is 1, values written to this field are part of the seed"
        " value.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HL",
        "In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for progr"
        "amming a seed value.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HU",
        "In 16-bit CRC mode (CTRL[TCRC] is 0), this field is not used for progr"
        "amming a seed value.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CRC_GPOLY.
static const field_t hw_crc_gpoly[] =
{
    {
        "LOW",
        "Writable and readable in both 32-bit and 16-bit CRC modes.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HIGH",
        "Writable and readable in 32-bit CRC mode (CTRL[TCRC] is 1).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CRC_CTRL.
static const field_t hw_crc_ctrl[] =
{
    {
        "TCRC",
        "Width of CRC protocol.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAS",
        "When asserted, a value written to the CRC data register is considered "
        "a seed value.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FXOR",
        "Some CRC protocols require the final checksum to be XORed with 0xFFFFF"
        "FFF or 0xFFFF.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOTR",
        "Identifies the transpose configuration of the value read from the CRC "
        "Data register.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOT",
        "Defines the transpose configuration of the data written to the CRC dat"
        "a register.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a CRC module.
static const reg_t hw_crc[] =
{
    {
        "DATA",
        "The CRC Data register contains the value of the seed, data, and checks"
        "um.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_crc_data
    },
    {
        "GPOLY",
        "This register contains the value of the polynomial for the CRC calcula"
        "tion.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_crc_gpoly
    },
    {
        "CTRL",
        "This register controls the configuration and working of the CRC module"
        ".",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_crc_ctrl
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark DAC
#endif

// Bitfields in register DAC_VERID.
static const field_t hw_dac_verid[] =
{
    {
        "FEATURE",
        "This read-only field returns the feature set number.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read-only field returns the minor version number for the module s"
        "pecification.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read-only field returns the major version number for the module s"
        "pecification.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DAC_PARAM.
static const field_t hw_dac_param[] =
{
    {
        "FIFOSZ",
        "The number of words in the DAC FIFO is 2^(FIFOSZ+1).",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DAC_DATA.
static const field_t hw_dac_data[] =
{
    {
        "DATA0",
        "",
        0, // LSB
        11, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DAC_CR.
static const field_t hw_dac_cr[] =
{
    {
        "FULLF",
        "This is the FIFO Full status bit.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEMPTF",
        "This is the FIFO nearly empty flag.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WMF",
        "This field is set if the remaining FIFO data is less than or equal to "
        "the watermark setting.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UDFF",
        "This is the FIFO underflow status flag.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVFF",
        "This is the FIFO overflow status flag.This flag indicates that more da"
        "ta has been written into FIFO than it can hold.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FULLIE",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EMPTIE",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WTMIE",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWTRG",
        "Active high.",
        12, // LSB
        12, // MSB
        false, // Readable
        false // Writable
    },
    {
        "TRGSEL",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DACRFS",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DACEN",
        "Starts the Programmable Reference Generator operation.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFOEN",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWMD",
        "In Swing mode, the FIFO must be set up such that the FIFO is full.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UVIE",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFORST",
        "Resets the FIFO pointers.",
        21, // LSB
        21, // MSB
        false, // Readable
        false // Writable
    },
    {
        "SWRST",
        "Resets all internal logic and registers, in case of any failure during"
        " the Low-power mode.",
        22, // LSB
        22, // MSB
        false, // Readable
        false // Writable
    },
    {
        "DMAEN",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WML",
        "MAX is the FIFO size.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DAC_PTR.
static const field_t hw_dac_ptr[] =
{
    {
        "DACWFP",
        "This is the FIFO write pointer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DACRFP",
        "This is the FIFO read pointer.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DAC_CR2.
static const field_t hw_dac_cr2[] =
{
    {
        "BFEN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BFMS",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BFHS",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IREF2",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IREF1",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IREF",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DAC_ITRM.
static const field_t hw_dac_itrm[] =
{
    {
        "TRIM",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a DAC module.
static const reg_t hw_dac[] =
{
    {
        "VERID",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_dac_verid
    },
    {
        "PARAM",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_dac_param
    },
    {
        "DATA",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_dac_data
    },
    {
        "CR",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_dac_cr
    },
    {
        "PTR",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_dac_ptr
    },
    {
        "CR2",
        "For CR2[6:4] (IREF, IREF1 and IREF2), it is suggested to enable one of"
        " the bits to reduce power.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_dac_cr2
    },
    {
        "ITRM",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dac_itrm
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark DCD
#endif

// Bitfields in register DCD_CONTROL.
static const field_t hw_dcd_control[] =
{
    {
        "IACK",
        "Determines whether the interrupt is cleared.",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "IF",
        "Determines whether an interrupt is pending.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IE",
        "Enables/disables interrupts to the system.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BC12",
        "BC1.2 compatibility.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START",
        "Determines whether the charger detection sequence is initiated.",
        24, // LSB
        24, // MSB
        false, // Readable
        false // Writable
    },
    {
        "SR",
        "Determines whether a software reset is performed.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCD_CLOCK.
static const field_t hw_dcd_clock[] =
{
    {
        "CLOCK_UNIT",
        "Specifies the unit of measure for the clock speed.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLOCK_SPEED",
        "The unit of measure is programmed in CLOCK_UNIT.",
        2, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCD_STATUS.
static const field_t hw_dcd_status[] =
{
    {
        "SEQ_RES",
        "Reports how the charger detection is attached.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEQ_STAT",
        "Indicates the status of the charger detection sequence.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR",
        "Indicates whether there is an error in the detection sequence.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TO",
        "Indicates whether the detection sequence has passed the timeout thresh"
        "hold.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ACTIVE",
        "Indicates whether the sequence is running.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCD_SIGNAL_OVERRIDE.
static const field_t hw_dcd_signal_override[] =
{
    {
        "PS",
        "Used to enable specified voltage and current source circuits on the US"
        "B_DP and USB_DM pins.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCD_TIMER0.
static const field_t hw_dcd_timer0[] =
{
    {
        "TUNITCON",
        "Displays the amount of elapsed time since the event of setting the STA"
        "RT bit plus the value of TSEQ_INIT.",
        0, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSEQ_INIT",
        "TSEQ_INIT represents the system latency (in ms) measured from the time"
        " VBUS goes active to the time system software initiates the charger de"
        "tection sequence in the USBDCD module.",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCD_TIMER1.
static const field_t hw_dcd_timer1[] =
{
    {
        "TVDPSRC_ON",
        "This timing parameter is used after detection of the data pin.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDCD_DBNC",
        "Sets the time period (ms) to debounce the D+ signal during the data pi"
        "n contact detection phase.",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCD_TIMER2_BC11.
static const field_t hw_dcd_timer2_bc11[] =
{
    {
        "CHECK_DM",
        "Sets the amount of time (in ms) that the module waits after the device"
        " connects to the USB bus until checking the state of the D- line to de"
        "termine the type of charging port.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TVDPSRC_CON",
        "Sets the time period (ms) that the module waits after charging port de"
        "tection before system software must enable the D+ pullup to connect to"
        " the USB host.",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DCD_TIMER2_BC12.
static const field_t hw_dcd_timer2_bc12[] =
{
    {
        "TVDMSRC_ON",
        "Sets the amount of time (in ms) that the module enables the VDM_SRC.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWAIT_AFTER_PRD",
        "Sets the amount of time (in ms) that the module waits after primary de"
        "tection before start to secondary detection.",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a DCD module.
static const reg_t hw_dcd[] =
{
    {
        "CONTROL",
        "Contains the control and interrupt bit fields.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_dcd_control
    },
    {
        "CLOCK",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dcd_clock
    },
    {
        "STATUS",
        "Provides the current state of the module for system software monitorin"
        "g.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_dcd_status
    },
    {
        "SIGNAL_OVERRIDE",
        "The Signal Override register provides a way for the customer to enable"
        " signaling required by the USB BC v1.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dcd_signal_override
    },
    {
        "TIMER0",
        "TIMER0 has an TSEQ_INIT field that represents the system latency in ms"
        ".",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dcd_timer0
    },
    {
        "TIMER1",
        "TIMER1 contains timing parameters.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dcd_timer1
    },
    {
        "TIMER2_BC11",
        "TIMER2_BC11 contains timing parameters for USB Battery Charging Specif"
        "ication, v1.1.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dcd_timer2_bc11
    },
    {
        "TIMER2_BC12",
        "TIMER2_BC12 contains timing parameters for USB Battery Charging Specif"
        "ication, v1.2.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dcd_timer2_bc12
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark DMA
#endif

// Bitfields in register DMA_CR.
static const field_t hw_dma_cr[] =
{
    {
        "EBWR",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDBG",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERCA",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERGA",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOE",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALT",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLM",
        "Do not use continuous link mode with a channel linking to itself if th"
        "ere is only one minor loop iteration per service request, for example,"
        " if the channel's NBYTES value is the same as either the source or des"
        "tination size.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EMLM",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRP0PRI",
        "Group 0 priority level when fixed priority group arbitration is enable"
        "d.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRP1PRI",
        "Group 1 priority level when fixed priority group arbitration is enable"
        "d.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECX",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CX",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_ES.
static const field_t hw_dma_es[] =
{
    {
        "DBE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBE",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SGE",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCE",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DOE",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DAE",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SOE",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SAE",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERRCHN",
        "The channel number of the last recorded error, excluding GPE and CPE e"
        "rrors, or last recorded error canceled transfer.",
        8, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CPE",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPE",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ECX",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VLD",
        "Logical OR of all ERR status bits",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_ERQ.
static const field_t hw_dma_erq[] =
{
    {
        "ERQ0",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ1",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ2",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ3",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ4",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ5",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ6",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ7",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ8",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ9",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ10",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ11",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ12",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ13",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ14",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ15",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ16",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ17",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ18",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ19",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ20",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ21",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ22",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ23",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ24",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ25",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ26",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ27",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ28",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ29",
        "",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ30",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERQ31",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_EEI.
static const field_t hw_dma_eei[] =
{
    {
        "EEI0",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI1",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI2",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI3",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI4",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI5",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI6",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI7",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI8",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI9",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI10",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI11",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI12",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI13",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI14",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI15",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI16",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI17",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI18",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI19",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI20",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI21",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI22",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI23",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI24",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI25",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI26",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI27",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI28",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI29",
        "",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI30",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EEI31",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CEEI.
static const field_t hw_dma_ceei[] =
{
    {
        "CEEI",
        "Clears the corresponding bit in EEI",
        0, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CAEE",
        "",
        6, // LSB
        6, // MSB
        false, // Readable
        false // Writable
    },
    {
        "NOP",
        "",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_SEEI.
static const field_t hw_dma_seei[] =
{
    {
        "SEEI",
        "Sets the corresponding bit in EEI",
        0, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "SAEE",
        "",
        6, // LSB
        6, // MSB
        false, // Readable
        false // Writable
    },
    {
        "NOP",
        "",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CERQ.
static const field_t hw_dma_cerq[] =
{
    {
        "CERQ",
        "Clears the corresponding bit in ERQ.",
        0, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CAER",
        "",
        6, // LSB
        6, // MSB
        false, // Readable
        false // Writable
    },
    {
        "NOP",
        "",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_SERQ.
static const field_t hw_dma_serq[] =
{
    {
        "SERQ",
        "Sets the corresponding bit in ERQ.",
        0, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "SAER",
        "",
        6, // LSB
        6, // MSB
        false, // Readable
        false // Writable
    },
    {
        "NOP",
        "",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CDNE.
static const field_t hw_dma_cdne[] =
{
    {
        "CDNE",
        "Clears the corresponding bit in TCDn_CSR[DONE]",
        0, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CADN",
        "",
        6, // LSB
        6, // MSB
        false, // Readable
        false // Writable
    },
    {
        "NOP",
        "",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_SSRT.
static const field_t hw_dma_ssrt[] =
{
    {
        "SSRT",
        "Sets the corresponding bit in TCDn_CSR[START]",
        0, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "SAST",
        "",
        6, // LSB
        6, // MSB
        false, // Readable
        false // Writable
    },
    {
        "NOP",
        "",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CERR.
static const field_t hw_dma_cerr[] =
{
    {
        "CERR",
        "Clears the corresponding bit in ERR",
        0, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CAEI",
        "",
        6, // LSB
        6, // MSB
        false, // Readable
        false // Writable
    },
    {
        "NOP",
        "",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CINT.
static const field_t hw_dma_cint[] =
{
    {
        "CINT",
        "Clears the corresponding bit in INT",
        0, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CAIR",
        "",
        6, // LSB
        6, // MSB
        false, // Readable
        false // Writable
    },
    {
        "NOP",
        "",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_INT.
static const field_t hw_dma_int[] =
{
    {
        "INT0",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT1",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT2",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT3",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT4",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT5",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT6",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT7",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT8",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT9",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT10",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT11",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT12",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT13",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT14",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT15",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT16",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT17",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT18",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT19",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT20",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT21",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT22",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT23",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT24",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT25",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT26",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT27",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT28",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT29",
        "",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT30",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT31",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_ERR.
static const field_t hw_dma_err[] =
{
    {
        "ERR0",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR1",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR2",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR3",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR4",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR5",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR6",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR7",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR8",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR9",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR10",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR11",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR12",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR13",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR14",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR15",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR16",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR17",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR18",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR19",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR20",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR21",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR22",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR23",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR24",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR25",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR26",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR27",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR28",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR29",
        "",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR30",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR31",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_HRS.
static const field_t hw_dma_hrs[] =
{
    {
        "HRS0",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS1",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS2",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS3",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS4",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS5",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS6",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS7",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS8",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS9",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS10",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS11",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS12",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS13",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS14",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS15",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS16",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS17",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS18",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS19",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS20",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS21",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS22",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS23",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS24",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS25",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS26",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS27",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS28",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS29",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS30",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HRS31",
        "The HRS bit for its respective channel remains asserted for the period"
        " when a Hardware Request is Present on the Channel.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_EARS.
static const field_t hw_dma_ears[] =
{
    {
        "EDREQ_0",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_1",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_2",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_3",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_4",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_5",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_6",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_7",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_8",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_9",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_10",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_11",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_12",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_13",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_14",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_15",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_16",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_17",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_18",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_19",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_20",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_21",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_22",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_23",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_24",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_25",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_26",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_27",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_28",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_29",
        "",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_30",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EDREQ_31",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI3.
static const field_t hw_dma_dchpri3[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI2.
static const field_t hw_dma_dchpri2[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI1.
static const field_t hw_dma_dchpri1[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI0.
static const field_t hw_dma_dchpri0[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI7.
static const field_t hw_dma_dchpri7[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI6.
static const field_t hw_dma_dchpri6[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI5.
static const field_t hw_dma_dchpri5[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI4.
static const field_t hw_dma_dchpri4[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI11.
static const field_t hw_dma_dchpri11[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI10.
static const field_t hw_dma_dchpri10[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI9.
static const field_t hw_dma_dchpri9[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI8.
static const field_t hw_dma_dchpri8[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI15.
static const field_t hw_dma_dchpri15[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI14.
static const field_t hw_dma_dchpri14[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI13.
static const field_t hw_dma_dchpri13[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI12.
static const field_t hw_dma_dchpri12[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI19.
static const field_t hw_dma_dchpri19[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI18.
static const field_t hw_dma_dchpri18[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI17.
static const field_t hw_dma_dchpri17[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI16.
static const field_t hw_dma_dchpri16[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI23.
static const field_t hw_dma_dchpri23[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI22.
static const field_t hw_dma_dchpri22[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI21.
static const field_t hw_dma_dchpri21[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI20.
static const field_t hw_dma_dchpri20[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI27.
static const field_t hw_dma_dchpri27[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI26.
static const field_t hw_dma_dchpri26[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI25.
static const field_t hw_dma_dchpri25[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI24.
static const field_t hw_dma_dchpri24[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI31.
static const field_t hw_dma_dchpri31[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI30.
static const field_t hw_dma_dchpri30[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI29.
static const field_t hw_dma_dchpri29[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_DCHPRI28.
static const field_t hw_dma_dchpri28[] =
{
    {
        "CHPRI",
        "Channel priority when fixed-priority arbitration is enabled Reset valu"
        "e for the group and channel priority fields, GRPPRI and CHPRI, is equa"
        "l to the corresponding channel number for each priority register, that"
        " is, DCHPRI31[GRPPRI] = 0b01 and DCHPRI31[CHPRI] = 0b01111.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRPPRI",
        "Group priority assigned to this channel group when fixed-priority arbi"
        "tration is enabled.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPA",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD0_SADDR.
static const field_t hw_dma_tcd0_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD0_SOFF.
static const field_t hw_dma_tcd0_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD0_ATTR.
static const field_t hw_dma_tcd0_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD0_NBYTES_MLNO.
static const field_t hw_dma_tcd0_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD0_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd0_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD0_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd0_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD0_SLAST.
static const field_t hw_dma_tcd0_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD0_DADDR.
static const field_t hw_dma_tcd0_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD0_CITER_ELINKYES.
static const field_t hw_dma_tcd0_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD0_CITER_ELINKNO.
static const field_t hw_dma_tcd0_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD0_DOFF.
static const field_t hw_dma_tcd0_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD0_DLASTSGA.
static const field_t hw_dma_tcd0_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD0_BITER_ELINKYES.
static const field_t hw_dma_tcd0_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD0_BITER_ELINKNO.
static const field_t hw_dma_tcd0_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD0_CSR.
static const field_t hw_dma_tcd0_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD1_SADDR.
static const field_t hw_dma_tcd1_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD1_SOFF.
static const field_t hw_dma_tcd1_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD1_ATTR.
static const field_t hw_dma_tcd1_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD1_NBYTES_MLNO.
static const field_t hw_dma_tcd1_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD1_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd1_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD1_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd1_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD1_SLAST.
static const field_t hw_dma_tcd1_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD1_DADDR.
static const field_t hw_dma_tcd1_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD1_CITER_ELINKYES.
static const field_t hw_dma_tcd1_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD1_CITER_ELINKNO.
static const field_t hw_dma_tcd1_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD1_DOFF.
static const field_t hw_dma_tcd1_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD1_DLASTSGA.
static const field_t hw_dma_tcd1_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD1_BITER_ELINKYES.
static const field_t hw_dma_tcd1_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD1_BITER_ELINKNO.
static const field_t hw_dma_tcd1_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD1_CSR.
static const field_t hw_dma_tcd1_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD2_SADDR.
static const field_t hw_dma_tcd2_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD2_SOFF.
static const field_t hw_dma_tcd2_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD2_ATTR.
static const field_t hw_dma_tcd2_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD2_NBYTES_MLNO.
static const field_t hw_dma_tcd2_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD2_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd2_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD2_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd2_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD2_SLAST.
static const field_t hw_dma_tcd2_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD2_DADDR.
static const field_t hw_dma_tcd2_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD2_CITER_ELINKYES.
static const field_t hw_dma_tcd2_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD2_CITER_ELINKNO.
static const field_t hw_dma_tcd2_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD2_DOFF.
static const field_t hw_dma_tcd2_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD2_DLASTSGA.
static const field_t hw_dma_tcd2_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD2_BITER_ELINKYES.
static const field_t hw_dma_tcd2_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD2_BITER_ELINKNO.
static const field_t hw_dma_tcd2_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD2_CSR.
static const field_t hw_dma_tcd2_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD3_SADDR.
static const field_t hw_dma_tcd3_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD3_SOFF.
static const field_t hw_dma_tcd3_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD3_ATTR.
static const field_t hw_dma_tcd3_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD3_NBYTES_MLNO.
static const field_t hw_dma_tcd3_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD3_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd3_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD3_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd3_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD3_SLAST.
static const field_t hw_dma_tcd3_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD3_DADDR.
static const field_t hw_dma_tcd3_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD3_CITER_ELINKYES.
static const field_t hw_dma_tcd3_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD3_CITER_ELINKNO.
static const field_t hw_dma_tcd3_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD3_DOFF.
static const field_t hw_dma_tcd3_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD3_DLASTSGA.
static const field_t hw_dma_tcd3_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD3_BITER_ELINKYES.
static const field_t hw_dma_tcd3_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD3_BITER_ELINKNO.
static const field_t hw_dma_tcd3_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD3_CSR.
static const field_t hw_dma_tcd3_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD4_SADDR.
static const field_t hw_dma_tcd4_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD4_SOFF.
static const field_t hw_dma_tcd4_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD4_ATTR.
static const field_t hw_dma_tcd4_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD4_NBYTES_MLNO.
static const field_t hw_dma_tcd4_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD4_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd4_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD4_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd4_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD4_SLAST.
static const field_t hw_dma_tcd4_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD4_DADDR.
static const field_t hw_dma_tcd4_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD4_CITER_ELINKYES.
static const field_t hw_dma_tcd4_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD4_CITER_ELINKNO.
static const field_t hw_dma_tcd4_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD4_DOFF.
static const field_t hw_dma_tcd4_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD4_DLASTSGA.
static const field_t hw_dma_tcd4_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD4_BITER_ELINKYES.
static const field_t hw_dma_tcd4_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD4_BITER_ELINKNO.
static const field_t hw_dma_tcd4_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD4_CSR.
static const field_t hw_dma_tcd4_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD5_SADDR.
static const field_t hw_dma_tcd5_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD5_SOFF.
static const field_t hw_dma_tcd5_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD5_ATTR.
static const field_t hw_dma_tcd5_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD5_NBYTES_MLNO.
static const field_t hw_dma_tcd5_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD5_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd5_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD5_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd5_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD5_SLAST.
static const field_t hw_dma_tcd5_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD5_DADDR.
static const field_t hw_dma_tcd5_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD5_CITER_ELINKYES.
static const field_t hw_dma_tcd5_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD5_CITER_ELINKNO.
static const field_t hw_dma_tcd5_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD5_DOFF.
static const field_t hw_dma_tcd5_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD5_DLASTSGA.
static const field_t hw_dma_tcd5_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD5_BITER_ELINKYES.
static const field_t hw_dma_tcd5_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD5_BITER_ELINKNO.
static const field_t hw_dma_tcd5_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD5_CSR.
static const field_t hw_dma_tcd5_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD6_SADDR.
static const field_t hw_dma_tcd6_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD6_SOFF.
static const field_t hw_dma_tcd6_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD6_ATTR.
static const field_t hw_dma_tcd6_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD6_NBYTES_MLNO.
static const field_t hw_dma_tcd6_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD6_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd6_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD6_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd6_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD6_SLAST.
static const field_t hw_dma_tcd6_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD6_DADDR.
static const field_t hw_dma_tcd6_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD6_CITER_ELINKYES.
static const field_t hw_dma_tcd6_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD6_CITER_ELINKNO.
static const field_t hw_dma_tcd6_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD6_DOFF.
static const field_t hw_dma_tcd6_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD6_DLASTSGA.
static const field_t hw_dma_tcd6_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD6_BITER_ELINKYES.
static const field_t hw_dma_tcd6_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD6_BITER_ELINKNO.
static const field_t hw_dma_tcd6_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD6_CSR.
static const field_t hw_dma_tcd6_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD7_SADDR.
static const field_t hw_dma_tcd7_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD7_SOFF.
static const field_t hw_dma_tcd7_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD7_ATTR.
static const field_t hw_dma_tcd7_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD7_NBYTES_MLNO.
static const field_t hw_dma_tcd7_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD7_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd7_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD7_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd7_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD7_SLAST.
static const field_t hw_dma_tcd7_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD7_DADDR.
static const field_t hw_dma_tcd7_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD7_CITER_ELINKYES.
static const field_t hw_dma_tcd7_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD7_CITER_ELINKNO.
static const field_t hw_dma_tcd7_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD7_DOFF.
static const field_t hw_dma_tcd7_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD7_DLASTSGA.
static const field_t hw_dma_tcd7_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD7_BITER_ELINKYES.
static const field_t hw_dma_tcd7_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD7_BITER_ELINKNO.
static const field_t hw_dma_tcd7_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD7_CSR.
static const field_t hw_dma_tcd7_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD8_SADDR.
static const field_t hw_dma_tcd8_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD8_SOFF.
static const field_t hw_dma_tcd8_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD8_ATTR.
static const field_t hw_dma_tcd8_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD8_NBYTES_MLNO.
static const field_t hw_dma_tcd8_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD8_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd8_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD8_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd8_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD8_SLAST.
static const field_t hw_dma_tcd8_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD8_DADDR.
static const field_t hw_dma_tcd8_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD8_CITER_ELINKYES.
static const field_t hw_dma_tcd8_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD8_CITER_ELINKNO.
static const field_t hw_dma_tcd8_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD8_DOFF.
static const field_t hw_dma_tcd8_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD8_DLASTSGA.
static const field_t hw_dma_tcd8_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD8_BITER_ELINKYES.
static const field_t hw_dma_tcd8_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD8_BITER_ELINKNO.
static const field_t hw_dma_tcd8_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD8_CSR.
static const field_t hw_dma_tcd8_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD9_SADDR.
static const field_t hw_dma_tcd9_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD9_SOFF.
static const field_t hw_dma_tcd9_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD9_ATTR.
static const field_t hw_dma_tcd9_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD9_NBYTES_MLNO.
static const field_t hw_dma_tcd9_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD9_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd9_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD9_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd9_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD9_SLAST.
static const field_t hw_dma_tcd9_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD9_DADDR.
static const field_t hw_dma_tcd9_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD9_CITER_ELINKYES.
static const field_t hw_dma_tcd9_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD9_CITER_ELINKNO.
static const field_t hw_dma_tcd9_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD9_DOFF.
static const field_t hw_dma_tcd9_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD9_DLASTSGA.
static const field_t hw_dma_tcd9_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD9_BITER_ELINKYES.
static const field_t hw_dma_tcd9_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD9_BITER_ELINKNO.
static const field_t hw_dma_tcd9_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD9_CSR.
static const field_t hw_dma_tcd9_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD10_SADDR.
static const field_t hw_dma_tcd10_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD10_SOFF.
static const field_t hw_dma_tcd10_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD10_ATTR.
static const field_t hw_dma_tcd10_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD10_NBYTES_MLNO.
static const field_t hw_dma_tcd10_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD10_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd10_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD10_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd10_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD10_SLAST.
static const field_t hw_dma_tcd10_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD10_DADDR.
static const field_t hw_dma_tcd10_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD10_CITER_ELINKYES.
static const field_t hw_dma_tcd10_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD10_CITER_ELINKNO.
static const field_t hw_dma_tcd10_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD10_DOFF.
static const field_t hw_dma_tcd10_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD10_DLASTSGA.
static const field_t hw_dma_tcd10_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD10_BITER_ELINKYES.
static const field_t hw_dma_tcd10_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD10_BITER_ELINKNO.
static const field_t hw_dma_tcd10_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD10_CSR.
static const field_t hw_dma_tcd10_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD11_SADDR.
static const field_t hw_dma_tcd11_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD11_SOFF.
static const field_t hw_dma_tcd11_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD11_ATTR.
static const field_t hw_dma_tcd11_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD11_NBYTES_MLNO.
static const field_t hw_dma_tcd11_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD11_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd11_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD11_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd11_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD11_SLAST.
static const field_t hw_dma_tcd11_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD11_DADDR.
static const field_t hw_dma_tcd11_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD11_CITER_ELINKYES.
static const field_t hw_dma_tcd11_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD11_CITER_ELINKNO.
static const field_t hw_dma_tcd11_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD11_DOFF.
static const field_t hw_dma_tcd11_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD11_DLASTSGA.
static const field_t hw_dma_tcd11_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD11_BITER_ELINKYES.
static const field_t hw_dma_tcd11_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD11_BITER_ELINKNO.
static const field_t hw_dma_tcd11_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD11_CSR.
static const field_t hw_dma_tcd11_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD12_SADDR.
static const field_t hw_dma_tcd12_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD12_SOFF.
static const field_t hw_dma_tcd12_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD12_ATTR.
static const field_t hw_dma_tcd12_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD12_NBYTES_MLNO.
static const field_t hw_dma_tcd12_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD12_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd12_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD12_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd12_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD12_SLAST.
static const field_t hw_dma_tcd12_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD12_DADDR.
static const field_t hw_dma_tcd12_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD12_CITER_ELINKYES.
static const field_t hw_dma_tcd12_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD12_CITER_ELINKNO.
static const field_t hw_dma_tcd12_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD12_DOFF.
static const field_t hw_dma_tcd12_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD12_DLASTSGA.
static const field_t hw_dma_tcd12_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD12_BITER_ELINKYES.
static const field_t hw_dma_tcd12_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD12_BITER_ELINKNO.
static const field_t hw_dma_tcd12_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD12_CSR.
static const field_t hw_dma_tcd12_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD13_SADDR.
static const field_t hw_dma_tcd13_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD13_SOFF.
static const field_t hw_dma_tcd13_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD13_ATTR.
static const field_t hw_dma_tcd13_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD13_NBYTES_MLNO.
static const field_t hw_dma_tcd13_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD13_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd13_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD13_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd13_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD13_SLAST.
static const field_t hw_dma_tcd13_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD13_DADDR.
static const field_t hw_dma_tcd13_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD13_CITER_ELINKYES.
static const field_t hw_dma_tcd13_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD13_CITER_ELINKNO.
static const field_t hw_dma_tcd13_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD13_DOFF.
static const field_t hw_dma_tcd13_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD13_DLASTSGA.
static const field_t hw_dma_tcd13_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD13_BITER_ELINKYES.
static const field_t hw_dma_tcd13_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD13_BITER_ELINKNO.
static const field_t hw_dma_tcd13_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD13_CSR.
static const field_t hw_dma_tcd13_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD14_SADDR.
static const field_t hw_dma_tcd14_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD14_SOFF.
static const field_t hw_dma_tcd14_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD14_ATTR.
static const field_t hw_dma_tcd14_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD14_NBYTES_MLNO.
static const field_t hw_dma_tcd14_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD14_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd14_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD14_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd14_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD14_SLAST.
static const field_t hw_dma_tcd14_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD14_DADDR.
static const field_t hw_dma_tcd14_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD14_CITER_ELINKYES.
static const field_t hw_dma_tcd14_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD14_CITER_ELINKNO.
static const field_t hw_dma_tcd14_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD14_DOFF.
static const field_t hw_dma_tcd14_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD14_DLASTSGA.
static const field_t hw_dma_tcd14_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD14_BITER_ELINKYES.
static const field_t hw_dma_tcd14_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD14_BITER_ELINKNO.
static const field_t hw_dma_tcd14_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD14_CSR.
static const field_t hw_dma_tcd14_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD15_SADDR.
static const field_t hw_dma_tcd15_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD15_SOFF.
static const field_t hw_dma_tcd15_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD15_ATTR.
static const field_t hw_dma_tcd15_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD15_NBYTES_MLNO.
static const field_t hw_dma_tcd15_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD15_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd15_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD15_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd15_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD15_SLAST.
static const field_t hw_dma_tcd15_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD15_DADDR.
static const field_t hw_dma_tcd15_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD15_CITER_ELINKYES.
static const field_t hw_dma_tcd15_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD15_CITER_ELINKNO.
static const field_t hw_dma_tcd15_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD15_DOFF.
static const field_t hw_dma_tcd15_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD15_DLASTSGA.
static const field_t hw_dma_tcd15_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD15_BITER_ELINKYES.
static const field_t hw_dma_tcd15_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD15_BITER_ELINKNO.
static const field_t hw_dma_tcd15_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD15_CSR.
static const field_t hw_dma_tcd15_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD16_SADDR.
static const field_t hw_dma_tcd16_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD16_SOFF.
static const field_t hw_dma_tcd16_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD16_ATTR.
static const field_t hw_dma_tcd16_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD16_NBYTES_MLNO.
static const field_t hw_dma_tcd16_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD16_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd16_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD16_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd16_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD16_SLAST.
static const field_t hw_dma_tcd16_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD16_DADDR.
static const field_t hw_dma_tcd16_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD16_CITER_ELINKYES.
static const field_t hw_dma_tcd16_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD16_CITER_ELINKNO.
static const field_t hw_dma_tcd16_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD16_DOFF.
static const field_t hw_dma_tcd16_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD16_DLASTSGA.
static const field_t hw_dma_tcd16_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD16_BITER_ELINKYES.
static const field_t hw_dma_tcd16_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD16_BITER_ELINKNO.
static const field_t hw_dma_tcd16_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD16_CSR.
static const field_t hw_dma_tcd16_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD17_SADDR.
static const field_t hw_dma_tcd17_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD17_SOFF.
static const field_t hw_dma_tcd17_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD17_ATTR.
static const field_t hw_dma_tcd17_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD17_NBYTES_MLNO.
static const field_t hw_dma_tcd17_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD17_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd17_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD17_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd17_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD17_SLAST.
static const field_t hw_dma_tcd17_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD17_DADDR.
static const field_t hw_dma_tcd17_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD17_CITER_ELINKYES.
static const field_t hw_dma_tcd17_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD17_CITER_ELINKNO.
static const field_t hw_dma_tcd17_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD17_DOFF.
static const field_t hw_dma_tcd17_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD17_DLASTSGA.
static const field_t hw_dma_tcd17_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD17_BITER_ELINKYES.
static const field_t hw_dma_tcd17_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD17_BITER_ELINKNO.
static const field_t hw_dma_tcd17_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD17_CSR.
static const field_t hw_dma_tcd17_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD18_SADDR.
static const field_t hw_dma_tcd18_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD18_SOFF.
static const field_t hw_dma_tcd18_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD18_ATTR.
static const field_t hw_dma_tcd18_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD18_NBYTES_MLNO.
static const field_t hw_dma_tcd18_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD18_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd18_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD18_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd18_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD18_SLAST.
static const field_t hw_dma_tcd18_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD18_DADDR.
static const field_t hw_dma_tcd18_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD18_CITER_ELINKYES.
static const field_t hw_dma_tcd18_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD18_CITER_ELINKNO.
static const field_t hw_dma_tcd18_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD18_DOFF.
static const field_t hw_dma_tcd18_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD18_DLASTSGA.
static const field_t hw_dma_tcd18_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD18_BITER_ELINKYES.
static const field_t hw_dma_tcd18_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD18_BITER_ELINKNO.
static const field_t hw_dma_tcd18_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD18_CSR.
static const field_t hw_dma_tcd18_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD19_SADDR.
static const field_t hw_dma_tcd19_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD19_SOFF.
static const field_t hw_dma_tcd19_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD19_ATTR.
static const field_t hw_dma_tcd19_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD19_NBYTES_MLNO.
static const field_t hw_dma_tcd19_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD19_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd19_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD19_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd19_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD19_SLAST.
static const field_t hw_dma_tcd19_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD19_DADDR.
static const field_t hw_dma_tcd19_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD19_CITER_ELINKYES.
static const field_t hw_dma_tcd19_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD19_CITER_ELINKNO.
static const field_t hw_dma_tcd19_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD19_DOFF.
static const field_t hw_dma_tcd19_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD19_DLASTSGA.
static const field_t hw_dma_tcd19_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD19_BITER_ELINKYES.
static const field_t hw_dma_tcd19_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD19_BITER_ELINKNO.
static const field_t hw_dma_tcd19_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD19_CSR.
static const field_t hw_dma_tcd19_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD20_SADDR.
static const field_t hw_dma_tcd20_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD20_SOFF.
static const field_t hw_dma_tcd20_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD20_ATTR.
static const field_t hw_dma_tcd20_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD20_NBYTES_MLNO.
static const field_t hw_dma_tcd20_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD20_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd20_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD20_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd20_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD20_SLAST.
static const field_t hw_dma_tcd20_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD20_DADDR.
static const field_t hw_dma_tcd20_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD20_CITER_ELINKYES.
static const field_t hw_dma_tcd20_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD20_CITER_ELINKNO.
static const field_t hw_dma_tcd20_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD20_DOFF.
static const field_t hw_dma_tcd20_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD20_DLASTSGA.
static const field_t hw_dma_tcd20_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD20_BITER_ELINKYES.
static const field_t hw_dma_tcd20_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD20_BITER_ELINKNO.
static const field_t hw_dma_tcd20_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD20_CSR.
static const field_t hw_dma_tcd20_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD21_SADDR.
static const field_t hw_dma_tcd21_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD21_SOFF.
static const field_t hw_dma_tcd21_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD21_ATTR.
static const field_t hw_dma_tcd21_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD21_NBYTES_MLNO.
static const field_t hw_dma_tcd21_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD21_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd21_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD21_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd21_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD21_SLAST.
static const field_t hw_dma_tcd21_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD21_DADDR.
static const field_t hw_dma_tcd21_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD21_CITER_ELINKYES.
static const field_t hw_dma_tcd21_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD21_CITER_ELINKNO.
static const field_t hw_dma_tcd21_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD21_DOFF.
static const field_t hw_dma_tcd21_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD21_DLASTSGA.
static const field_t hw_dma_tcd21_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD21_BITER_ELINKYES.
static const field_t hw_dma_tcd21_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD21_BITER_ELINKNO.
static const field_t hw_dma_tcd21_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD21_CSR.
static const field_t hw_dma_tcd21_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD22_SADDR.
static const field_t hw_dma_tcd22_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD22_SOFF.
static const field_t hw_dma_tcd22_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD22_ATTR.
static const field_t hw_dma_tcd22_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD22_NBYTES_MLNO.
static const field_t hw_dma_tcd22_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD22_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd22_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD22_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd22_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD22_SLAST.
static const field_t hw_dma_tcd22_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD22_DADDR.
static const field_t hw_dma_tcd22_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD22_CITER_ELINKYES.
static const field_t hw_dma_tcd22_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD22_CITER_ELINKNO.
static const field_t hw_dma_tcd22_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD22_DOFF.
static const field_t hw_dma_tcd22_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD22_DLASTSGA.
static const field_t hw_dma_tcd22_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD22_BITER_ELINKYES.
static const field_t hw_dma_tcd22_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD22_BITER_ELINKNO.
static const field_t hw_dma_tcd22_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD22_CSR.
static const field_t hw_dma_tcd22_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD23_SADDR.
static const field_t hw_dma_tcd23_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD23_SOFF.
static const field_t hw_dma_tcd23_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD23_ATTR.
static const field_t hw_dma_tcd23_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD23_NBYTES_MLNO.
static const field_t hw_dma_tcd23_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD23_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd23_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD23_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd23_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD23_SLAST.
static const field_t hw_dma_tcd23_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD23_DADDR.
static const field_t hw_dma_tcd23_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD23_CITER_ELINKYES.
static const field_t hw_dma_tcd23_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD23_CITER_ELINKNO.
static const field_t hw_dma_tcd23_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD23_DOFF.
static const field_t hw_dma_tcd23_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD23_DLASTSGA.
static const field_t hw_dma_tcd23_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD23_BITER_ELINKYES.
static const field_t hw_dma_tcd23_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD23_BITER_ELINKNO.
static const field_t hw_dma_tcd23_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD23_CSR.
static const field_t hw_dma_tcd23_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD24_SADDR.
static const field_t hw_dma_tcd24_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD24_SOFF.
static const field_t hw_dma_tcd24_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD24_ATTR.
static const field_t hw_dma_tcd24_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD24_NBYTES_MLNO.
static const field_t hw_dma_tcd24_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD24_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd24_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD24_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd24_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD24_SLAST.
static const field_t hw_dma_tcd24_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD24_DADDR.
static const field_t hw_dma_tcd24_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD24_CITER_ELINKYES.
static const field_t hw_dma_tcd24_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD24_CITER_ELINKNO.
static const field_t hw_dma_tcd24_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD24_DOFF.
static const field_t hw_dma_tcd24_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD24_DLASTSGA.
static const field_t hw_dma_tcd24_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD24_BITER_ELINKYES.
static const field_t hw_dma_tcd24_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD24_BITER_ELINKNO.
static const field_t hw_dma_tcd24_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD24_CSR.
static const field_t hw_dma_tcd24_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD25_SADDR.
static const field_t hw_dma_tcd25_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD25_SOFF.
static const field_t hw_dma_tcd25_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD25_ATTR.
static const field_t hw_dma_tcd25_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD25_NBYTES_MLNO.
static const field_t hw_dma_tcd25_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD25_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd25_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD25_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd25_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD25_SLAST.
static const field_t hw_dma_tcd25_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD25_DADDR.
static const field_t hw_dma_tcd25_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD25_CITER_ELINKYES.
static const field_t hw_dma_tcd25_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD25_CITER_ELINKNO.
static const field_t hw_dma_tcd25_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD25_DOFF.
static const field_t hw_dma_tcd25_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD25_DLASTSGA.
static const field_t hw_dma_tcd25_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD25_BITER_ELINKYES.
static const field_t hw_dma_tcd25_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD25_BITER_ELINKNO.
static const field_t hw_dma_tcd25_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD25_CSR.
static const field_t hw_dma_tcd25_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD26_SADDR.
static const field_t hw_dma_tcd26_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD26_SOFF.
static const field_t hw_dma_tcd26_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD26_ATTR.
static const field_t hw_dma_tcd26_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD26_NBYTES_MLNO.
static const field_t hw_dma_tcd26_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD26_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd26_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD26_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd26_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD26_SLAST.
static const field_t hw_dma_tcd26_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD26_DADDR.
static const field_t hw_dma_tcd26_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD26_CITER_ELINKYES.
static const field_t hw_dma_tcd26_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD26_CITER_ELINKNO.
static const field_t hw_dma_tcd26_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD26_DOFF.
static const field_t hw_dma_tcd26_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD26_DLASTSGA.
static const field_t hw_dma_tcd26_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD26_BITER_ELINKYES.
static const field_t hw_dma_tcd26_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD26_BITER_ELINKNO.
static const field_t hw_dma_tcd26_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD26_CSR.
static const field_t hw_dma_tcd26_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD27_SADDR.
static const field_t hw_dma_tcd27_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD27_SOFF.
static const field_t hw_dma_tcd27_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD27_ATTR.
static const field_t hw_dma_tcd27_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD27_NBYTES_MLNO.
static const field_t hw_dma_tcd27_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD27_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd27_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD27_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd27_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD27_SLAST.
static const field_t hw_dma_tcd27_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD27_DADDR.
static const field_t hw_dma_tcd27_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD27_CITER_ELINKYES.
static const field_t hw_dma_tcd27_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD27_CITER_ELINKNO.
static const field_t hw_dma_tcd27_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD27_DOFF.
static const field_t hw_dma_tcd27_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD27_DLASTSGA.
static const field_t hw_dma_tcd27_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD27_BITER_ELINKYES.
static const field_t hw_dma_tcd27_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD27_BITER_ELINKNO.
static const field_t hw_dma_tcd27_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD27_CSR.
static const field_t hw_dma_tcd27_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD28_SADDR.
static const field_t hw_dma_tcd28_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD28_SOFF.
static const field_t hw_dma_tcd28_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD28_ATTR.
static const field_t hw_dma_tcd28_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD28_NBYTES_MLNO.
static const field_t hw_dma_tcd28_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD28_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd28_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD28_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd28_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD28_SLAST.
static const field_t hw_dma_tcd28_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD28_DADDR.
static const field_t hw_dma_tcd28_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD28_CITER_ELINKYES.
static const field_t hw_dma_tcd28_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD28_CITER_ELINKNO.
static const field_t hw_dma_tcd28_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD28_DOFF.
static const field_t hw_dma_tcd28_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD28_DLASTSGA.
static const field_t hw_dma_tcd28_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD28_BITER_ELINKYES.
static const field_t hw_dma_tcd28_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD28_BITER_ELINKNO.
static const field_t hw_dma_tcd28_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD28_CSR.
static const field_t hw_dma_tcd28_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD29_SADDR.
static const field_t hw_dma_tcd29_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD29_SOFF.
static const field_t hw_dma_tcd29_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD29_ATTR.
static const field_t hw_dma_tcd29_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD29_NBYTES_MLNO.
static const field_t hw_dma_tcd29_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD29_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd29_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD29_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd29_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD29_SLAST.
static const field_t hw_dma_tcd29_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD29_DADDR.
static const field_t hw_dma_tcd29_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD29_CITER_ELINKYES.
static const field_t hw_dma_tcd29_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD29_CITER_ELINKNO.
static const field_t hw_dma_tcd29_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD29_DOFF.
static const field_t hw_dma_tcd29_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD29_DLASTSGA.
static const field_t hw_dma_tcd29_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD29_BITER_ELINKYES.
static const field_t hw_dma_tcd29_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD29_BITER_ELINKNO.
static const field_t hw_dma_tcd29_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD29_CSR.
static const field_t hw_dma_tcd29_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD30_SADDR.
static const field_t hw_dma_tcd30_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD30_SOFF.
static const field_t hw_dma_tcd30_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD30_ATTR.
static const field_t hw_dma_tcd30_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD30_NBYTES_MLNO.
static const field_t hw_dma_tcd30_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD30_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd30_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD30_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd30_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD30_SLAST.
static const field_t hw_dma_tcd30_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD30_DADDR.
static const field_t hw_dma_tcd30_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD30_CITER_ELINKYES.
static const field_t hw_dma_tcd30_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD30_CITER_ELINKNO.
static const field_t hw_dma_tcd30_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD30_DOFF.
static const field_t hw_dma_tcd30_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD30_DLASTSGA.
static const field_t hw_dma_tcd30_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD30_BITER_ELINKYES.
static const field_t hw_dma_tcd30_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD30_BITER_ELINKNO.
static const field_t hw_dma_tcd30_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD30_CSR.
static const field_t hw_dma_tcd30_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD31_SADDR.
static const field_t hw_dma_tcd31_saddr[] =
{
    {
        "SADDR",
        "Memory address pointing to the source data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD31_SOFF.
static const field_t hw_dma_tcd31_soff[] =
{
    {
        "SOFF",
        "Sign-extended offset applied to the current source address to form the"
        " next-state value as each source read is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD31_ATTR.
static const field_t hw_dma_tcd31_attr[] =
{
    {
        "DSIZE",
        "See the SSIZE definition",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMOD",
        "See the SMOD definition",
        3, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSIZE",
        "Using a Reserved value causes a configuration error.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMOD",
        "",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD31_NBYTES_MLNO.
static const field_t hw_dma_tcd31_nbytes_mlno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD31_NBYTES_MLOFFNO.
static const field_t hw_dma_tcd31_nbytes_mloffno[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD31_NBYTES_MLOFFYES.
static const field_t hw_dma_tcd31_nbytes_mloffyes[] =
{
    {
        "NBYTES",
        "Number of bytes to be transferred in each service request of the chann"
        "el.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MLOFF",
        "",
        10, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMLOE",
        "Selects whether the minor loop offset is applied to the destination ad"
        "dress upon minor loop completion.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMLOE",
        "Selects whether the minor loop offset is applied to the source address"
        " upon minor loop completion.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD31_SLAST.
static const field_t hw_dma_tcd31_slast[] =
{
    {
        "SLAST",
        "Adjustment value added to the source address at the completion of the "
        "major iteration count.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD31_DADDR.
static const field_t hw_dma_tcd31_daddr[] =
{
    {
        "DADDR",
        "Memory address pointing to the destination data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD31_CITER_ELINKYES.
static const field_t hw_dma_tcd31_citer_elinkyes[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest to the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD31_CITER_ELINKNO.
static const field_t hw_dma_tcd31_citer_elinkno[] =
{
    {
        "CITER",
        "This field is the current major loop count for the channel.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables linking to "
        "another channel, defined by the LINKCH field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD31_DOFF.
static const field_t hw_dma_tcd31_doff[] =
{
    {
        "DOFF",
        "Sign-extended offset applied to the current destination address to for"
        "m the next-state value as each destination write is completed.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD31_DLASTSGA.
static const field_t hw_dma_tcd31_dlastsga[] =
{
    {
        "DLASTSGA",
        "Destination last address adjustment or the memory address for the next"
        " transfer control descriptor to be loaded into this channel (scatter/g"
        "ather).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD31_BITER_ELINKYES.
static const field_t hw_dma_tcd31_biter_elinkyes[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINKCH",
        "If channel-to-channel linking is enabled (ELINK = 1), then after the m"
        "inor loop is exhausted, the eDMA engine initiates a channel service re"
        "quest at the channel defined by this field by setting that channel's T"
        "CDn_CSR[START] bit.",
        9, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD31_BITER_ELINKNO.
static const field_t hw_dma_tcd31_biter_elinkno[] =
{
    {
        "BITER",
        "As the transfer control descriptor is first loaded by software, this 9"
        "-bit (ELINK = 1) or 15-bit (ELINK = 0) field must be equal to the valu"
        "e in the CITER field.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELINK",
        "As the channel completes the minor loop, this flag enables the linking"
        " to another channel, defined by BITER[LINKCH].",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_TCD31_CSR.
static const field_t hw_dma_tcd31_csr[] =
{
    {
        "START",
        "If this flag is set, the channel is requesting service.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTMAJOR",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT when the current major iteration c"
        "ount reaches zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTHALF",
        "If this flag is set, the channel generates an interrupt request by set"
        "ting the appropriate bit in the INT register when the current major it"
        "eration count reaches the halfway point.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DREQ",
        "If this flag is set, the eDMA hardware automatically clears the corres"
        "ponding ERQ bit when the current major iteration count reaches zero.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESG",
        "As the channel completes the major loop, this flag enables scatter/gat"
        "her processing in the current channel.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORELINK",
        "As the channel completes the major loop, this flag enables the linking"
        " to another channel, defined by MAJORLINKCH.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACTIVE",
        "This flag signals the channel is currently in execution.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DONE",
        "This flag indicates the eDMA has completed the major loop.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAJORLINKCH",
        "If (MAJORELINK = 0) then: No channel-to-channel linking, or chaining, "
        "is performed after the major loop counter is exhausted.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWC",
        "Throttles the amount of bus bandwidth consumed by the eDMA.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a DMA module.
static const reg_t hw_dma[] =
{
    {
        "CR",
        "The CR defines the basic operating configuration of the DMA.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_dma_cr
    },
    {
        "ES",
        "The ES provides information concerning the last recorded channel error"
        ".",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        13, // Number of bitfields
        hw_dma_es
    },
    {
        "ERQ",
        "The ERQ register provides a bit map for the 32 channels to enable the "
        "request signal for each channel.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_dma_erq
    },
    {
        "EEI",
        "The EEI register provides a bit map for the 32 channels to enable the "
        "error interrupt signal for each channel.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_dma_eei
    },
    {
        "CEEI",
        "The CEEI provides a simple memory-mapped mechanism to clear a given bi"
        "t in the EEI to disable the error interrupt for a given channel.",
        1, // Width in bytes
        0x00000018, // Base address offset
        false, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_ceei
    },
    {
        "SEEI",
        "The SEEI provides a simple memory-mapped mechanism to set a given bit "
        "in the EEI to enable the error interrupt for a given channel.",
        1, // Width in bytes
        0x00000019, // Base address offset
        false, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_seei
    },
    {
        "CERQ",
        "The CERQ provides a simple memory-mapped mechanism to clear a given bi"
        "t in the ERQ to disable the DMA request for a given channel.",
        1, // Width in bytes
        0x0000001a, // Base address offset
        false, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_cerq
    },
    {
        "SERQ",
        "The SERQ provides a simple memory-mapped mechanism to set a given bit "
        "in the ERQ to enable the DMA request for a given channel.",
        1, // Width in bytes
        0x0000001b, // Base address offset
        false, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_serq
    },
    {
        "CDNE",
        "The CDNE provides a simple memory-mapped mechanism to clear the DONE b"
        "it in the TCD of the given channel.",
        1, // Width in bytes
        0x0000001c, // Base address offset
        false, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_cdne
    },
    {
        "SSRT",
        "The SSRT provides a simple memory-mapped mechanism to set the START bi"
        "t in the TCD of the given channel.",
        1, // Width in bytes
        0x0000001d, // Base address offset
        false, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_ssrt
    },
    {
        "CERR",
        "The CERR provides a simple memory-mapped mechanism to clear a given bi"
        "t in the ERR to disable the error condition flag for a given channel.",
        1, // Width in bytes
        0x0000001e, // Base address offset
        false, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_cerr
    },
    {
        "CINT",
        "The CINT provides a simple, memory-mapped mechanism to clear a given b"
        "it in the INT to disable the interrupt request for a given channel.",
        1, // Width in bytes
        0x0000001f, // Base address offset
        false, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_cint
    },
    {
        "INT",
        "The INT register provides a bit map for the 32 channels signaling the "
        "presence of an interrupt request for each channel.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_dma_int
    },
    {
        "ERR",
        "The ERR register provides a bit map for the 32 channels, signaling the"
        " presence of an error for each channel.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_dma_err
    },
    {
        "HRS",
        "The HRS register provides a bit map for the DMA channels, signaling th"
        "e presence of a hardware request for each channel.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        32, // Number of bitfields
        hw_dma_hrs
    },
    {
        "EARS",
        "The EARS register is used to enable or disable the DMA requests in by "
        "AND'ing the bits of these two registers.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_dma_ears
    },
    {
        "DCHPRI3",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri3
    },
    {
        "DCHPRI2",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000101, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri2
    },
    {
        "DCHPRI1",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000102, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri1
    },
    {
        "DCHPRI0",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000103, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri0
    },
    {
        "DCHPRI7",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri7
    },
    {
        "DCHPRI6",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000105, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri6
    },
    {
        "DCHPRI5",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000106, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri5
    },
    {
        "DCHPRI4",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000107, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri4
    },
    {
        "DCHPRI11",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri11
    },
    {
        "DCHPRI10",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000109, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri10
    },
    {
        "DCHPRI9",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x0000010a, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri9
    },
    {
        "DCHPRI8",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x0000010b, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri8
    },
    {
        "DCHPRI15",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri15
    },
    {
        "DCHPRI14",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x0000010d, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri14
    },
    {
        "DCHPRI13",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x0000010e, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri13
    },
    {
        "DCHPRI12",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x0000010f, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri12
    },
    {
        "DCHPRI19",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri19
    },
    {
        "DCHPRI18",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000111, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri18
    },
    {
        "DCHPRI17",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000112, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri17
    },
    {
        "DCHPRI16",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000113, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri16
    },
    {
        "DCHPRI23",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri23
    },
    {
        "DCHPRI22",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000115, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri22
    },
    {
        "DCHPRI21",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000116, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri21
    },
    {
        "DCHPRI20",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000117, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri20
    },
    {
        "DCHPRI27",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri27
    },
    {
        "DCHPRI26",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x00000119, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri26
    },
    {
        "DCHPRI25",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x0000011a, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri25
    },
    {
        "DCHPRI24",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x0000011b, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri24
    },
    {
        "DCHPRI31",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri31
    },
    {
        "DCHPRI30",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x0000011d, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri30
    },
    {
        "DCHPRI29",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x0000011e, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri29
    },
    {
        "DCHPRI28",
        "When fixed-priority channel arbitration is enabled (CR[ERCA] = 0), the"
        " contents of these registers define the unique priorities associated w"
        "ith each channel within a group.",
        1, // Width in bytes
        0x0000011f, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_dchpri28
    },
    {
        "TCD0_SADDR",
        "",
        4, // Width in bytes
        0x00001000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd0_saddr
    },
    {
        "TCD0_SOFF",
        "",
        2, // Width in bytes
        0x00001004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd0_soff
    },
    {
        "TCD0_ATTR",
        "",
        2, // Width in bytes
        0x00001006, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd0_attr
    },
    {
        "TCD0_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd0_nbytes_mlno
    },
    {
        "TCD0_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001008, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd0_nbytes_mloffno
    },
    {
        "TCD0_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001008, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd0_nbytes_mloffyes
    },
    {
        "TCD0_SLAST",
        "",
        4, // Width in bytes
        0x0000100c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd0_slast
    },
    {
        "TCD0_DADDR",
        "",
        4, // Width in bytes
        0x00001010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd0_daddr
    },
    {
        "TCD0_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001016, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd0_citer_elinkyes
    },
    {
        "TCD0_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001016, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd0_citer_elinkno
    },
    {
        "TCD0_DOFF",
        "",
        2, // Width in bytes
        0x00001014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd0_doff
    },
    {
        "TCD0_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd0_dlastsga
    },
    {
        "TCD0_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000101e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd0_biter_elinkyes
    },
    {
        "TCD0_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000101e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd0_biter_elinkno
    },
    {
        "TCD0_CSR",
        "",
        2, // Width in bytes
        0x0000101c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd0_csr
    },
    {
        "TCD1_SADDR",
        "",
        4, // Width in bytes
        0x00001020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd1_saddr
    },
    {
        "TCD1_SOFF",
        "",
        2, // Width in bytes
        0x00001024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd1_soff
    },
    {
        "TCD1_ATTR",
        "",
        2, // Width in bytes
        0x00001026, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd1_attr
    },
    {
        "TCD1_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd1_nbytes_mlno
    },
    {
        "TCD1_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001028, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd1_nbytes_mloffno
    },
    {
        "TCD1_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001028, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd1_nbytes_mloffyes
    },
    {
        "TCD1_SLAST",
        "",
        4, // Width in bytes
        0x0000102c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd1_slast
    },
    {
        "TCD1_DADDR",
        "",
        4, // Width in bytes
        0x00001030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd1_daddr
    },
    {
        "TCD1_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001036, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd1_citer_elinkyes
    },
    {
        "TCD1_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001036, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd1_citer_elinkno
    },
    {
        "TCD1_DOFF",
        "",
        2, // Width in bytes
        0x00001034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd1_doff
    },
    {
        "TCD1_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd1_dlastsga
    },
    {
        "TCD1_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000103e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd1_biter_elinkyes
    },
    {
        "TCD1_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000103e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd1_biter_elinkno
    },
    {
        "TCD1_CSR",
        "",
        2, // Width in bytes
        0x0000103c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd1_csr
    },
    {
        "TCD2_SADDR",
        "",
        4, // Width in bytes
        0x00001040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd2_saddr
    },
    {
        "TCD2_SOFF",
        "",
        2, // Width in bytes
        0x00001044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd2_soff
    },
    {
        "TCD2_ATTR",
        "",
        2, // Width in bytes
        0x00001046, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd2_attr
    },
    {
        "TCD2_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001048, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd2_nbytes_mlno
    },
    {
        "TCD2_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001048, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd2_nbytes_mloffno
    },
    {
        "TCD2_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001048, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd2_nbytes_mloffyes
    },
    {
        "TCD2_SLAST",
        "",
        4, // Width in bytes
        0x0000104c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd2_slast
    },
    {
        "TCD2_DADDR",
        "",
        4, // Width in bytes
        0x00001050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd2_daddr
    },
    {
        "TCD2_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001056, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd2_citer_elinkyes
    },
    {
        "TCD2_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001056, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd2_citer_elinkno
    },
    {
        "TCD2_DOFF",
        "",
        2, // Width in bytes
        0x00001054, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd2_doff
    },
    {
        "TCD2_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001058, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd2_dlastsga
    },
    {
        "TCD2_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000105e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd2_biter_elinkyes
    },
    {
        "TCD2_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000105e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd2_biter_elinkno
    },
    {
        "TCD2_CSR",
        "",
        2, // Width in bytes
        0x0000105c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd2_csr
    },
    {
        "TCD3_SADDR",
        "",
        4, // Width in bytes
        0x00001060, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd3_saddr
    },
    {
        "TCD3_SOFF",
        "",
        2, // Width in bytes
        0x00001064, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd3_soff
    },
    {
        "TCD3_ATTR",
        "",
        2, // Width in bytes
        0x00001066, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd3_attr
    },
    {
        "TCD3_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001068, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd3_nbytes_mlno
    },
    {
        "TCD3_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001068, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd3_nbytes_mloffno
    },
    {
        "TCD3_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001068, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd3_nbytes_mloffyes
    },
    {
        "TCD3_SLAST",
        "",
        4, // Width in bytes
        0x0000106c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd3_slast
    },
    {
        "TCD3_DADDR",
        "",
        4, // Width in bytes
        0x00001070, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd3_daddr
    },
    {
        "TCD3_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001076, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd3_citer_elinkyes
    },
    {
        "TCD3_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001076, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd3_citer_elinkno
    },
    {
        "TCD3_DOFF",
        "",
        2, // Width in bytes
        0x00001074, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd3_doff
    },
    {
        "TCD3_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001078, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd3_dlastsga
    },
    {
        "TCD3_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000107e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd3_biter_elinkyes
    },
    {
        "TCD3_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000107e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd3_biter_elinkno
    },
    {
        "TCD3_CSR",
        "",
        2, // Width in bytes
        0x0000107c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd3_csr
    },
    {
        "TCD4_SADDR",
        "",
        4, // Width in bytes
        0x00001080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd4_saddr
    },
    {
        "TCD4_SOFF",
        "",
        2, // Width in bytes
        0x00001084, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd4_soff
    },
    {
        "TCD4_ATTR",
        "",
        2, // Width in bytes
        0x00001086, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd4_attr
    },
    {
        "TCD4_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001088, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd4_nbytes_mlno
    },
    {
        "TCD4_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001088, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd4_nbytes_mloffno
    },
    {
        "TCD4_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001088, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd4_nbytes_mloffyes
    },
    {
        "TCD4_SLAST",
        "",
        4, // Width in bytes
        0x0000108c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd4_slast
    },
    {
        "TCD4_DADDR",
        "",
        4, // Width in bytes
        0x00001090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd4_daddr
    },
    {
        "TCD4_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001096, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd4_citer_elinkyes
    },
    {
        "TCD4_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001096, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd4_citer_elinkno
    },
    {
        "TCD4_DOFF",
        "",
        2, // Width in bytes
        0x00001094, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd4_doff
    },
    {
        "TCD4_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001098, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd4_dlastsga
    },
    {
        "TCD4_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000109e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd4_biter_elinkyes
    },
    {
        "TCD4_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000109e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd4_biter_elinkno
    },
    {
        "TCD4_CSR",
        "",
        2, // Width in bytes
        0x0000109c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd4_csr
    },
    {
        "TCD5_SADDR",
        "",
        4, // Width in bytes
        0x000010a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd5_saddr
    },
    {
        "TCD5_SOFF",
        "",
        2, // Width in bytes
        0x000010a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd5_soff
    },
    {
        "TCD5_ATTR",
        "",
        2, // Width in bytes
        0x000010a6, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd5_attr
    },
    {
        "TCD5_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x000010a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd5_nbytes_mlno
    },
    {
        "TCD5_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000010a8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd5_nbytes_mloffno
    },
    {
        "TCD5_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000010a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd5_nbytes_mloffyes
    },
    {
        "TCD5_SLAST",
        "",
        4, // Width in bytes
        0x000010ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd5_slast
    },
    {
        "TCD5_DADDR",
        "",
        4, // Width in bytes
        0x000010b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd5_daddr
    },
    {
        "TCD5_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000010b6, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd5_citer_elinkyes
    },
    {
        "TCD5_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000010b6, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd5_citer_elinkno
    },
    {
        "TCD5_DOFF",
        "",
        2, // Width in bytes
        0x000010b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd5_doff
    },
    {
        "TCD5_DLASTSGA",
        "",
        4, // Width in bytes
        0x000010b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd5_dlastsga
    },
    {
        "TCD5_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x000010be, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd5_biter_elinkyes
    },
    {
        "TCD5_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x000010be, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd5_biter_elinkno
    },
    {
        "TCD5_CSR",
        "",
        2, // Width in bytes
        0x000010bc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd5_csr
    },
    {
        "TCD6_SADDR",
        "",
        4, // Width in bytes
        0x000010c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd6_saddr
    },
    {
        "TCD6_SOFF",
        "",
        2, // Width in bytes
        0x000010c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd6_soff
    },
    {
        "TCD6_ATTR",
        "",
        2, // Width in bytes
        0x000010c6, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd6_attr
    },
    {
        "TCD6_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x000010c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd6_nbytes_mlno
    },
    {
        "TCD6_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000010c8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd6_nbytes_mloffno
    },
    {
        "TCD6_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000010c8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd6_nbytes_mloffyes
    },
    {
        "TCD6_SLAST",
        "",
        4, // Width in bytes
        0x000010cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd6_slast
    },
    {
        "TCD6_DADDR",
        "",
        4, // Width in bytes
        0x000010d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd6_daddr
    },
    {
        "TCD6_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000010d6, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd6_citer_elinkyes
    },
    {
        "TCD6_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000010d6, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd6_citer_elinkno
    },
    {
        "TCD6_DOFF",
        "",
        2, // Width in bytes
        0x000010d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd6_doff
    },
    {
        "TCD6_DLASTSGA",
        "",
        4, // Width in bytes
        0x000010d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd6_dlastsga
    },
    {
        "TCD6_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x000010de, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd6_biter_elinkyes
    },
    {
        "TCD6_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x000010de, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd6_biter_elinkno
    },
    {
        "TCD6_CSR",
        "",
        2, // Width in bytes
        0x000010dc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd6_csr
    },
    {
        "TCD7_SADDR",
        "",
        4, // Width in bytes
        0x000010e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd7_saddr
    },
    {
        "TCD7_SOFF",
        "",
        2, // Width in bytes
        0x000010e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd7_soff
    },
    {
        "TCD7_ATTR",
        "",
        2, // Width in bytes
        0x000010e6, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd7_attr
    },
    {
        "TCD7_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x000010e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd7_nbytes_mlno
    },
    {
        "TCD7_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000010e8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd7_nbytes_mloffno
    },
    {
        "TCD7_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000010e8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd7_nbytes_mloffyes
    },
    {
        "TCD7_SLAST",
        "",
        4, // Width in bytes
        0x000010ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd7_slast
    },
    {
        "TCD7_DADDR",
        "",
        4, // Width in bytes
        0x000010f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd7_daddr
    },
    {
        "TCD7_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000010f6, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd7_citer_elinkyes
    },
    {
        "TCD7_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000010f6, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd7_citer_elinkno
    },
    {
        "TCD7_DOFF",
        "",
        2, // Width in bytes
        0x000010f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd7_doff
    },
    {
        "TCD7_DLASTSGA",
        "",
        4, // Width in bytes
        0x000010f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd7_dlastsga
    },
    {
        "TCD7_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x000010fe, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd7_biter_elinkyes
    },
    {
        "TCD7_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x000010fe, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd7_biter_elinkno
    },
    {
        "TCD7_CSR",
        "",
        2, // Width in bytes
        0x000010fc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd7_csr
    },
    {
        "TCD8_SADDR",
        "",
        4, // Width in bytes
        0x00001100, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd8_saddr
    },
    {
        "TCD8_SOFF",
        "",
        2, // Width in bytes
        0x00001104, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd8_soff
    },
    {
        "TCD8_ATTR",
        "",
        2, // Width in bytes
        0x00001106, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd8_attr
    },
    {
        "TCD8_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001108, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd8_nbytes_mlno
    },
    {
        "TCD8_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001108, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd8_nbytes_mloffno
    },
    {
        "TCD8_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001108, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd8_nbytes_mloffyes
    },
    {
        "TCD8_SLAST",
        "",
        4, // Width in bytes
        0x0000110c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd8_slast
    },
    {
        "TCD8_DADDR",
        "",
        4, // Width in bytes
        0x00001110, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd8_daddr
    },
    {
        "TCD8_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001116, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd8_citer_elinkyes
    },
    {
        "TCD8_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001116, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd8_citer_elinkno
    },
    {
        "TCD8_DOFF",
        "",
        2, // Width in bytes
        0x00001114, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd8_doff
    },
    {
        "TCD8_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001118, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd8_dlastsga
    },
    {
        "TCD8_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000111e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd8_biter_elinkyes
    },
    {
        "TCD8_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000111e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd8_biter_elinkno
    },
    {
        "TCD8_CSR",
        "",
        2, // Width in bytes
        0x0000111c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd8_csr
    },
    {
        "TCD9_SADDR",
        "",
        4, // Width in bytes
        0x00001120, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd9_saddr
    },
    {
        "TCD9_SOFF",
        "",
        2, // Width in bytes
        0x00001124, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd9_soff
    },
    {
        "TCD9_ATTR",
        "",
        2, // Width in bytes
        0x00001126, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd9_attr
    },
    {
        "TCD9_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001128, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd9_nbytes_mlno
    },
    {
        "TCD9_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001128, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd9_nbytes_mloffno
    },
    {
        "TCD9_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001128, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd9_nbytes_mloffyes
    },
    {
        "TCD9_SLAST",
        "",
        4, // Width in bytes
        0x0000112c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd9_slast
    },
    {
        "TCD9_DADDR",
        "",
        4, // Width in bytes
        0x00001130, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd9_daddr
    },
    {
        "TCD9_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001136, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd9_citer_elinkyes
    },
    {
        "TCD9_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001136, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd9_citer_elinkno
    },
    {
        "TCD9_DOFF",
        "",
        2, // Width in bytes
        0x00001134, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd9_doff
    },
    {
        "TCD9_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001138, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd9_dlastsga
    },
    {
        "TCD9_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000113e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd9_biter_elinkyes
    },
    {
        "TCD9_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000113e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd9_biter_elinkno
    },
    {
        "TCD9_CSR",
        "",
        2, // Width in bytes
        0x0000113c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd9_csr
    },
    {
        "TCD10_SADDR",
        "",
        4, // Width in bytes
        0x00001140, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd10_saddr
    },
    {
        "TCD10_SOFF",
        "",
        2, // Width in bytes
        0x00001144, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd10_soff
    },
    {
        "TCD10_ATTR",
        "",
        2, // Width in bytes
        0x00001146, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd10_attr
    },
    {
        "TCD10_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001148, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd10_nbytes_mlno
    },
    {
        "TCD10_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001148, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd10_nbytes_mloffno
    },
    {
        "TCD10_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001148, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd10_nbytes_mloffyes
    },
    {
        "TCD10_SLAST",
        "",
        4, // Width in bytes
        0x0000114c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd10_slast
    },
    {
        "TCD10_DADDR",
        "",
        4, // Width in bytes
        0x00001150, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd10_daddr
    },
    {
        "TCD10_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001156, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd10_citer_elinkyes
    },
    {
        "TCD10_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001156, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd10_citer_elinkno
    },
    {
        "TCD10_DOFF",
        "",
        2, // Width in bytes
        0x00001154, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd10_doff
    },
    {
        "TCD10_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001158, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd10_dlastsga
    },
    {
        "TCD10_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000115e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd10_biter_elinkyes
    },
    {
        "TCD10_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000115e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd10_biter_elinkno
    },
    {
        "TCD10_CSR",
        "",
        2, // Width in bytes
        0x0000115c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd10_csr
    },
    {
        "TCD11_SADDR",
        "",
        4, // Width in bytes
        0x00001160, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd11_saddr
    },
    {
        "TCD11_SOFF",
        "",
        2, // Width in bytes
        0x00001164, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd11_soff
    },
    {
        "TCD11_ATTR",
        "",
        2, // Width in bytes
        0x00001166, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd11_attr
    },
    {
        "TCD11_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001168, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd11_nbytes_mlno
    },
    {
        "TCD11_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001168, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd11_nbytes_mloffno
    },
    {
        "TCD11_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001168, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd11_nbytes_mloffyes
    },
    {
        "TCD11_SLAST",
        "",
        4, // Width in bytes
        0x0000116c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd11_slast
    },
    {
        "TCD11_DADDR",
        "",
        4, // Width in bytes
        0x00001170, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd11_daddr
    },
    {
        "TCD11_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001176, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd11_citer_elinkyes
    },
    {
        "TCD11_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001176, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd11_citer_elinkno
    },
    {
        "TCD11_DOFF",
        "",
        2, // Width in bytes
        0x00001174, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd11_doff
    },
    {
        "TCD11_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001178, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd11_dlastsga
    },
    {
        "TCD11_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000117e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd11_biter_elinkyes
    },
    {
        "TCD11_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000117e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd11_biter_elinkno
    },
    {
        "TCD11_CSR",
        "",
        2, // Width in bytes
        0x0000117c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd11_csr
    },
    {
        "TCD12_SADDR",
        "",
        4, // Width in bytes
        0x00001180, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd12_saddr
    },
    {
        "TCD12_SOFF",
        "",
        2, // Width in bytes
        0x00001184, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd12_soff
    },
    {
        "TCD12_ATTR",
        "",
        2, // Width in bytes
        0x00001186, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd12_attr
    },
    {
        "TCD12_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001188, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd12_nbytes_mlno
    },
    {
        "TCD12_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001188, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd12_nbytes_mloffno
    },
    {
        "TCD12_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001188, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd12_nbytes_mloffyes
    },
    {
        "TCD12_SLAST",
        "",
        4, // Width in bytes
        0x0000118c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd12_slast
    },
    {
        "TCD12_DADDR",
        "",
        4, // Width in bytes
        0x00001190, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd12_daddr
    },
    {
        "TCD12_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001196, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd12_citer_elinkyes
    },
    {
        "TCD12_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001196, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd12_citer_elinkno
    },
    {
        "TCD12_DOFF",
        "",
        2, // Width in bytes
        0x00001194, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd12_doff
    },
    {
        "TCD12_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001198, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd12_dlastsga
    },
    {
        "TCD12_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000119e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd12_biter_elinkyes
    },
    {
        "TCD12_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000119e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd12_biter_elinkno
    },
    {
        "TCD12_CSR",
        "",
        2, // Width in bytes
        0x0000119c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd12_csr
    },
    {
        "TCD13_SADDR",
        "",
        4, // Width in bytes
        0x000011a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd13_saddr
    },
    {
        "TCD13_SOFF",
        "",
        2, // Width in bytes
        0x000011a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd13_soff
    },
    {
        "TCD13_ATTR",
        "",
        2, // Width in bytes
        0x000011a6, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd13_attr
    },
    {
        "TCD13_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x000011a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd13_nbytes_mlno
    },
    {
        "TCD13_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000011a8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd13_nbytes_mloffno
    },
    {
        "TCD13_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000011a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd13_nbytes_mloffyes
    },
    {
        "TCD13_SLAST",
        "",
        4, // Width in bytes
        0x000011ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd13_slast
    },
    {
        "TCD13_DADDR",
        "",
        4, // Width in bytes
        0x000011b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd13_daddr
    },
    {
        "TCD13_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000011b6, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd13_citer_elinkyes
    },
    {
        "TCD13_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000011b6, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd13_citer_elinkno
    },
    {
        "TCD13_DOFF",
        "",
        2, // Width in bytes
        0x000011b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd13_doff
    },
    {
        "TCD13_DLASTSGA",
        "",
        4, // Width in bytes
        0x000011b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd13_dlastsga
    },
    {
        "TCD13_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x000011be, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd13_biter_elinkyes
    },
    {
        "TCD13_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x000011be, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd13_biter_elinkno
    },
    {
        "TCD13_CSR",
        "",
        2, // Width in bytes
        0x000011bc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd13_csr
    },
    {
        "TCD14_SADDR",
        "",
        4, // Width in bytes
        0x000011c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd14_saddr
    },
    {
        "TCD14_SOFF",
        "",
        2, // Width in bytes
        0x000011c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd14_soff
    },
    {
        "TCD14_ATTR",
        "",
        2, // Width in bytes
        0x000011c6, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd14_attr
    },
    {
        "TCD14_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x000011c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd14_nbytes_mlno
    },
    {
        "TCD14_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000011c8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd14_nbytes_mloffno
    },
    {
        "TCD14_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000011c8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd14_nbytes_mloffyes
    },
    {
        "TCD14_SLAST",
        "",
        4, // Width in bytes
        0x000011cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd14_slast
    },
    {
        "TCD14_DADDR",
        "",
        4, // Width in bytes
        0x000011d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd14_daddr
    },
    {
        "TCD14_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000011d6, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd14_citer_elinkyes
    },
    {
        "TCD14_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000011d6, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd14_citer_elinkno
    },
    {
        "TCD14_DOFF",
        "",
        2, // Width in bytes
        0x000011d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd14_doff
    },
    {
        "TCD14_DLASTSGA",
        "",
        4, // Width in bytes
        0x000011d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd14_dlastsga
    },
    {
        "TCD14_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x000011de, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd14_biter_elinkyes
    },
    {
        "TCD14_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x000011de, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd14_biter_elinkno
    },
    {
        "TCD14_CSR",
        "",
        2, // Width in bytes
        0x000011dc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd14_csr
    },
    {
        "TCD15_SADDR",
        "",
        4, // Width in bytes
        0x000011e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd15_saddr
    },
    {
        "TCD15_SOFF",
        "",
        2, // Width in bytes
        0x000011e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd15_soff
    },
    {
        "TCD15_ATTR",
        "",
        2, // Width in bytes
        0x000011e6, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd15_attr
    },
    {
        "TCD15_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x000011e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd15_nbytes_mlno
    },
    {
        "TCD15_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000011e8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd15_nbytes_mloffno
    },
    {
        "TCD15_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000011e8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd15_nbytes_mloffyes
    },
    {
        "TCD15_SLAST",
        "",
        4, // Width in bytes
        0x000011ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd15_slast
    },
    {
        "TCD15_DADDR",
        "",
        4, // Width in bytes
        0x000011f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd15_daddr
    },
    {
        "TCD15_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000011f6, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd15_citer_elinkyes
    },
    {
        "TCD15_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000011f6, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd15_citer_elinkno
    },
    {
        "TCD15_DOFF",
        "",
        2, // Width in bytes
        0x000011f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd15_doff
    },
    {
        "TCD15_DLASTSGA",
        "",
        4, // Width in bytes
        0x000011f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd15_dlastsga
    },
    {
        "TCD15_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x000011fe, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd15_biter_elinkyes
    },
    {
        "TCD15_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x000011fe, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd15_biter_elinkno
    },
    {
        "TCD15_CSR",
        "",
        2, // Width in bytes
        0x000011fc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd15_csr
    },
    {
        "TCD16_SADDR",
        "",
        4, // Width in bytes
        0x00001200, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd16_saddr
    },
    {
        "TCD16_SOFF",
        "",
        2, // Width in bytes
        0x00001204, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd16_soff
    },
    {
        "TCD16_ATTR",
        "",
        2, // Width in bytes
        0x00001206, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd16_attr
    },
    {
        "TCD16_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001208, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd16_nbytes_mlno
    },
    {
        "TCD16_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001208, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd16_nbytes_mloffno
    },
    {
        "TCD16_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001208, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd16_nbytes_mloffyes
    },
    {
        "TCD16_SLAST",
        "",
        4, // Width in bytes
        0x0000120c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd16_slast
    },
    {
        "TCD16_DADDR",
        "",
        4, // Width in bytes
        0x00001210, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd16_daddr
    },
    {
        "TCD16_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001216, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd16_citer_elinkyes
    },
    {
        "TCD16_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001216, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd16_citer_elinkno
    },
    {
        "TCD16_DOFF",
        "",
        2, // Width in bytes
        0x00001214, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd16_doff
    },
    {
        "TCD16_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001218, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd16_dlastsga
    },
    {
        "TCD16_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000121e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd16_biter_elinkyes
    },
    {
        "TCD16_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000121e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd16_biter_elinkno
    },
    {
        "TCD16_CSR",
        "",
        2, // Width in bytes
        0x0000121c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd16_csr
    },
    {
        "TCD17_SADDR",
        "",
        4, // Width in bytes
        0x00001220, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd17_saddr
    },
    {
        "TCD17_SOFF",
        "",
        2, // Width in bytes
        0x00001224, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd17_soff
    },
    {
        "TCD17_ATTR",
        "",
        2, // Width in bytes
        0x00001226, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd17_attr
    },
    {
        "TCD17_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001228, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd17_nbytes_mlno
    },
    {
        "TCD17_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001228, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd17_nbytes_mloffno
    },
    {
        "TCD17_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001228, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd17_nbytes_mloffyes
    },
    {
        "TCD17_SLAST",
        "",
        4, // Width in bytes
        0x0000122c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd17_slast
    },
    {
        "TCD17_DADDR",
        "",
        4, // Width in bytes
        0x00001230, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd17_daddr
    },
    {
        "TCD17_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001236, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd17_citer_elinkyes
    },
    {
        "TCD17_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001236, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd17_citer_elinkno
    },
    {
        "TCD17_DOFF",
        "",
        2, // Width in bytes
        0x00001234, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd17_doff
    },
    {
        "TCD17_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001238, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd17_dlastsga
    },
    {
        "TCD17_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000123e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd17_biter_elinkyes
    },
    {
        "TCD17_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000123e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd17_biter_elinkno
    },
    {
        "TCD17_CSR",
        "",
        2, // Width in bytes
        0x0000123c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd17_csr
    },
    {
        "TCD18_SADDR",
        "",
        4, // Width in bytes
        0x00001240, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd18_saddr
    },
    {
        "TCD18_SOFF",
        "",
        2, // Width in bytes
        0x00001244, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd18_soff
    },
    {
        "TCD18_ATTR",
        "",
        2, // Width in bytes
        0x00001246, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd18_attr
    },
    {
        "TCD18_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001248, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd18_nbytes_mlno
    },
    {
        "TCD18_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001248, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd18_nbytes_mloffno
    },
    {
        "TCD18_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001248, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd18_nbytes_mloffyes
    },
    {
        "TCD18_SLAST",
        "",
        4, // Width in bytes
        0x0000124c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd18_slast
    },
    {
        "TCD18_DADDR",
        "",
        4, // Width in bytes
        0x00001250, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd18_daddr
    },
    {
        "TCD18_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001256, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd18_citer_elinkyes
    },
    {
        "TCD18_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001256, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd18_citer_elinkno
    },
    {
        "TCD18_DOFF",
        "",
        2, // Width in bytes
        0x00001254, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd18_doff
    },
    {
        "TCD18_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001258, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd18_dlastsga
    },
    {
        "TCD18_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000125e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd18_biter_elinkyes
    },
    {
        "TCD18_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000125e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd18_biter_elinkno
    },
    {
        "TCD18_CSR",
        "",
        2, // Width in bytes
        0x0000125c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd18_csr
    },
    {
        "TCD19_SADDR",
        "",
        4, // Width in bytes
        0x00001260, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd19_saddr
    },
    {
        "TCD19_SOFF",
        "",
        2, // Width in bytes
        0x00001264, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd19_soff
    },
    {
        "TCD19_ATTR",
        "",
        2, // Width in bytes
        0x00001266, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd19_attr
    },
    {
        "TCD19_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001268, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd19_nbytes_mlno
    },
    {
        "TCD19_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001268, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd19_nbytes_mloffno
    },
    {
        "TCD19_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001268, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd19_nbytes_mloffyes
    },
    {
        "TCD19_SLAST",
        "",
        4, // Width in bytes
        0x0000126c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd19_slast
    },
    {
        "TCD19_DADDR",
        "",
        4, // Width in bytes
        0x00001270, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd19_daddr
    },
    {
        "TCD19_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001276, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd19_citer_elinkyes
    },
    {
        "TCD19_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001276, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd19_citer_elinkno
    },
    {
        "TCD19_DOFF",
        "",
        2, // Width in bytes
        0x00001274, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd19_doff
    },
    {
        "TCD19_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001278, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd19_dlastsga
    },
    {
        "TCD19_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000127e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd19_biter_elinkyes
    },
    {
        "TCD19_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000127e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd19_biter_elinkno
    },
    {
        "TCD19_CSR",
        "",
        2, // Width in bytes
        0x0000127c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd19_csr
    },
    {
        "TCD20_SADDR",
        "",
        4, // Width in bytes
        0x00001280, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd20_saddr
    },
    {
        "TCD20_SOFF",
        "",
        2, // Width in bytes
        0x00001284, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd20_soff
    },
    {
        "TCD20_ATTR",
        "",
        2, // Width in bytes
        0x00001286, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd20_attr
    },
    {
        "TCD20_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001288, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd20_nbytes_mlno
    },
    {
        "TCD20_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001288, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd20_nbytes_mloffno
    },
    {
        "TCD20_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001288, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd20_nbytes_mloffyes
    },
    {
        "TCD20_SLAST",
        "",
        4, // Width in bytes
        0x0000128c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd20_slast
    },
    {
        "TCD20_DADDR",
        "",
        4, // Width in bytes
        0x00001290, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd20_daddr
    },
    {
        "TCD20_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001296, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd20_citer_elinkyes
    },
    {
        "TCD20_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001296, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd20_citer_elinkno
    },
    {
        "TCD20_DOFF",
        "",
        2, // Width in bytes
        0x00001294, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd20_doff
    },
    {
        "TCD20_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001298, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd20_dlastsga
    },
    {
        "TCD20_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000129e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd20_biter_elinkyes
    },
    {
        "TCD20_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000129e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd20_biter_elinkno
    },
    {
        "TCD20_CSR",
        "",
        2, // Width in bytes
        0x0000129c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd20_csr
    },
    {
        "TCD21_SADDR",
        "",
        4, // Width in bytes
        0x000012a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd21_saddr
    },
    {
        "TCD21_SOFF",
        "",
        2, // Width in bytes
        0x000012a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd21_soff
    },
    {
        "TCD21_ATTR",
        "",
        2, // Width in bytes
        0x000012a6, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd21_attr
    },
    {
        "TCD21_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x000012a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd21_nbytes_mlno
    },
    {
        "TCD21_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000012a8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd21_nbytes_mloffno
    },
    {
        "TCD21_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000012a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd21_nbytes_mloffyes
    },
    {
        "TCD21_SLAST",
        "",
        4, // Width in bytes
        0x000012ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd21_slast
    },
    {
        "TCD21_DADDR",
        "",
        4, // Width in bytes
        0x000012b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd21_daddr
    },
    {
        "TCD21_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000012b6, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd21_citer_elinkyes
    },
    {
        "TCD21_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000012b6, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd21_citer_elinkno
    },
    {
        "TCD21_DOFF",
        "",
        2, // Width in bytes
        0x000012b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd21_doff
    },
    {
        "TCD21_DLASTSGA",
        "",
        4, // Width in bytes
        0x000012b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd21_dlastsga
    },
    {
        "TCD21_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x000012be, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd21_biter_elinkyes
    },
    {
        "TCD21_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x000012be, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd21_biter_elinkno
    },
    {
        "TCD21_CSR",
        "",
        2, // Width in bytes
        0x000012bc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd21_csr
    },
    {
        "TCD22_SADDR",
        "",
        4, // Width in bytes
        0x000012c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd22_saddr
    },
    {
        "TCD22_SOFF",
        "",
        2, // Width in bytes
        0x000012c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd22_soff
    },
    {
        "TCD22_ATTR",
        "",
        2, // Width in bytes
        0x000012c6, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd22_attr
    },
    {
        "TCD22_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x000012c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd22_nbytes_mlno
    },
    {
        "TCD22_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000012c8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd22_nbytes_mloffno
    },
    {
        "TCD22_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000012c8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd22_nbytes_mloffyes
    },
    {
        "TCD22_SLAST",
        "",
        4, // Width in bytes
        0x000012cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd22_slast
    },
    {
        "TCD22_DADDR",
        "",
        4, // Width in bytes
        0x000012d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd22_daddr
    },
    {
        "TCD22_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000012d6, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd22_citer_elinkyes
    },
    {
        "TCD22_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000012d6, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd22_citer_elinkno
    },
    {
        "TCD22_DOFF",
        "",
        2, // Width in bytes
        0x000012d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd22_doff
    },
    {
        "TCD22_DLASTSGA",
        "",
        4, // Width in bytes
        0x000012d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd22_dlastsga
    },
    {
        "TCD22_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x000012de, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd22_biter_elinkyes
    },
    {
        "TCD22_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x000012de, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd22_biter_elinkno
    },
    {
        "TCD22_CSR",
        "",
        2, // Width in bytes
        0x000012dc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd22_csr
    },
    {
        "TCD23_SADDR",
        "",
        4, // Width in bytes
        0x000012e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd23_saddr
    },
    {
        "TCD23_SOFF",
        "",
        2, // Width in bytes
        0x000012e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd23_soff
    },
    {
        "TCD23_ATTR",
        "",
        2, // Width in bytes
        0x000012e6, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd23_attr
    },
    {
        "TCD23_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x000012e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd23_nbytes_mlno
    },
    {
        "TCD23_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000012e8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd23_nbytes_mloffno
    },
    {
        "TCD23_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000012e8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd23_nbytes_mloffyes
    },
    {
        "TCD23_SLAST",
        "",
        4, // Width in bytes
        0x000012ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd23_slast
    },
    {
        "TCD23_DADDR",
        "",
        4, // Width in bytes
        0x000012f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd23_daddr
    },
    {
        "TCD23_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000012f6, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd23_citer_elinkyes
    },
    {
        "TCD23_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000012f6, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd23_citer_elinkno
    },
    {
        "TCD23_DOFF",
        "",
        2, // Width in bytes
        0x000012f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd23_doff
    },
    {
        "TCD23_DLASTSGA",
        "",
        4, // Width in bytes
        0x000012f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd23_dlastsga
    },
    {
        "TCD23_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x000012fe, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd23_biter_elinkyes
    },
    {
        "TCD23_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x000012fe, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd23_biter_elinkno
    },
    {
        "TCD23_CSR",
        "",
        2, // Width in bytes
        0x000012fc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd23_csr
    },
    {
        "TCD24_SADDR",
        "",
        4, // Width in bytes
        0x00001300, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd24_saddr
    },
    {
        "TCD24_SOFF",
        "",
        2, // Width in bytes
        0x00001304, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd24_soff
    },
    {
        "TCD24_ATTR",
        "",
        2, // Width in bytes
        0x00001306, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd24_attr
    },
    {
        "TCD24_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001308, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd24_nbytes_mlno
    },
    {
        "TCD24_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001308, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd24_nbytes_mloffno
    },
    {
        "TCD24_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001308, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd24_nbytes_mloffyes
    },
    {
        "TCD24_SLAST",
        "",
        4, // Width in bytes
        0x0000130c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd24_slast
    },
    {
        "TCD24_DADDR",
        "",
        4, // Width in bytes
        0x00001310, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd24_daddr
    },
    {
        "TCD24_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001316, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd24_citer_elinkyes
    },
    {
        "TCD24_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001316, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd24_citer_elinkno
    },
    {
        "TCD24_DOFF",
        "",
        2, // Width in bytes
        0x00001314, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd24_doff
    },
    {
        "TCD24_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001318, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd24_dlastsga
    },
    {
        "TCD24_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000131e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd24_biter_elinkyes
    },
    {
        "TCD24_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000131e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd24_biter_elinkno
    },
    {
        "TCD24_CSR",
        "",
        2, // Width in bytes
        0x0000131c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd24_csr
    },
    {
        "TCD25_SADDR",
        "",
        4, // Width in bytes
        0x00001320, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd25_saddr
    },
    {
        "TCD25_SOFF",
        "",
        2, // Width in bytes
        0x00001324, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd25_soff
    },
    {
        "TCD25_ATTR",
        "",
        2, // Width in bytes
        0x00001326, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd25_attr
    },
    {
        "TCD25_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001328, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd25_nbytes_mlno
    },
    {
        "TCD25_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001328, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd25_nbytes_mloffno
    },
    {
        "TCD25_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001328, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd25_nbytes_mloffyes
    },
    {
        "TCD25_SLAST",
        "",
        4, // Width in bytes
        0x0000132c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd25_slast
    },
    {
        "TCD25_DADDR",
        "",
        4, // Width in bytes
        0x00001330, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd25_daddr
    },
    {
        "TCD25_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001336, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd25_citer_elinkyes
    },
    {
        "TCD25_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001336, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd25_citer_elinkno
    },
    {
        "TCD25_DOFF",
        "",
        2, // Width in bytes
        0x00001334, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd25_doff
    },
    {
        "TCD25_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001338, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd25_dlastsga
    },
    {
        "TCD25_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000133e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd25_biter_elinkyes
    },
    {
        "TCD25_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000133e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd25_biter_elinkno
    },
    {
        "TCD25_CSR",
        "",
        2, // Width in bytes
        0x0000133c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd25_csr
    },
    {
        "TCD26_SADDR",
        "",
        4, // Width in bytes
        0x00001340, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd26_saddr
    },
    {
        "TCD26_SOFF",
        "",
        2, // Width in bytes
        0x00001344, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd26_soff
    },
    {
        "TCD26_ATTR",
        "",
        2, // Width in bytes
        0x00001346, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd26_attr
    },
    {
        "TCD26_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001348, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd26_nbytes_mlno
    },
    {
        "TCD26_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001348, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd26_nbytes_mloffno
    },
    {
        "TCD26_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001348, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd26_nbytes_mloffyes
    },
    {
        "TCD26_SLAST",
        "",
        4, // Width in bytes
        0x0000134c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd26_slast
    },
    {
        "TCD26_DADDR",
        "",
        4, // Width in bytes
        0x00001350, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd26_daddr
    },
    {
        "TCD26_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001356, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd26_citer_elinkyes
    },
    {
        "TCD26_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001356, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd26_citer_elinkno
    },
    {
        "TCD26_DOFF",
        "",
        2, // Width in bytes
        0x00001354, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd26_doff
    },
    {
        "TCD26_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001358, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd26_dlastsga
    },
    {
        "TCD26_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000135e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd26_biter_elinkyes
    },
    {
        "TCD26_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000135e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd26_biter_elinkno
    },
    {
        "TCD26_CSR",
        "",
        2, // Width in bytes
        0x0000135c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd26_csr
    },
    {
        "TCD27_SADDR",
        "",
        4, // Width in bytes
        0x00001360, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd27_saddr
    },
    {
        "TCD27_SOFF",
        "",
        2, // Width in bytes
        0x00001364, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd27_soff
    },
    {
        "TCD27_ATTR",
        "",
        2, // Width in bytes
        0x00001366, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd27_attr
    },
    {
        "TCD27_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001368, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd27_nbytes_mlno
    },
    {
        "TCD27_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001368, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd27_nbytes_mloffno
    },
    {
        "TCD27_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001368, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd27_nbytes_mloffyes
    },
    {
        "TCD27_SLAST",
        "",
        4, // Width in bytes
        0x0000136c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd27_slast
    },
    {
        "TCD27_DADDR",
        "",
        4, // Width in bytes
        0x00001370, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd27_daddr
    },
    {
        "TCD27_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001376, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd27_citer_elinkyes
    },
    {
        "TCD27_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001376, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd27_citer_elinkno
    },
    {
        "TCD27_DOFF",
        "",
        2, // Width in bytes
        0x00001374, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd27_doff
    },
    {
        "TCD27_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001378, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd27_dlastsga
    },
    {
        "TCD27_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000137e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd27_biter_elinkyes
    },
    {
        "TCD27_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000137e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd27_biter_elinkno
    },
    {
        "TCD27_CSR",
        "",
        2, // Width in bytes
        0x0000137c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd27_csr
    },
    {
        "TCD28_SADDR",
        "",
        4, // Width in bytes
        0x00001380, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd28_saddr
    },
    {
        "TCD28_SOFF",
        "",
        2, // Width in bytes
        0x00001384, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd28_soff
    },
    {
        "TCD28_ATTR",
        "",
        2, // Width in bytes
        0x00001386, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd28_attr
    },
    {
        "TCD28_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x00001388, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd28_nbytes_mlno
    },
    {
        "TCD28_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001388, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd28_nbytes_mloffno
    },
    {
        "TCD28_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x00001388, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd28_nbytes_mloffyes
    },
    {
        "TCD28_SLAST",
        "",
        4, // Width in bytes
        0x0000138c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd28_slast
    },
    {
        "TCD28_DADDR",
        "",
        4, // Width in bytes
        0x00001390, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd28_daddr
    },
    {
        "TCD28_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001396, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd28_citer_elinkyes
    },
    {
        "TCD28_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x00001396, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd28_citer_elinkno
    },
    {
        "TCD28_DOFF",
        "",
        2, // Width in bytes
        0x00001394, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd28_doff
    },
    {
        "TCD28_DLASTSGA",
        "",
        4, // Width in bytes
        0x00001398, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd28_dlastsga
    },
    {
        "TCD28_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x0000139e, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd28_biter_elinkyes
    },
    {
        "TCD28_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x0000139e, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd28_biter_elinkno
    },
    {
        "TCD28_CSR",
        "",
        2, // Width in bytes
        0x0000139c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd28_csr
    },
    {
        "TCD29_SADDR",
        "",
        4, // Width in bytes
        0x000013a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd29_saddr
    },
    {
        "TCD29_SOFF",
        "",
        2, // Width in bytes
        0x000013a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd29_soff
    },
    {
        "TCD29_ATTR",
        "",
        2, // Width in bytes
        0x000013a6, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd29_attr
    },
    {
        "TCD29_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x000013a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd29_nbytes_mlno
    },
    {
        "TCD29_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000013a8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd29_nbytes_mloffno
    },
    {
        "TCD29_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000013a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd29_nbytes_mloffyes
    },
    {
        "TCD29_SLAST",
        "",
        4, // Width in bytes
        0x000013ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd29_slast
    },
    {
        "TCD29_DADDR",
        "",
        4, // Width in bytes
        0x000013b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd29_daddr
    },
    {
        "TCD29_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000013b6, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd29_citer_elinkyes
    },
    {
        "TCD29_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000013b6, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd29_citer_elinkno
    },
    {
        "TCD29_DOFF",
        "",
        2, // Width in bytes
        0x000013b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd29_doff
    },
    {
        "TCD29_DLASTSGA",
        "",
        4, // Width in bytes
        0x000013b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd29_dlastsga
    },
    {
        "TCD29_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x000013be, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd29_biter_elinkyes
    },
    {
        "TCD29_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x000013be, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd29_biter_elinkno
    },
    {
        "TCD29_CSR",
        "",
        2, // Width in bytes
        0x000013bc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd29_csr
    },
    {
        "TCD30_SADDR",
        "",
        4, // Width in bytes
        0x000013c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd30_saddr
    },
    {
        "TCD30_SOFF",
        "",
        2, // Width in bytes
        0x000013c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd30_soff
    },
    {
        "TCD30_ATTR",
        "",
        2, // Width in bytes
        0x000013c6, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd30_attr
    },
    {
        "TCD30_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x000013c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd30_nbytes_mlno
    },
    {
        "TCD30_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000013c8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd30_nbytes_mloffno
    },
    {
        "TCD30_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000013c8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd30_nbytes_mloffyes
    },
    {
        "TCD30_SLAST",
        "",
        4, // Width in bytes
        0x000013cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd30_slast
    },
    {
        "TCD30_DADDR",
        "",
        4, // Width in bytes
        0x000013d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd30_daddr
    },
    {
        "TCD30_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000013d6, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd30_citer_elinkyes
    },
    {
        "TCD30_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000013d6, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd30_citer_elinkno
    },
    {
        "TCD30_DOFF",
        "",
        2, // Width in bytes
        0x000013d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd30_doff
    },
    {
        "TCD30_DLASTSGA",
        "",
        4, // Width in bytes
        0x000013d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd30_dlastsga
    },
    {
        "TCD30_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x000013de, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd30_biter_elinkyes
    },
    {
        "TCD30_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x000013de, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd30_biter_elinkno
    },
    {
        "TCD30_CSR",
        "",
        2, // Width in bytes
        0x000013dc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd30_csr
    },
    {
        "TCD31_SADDR",
        "",
        4, // Width in bytes
        0x000013e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd31_saddr
    },
    {
        "TCD31_SOFF",
        "",
        2, // Width in bytes
        0x000013e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd31_soff
    },
    {
        "TCD31_ATTR",
        "",
        2, // Width in bytes
        0x000013e6, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd31_attr
    },
    {
        "TCD31_NBYTES_MLNO",
        "This register, or one of the next two registers (TCD_NBYTES_MLOFFNO, T"
        "CD_NBYTES_MLOFFYES), defines the number of bytes to transfer per reque"
        "st.",
        4, // Width in bytes
        0x000013e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd31_nbytes_mlno
    },
    {
        "TCD31_NBYTES_MLOFFNO",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFYES), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000013e8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd31_nbytes_mloffno
    },
    {
        "TCD31_NBYTES_MLOFFYES",
        "One of three registers (this register, TCD_NBYTES_MLNO, or TCD_NBYTES_"
        "MLOFFNO), defines the number of bytes to transfer per request.",
        4, // Width in bytes
        0x000013e8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_tcd31_nbytes_mloffyes
    },
    {
        "TCD31_SLAST",
        "",
        4, // Width in bytes
        0x000013ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd31_slast
    },
    {
        "TCD31_DADDR",
        "",
        4, // Width in bytes
        0x000013f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd31_daddr
    },
    {
        "TCD31_CITER_ELINKYES",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000013f6, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd31_citer_elinkyes
    },
    {
        "TCD31_CITER_ELINKNO",
        "This register contains the minor-loop channel-linking configuration an"
        "d the channel's current iteration count.",
        2, // Width in bytes
        0x000013f6, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd31_citer_elinkno
    },
    {
        "TCD31_DOFF",
        "",
        2, // Width in bytes
        0x000013f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd31_doff
    },
    {
        "TCD31_DLASTSGA",
        "",
        4, // Width in bytes
        0x000013f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_dma_tcd31_dlastsga
    },
    {
        "TCD31_BITER_ELINKYES",
        "If the TCDn_BITER[ELINK] bit is set, the TCDn_BITER register is define"
        "d as follows.",
        2, // Width in bytes
        0x000013fe, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_dma_tcd31_biter_elinkyes
    },
    {
        "TCD31_BITER_ELINKNO",
        "If the TCDn_BITER[ELINK] bit is cleared, the TCDn_BITER register is de"
        "fined as follows.",
        2, // Width in bytes
        0x000013fe, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_dma_tcd31_biter_elinkno
    },
    {
        "TCD31_CSR",
        "",
        2, // Width in bytes
        0x000013fc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_dma_tcd31_csr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark DMA_CH_MUX
#endif

// Bitfields in register DMA_CH_MUX_CHCFG0.
static const field_t hw_dma_ch_mux_chcfg0[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG1.
static const field_t hw_dma_ch_mux_chcfg1[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG2.
static const field_t hw_dma_ch_mux_chcfg2[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG3.
static const field_t hw_dma_ch_mux_chcfg3[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG4.
static const field_t hw_dma_ch_mux_chcfg4[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG5.
static const field_t hw_dma_ch_mux_chcfg5[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG6.
static const field_t hw_dma_ch_mux_chcfg6[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG7.
static const field_t hw_dma_ch_mux_chcfg7[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG8.
static const field_t hw_dma_ch_mux_chcfg8[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG9.
static const field_t hw_dma_ch_mux_chcfg9[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG10.
static const field_t hw_dma_ch_mux_chcfg10[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG11.
static const field_t hw_dma_ch_mux_chcfg11[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG12.
static const field_t hw_dma_ch_mux_chcfg12[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG13.
static const field_t hw_dma_ch_mux_chcfg13[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG14.
static const field_t hw_dma_ch_mux_chcfg14[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG15.
static const field_t hw_dma_ch_mux_chcfg15[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG16.
static const field_t hw_dma_ch_mux_chcfg16[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG17.
static const field_t hw_dma_ch_mux_chcfg17[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG18.
static const field_t hw_dma_ch_mux_chcfg18[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG19.
static const field_t hw_dma_ch_mux_chcfg19[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG20.
static const field_t hw_dma_ch_mux_chcfg20[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG21.
static const field_t hw_dma_ch_mux_chcfg21[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG22.
static const field_t hw_dma_ch_mux_chcfg22[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG23.
static const field_t hw_dma_ch_mux_chcfg23[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG24.
static const field_t hw_dma_ch_mux_chcfg24[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG25.
static const field_t hw_dma_ch_mux_chcfg25[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG26.
static const field_t hw_dma_ch_mux_chcfg26[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG27.
static const field_t hw_dma_ch_mux_chcfg27[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG28.
static const field_t hw_dma_ch_mux_chcfg28[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG29.
static const field_t hw_dma_ch_mux_chcfg29[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG30.
static const field_t hw_dma_ch_mux_chcfg30[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register DMA_CH_MUX_CHCFG31.
static const field_t hw_dma_ch_mux_chcfg31[] =
{
    {
        "SOURCE",
        "Specifies which DMA source, if any, is routed to a particular DMA chan"
        "nel.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A_ON",
        "Enables the DMA Channel to be always ON.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG",
        "Enables the periodic trigger capability for the triggered DMA channel.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENBL",
        "Enables the channel for DMA Mux.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a DMA_CH_MUX module.
static const reg_t hw_dma_ch_mux[] =
{
    {
        "CHCFG0",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg0
    },
    {
        "CHCFG1",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg1
    },
    {
        "CHCFG2",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg2
    },
    {
        "CHCFG3",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg3
    },
    {
        "CHCFG4",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg4
    },
    {
        "CHCFG5",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg5
    },
    {
        "CHCFG6",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg6
    },
    {
        "CHCFG7",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg7
    },
    {
        "CHCFG8",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg8
    },
    {
        "CHCFG9",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg9
    },
    {
        "CHCFG10",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg10
    },
    {
        "CHCFG11",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg11
    },
    {
        "CHCFG12",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg12
    },
    {
        "CHCFG13",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg13
    },
    {
        "CHCFG14",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg14
    },
    {
        "CHCFG15",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg15
    },
    {
        "CHCFG16",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg16
    },
    {
        "CHCFG17",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg17
    },
    {
        "CHCFG18",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg18
    },
    {
        "CHCFG19",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg19
    },
    {
        "CHCFG20",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg20
    },
    {
        "CHCFG21",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg21
    },
    {
        "CHCFG22",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg22
    },
    {
        "CHCFG23",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg23
    },
    {
        "CHCFG24",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg24
    },
    {
        "CHCFG25",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg25
    },
    {
        "CHCFG26",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg26
    },
    {
        "CHCFG27",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg27
    },
    {
        "CHCFG28",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg28
    },
    {
        "CHCFG29",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg29
    },
    {
        "CHCFG30",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg30
    },
    {
        "CHCFG31",
        "Each of the DMA channels can be independently enabled/disabled and ass"
        "ociated with one of the DMA slots (peripheral slots or always-on slots"
        ") in the system.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_dma_ch_mux_chcfg31
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark EWM
#endif

// Bitfields in register EWM_CTRL.
static const field_t hw_ewm_ctrl[] =
{
    {
        "EWMEN",
        "This bit when set, enables the EWM module.",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ASSIN",
        "Default assert state of the EWM_in signal is logic zero.",
        1, // LSB
        1, // MSB
        false, // Readable
        false // Writable
    },
    {
        "INEN",
        "This bit when set, enables the EWM_in port.",
        2, // LSB
        2, // MSB
        false, // Readable
        false // Writable
    },
    {
        "INTEN",
        "This bit when set and EWM_OUT_b is asserted, an interrupt request is g"
        "enerated.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EWM_SERV.
static const field_t hw_ewm_serv[] =
{
    {
        "SERVICE",
        "The EWM refresh mechanism requires the CPU to write two values to the "
        "SERV register: a first data byte of 0xB4, followed by a second data by"
        "te of 0x2C.",
        0, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EWM_CMPL.
static const field_t hw_ewm_cmpl[] =
{
    {
        "COMPAREL",
        "To prevent runaway code from changing this field, software should writ"
        "e to this field after a CPU reset even if the (default) minimum refres"
        "h time is required.",
        0, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EWM_CMPH.
static const field_t hw_ewm_cmph[] =
{
    {
        "COMPAREH",
        "To prevent runaway code from changing this field, software should writ"
        "e to this field after a CPU reset even if the (default) maximum refres"
        "h time is required.",
        0, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EWM_CLKCTRL.
static const field_t hw_ewm_clkctrl[] =
{
    {
        "CLKSEL",
        "EWM has 4 possible low power clock sources for running EWM counter.",
        0, // LSB
        1, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EWM_CLKPRESCALER.
static const field_t hw_ewm_clkprescaler[] =
{
    {
        "CLK_DIV",
        "Selected low power clock source for running the EWM counter can be pre"
        "scaled as below.",
        0, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a EWM module.
static const reg_t hw_ewm[] =
{
    {
        "CTRL",
        "The CTRL register is cleared by any reset.",
        1, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ewm_ctrl
    },
    {
        "SERV",
        "The SERV register provides the interface from the CPU to the EWM modul"
        "e.",
        1, // Width in bytes
        0x00000001, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ewm_serv
    },
    {
        "CMPL",
        "The CMPL register is reset to zero after a CPU reset.",
        1, // Width in bytes
        0x00000002, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ewm_cmpl
    },
    {
        "CMPH",
        "The CMPH register is reset to 0xFF after a CPU reset.",
        1, // Width in bytes
        0x00000003, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ewm_cmph
    },
    {
        "CLKCTRL",
        "This CLKCTRL register is reset to 0x00 after a CPU reset.",
        1, // Width in bytes
        0x00000004, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ewm_clkctrl
    },
    {
        "CLKPRESCALER",
        "This CLKPRESCALER register is reset to 0x00 after a CPU reset.",
        1, // Width in bytes
        0x00000005, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ewm_clkprescaler
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark FB
#endif

// Bitfields in register FB_CSAR0.
static const field_t hw_fb_csar0[] =
{
    {
        "BA",
        "Defines the base address for memory dedicated to the associated chip-s"
        "elect.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSMR0.
static const field_t hw_fb_csmr0[] =
{
    {
        "V",
        "Specifies whether the corresponding CSAR, CSMR, and CSCR contents are "
        "valid.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Controls write accesses to the address range in the corresponding CSAR"
        ".",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BAM",
        "Defines the associated chip-select's block size by masking address bit"
        "s.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSCR0.
static const field_t hw_fb_cscr0[] =
{
    {
        "BSTW",
        "Specifies whether burst writes are enabled for memory associated with "
        "each chip select.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSTR",
        "Specifies whether burst reads are enabled for memory associated with e"
        "ach chip select.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BEM",
        "Specifies whether the corresponding FB_BE_B is asserted for read acces"
        "ses.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        "Specifies the data port width of the associated chip-select, and deter"
        "mines where data is driven during write cycles and where data is sampl"
        "ed during read cycles.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AA",
        "Asserts the internal transfer acknowledge for accesses specified by th"
        "e chip-select address.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BLS",
        "Specifies if data on FB_AD appears left-aligned or right-aligned durin"
        "g the data phase of a FlexBus access.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WS",
        "Specifies the number of wait states inserted after FlexBus asserts the"
        " associated chip-select and before an internal transfer acknowledge is"
        " generated (WS = 00h inserts 0 wait states, .",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRAH",
        "Controls the address, data, and attribute hold time after the terminat"
        "ion of a write cycle that hits in the associated chip-select's address"
        " space.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDAH",
        "Controls the address and attribute hold time after the termination dur"
        "ing a read cycle that hits in the associated chip-select's address spa"
        "ce.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASET",
        "Controls when the chip-select is asserted with respect to assertion of"
        " a valid address and attributes.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTS",
        "Extended Transfer Start/Extended Address Latch Enable Controls how lon"
        "g FB_TS_B /FB_ALE is asserted.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWSEN",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWS",
        "Used only when the SWSEN bit is 1b.",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSAR1.
static const field_t hw_fb_csar1[] =
{
    {
        "BA",
        "Defines the base address for memory dedicated to the associated chip-s"
        "elect.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSMR1.
static const field_t hw_fb_csmr1[] =
{
    {
        "V",
        "Specifies whether the corresponding CSAR, CSMR, and CSCR contents are "
        "valid.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Controls write accesses to the address range in the corresponding CSAR"
        ".",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BAM",
        "Defines the associated chip-select's block size by masking address bit"
        "s.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSCR1.
static const field_t hw_fb_cscr1[] =
{
    {
        "BSTW",
        "Specifies whether burst writes are enabled for memory associated with "
        "each chip select.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSTR",
        "Specifies whether burst reads are enabled for memory associated with e"
        "ach chip select.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BEM",
        "Specifies whether the corresponding FB_BE_B is asserted for read acces"
        "ses.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        "Specifies the data port width of the associated chip-select, and deter"
        "mines where data is driven during write cycles and where data is sampl"
        "ed during read cycles.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AA",
        "Asserts the internal transfer acknowledge for accesses specified by th"
        "e chip-select address.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BLS",
        "Specifies if data on FB_AD appears left-aligned or right-aligned durin"
        "g the data phase of a FlexBus access.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WS",
        "Specifies the number of wait states inserted after FlexBus asserts the"
        " associated chip-select and before an internal transfer acknowledge is"
        " generated (WS = 00h inserts 0 wait states, .",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRAH",
        "Controls the address, data, and attribute hold time after the terminat"
        "ion of a write cycle that hits in the associated chip-select's address"
        " space.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDAH",
        "Controls the address and attribute hold time after the termination dur"
        "ing a read cycle that hits in the associated chip-select's address spa"
        "ce.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASET",
        "Controls when the chip-select is asserted with respect to assertion of"
        " a valid address and attributes.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTS",
        "Extended Transfer Start/Extended Address Latch Enable Controls how lon"
        "g FB_TS_B /FB_ALE is asserted.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWSEN",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWS",
        "Used only when the SWSEN bit is 1b.",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSAR2.
static const field_t hw_fb_csar2[] =
{
    {
        "BA",
        "Defines the base address for memory dedicated to the associated chip-s"
        "elect.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSMR2.
static const field_t hw_fb_csmr2[] =
{
    {
        "V",
        "Specifies whether the corresponding CSAR, CSMR, and CSCR contents are "
        "valid.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Controls write accesses to the address range in the corresponding CSAR"
        ".",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BAM",
        "Defines the associated chip-select's block size by masking address bit"
        "s.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSCR2.
static const field_t hw_fb_cscr2[] =
{
    {
        "BSTW",
        "Specifies whether burst writes are enabled for memory associated with "
        "each chip select.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSTR",
        "Specifies whether burst reads are enabled for memory associated with e"
        "ach chip select.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BEM",
        "Specifies whether the corresponding FB_BE_B is asserted for read acces"
        "ses.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        "Specifies the data port width of the associated chip-select, and deter"
        "mines where data is driven during write cycles and where data is sampl"
        "ed during read cycles.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AA",
        "Asserts the internal transfer acknowledge for accesses specified by th"
        "e chip-select address.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BLS",
        "Specifies if data on FB_AD appears left-aligned or right-aligned durin"
        "g the data phase of a FlexBus access.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WS",
        "Specifies the number of wait states inserted after FlexBus asserts the"
        " associated chip-select and before an internal transfer acknowledge is"
        " generated (WS = 00h inserts 0 wait states, .",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRAH",
        "Controls the address, data, and attribute hold time after the terminat"
        "ion of a write cycle that hits in the associated chip-select's address"
        " space.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDAH",
        "Controls the address and attribute hold time after the termination dur"
        "ing a read cycle that hits in the associated chip-select's address spa"
        "ce.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASET",
        "Controls when the chip-select is asserted with respect to assertion of"
        " a valid address and attributes.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTS",
        "Extended Transfer Start/Extended Address Latch Enable Controls how lon"
        "g FB_TS_B /FB_ALE is asserted.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWSEN",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWS",
        "Used only when the SWSEN bit is 1b.",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSAR3.
static const field_t hw_fb_csar3[] =
{
    {
        "BA",
        "Defines the base address for memory dedicated to the associated chip-s"
        "elect.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSMR3.
static const field_t hw_fb_csmr3[] =
{
    {
        "V",
        "Specifies whether the corresponding CSAR, CSMR, and CSCR contents are "
        "valid.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Controls write accesses to the address range in the corresponding CSAR"
        ".",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BAM",
        "Defines the associated chip-select's block size by masking address bit"
        "s.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSCR3.
static const field_t hw_fb_cscr3[] =
{
    {
        "BSTW",
        "Specifies whether burst writes are enabled for memory associated with "
        "each chip select.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSTR",
        "Specifies whether burst reads are enabled for memory associated with e"
        "ach chip select.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BEM",
        "Specifies whether the corresponding FB_BE_B is asserted for read acces"
        "ses.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        "Specifies the data port width of the associated chip-select, and deter"
        "mines where data is driven during write cycles and where data is sampl"
        "ed during read cycles.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AA",
        "Asserts the internal transfer acknowledge for accesses specified by th"
        "e chip-select address.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BLS",
        "Specifies if data on FB_AD appears left-aligned or right-aligned durin"
        "g the data phase of a FlexBus access.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WS",
        "Specifies the number of wait states inserted after FlexBus asserts the"
        " associated chip-select and before an internal transfer acknowledge is"
        " generated (WS = 00h inserts 0 wait states, .",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRAH",
        "Controls the address, data, and attribute hold time after the terminat"
        "ion of a write cycle that hits in the associated chip-select's address"
        " space.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDAH",
        "Controls the address and attribute hold time after the termination dur"
        "ing a read cycle that hits in the associated chip-select's address spa"
        "ce.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASET",
        "Controls when the chip-select is asserted with respect to assertion of"
        " a valid address and attributes.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTS",
        "Extended Transfer Start/Extended Address Latch Enable Controls how lon"
        "g FB_TS_B /FB_ALE is asserted.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWSEN",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWS",
        "Used only when the SWSEN bit is 1b.",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSAR4.
static const field_t hw_fb_csar4[] =
{
    {
        "BA",
        "Defines the base address for memory dedicated to the associated chip-s"
        "elect.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSMR4.
static const field_t hw_fb_csmr4[] =
{
    {
        "V",
        "Specifies whether the corresponding CSAR, CSMR, and CSCR contents are "
        "valid.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Controls write accesses to the address range in the corresponding CSAR"
        ".",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BAM",
        "Defines the associated chip-select's block size by masking address bit"
        "s.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSCR4.
static const field_t hw_fb_cscr4[] =
{
    {
        "BSTW",
        "Specifies whether burst writes are enabled for memory associated with "
        "each chip select.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSTR",
        "Specifies whether burst reads are enabled for memory associated with e"
        "ach chip select.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BEM",
        "Specifies whether the corresponding FB_BE_B is asserted for read acces"
        "ses.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        "Specifies the data port width of the associated chip-select, and deter"
        "mines where data is driven during write cycles and where data is sampl"
        "ed during read cycles.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AA",
        "Asserts the internal transfer acknowledge for accesses specified by th"
        "e chip-select address.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BLS",
        "Specifies if data on FB_AD appears left-aligned or right-aligned durin"
        "g the data phase of a FlexBus access.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WS",
        "Specifies the number of wait states inserted after FlexBus asserts the"
        " associated chip-select and before an internal transfer acknowledge is"
        " generated (WS = 00h inserts 0 wait states, .",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRAH",
        "Controls the address, data, and attribute hold time after the terminat"
        "ion of a write cycle that hits in the associated chip-select's address"
        " space.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDAH",
        "Controls the address and attribute hold time after the termination dur"
        "ing a read cycle that hits in the associated chip-select's address spa"
        "ce.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASET",
        "Controls when the chip-select is asserted with respect to assertion of"
        " a valid address and attributes.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTS",
        "Extended Transfer Start/Extended Address Latch Enable Controls how lon"
        "g FB_TS_B /FB_ALE is asserted.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWSEN",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWS",
        "Used only when the SWSEN bit is 1b.",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSAR5.
static const field_t hw_fb_csar5[] =
{
    {
        "BA",
        "Defines the base address for memory dedicated to the associated chip-s"
        "elect.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSMR5.
static const field_t hw_fb_csmr5[] =
{
    {
        "V",
        "Specifies whether the corresponding CSAR, CSMR, and CSCR contents are "
        "valid.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Controls write accesses to the address range in the corresponding CSAR"
        ".",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BAM",
        "Defines the associated chip-select's block size by masking address bit"
        "s.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSCR5.
static const field_t hw_fb_cscr5[] =
{
    {
        "BSTW",
        "Specifies whether burst writes are enabled for memory associated with "
        "each chip select.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSTR",
        "Specifies whether burst reads are enabled for memory associated with e"
        "ach chip select.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BEM",
        "Specifies whether the corresponding FB_BE_B is asserted for read acces"
        "ses.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        "Specifies the data port width of the associated chip-select, and deter"
        "mines where data is driven during write cycles and where data is sampl"
        "ed during read cycles.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AA",
        "Asserts the internal transfer acknowledge for accesses specified by th"
        "e chip-select address.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BLS",
        "Specifies if data on FB_AD appears left-aligned or right-aligned durin"
        "g the data phase of a FlexBus access.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WS",
        "Specifies the number of wait states inserted after FlexBus asserts the"
        " associated chip-select and before an internal transfer acknowledge is"
        " generated (WS = 00h inserts 0 wait states, .",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRAH",
        "Controls the address, data, and attribute hold time after the terminat"
        "ion of a write cycle that hits in the associated chip-select's address"
        " space.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDAH",
        "Controls the address and attribute hold time after the termination dur"
        "ing a read cycle that hits in the associated chip-select's address spa"
        "ce.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASET",
        "Controls when the chip-select is asserted with respect to assertion of"
        " a valid address and attributes.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTS",
        "Extended Transfer Start/Extended Address Latch Enable Controls how lon"
        "g FB_TS_B /FB_ALE is asserted.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWSEN",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWS",
        "Used only when the SWSEN bit is 1b.",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FB_CSPMCR.
static const field_t hw_fb_cspmcr[] =
{
    {
        "GROUP5",
        "Controls the multiplexing of the FB_TA_B, FB_CS3_B, and FB_BE_7_0_B si"
        "gnals.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GROUP4",
        "Controls the multiplexing of the FB_TBST_B, FB_CS2_B, and FB_BE_15_8_B"
        " signals.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GROUP3",
        "Controls the multiplexing of the FB_CS5_B, FB_TSIZ1, and FB_BE_23_16_B"
        " signals.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GROUP2",
        "Controls the multiplexing of the FB_CS4_B, FB_TSIZ0, and FB_BE_31_24_B"
        " signals.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GROUP1",
        "Controls the multiplexing of the FB_ALE, FB_CS1_B, and FB_TS_B signals"
        ".",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a FB module.
static const reg_t hw_fb[] =
{
    {
        "CSAR0",
        "Specifies the associated chip-select's base address.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fb_csar0
    },
    {
        "CSMR0",
        "Specifies the address mask and allowable access types for the associat"
        "ed chip-select.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_fb_csmr0
    },
    {
        "CSCR0",
        "Controls the auto-acknowledge, address setup and hold times, port size"
        ", burst capability, and number of wait states for the associated chip "
        "select.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_fb_cscr0
    },
    {
        "CSAR1",
        "Specifies the associated chip-select's base address.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fb_csar1
    },
    {
        "CSMR1",
        "Specifies the address mask and allowable access types for the associat"
        "ed chip-select.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_fb_csmr1
    },
    {
        "CSCR1",
        "Controls the auto-acknowledge, address setup and hold times, port size"
        ", burst capability, and number of wait states for the associated chip "
        "select.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_fb_cscr1
    },
    {
        "CSAR2",
        "Specifies the associated chip-select's base address.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fb_csar2
    },
    {
        "CSMR2",
        "Specifies the address mask and allowable access types for the associat"
        "ed chip-select.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_fb_csmr2
    },
    {
        "CSCR2",
        "Controls the auto-acknowledge, address setup and hold times, port size"
        ", burst capability, and number of wait states for the associated chip "
        "select.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_fb_cscr2
    },
    {
        "CSAR3",
        "Specifies the associated chip-select's base address.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fb_csar3
    },
    {
        "CSMR3",
        "Specifies the address mask and allowable access types for the associat"
        "ed chip-select.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_fb_csmr3
    },
    {
        "CSCR3",
        "Controls the auto-acknowledge, address setup and hold times, port size"
        ", burst capability, and number of wait states for the associated chip "
        "select.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_fb_cscr3
    },
    {
        "CSAR4",
        "Specifies the associated chip-select's base address.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fb_csar4
    },
    {
        "CSMR4",
        "Specifies the address mask and allowable access types for the associat"
        "ed chip-select.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_fb_csmr4
    },
    {
        "CSCR4",
        "Controls the auto-acknowledge, address setup and hold times, port size"
        ", burst capability, and number of wait states for the associated chip "
        "select.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_fb_cscr4
    },
    {
        "CSAR5",
        "Specifies the associated chip-select's base address.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_fb_csar5
    },
    {
        "CSMR5",
        "Specifies the address mask and allowable access types for the associat"
        "ed chip-select.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_fb_csmr5
    },
    {
        "CSCR5",
        "Controls the auto-acknowledge, address setup and hold times, port size"
        ", burst capability, and number of wait states for the associated chip "
        "select.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_fb_cscr5
    },
    {
        "CSPMCR",
        "Controls the multiplexing of the FlexBus signals.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_fb_cspmcr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark FLEXIO_8SHIFT_8TIM_32PIN
#endif

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUF0.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbuf0[] =
{
    {
        "SHIFTBUF",
        "Shift buffer data is used for a variety of functions depending on the "
        "SMOD setting: For SMOD=Receive, Shifter data is transferred into SHIFT"
        "BUF at the expiration of Timer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUF1.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbuf1[] =
{
    {
        "SHIFTBUF",
        "Shift buffer data is used for a variety of functions depending on the "
        "SMOD setting: For SMOD=Receive, Shifter data is transferred into SHIFT"
        "BUF at the expiration of Timer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUF2.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbuf2[] =
{
    {
        "SHIFTBUF",
        "Shift buffer data is used for a variety of functions depending on the "
        "SMOD setting: For SMOD=Receive, Shifter data is transferred into SHIFT"
        "BUF at the expiration of Timer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUF3.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbuf3[] =
{
    {
        "SHIFTBUF",
        "Shift buffer data is used for a variety of functions depending on the "
        "SMOD setting: For SMOD=Receive, Shifter data is transferred into SHIFT"
        "BUF at the expiration of Timer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUF4.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbuf4[] =
{
    {
        "SHIFTBUF",
        "Shift buffer data is used for a variety of functions depending on the "
        "SMOD setting: For SMOD=Receive, Shifter data is transferred into SHIFT"
        "BUF at the expiration of Timer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUF5.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbuf5[] =
{
    {
        "SHIFTBUF",
        "Shift buffer data is used for a variety of functions depending on the "
        "SMOD setting: For SMOD=Receive, Shifter data is transferred into SHIFT"
        "BUF at the expiration of Timer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUF6.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbuf6[] =
{
    {
        "SHIFTBUF",
        "Shift buffer data is used for a variety of functions depending on the "
        "SMOD setting: For SMOD=Receive, Shifter data is transferred into SHIFT"
        "BUF at the expiration of Timer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUF7.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbuf7[] =
{
    {
        "SHIFTBUF",
        "Shift buffer data is used for a variety of functions depending on the "
        "SMOD setting: For SMOD=Receive, Shifter data is transferred into SHIFT"
        "BUF at the expiration of Timer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTCFG0.
static const field_t hw_flexio_8shift_8tim_32pin_shiftcfg0[] =
{
    {
        "SSTART",
        "For SMOD=Transmit, this field allows automatic start bit insertion if "
        "the selected timer has also enabled a start bit.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSTOP",
        "For SMOD=Transmit, this field allows automatic stop bit insertion if t"
        "he selected timer has also enabled a stop bit.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSRC",
        "Selects the input source for the shifter.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWIDTH",
        "For all Shifters, this register field configures the number of bits to"
        " be shifted on each Shift clock as follows: 1-bit shift for PWIDTH=0 4"
        "-bit shift for PWIDTH=1...3 8-bit shift for PWIDTH=4...7 16-bit shift "
        "for PWIDTH=8...15 32-bit shift for PWIDTH=16...31 For Shifters which s"
        "upport parallel transmit (SHIFTER0, SHIFTER4) or parallel receive (SHI"
        "FTER3, SHIFTER7), this register field, together with SHIFTCTL[PINSEL],"
        " also selects the pins to be driven or sampled on each Shift clock as "
        "follows: FXIO_D[PINSEL+PWIDTH]:FXIO_D[PINSEL] For SMOD=State, this fie"
        "ld is used to disable state outputs.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTCFG1.
static const field_t hw_flexio_8shift_8tim_32pin_shiftcfg1[] =
{
    {
        "SSTART",
        "For SMOD=Transmit, this field allows automatic start bit insertion if "
        "the selected timer has also enabled a start bit.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSTOP",
        "For SMOD=Transmit, this field allows automatic stop bit insertion if t"
        "he selected timer has also enabled a stop bit.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSRC",
        "Selects the input source for the shifter.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWIDTH",
        "For all Shifters, this register field configures the number of bits to"
        " be shifted on each Shift clock as follows: 1-bit shift for PWIDTH=0 4"
        "-bit shift for PWIDTH=1...3 8-bit shift for PWIDTH=4...7 16-bit shift "
        "for PWIDTH=8...15 32-bit shift for PWIDTH=16...31 For Shifters which s"
        "upport parallel transmit (SHIFTER0, SHIFTER4) or parallel receive (SHI"
        "FTER3, SHIFTER7), this register field, together with SHIFTCTL[PINSEL],"
        " also selects the pins to be driven or sampled on each Shift clock as "
        "follows: FXIO_D[PINSEL+PWIDTH]:FXIO_D[PINSEL] For SMOD=State, this fie"
        "ld is used to disable state outputs.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTCFG2.
static const field_t hw_flexio_8shift_8tim_32pin_shiftcfg2[] =
{
    {
        "SSTART",
        "For SMOD=Transmit, this field allows automatic start bit insertion if "
        "the selected timer has also enabled a start bit.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSTOP",
        "For SMOD=Transmit, this field allows automatic stop bit insertion if t"
        "he selected timer has also enabled a stop bit.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSRC",
        "Selects the input source for the shifter.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWIDTH",
        "For all Shifters, this register field configures the number of bits to"
        " be shifted on each Shift clock as follows: 1-bit shift for PWIDTH=0 4"
        "-bit shift for PWIDTH=1...3 8-bit shift for PWIDTH=4...7 16-bit shift "
        "for PWIDTH=8...15 32-bit shift for PWIDTH=16...31 For Shifters which s"
        "upport parallel transmit (SHIFTER0, SHIFTER4) or parallel receive (SHI"
        "FTER3, SHIFTER7), this register field, together with SHIFTCTL[PINSEL],"
        " also selects the pins to be driven or sampled on each Shift clock as "
        "follows: FXIO_D[PINSEL+PWIDTH]:FXIO_D[PINSEL] For SMOD=State, this fie"
        "ld is used to disable state outputs.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTCFG3.
static const field_t hw_flexio_8shift_8tim_32pin_shiftcfg3[] =
{
    {
        "SSTART",
        "For SMOD=Transmit, this field allows automatic start bit insertion if "
        "the selected timer has also enabled a start bit.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSTOP",
        "For SMOD=Transmit, this field allows automatic stop bit insertion if t"
        "he selected timer has also enabled a stop bit.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSRC",
        "Selects the input source for the shifter.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWIDTH",
        "For all Shifters, this register field configures the number of bits to"
        " be shifted on each Shift clock as follows: 1-bit shift for PWIDTH=0 4"
        "-bit shift for PWIDTH=1...3 8-bit shift for PWIDTH=4...7 16-bit shift "
        "for PWIDTH=8...15 32-bit shift for PWIDTH=16...31 For Shifters which s"
        "upport parallel transmit (SHIFTER0, SHIFTER4) or parallel receive (SHI"
        "FTER3, SHIFTER7), this register field, together with SHIFTCTL[PINSEL],"
        " also selects the pins to be driven or sampled on each Shift clock as "
        "follows: FXIO_D[PINSEL+PWIDTH]:FXIO_D[PINSEL] For SMOD=State, this fie"
        "ld is used to disable state outputs.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTCFG4.
static const field_t hw_flexio_8shift_8tim_32pin_shiftcfg4[] =
{
    {
        "SSTART",
        "For SMOD=Transmit, this field allows automatic start bit insertion if "
        "the selected timer has also enabled a start bit.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSTOP",
        "For SMOD=Transmit, this field allows automatic stop bit insertion if t"
        "he selected timer has also enabled a stop bit.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSRC",
        "Selects the input source for the shifter.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWIDTH",
        "For all Shifters, this register field configures the number of bits to"
        " be shifted on each Shift clock as follows: 1-bit shift for PWIDTH=0 4"
        "-bit shift for PWIDTH=1...3 8-bit shift for PWIDTH=4...7 16-bit shift "
        "for PWIDTH=8...15 32-bit shift for PWIDTH=16...31 For Shifters which s"
        "upport parallel transmit (SHIFTER0, SHIFTER4) or parallel receive (SHI"
        "FTER3, SHIFTER7), this register field, together with SHIFTCTL[PINSEL],"
        " also selects the pins to be driven or sampled on each Shift clock as "
        "follows: FXIO_D[PINSEL+PWIDTH]:FXIO_D[PINSEL] For SMOD=State, this fie"
        "ld is used to disable state outputs.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTCFG5.
static const field_t hw_flexio_8shift_8tim_32pin_shiftcfg5[] =
{
    {
        "SSTART",
        "For SMOD=Transmit, this field allows automatic start bit insertion if "
        "the selected timer has also enabled a start bit.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSTOP",
        "For SMOD=Transmit, this field allows automatic stop bit insertion if t"
        "he selected timer has also enabled a stop bit.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSRC",
        "Selects the input source for the shifter.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWIDTH",
        "For all Shifters, this register field configures the number of bits to"
        " be shifted on each Shift clock as follows: 1-bit shift for PWIDTH=0 4"
        "-bit shift for PWIDTH=1...3 8-bit shift for PWIDTH=4...7 16-bit shift "
        "for PWIDTH=8...15 32-bit shift for PWIDTH=16...31 For Shifters which s"
        "upport parallel transmit (SHIFTER0, SHIFTER4) or parallel receive (SHI"
        "FTER3, SHIFTER7), this register field, together with SHIFTCTL[PINSEL],"
        " also selects the pins to be driven or sampled on each Shift clock as "
        "follows: FXIO_D[PINSEL+PWIDTH]:FXIO_D[PINSEL] For SMOD=State, this fie"
        "ld is used to disable state outputs.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTCFG6.
static const field_t hw_flexio_8shift_8tim_32pin_shiftcfg6[] =
{
    {
        "SSTART",
        "For SMOD=Transmit, this field allows automatic start bit insertion if "
        "the selected timer has also enabled a start bit.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSTOP",
        "For SMOD=Transmit, this field allows automatic stop bit insertion if t"
        "he selected timer has also enabled a stop bit.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSRC",
        "Selects the input source for the shifter.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWIDTH",
        "For all Shifters, this register field configures the number of bits to"
        " be shifted on each Shift clock as follows: 1-bit shift for PWIDTH=0 4"
        "-bit shift for PWIDTH=1...3 8-bit shift for PWIDTH=4...7 16-bit shift "
        "for PWIDTH=8...15 32-bit shift for PWIDTH=16...31 For Shifters which s"
        "upport parallel transmit (SHIFTER0, SHIFTER4) or parallel receive (SHI"
        "FTER3, SHIFTER7), this register field, together with SHIFTCTL[PINSEL],"
        " also selects the pins to be driven or sampled on each Shift clock as "
        "follows: FXIO_D[PINSEL+PWIDTH]:FXIO_D[PINSEL] For SMOD=State, this fie"
        "ld is used to disable state outputs.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTCFG7.
static const field_t hw_flexio_8shift_8tim_32pin_shiftcfg7[] =
{
    {
        "SSTART",
        "For SMOD=Transmit, this field allows automatic start bit insertion if "
        "the selected timer has also enabled a start bit.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSTOP",
        "For SMOD=Transmit, this field allows automatic stop bit insertion if t"
        "he selected timer has also enabled a stop bit.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSRC",
        "Selects the input source for the shifter.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWIDTH",
        "For all Shifters, this register field configures the number of bits to"
        " be shifted on each Shift clock as follows: 1-bit shift for PWIDTH=0 4"
        "-bit shift for PWIDTH=1...3 8-bit shift for PWIDTH=4...7 16-bit shift "
        "for PWIDTH=8...15 32-bit shift for PWIDTH=16...31 For Shifters which s"
        "upport parallel transmit (SHIFTER0, SHIFTER4) or parallel receive (SHI"
        "FTER3, SHIFTER7), this register field, together with SHIFTCTL[PINSEL],"
        " also selects the pins to be driven or sampled on each Shift clock as "
        "follows: FXIO_D[PINSEL+PWIDTH]:FXIO_D[PINSEL] For SMOD=State, this fie"
        "ld is used to disable state outputs.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCTL0.
static const field_t hw_flexio_8shift_8tim_32pin_timctl0[] =
{
    {
        "TIMOD",
        "In 8-bit baud counter mode, the lower 8-bits of the counter and compar"
        "e register are used to configure the baud rate of the timer shift cloc"
        "k, and the upper 8-bits are used to configure the shifter bit count.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPOL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINSEL",
        "Selects which pin is used by the Timer input or output.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSRC",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGPOL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSEL",
        "The valid values for TRGSEL will depend on the FLEXIO_PARAM register.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCTL1.
static const field_t hw_flexio_8shift_8tim_32pin_timctl1[] =
{
    {
        "TIMOD",
        "In 8-bit baud counter mode, the lower 8-bits of the counter and compar"
        "e register are used to configure the baud rate of the timer shift cloc"
        "k, and the upper 8-bits are used to configure the shifter bit count.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPOL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINSEL",
        "Selects which pin is used by the Timer input or output.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSRC",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGPOL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSEL",
        "The valid values for TRGSEL will depend on the FLEXIO_PARAM register.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCTL2.
static const field_t hw_flexio_8shift_8tim_32pin_timctl2[] =
{
    {
        "TIMOD",
        "In 8-bit baud counter mode, the lower 8-bits of the counter and compar"
        "e register are used to configure the baud rate of the timer shift cloc"
        "k, and the upper 8-bits are used to configure the shifter bit count.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPOL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINSEL",
        "Selects which pin is used by the Timer input or output.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSRC",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGPOL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSEL",
        "The valid values for TRGSEL will depend on the FLEXIO_PARAM register.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCTL3.
static const field_t hw_flexio_8shift_8tim_32pin_timctl3[] =
{
    {
        "TIMOD",
        "In 8-bit baud counter mode, the lower 8-bits of the counter and compar"
        "e register are used to configure the baud rate of the timer shift cloc"
        "k, and the upper 8-bits are used to configure the shifter bit count.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPOL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINSEL",
        "Selects which pin is used by the Timer input or output.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSRC",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGPOL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSEL",
        "The valid values for TRGSEL will depend on the FLEXIO_PARAM register.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCTL4.
static const field_t hw_flexio_8shift_8tim_32pin_timctl4[] =
{
    {
        "TIMOD",
        "In 8-bit baud counter mode, the lower 8-bits of the counter and compar"
        "e register are used to configure the baud rate of the timer shift cloc"
        "k, and the upper 8-bits are used to configure the shifter bit count.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPOL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINSEL",
        "Selects which pin is used by the Timer input or output.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSRC",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGPOL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSEL",
        "The valid values for TRGSEL will depend on the FLEXIO_PARAM register.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCTL5.
static const field_t hw_flexio_8shift_8tim_32pin_timctl5[] =
{
    {
        "TIMOD",
        "In 8-bit baud counter mode, the lower 8-bits of the counter and compar"
        "e register are used to configure the baud rate of the timer shift cloc"
        "k, and the upper 8-bits are used to configure the shifter bit count.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPOL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINSEL",
        "Selects which pin is used by the Timer input or output.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSRC",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGPOL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSEL",
        "The valid values for TRGSEL will depend on the FLEXIO_PARAM register.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCTL6.
static const field_t hw_flexio_8shift_8tim_32pin_timctl6[] =
{
    {
        "TIMOD",
        "In 8-bit baud counter mode, the lower 8-bits of the counter and compar"
        "e register are used to configure the baud rate of the timer shift cloc"
        "k, and the upper 8-bits are used to configure the shifter bit count.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPOL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINSEL",
        "Selects which pin is used by the Timer input or output.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSRC",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGPOL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSEL",
        "The valid values for TRGSEL will depend on the FLEXIO_PARAM register.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCTL7.
static const field_t hw_flexio_8shift_8tim_32pin_timctl7[] =
{
    {
        "TIMOD",
        "In 8-bit baud counter mode, the lower 8-bits of the counter and compar"
        "e register are used to configure the baud rate of the timer shift cloc"
        "k, and the upper 8-bits are used to configure the shifter bit count.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPOL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINSEL",
        "Selects which pin is used by the Timer input or output.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSRC",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGPOL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSEL",
        "The valid values for TRGSEL will depend on the FLEXIO_PARAM register.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCFG0.
static const field_t hw_flexio_8shift_8tim_32pin_timcfg0[] =
{
    {
        "TSTART",
        "When start bit is enabled, configured shifters will output the content"
        "s of the start bit when the timer is enabled and the timer counter wil"
        "l reload from the compare register on the first rising edge of the shi"
        "ft clock.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTOP",
        "The stop bit can be added on a timer compare (between each word) or on"
        " a timer disable.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMENA",
        "Configures the condition that causes the Timer to be enabled and start"
        " decrementing.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMDIS",
        "Configures the condition that causes the Timer to be disabled and stop"
        " decrementing.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMRST",
        "Configures the condition that causes the timer counter (and optionally"
        " the timer output) to be reset.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMDEC",
        "Configures the source of the Timer decrement and the source of the Shi"
        "ft clock.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMOUT",
        "Configures the initial state of the Timer Output and whether it is aff"
        "ected by the Timer reset.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCFG1.
static const field_t hw_flexio_8shift_8tim_32pin_timcfg1[] =
{
    {
        "TSTART",
        "When start bit is enabled, configured shifters will output the content"
        "s of the start bit when the timer is enabled and the timer counter wil"
        "l reload from the compare register on the first rising edge of the shi"
        "ft clock.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTOP",
        "The stop bit can be added on a timer compare (between each word) or on"
        " a timer disable.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMENA",
        "Configures the condition that causes the Timer to be enabled and start"
        " decrementing.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMDIS",
        "Configures the condition that causes the Timer to be disabled and stop"
        " decrementing.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMRST",
        "Configures the condition that causes the timer counter (and optionally"
        " the timer output) to be reset.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMDEC",
        "Configures the source of the Timer decrement and the source of the Shi"
        "ft clock.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMOUT",
        "Configures the initial state of the Timer Output and whether it is aff"
        "ected by the Timer reset.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCFG2.
static const field_t hw_flexio_8shift_8tim_32pin_timcfg2[] =
{
    {
        "TSTART",
        "When start bit is enabled, configured shifters will output the content"
        "s of the start bit when the timer is enabled and the timer counter wil"
        "l reload from the compare register on the first rising edge of the shi"
        "ft clock.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTOP",
        "The stop bit can be added on a timer compare (between each word) or on"
        " a timer disable.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMENA",
        "Configures the condition that causes the Timer to be enabled and start"
        " decrementing.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMDIS",
        "Configures the condition that causes the Timer to be disabled and stop"
        " decrementing.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMRST",
        "Configures the condition that causes the timer counter (and optionally"
        " the timer output) to be reset.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMDEC",
        "Configures the source of the Timer decrement and the source of the Shi"
        "ft clock.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMOUT",
        "Configures the initial state of the Timer Output and whether it is aff"
        "ected by the Timer reset.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCFG3.
static const field_t hw_flexio_8shift_8tim_32pin_timcfg3[] =
{
    {
        "TSTART",
        "When start bit is enabled, configured shifters will output the content"
        "s of the start bit when the timer is enabled and the timer counter wil"
        "l reload from the compare register on the first rising edge of the shi"
        "ft clock.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTOP",
        "The stop bit can be added on a timer compare (between each word) or on"
        " a timer disable.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMENA",
        "Configures the condition that causes the Timer to be enabled and start"
        " decrementing.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMDIS",
        "Configures the condition that causes the Timer to be disabled and stop"
        " decrementing.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMRST",
        "Configures the condition that causes the timer counter (and optionally"
        " the timer output) to be reset.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMDEC",
        "Configures the source of the Timer decrement and the source of the Shi"
        "ft clock.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMOUT",
        "Configures the initial state of the Timer Output and whether it is aff"
        "ected by the Timer reset.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCFG4.
static const field_t hw_flexio_8shift_8tim_32pin_timcfg4[] =
{
    {
        "TSTART",
        "When start bit is enabled, configured shifters will output the content"
        "s of the start bit when the timer is enabled and the timer counter wil"
        "l reload from the compare register on the first rising edge of the shi"
        "ft clock.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTOP",
        "The stop bit can be added on a timer compare (between each word) or on"
        " a timer disable.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMENA",
        "Configures the condition that causes the Timer to be enabled and start"
        " decrementing.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMDIS",
        "Configures the condition that causes the Timer to be disabled and stop"
        " decrementing.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMRST",
        "Configures the condition that causes the timer counter (and optionally"
        " the timer output) to be reset.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMDEC",
        "Configures the source of the Timer decrement and the source of the Shi"
        "ft clock.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMOUT",
        "Configures the initial state of the Timer Output and whether it is aff"
        "ected by the Timer reset.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCFG5.
static const field_t hw_flexio_8shift_8tim_32pin_timcfg5[] =
{
    {
        "TSTART",
        "When start bit is enabled, configured shifters will output the content"
        "s of the start bit when the timer is enabled and the timer counter wil"
        "l reload from the compare register on the first rising edge of the shi"
        "ft clock.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTOP",
        "The stop bit can be added on a timer compare (between each word) or on"
        " a timer disable.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMENA",
        "Configures the condition that causes the Timer to be enabled and start"
        " decrementing.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMDIS",
        "Configures the condition that causes the Timer to be disabled and stop"
        " decrementing.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMRST",
        "Configures the condition that causes the timer counter (and optionally"
        " the timer output) to be reset.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMDEC",
        "Configures the source of the Timer decrement and the source of the Shi"
        "ft clock.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMOUT",
        "Configures the initial state of the Timer Output and whether it is aff"
        "ected by the Timer reset.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCFG6.
static const field_t hw_flexio_8shift_8tim_32pin_timcfg6[] =
{
    {
        "TSTART",
        "When start bit is enabled, configured shifters will output the content"
        "s of the start bit when the timer is enabled and the timer counter wil"
        "l reload from the compare register on the first rising edge of the shi"
        "ft clock.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTOP",
        "The stop bit can be added on a timer compare (between each word) or on"
        " a timer disable.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMENA",
        "Configures the condition that causes the Timer to be enabled and start"
        " decrementing.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMDIS",
        "Configures the condition that causes the Timer to be disabled and stop"
        " decrementing.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMRST",
        "Configures the condition that causes the timer counter (and optionally"
        " the timer output) to be reset.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMDEC",
        "Configures the source of the Timer decrement and the source of the Shi"
        "ft clock.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMOUT",
        "Configures the initial state of the Timer Output and whether it is aff"
        "ected by the Timer reset.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCFG7.
static const field_t hw_flexio_8shift_8tim_32pin_timcfg7[] =
{
    {
        "TSTART",
        "When start bit is enabled, configured shifters will output the content"
        "s of the start bit when the timer is enabled and the timer counter wil"
        "l reload from the compare register on the first rising edge of the shi"
        "ft clock.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTOP",
        "The stop bit can be added on a timer compare (between each word) or on"
        " a timer disable.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMENA",
        "Configures the condition that causes the Timer to be enabled and start"
        " decrementing.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMDIS",
        "Configures the condition that causes the Timer to be disabled and stop"
        " decrementing.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMRST",
        "Configures the condition that causes the timer counter (and optionally"
        " the timer output) to be reset.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMDEC",
        "Configures the source of the Timer decrement and the source of the Shi"
        "ft clock.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMOUT",
        "Configures the initial state of the Timer Output and whether it is aff"
        "ected by the Timer reset.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCMP0.
static const field_t hw_flexio_8shift_8tim_32pin_timcmp0[] =
{
    {
        "CMP",
        "The timer compare value is loaded into the timer counter when the time"
        "r is first enabled, when the timer is reset and when the timer decreme"
        "nts down to zero.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCMP1.
static const field_t hw_flexio_8shift_8tim_32pin_timcmp1[] =
{
    {
        "CMP",
        "The timer compare value is loaded into the timer counter when the time"
        "r is first enabled, when the timer is reset and when the timer decreme"
        "nts down to zero.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCMP2.
static const field_t hw_flexio_8shift_8tim_32pin_timcmp2[] =
{
    {
        "CMP",
        "The timer compare value is loaded into the timer counter when the time"
        "r is first enabled, when the timer is reset and when the timer decreme"
        "nts down to zero.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCMP3.
static const field_t hw_flexio_8shift_8tim_32pin_timcmp3[] =
{
    {
        "CMP",
        "The timer compare value is loaded into the timer counter when the time"
        "r is first enabled, when the timer is reset and when the timer decreme"
        "nts down to zero.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCMP4.
static const field_t hw_flexio_8shift_8tim_32pin_timcmp4[] =
{
    {
        "CMP",
        "The timer compare value is loaded into the timer counter when the time"
        "r is first enabled, when the timer is reset and when the timer decreme"
        "nts down to zero.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCMP5.
static const field_t hw_flexio_8shift_8tim_32pin_timcmp5[] =
{
    {
        "CMP",
        "The timer compare value is loaded into the timer counter when the time"
        "r is first enabled, when the timer is reset and when the timer decreme"
        "nts down to zero.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCMP6.
static const field_t hw_flexio_8shift_8tim_32pin_timcmp6[] =
{
    {
        "CMP",
        "The timer compare value is loaded into the timer counter when the time"
        "r is first enabled, when the timer is reset and when the timer decreme"
        "nts down to zero.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMCMP7.
static const field_t hw_flexio_8shift_8tim_32pin_timcmp7[] =
{
    {
        "CMP",
        "The timer compare value is loaded into the timer counter when the time"
        "r is first enabled, when the timer is reset and when the timer decreme"
        "nts down to zero.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_CTRL.
static const field_t hw_flexio_8shift_8tim_32pin_ctrl[] =
{
    {
        "FLEXEN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWRST",
        "The FlexIO Control Register is not affected by the software reset, all"
        " other logic in the FlexIO is affected by the software reset and regis"
        "ter accesses are ignored until this bit is cleared.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FASTACC",
        "Enables fast register accesses to FlexIO registers, but requires the F"
        "lexIO functional clock to be at least twice the frequency of the bus c"
        "lock.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGE",
        "Enables FlexIO operation in Debug mode.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZEN",
        "Disables FlexIO operation in Doze modes.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTSTAT.
static const field_t hw_flexio_8shift_8tim_32pin_shiftstat[] =
{
    {
        "SSF",
        "The shifter status flag is updated when one of the following events oc"
        "curs: For SMOD=Receive, the status flag is set when SHIFTBUF has been "
        "loaded with data from Shifter (SHIFTBUF is full), and the status flag "
        "is cleared when SHIFTBUF register is read.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMSTAT.
static const field_t hw_flexio_8shift_8tim_32pin_timstat[] =
{
    {
        "TSF",
        "The timer status flag sets depending on the timer mode, and can be cle"
        "ared by writing logic one to the flag.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTERR.
static const field_t hw_flexio_8shift_8tim_32pin_shifterr[] =
{
    {
        "SEF",
        "The shifter error flag is set when one of the following events occurs:"
        " For SMOD=Receive, indicates Shifter was ready to store new data into "
        "SHIFTBUF before the previous data was read from SHIFTBUF (SHIFTBUF Ove"
        "rrun), or indicates that the received start or stop bit does not match"
        " the expected value.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBBS0.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbbs0[] =
{
    {
        "SHIFTBUFBBS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "it swapped within each byte.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBBS1.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbbs1[] =
{
    {
        "SHIFTBUFBBS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "it swapped within each byte.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBBS2.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbbs2[] =
{
    {
        "SHIFTBUFBBS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "it swapped within each byte.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBBS3.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbbs3[] =
{
    {
        "SHIFTBUFBBS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "it swapped within each byte.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBBS4.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbbs4[] =
{
    {
        "SHIFTBUFBBS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "it swapped within each byte.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBBS5.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbbs5[] =
{
    {
        "SHIFTBUFBBS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "it swapped within each byte.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBBS6.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbbs6[] =
{
    {
        "SHIFTBUFBBS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "it swapped within each byte.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBBS7.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbbs7[] =
{
    {
        "SHIFTBUFBBS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "it swapped within each byte.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTCTL0.
static const field_t hw_flexio_8shift_8tim_32pin_shiftctl0[] =
{
    {
        "SMOD",
        "Configures the mode of the Shifter.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPOL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINSEL",
        "Selects which pin is used by the Shifter input or output.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMPOL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMSEL",
        "Selects which Timer is used for controlling the logic/shift register a"
        "nd generating the Shift clock.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTCTL1.
static const field_t hw_flexio_8shift_8tim_32pin_shiftctl1[] =
{
    {
        "SMOD",
        "Configures the mode of the Shifter.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPOL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINSEL",
        "Selects which pin is used by the Shifter input or output.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMPOL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMSEL",
        "Selects which Timer is used for controlling the logic/shift register a"
        "nd generating the Shift clock.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTCTL2.
static const field_t hw_flexio_8shift_8tim_32pin_shiftctl2[] =
{
    {
        "SMOD",
        "Configures the mode of the Shifter.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPOL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINSEL",
        "Selects which pin is used by the Shifter input or output.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMPOL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMSEL",
        "Selects which Timer is used for controlling the logic/shift register a"
        "nd generating the Shift clock.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTCTL3.
static const field_t hw_flexio_8shift_8tim_32pin_shiftctl3[] =
{
    {
        "SMOD",
        "Configures the mode of the Shifter.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPOL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINSEL",
        "Selects which pin is used by the Shifter input or output.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMPOL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMSEL",
        "Selects which Timer is used for controlling the logic/shift register a"
        "nd generating the Shift clock.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTCTL4.
static const field_t hw_flexio_8shift_8tim_32pin_shiftctl4[] =
{
    {
        "SMOD",
        "Configures the mode of the Shifter.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPOL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINSEL",
        "Selects which pin is used by the Shifter input or output.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMPOL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMSEL",
        "Selects which Timer is used for controlling the logic/shift register a"
        "nd generating the Shift clock.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTCTL5.
static const field_t hw_flexio_8shift_8tim_32pin_shiftctl5[] =
{
    {
        "SMOD",
        "Configures the mode of the Shifter.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPOL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINSEL",
        "Selects which pin is used by the Shifter input or output.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMPOL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMSEL",
        "Selects which Timer is used for controlling the logic/shift register a"
        "nd generating the Shift clock.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTCTL6.
static const field_t hw_flexio_8shift_8tim_32pin_shiftctl6[] =
{
    {
        "SMOD",
        "Configures the mode of the Shifter.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPOL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINSEL",
        "Selects which pin is used by the Shifter input or output.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMPOL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMSEL",
        "Selects which Timer is used for controlling the logic/shift register a"
        "nd generating the Shift clock.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTCTL7.
static const field_t hw_flexio_8shift_8tim_32pin_shiftctl7[] =
{
    {
        "SMOD",
        "Configures the mode of the Shifter.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPOL",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINSEL",
        "Selects which pin is used by the Shifter input or output.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMPOL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMSEL",
        "Selects which Timer is used for controlling the logic/shift register a"
        "nd generating the Shift clock.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_VERID.
static const field_t hw_flexio_8shift_8tim_32pin_verid[] =
{
    {
        "FEATURE",
        "This read only field returns the feature set number.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read only field returns the minor version number for the module s"
        "pecification.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read only field returns the major version number for the module s"
        "pecification.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_PARAM.
static const field_t hw_flexio_8shift_8tim_32pin_param[] =
{
    {
        "SHIFTER",
        "Number of Shifters implemented.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TIMER",
        "Number of Timers implemented.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIN",
        "Number of Pins implemented.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIGGER",
        "Number of external triggers implemented.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_TIMIEN.
static const field_t hw_flexio_8shift_8tim_32pin_timien[] =
{
    {
        "TEIE",
        "Enables interrupt generation when corresponding TSF is set.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTSIEN.
static const field_t hw_flexio_8shift_8tim_32pin_shiftsien[] =
{
    {
        "SSIE",
        "Enables interrupt generation when corresponding SSF is set.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTEIEN.
static const field_t hw_flexio_8shift_8tim_32pin_shifteien[] =
{
    {
        "SEIE",
        "Enables interrupt generation when corresponding SEF is set.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTSDEN.
static const field_t hw_flexio_8shift_8tim_32pin_shiftsden[] =
{
    {
        "SSDE",
        "Enables DMA request generation when corresponding SSF is set.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBYS0.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbys0[] =
{
    {
        "SHIFTBUFBYS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "yte swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBYS1.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbys1[] =
{
    {
        "SHIFTBUFBYS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "yte swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBYS2.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbys2[] =
{
    {
        "SHIFTBUFBYS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "yte swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBYS3.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbys3[] =
{
    {
        "SHIFTBUFBYS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "yte swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBYS4.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbys4[] =
{
    {
        "SHIFTBUFBYS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "yte swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBYS5.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbys5[] =
{
    {
        "SHIFTBUFBYS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "yte swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBYS6.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbys6[] =
{
    {
        "SHIFTBUFBYS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "yte swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBYS7.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbys7[] =
{
    {
        "SHIFTBUFBYS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "yte swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBIS0.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbis0[] =
{
    {
        "SHIFTBUFBIS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "it swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBIS1.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbis1[] =
{
    {
        "SHIFTBUFBIS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "it swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBIS2.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbis2[] =
{
    {
        "SHIFTBUFBIS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "it swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBIS3.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbis3[] =
{
    {
        "SHIFTBUFBIS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "it swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBIS4.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbis4[] =
{
    {
        "SHIFTBUFBIS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "it swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBIS5.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbis5[] =
{
    {
        "SHIFTBUFBIS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "it swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBIS6.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbis6[] =
{
    {
        "SHIFTBUFBIS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "it swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFBIS7.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufbis7[] =
{
    {
        "SHIFTBUFBIS",
        "Alias to SHIFTBUF register, except reads/writes to this register are b"
        "it swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_PIN.
static const field_t hw_flexio_8shift_8tim_32pin_pin[] =
{
    {
        "PDI",
        "Returns the input data on each of the FlexIO pins.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFHWS0.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufhws0[] =
{
    {
        "SHIFTBUFHWS",
        "Alias to SHIFTBUF register, except reads/writes to this register are h"
        "alf word swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFHWS1.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufhws1[] =
{
    {
        "SHIFTBUFHWS",
        "Alias to SHIFTBUF register, except reads/writes to this register are h"
        "alf word swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFHWS2.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufhws2[] =
{
    {
        "SHIFTBUFHWS",
        "Alias to SHIFTBUF register, except reads/writes to this register are h"
        "alf word swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFHWS3.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufhws3[] =
{
    {
        "SHIFTBUFHWS",
        "Alias to SHIFTBUF register, except reads/writes to this register are h"
        "alf word swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFHWS4.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufhws4[] =
{
    {
        "SHIFTBUFHWS",
        "Alias to SHIFTBUF register, except reads/writes to this register are h"
        "alf word swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFHWS5.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufhws5[] =
{
    {
        "SHIFTBUFHWS",
        "Alias to SHIFTBUF register, except reads/writes to this register are h"
        "alf word swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFHWS6.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufhws6[] =
{
    {
        "SHIFTBUFHWS",
        "Alias to SHIFTBUF register, except reads/writes to this register are h"
        "alf word swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFHWS7.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufhws7[] =
{
    {
        "SHIFTBUFHWS",
        "Alias to SHIFTBUF register, except reads/writes to this register are h"
        "alf word swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFNIS0.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufnis0[] =
{
    {
        "SHIFTBUFNIS",
        "Alias to SHIFTBUF register, except reads/writes to this register are n"
        "ibble swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFNIS1.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufnis1[] =
{
    {
        "SHIFTBUFNIS",
        "Alias to SHIFTBUF register, except reads/writes to this register are n"
        "ibble swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFNIS2.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufnis2[] =
{
    {
        "SHIFTBUFNIS",
        "Alias to SHIFTBUF register, except reads/writes to this register are n"
        "ibble swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFNIS3.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufnis3[] =
{
    {
        "SHIFTBUFNIS",
        "Alias to SHIFTBUF register, except reads/writes to this register are n"
        "ibble swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFNIS4.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufnis4[] =
{
    {
        "SHIFTBUFNIS",
        "Alias to SHIFTBUF register, except reads/writes to this register are n"
        "ibble swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFNIS5.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufnis5[] =
{
    {
        "SHIFTBUFNIS",
        "Alias to SHIFTBUF register, except reads/writes to this register are n"
        "ibble swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFNIS6.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufnis6[] =
{
    {
        "SHIFTBUFNIS",
        "Alias to SHIFTBUF register, except reads/writes to this register are n"
        "ibble swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFNIS7.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufnis7[] =
{
    {
        "SHIFTBUFNIS",
        "Alias to SHIFTBUF register, except reads/writes to this register are n"
        "ibble swapped.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFNBS0.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufnbs0[] =
{
    {
        "SHIFTBUFNBS",
        "Alias to SHIFTBUF register, except reads/writes to this register are n"
        "ibble swapped within each byte.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFNBS1.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufnbs1[] =
{
    {
        "SHIFTBUFNBS",
        "Alias to SHIFTBUF register, except reads/writes to this register are n"
        "ibble swapped within each byte.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFNBS2.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufnbs2[] =
{
    {
        "SHIFTBUFNBS",
        "Alias to SHIFTBUF register, except reads/writes to this register are n"
        "ibble swapped within each byte.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFNBS3.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufnbs3[] =
{
    {
        "SHIFTBUFNBS",
        "Alias to SHIFTBUF register, except reads/writes to this register are n"
        "ibble swapped within each byte.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFNBS4.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufnbs4[] =
{
    {
        "SHIFTBUFNBS",
        "Alias to SHIFTBUF register, except reads/writes to this register are n"
        "ibble swapped within each byte.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFNBS5.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufnbs5[] =
{
    {
        "SHIFTBUFNBS",
        "Alias to SHIFTBUF register, except reads/writes to this register are n"
        "ibble swapped within each byte.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFNBS6.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufnbs6[] =
{
    {
        "SHIFTBUFNBS",
        "Alias to SHIFTBUF register, except reads/writes to this register are n"
        "ibble swapped within each byte.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTBUFNBS7.
static const field_t hw_flexio_8shift_8tim_32pin_shiftbufnbs7[] =
{
    {
        "SHIFTBUFNBS",
        "Alias to SHIFTBUF register, except reads/writes to this register are n"
        "ibble swapped within each byte.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXIO_8SHIFT_8TIM_32PIN_SHIFTSTATE.
static const field_t hw_flexio_8shift_8tim_32pin_shiftstate[] =
{
    {
        "STATE",
        "The current state field maintains a pointer to keep track of the curre"
        "nt Shifter (configured for State mode) enabled to drive outputs and co"
        "mpute the next state.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a FLEXIO_8SHIFT_8TIM_32PIN module.
static const reg_t hw_flexio_8shift_8tim_32pin[] =
{
    {
        "SHIFTBUF0",
        "",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbuf0
    },
    {
        "SHIFTBUF1",
        "",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbuf1
    },
    {
        "SHIFTBUF2",
        "",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbuf2
    },
    {
        "SHIFTBUF3",
        "",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbuf3
    },
    {
        "SHIFTBUF4",
        "",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbuf4
    },
    {
        "SHIFTBUF5",
        "",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbuf5
    },
    {
        "SHIFTBUF6",
        "",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbuf6
    },
    {
        "SHIFTBUF7",
        "",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbuf7
    },
    {
        "SHIFTCFG0",
        "",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftcfg0
    },
    {
        "SHIFTCFG1",
        "",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftcfg1
    },
    {
        "SHIFTCFG2",
        "",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftcfg2
    },
    {
        "SHIFTCFG3",
        "",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftcfg3
    },
    {
        "SHIFTCFG4",
        "",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftcfg4
    },
    {
        "SHIFTCFG5",
        "",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftcfg5
    },
    {
        "SHIFTCFG6",
        "",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftcfg6
    },
    {
        "SHIFTCFG7",
        "",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftcfg7
    },
    {
        "TIMCTL0",
        "",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timctl0
    },
    {
        "TIMCTL1",
        "",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timctl1
    },
    {
        "TIMCTL2",
        "",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timctl2
    },
    {
        "TIMCTL3",
        "",
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timctl3
    },
    {
        "TIMCTL4",
        "",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timctl4
    },
    {
        "TIMCTL5",
        "",
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timctl5
    },
    {
        "TIMCTL6",
        "",
        4, // Width in bytes
        0x00000418, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timctl6
    },
    {
        "TIMCTL7",
        "",
        4, // Width in bytes
        0x0000041c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timctl7
    },
    {
        "TIMCFG0",
        "The options to enable or disable the timer using the Timer N-1 enable "
        "or disable are reserved when N is evenly divisible by 4 (eg: Timer 0).",
        4, // Width in bytes
        0x00000480, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timcfg0
    },
    {
        "TIMCFG1",
        "The options to enable or disable the timer using the Timer N-1 enable "
        "or disable are reserved when N is evenly divisible by 4 (eg: Timer 0).",
        4, // Width in bytes
        0x00000484, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timcfg1
    },
    {
        "TIMCFG2",
        "The options to enable or disable the timer using the Timer N-1 enable "
        "or disable are reserved when N is evenly divisible by 4 (eg: Timer 0).",
        4, // Width in bytes
        0x00000488, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timcfg2
    },
    {
        "TIMCFG3",
        "The options to enable or disable the timer using the Timer N-1 enable "
        "or disable are reserved when N is evenly divisible by 4 (eg: Timer 0).",
        4, // Width in bytes
        0x0000048c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timcfg3
    },
    {
        "TIMCFG4",
        "The options to enable or disable the timer using the Timer N-1 enable "
        "or disable are reserved when N is evenly divisible by 4 (eg: Timer 0).",
        4, // Width in bytes
        0x00000490, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timcfg4
    },
    {
        "TIMCFG5",
        "The options to enable or disable the timer using the Timer N-1 enable "
        "or disable are reserved when N is evenly divisible by 4 (eg: Timer 0).",
        4, // Width in bytes
        0x00000494, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timcfg5
    },
    {
        "TIMCFG6",
        "The options to enable or disable the timer using the Timer N-1 enable "
        "or disable are reserved when N is evenly divisible by 4 (eg: Timer 0).",
        4, // Width in bytes
        0x00000498, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timcfg6
    },
    {
        "TIMCFG7",
        "The options to enable or disable the timer using the Timer N-1 enable "
        "or disable are reserved when N is evenly divisible by 4 (eg: Timer 0).",
        4, // Width in bytes
        0x0000049c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timcfg7
    },
    {
        "TIMCMP0",
        "",
        4, // Width in bytes
        0x00000500, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timcmp0
    },
    {
        "TIMCMP1",
        "",
        4, // Width in bytes
        0x00000504, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timcmp1
    },
    {
        "TIMCMP2",
        "",
        4, // Width in bytes
        0x00000508, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timcmp2
    },
    {
        "TIMCMP3",
        "",
        4, // Width in bytes
        0x0000050c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timcmp3
    },
    {
        "TIMCMP4",
        "",
        4, // Width in bytes
        0x00000510, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timcmp4
    },
    {
        "TIMCMP5",
        "",
        4, // Width in bytes
        0x00000514, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timcmp5
    },
    {
        "TIMCMP6",
        "",
        4, // Width in bytes
        0x00000518, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timcmp6
    },
    {
        "TIMCMP7",
        "",
        4, // Width in bytes
        0x0000051c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timcmp7
    },
    {
        "CTRL",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_ctrl
    },
    {
        "SHIFTSTAT",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftstat
    },
    {
        "TIMSTAT",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timstat
    },
    {
        "SHIFTERR",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shifterr
    },
    {
        "SHIFTBUFBBS0",
        "",
        4, // Width in bytes
        0x00000380, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbbs0
    },
    {
        "SHIFTBUFBBS1",
        "",
        4, // Width in bytes
        0x00000384, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbbs1
    },
    {
        "SHIFTBUFBBS2",
        "",
        4, // Width in bytes
        0x00000388, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbbs2
    },
    {
        "SHIFTBUFBBS3",
        "",
        4, // Width in bytes
        0x0000038c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbbs3
    },
    {
        "SHIFTBUFBBS4",
        "",
        4, // Width in bytes
        0x00000390, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbbs4
    },
    {
        "SHIFTBUFBBS5",
        "",
        4, // Width in bytes
        0x00000394, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbbs5
    },
    {
        "SHIFTBUFBBS6",
        "",
        4, // Width in bytes
        0x00000398, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbbs6
    },
    {
        "SHIFTBUFBBS7",
        "",
        4, // Width in bytes
        0x0000039c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbbs7
    },
    {
        "SHIFTCTL0",
        "",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftctl0
    },
    {
        "SHIFTCTL1",
        "",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftctl1
    },
    {
        "SHIFTCTL2",
        "",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftctl2
    },
    {
        "SHIFTCTL3",
        "",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftctl3
    },
    {
        "SHIFTCTL4",
        "",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftctl4
    },
    {
        "SHIFTCTL5",
        "",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftctl5
    },
    {
        "SHIFTCTL6",
        "",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftctl6
    },
    {
        "SHIFTCTL7",
        "",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftctl7
    },
    {
        "VERID",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_verid
    },
    {
        "PARAM",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_param
    },
    {
        "TIMIEN",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_timien
    },
    {
        "SHIFTSIEN",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftsien
    },
    {
        "SHIFTEIEN",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shifteien
    },
    {
        "SHIFTSDEN",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftsden
    },
    {
        "SHIFTBUFBYS0",
        "",
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbys0
    },
    {
        "SHIFTBUFBYS1",
        "",
        4, // Width in bytes
        0x00000304, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbys1
    },
    {
        "SHIFTBUFBYS2",
        "",
        4, // Width in bytes
        0x00000308, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbys2
    },
    {
        "SHIFTBUFBYS3",
        "",
        4, // Width in bytes
        0x0000030c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbys3
    },
    {
        "SHIFTBUFBYS4",
        "",
        4, // Width in bytes
        0x00000310, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbys4
    },
    {
        "SHIFTBUFBYS5",
        "",
        4, // Width in bytes
        0x00000314, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbys5
    },
    {
        "SHIFTBUFBYS6",
        "",
        4, // Width in bytes
        0x00000318, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbys6
    },
    {
        "SHIFTBUFBYS7",
        "",
        4, // Width in bytes
        0x0000031c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbys7
    },
    {
        "SHIFTBUFBIS0",
        "",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbis0
    },
    {
        "SHIFTBUFBIS1",
        "",
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbis1
    },
    {
        "SHIFTBUFBIS2",
        "",
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbis2
    },
    {
        "SHIFTBUFBIS3",
        "",
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbis3
    },
    {
        "SHIFTBUFBIS4",
        "",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbis4
    },
    {
        "SHIFTBUFBIS5",
        "",
        4, // Width in bytes
        0x00000294, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbis5
    },
    {
        "SHIFTBUFBIS6",
        "",
        4, // Width in bytes
        0x00000298, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbis6
    },
    {
        "SHIFTBUFBIS7",
        "",
        4, // Width in bytes
        0x0000029c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufbis7
    },
    {
        "PIN",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_pin
    },
    {
        "SHIFTBUFHWS0",
        "",
        4, // Width in bytes
        0x00000700, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufhws0
    },
    {
        "SHIFTBUFHWS1",
        "",
        4, // Width in bytes
        0x00000704, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufhws1
    },
    {
        "SHIFTBUFHWS2",
        "",
        4, // Width in bytes
        0x00000708, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufhws2
    },
    {
        "SHIFTBUFHWS3",
        "",
        4, // Width in bytes
        0x0000070c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufhws3
    },
    {
        "SHIFTBUFHWS4",
        "",
        4, // Width in bytes
        0x00000710, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufhws4
    },
    {
        "SHIFTBUFHWS5",
        "",
        4, // Width in bytes
        0x00000714, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufhws5
    },
    {
        "SHIFTBUFHWS6",
        "",
        4, // Width in bytes
        0x00000718, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufhws6
    },
    {
        "SHIFTBUFHWS7",
        "",
        4, // Width in bytes
        0x0000071c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufhws7
    },
    {
        "SHIFTBUFNIS0",
        "",
        4, // Width in bytes
        0x00000780, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufnis0
    },
    {
        "SHIFTBUFNIS1",
        "",
        4, // Width in bytes
        0x00000784, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufnis1
    },
    {
        "SHIFTBUFNIS2",
        "",
        4, // Width in bytes
        0x00000788, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufnis2
    },
    {
        "SHIFTBUFNIS3",
        "",
        4, // Width in bytes
        0x0000078c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufnis3
    },
    {
        "SHIFTBUFNIS4",
        "",
        4, // Width in bytes
        0x00000790, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufnis4
    },
    {
        "SHIFTBUFNIS5",
        "",
        4, // Width in bytes
        0x00000794, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufnis5
    },
    {
        "SHIFTBUFNIS6",
        "",
        4, // Width in bytes
        0x00000798, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufnis6
    },
    {
        "SHIFTBUFNIS7",
        "",
        4, // Width in bytes
        0x0000079c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufnis7
    },
    {
        "SHIFTBUFNBS0",
        "",
        4, // Width in bytes
        0x00000680, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufnbs0
    },
    {
        "SHIFTBUFNBS1",
        "",
        4, // Width in bytes
        0x00000684, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufnbs1
    },
    {
        "SHIFTBUFNBS2",
        "",
        4, // Width in bytes
        0x00000688, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufnbs2
    },
    {
        "SHIFTBUFNBS3",
        "",
        4, // Width in bytes
        0x0000068c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufnbs3
    },
    {
        "SHIFTBUFNBS4",
        "",
        4, // Width in bytes
        0x00000690, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufnbs4
    },
    {
        "SHIFTBUFNBS5",
        "",
        4, // Width in bytes
        0x00000694, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufnbs5
    },
    {
        "SHIFTBUFNBS6",
        "",
        4, // Width in bytes
        0x00000698, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufnbs6
    },
    {
        "SHIFTBUFNBS7",
        "",
        4, // Width in bytes
        0x0000069c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftbufnbs7
    },
    {
        "SHIFTSTATE",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexio_8shift_8tim_32pin_shiftstate
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPIO
#endif

// Bitfields in register GPIO_PDOR.
static const field_t hw_gpio_pdor[] =
{
    {
        "PDO",
        "Register bits for unbonded pins return an undefined value when read.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_PSOR.
static const field_t hw_gpio_psor[] =
{
    {
        "PTSO",
        "Writing to this register updates the contents of the corresponding bit"
        " in the PDOR as follows: 0b - Corresponding bit in PDORn does not chan"
        "ge.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_PCOR.
static const field_t hw_gpio_pcor[] =
{
    {
        "PTCO",
        "Writing to this register updates the contents of the corresponding bit"
        " in the Port Data Output Register (PDOR) as follows: 0b - Correspondin"
        "g bit in PDORn does not change.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_PTOR.
static const field_t hw_gpio_ptor[] =
{
    {
        "PTTO",
        "Writing to this register updates the contents of the corresponding bit"
        " in the PDOR as follows: 0b - Corresponding bit in PDORn does not chan"
        "ge.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_PDIR.
static const field_t hw_gpio_pdir[] =
{
    {
        "PDI",
        "Reads 0 at the unimplemented pins for a particular device.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_PDDR.
static const field_t hw_gpio_pddr[] =
{
    {
        "PDD",
        "Configures individual port pins for input or output.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_GACR.
static const field_t hw_gpio_gacr[] =
{
    {
        "ACB0",
        "This 3 bit field defines the attributes required to access the corresp"
        "onding GPIO port's programming model.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROB0",
        "This register bit provides a mechanism to \"lock\" the configuration s"
        "tate defined by ACB0.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACB1",
        "This 3 bit field defines the attributes required to access the corresp"
        "onding GPIO port's programming model.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROB1",
        "This register bit provides a mechanism to \"lock\" the configuration s"
        "tate defined by ACB1.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACB2",
        "This 3 bit field defines the attributes required to access the corresp"
        "onding GPIO port's programming model.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROB2",
        "This register bit provides a mechanism to \"lock\" the configuration s"
        "tate defined by ACB2.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACB3",
        "This 3 bit field defines the attributes required to access the corresp"
        "onding GPIO port's programming model.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROB3",
        "This register bit provides a mechanism to \"lock\" the configuration s"
        "tate defined by ACB3.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPIO module.
static const reg_t hw_gpio[] =
{
    {
        "PDOR",
        "This register configures the logic levels that are driven on each gene"
        "ral-purpose output pin.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_pdor
    },
    {
        "PSOR",
        "This register configures whether to set the fields of the PDOR.",
        4, // Width in bytes
        0x00000004, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_psor
    },
    {
        "PCOR",
        "This register configures whether to clear the fields of PDOR.",
        4, // Width in bytes
        0x00000008, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_pcor
    },
    {
        "PTOR",
        "This register toggles the logic levels that are driven on each general"
        "-purpose output pin.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_ptor
    },
    {
        "PDIR",
        "This register captures the logic levels that are driven into each gene"
        "ral-purpose input pin.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpio_pdir
    },
    {
        "PDDR",
        "The PDDR configures the individual port pins for input or output.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_pddr
    },
    {
        "GACR",
        "The GPIO module supports a device-specific number of data ports, organ"
        "ized as 32-bit words.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_gpio_gacr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SAI_2CH
#endif

// Bitfields in register SAI_2CH_TCSR.
static const field_t hw_sai_2ch_tcsr[] =
{
    {
        "FRDE",
        "Enables/disables DMA requests.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWDE",
        "Enables/disables DMA requests.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRIE",
        "Enables/disables FIFO request interrupts.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWIE",
        "Enables/disables FIFO warning interrupts.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FEIE",
        "Enables/disables FIFO error interrupts.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEIE",
        "Enables/disables sync error interrupts.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSIE",
        "Enables/disables word start interrupts.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRF",
        "Indicates that the number of words in an enabled transmit channel FIFO"
        " is less than or equal to the transmit FIFO watermark.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FWF",
        "Indicates that an enabled transmit FIFO is empty.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FEF",
        "Indicates that an enabled transmit FIFO has underrun.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEF",
        "Indicates that an error in the externally-generated frame sync has bee"
        "n detected.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSF",
        "Indicates that the start of the configured word has been detected.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SR",
        "When set, resets the internal transmitter logic including the FIFO poi"
        "nters.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FR",
        "Resets the FIFO pointers.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BCE",
        "Enables the transmit bit clock, separately from the TE.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGE",
        "Enables/disables transmitter operation in Debug mode.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPE",
        "Configures transmitter operation in Stop mode.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE",
        "Enables/disables the transmitter.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_TCR1.
static const field_t hw_sai_2ch_tcr1[] =
{
    {
        "TFW",
        "Configures the watermark level for all enabled transmit channels.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_TCR2.
static const field_t hw_sai_2ch_tcr2[] =
{
    {
        "DIV",
        "Divides down the audio master clock to generate the bit clock when con"
        "figured for an internal bit clock.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Configures the direction of the bit clock.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCP",
        "Configures the polarity of the bit clock.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSEL",
        "Selects the audio Master Clock option used to generate an internally g"
        "enerated bit clock.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCI",
        "When this field is set and using an internally generated bit clock in "
        "either synchronous or asynchronous mode, the bit clock actually used b"
        "y the transmitter is delayed by the pad output delay (the transmitter "
        "is clocked by the pad input as if the clock was externally generated).",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "This field swaps the bit clock used by the transmitter.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC",
        "Configures between asynchronous and synchronous modes of operation.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_TCR3.
static const field_t hw_sai_2ch_tcr3[] =
{
    {
        "WDFL",
        "Configures which word sets the start of word flag.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCE",
        "Enables the corresponding data channel for transmit operation.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CFR",
        "Resets the FIFO pointers for a specific channel.",
        24, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_TCR4.
static const field_t hw_sai_2ch_tcr4[] =
{
    {
        "FSD",
        "Configures the direction of the frame sync.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSP",
        "Configures the polarity of the frame sync.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ONDEM",
        "When set, and the frame sync is generated internally, a frame sync is "
        "only generated when the FIFO warning flag is clear.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSE",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MF",
        "Configures whether the LSB or the MSB is transmitted first.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYWD",
        "Configures the length of the frame sync in number of bit clocks.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRSZ",
        "Configures the number of words in each frame.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPACK",
        "Enables packing of 8-bit data or 16-bit data into each 32-bit FIFO wor"
        "d.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCOMB",
        "When FIFO combine mode is enabled for FIFO writes, software writing to"
        " any FIFO data register will alternate the write among the enabled dat"
        "a channel FIFOs.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCONT",
        "Configures when the SAI will continue transmitting after a FIFO error "
        "has been detected.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_TCR5.
static const field_t hw_sai_2ch_tcr5[] =
{
    {
        "FBT",
        "Configures the bit index for the first bit transmitted for each word i"
        "n the frame.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "W0W",
        "Configures the number of bits in the first word in each frame.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WNW",
        "Configures the number of bits in each word, for each word except the f"
        "irst in the frame.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_TDR0.
static const field_t hw_sai_2ch_tdr0[] =
{
    {
        "TDR",
        "Writes to this register when the transmit FIFO is not full will push t"
        "he data written into the transmit data FIFO.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_TDR1.
static const field_t hw_sai_2ch_tdr1[] =
{
    {
        "TDR",
        "Writes to this register when the transmit FIFO is not full will push t"
        "he data written into the transmit data FIFO.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_TFR0.
static const field_t hw_sai_2ch_tfr0[] =
{
    {
        "RFP",
        "FIFO read pointer for transmit data channel.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFP",
        "FIFO write pointer for transmit data channel.",
        16, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WCP",
        "When FIFO Combine mode is enabled for writes, indicates that this data"
        " channel is the next FIFO to be written.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_TFR1.
static const field_t hw_sai_2ch_tfr1[] =
{
    {
        "RFP",
        "FIFO read pointer for transmit data channel.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFP",
        "FIFO write pointer for transmit data channel.",
        16, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WCP",
        "When FIFO Combine mode is enabled for writes, indicates that this data"
        " channel is the next FIFO to be written.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_TMR.
static const field_t hw_sai_2ch_tmr[] =
{
    {
        "TWM",
        "Configures whether the transmit word is masked (transmit data pins are"
        " tri-stated and transmit data not read from FIFO) for the correspondin"
        "g word in the frame.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_RCSR.
static const field_t hw_sai_2ch_rcsr[] =
{
    {
        "FRDE",
        "Enables/disables DMA requests.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWDE",
        "Enables/disables DMA requests.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRIE",
        "Enables/disables FIFO request interrupts.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWIE",
        "Enables/disables FIFO warning interrupts.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FEIE",
        "Enables/disables FIFO error interrupts.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEIE",
        "Enables/disables sync error interrupts.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSIE",
        "Enables/disables word start interrupts.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRF",
        "Indicates that the number of words in an enabled receive channel FIFO "
        "is greater than the receive FIFO watermark.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FWF",
        "Indicates that an enabled receive FIFO is full.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FEF",
        "Indicates that an enabled receive FIFO has overflowed.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEF",
        "Indicates that an error in the externally-generated frame sync has bee"
        "n detected.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSF",
        "Indicates that the start of the configured word has been detected.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SR",
        "Resets the internal receiver logic including the FIFO pointers.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FR",
        "Resets the FIFO pointers.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BCE",
        "Enables the receive bit clock, separately from RE.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGE",
        "Enables/disables receiver operation in Debug mode.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPE",
        "Configures receiver operation in Stop mode.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE",
        "Enables/disables the receiver.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_RCR1.
static const field_t hw_sai_2ch_rcr1[] =
{
    {
        "RFW",
        "Configures the watermark level for all enabled receiver channels.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_RCR2.
static const field_t hw_sai_2ch_rcr2[] =
{
    {
        "DIV",
        "Divides down the audio master clock to generate the bit clock when con"
        "figured for an internal bit clock.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Configures the direction of the bit clock.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCP",
        "Configures the polarity of the bit clock.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSEL",
        "Selects the audio Master Clock option used to generate an internally g"
        "enerated bit clock.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCI",
        "When this field is set and using an internally generated bit clock in "
        "either synchronous or asynchronous mode, the bit clock actually used b"
        "y the receiver is delayed by the pad output delay (the receiver is clo"
        "cked by the pad input as if the clock was externally generated).",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "This field swaps the bit clock used by the receiver.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC",
        "Configures between asynchronous and synchronous modes of operation.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_RCR3.
static const field_t hw_sai_2ch_rcr3[] =
{
    {
        "WDFL",
        "Configures which word the start of word flag is set.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCE",
        "Enables the corresponding data channel for receive operation.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CFR",
        "Resets the FIFO pointers for a specific channel.",
        24, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_RCR4.
static const field_t hw_sai_2ch_rcr4[] =
{
    {
        "FSD",
        "Configures the direction of the frame sync.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSP",
        "Configures the polarity of the frame sync.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ONDEM",
        "When set, and the frame sync is generated internally, a frame sync is "
        "only generated when the FIFO warning flag is clear.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSE",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MF",
        "Configures whether the LSB or the MSB is received first.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYWD",
        "Configures the length of the frame sync in number of bit clocks.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRSZ",
        "Configures the number of words in each frame.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPACK",
        "Enables packing of 8-bit data or 16-bit data into each 32-bit FIFO wor"
        "d.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCOMB",
        "When FIFO combine mode is enabled for FIFO reads, software reading any"
        " FIFO data register will alternate the read among the enabled data cha"
        "nnel FIFOs.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCONT",
        "Configures when the SAI will continue receiving after a FIFO error has"
        " been detected.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_RCR5.
static const field_t hw_sai_2ch_rcr5[] =
{
    {
        "FBT",
        "Configures the bit index for the first bit received for each word in t"
        "he frame.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "W0W",
        "Configures the number of bits in the first word in each frame.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WNW",
        "Configures the number of bits in each word, for each word except the f"
        "irst in the frame.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_RDR0.
static const field_t hw_sai_2ch_rdr0[] =
{
    {
        "RDR",
        "Reads from this register when the receive FIFO is not empty will retur"
        "n the data from the top of the receive FIFO.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_RDR1.
static const field_t hw_sai_2ch_rdr1[] =
{
    {
        "RDR",
        "Reads from this register when the receive FIFO is not empty will retur"
        "n the data from the top of the receive FIFO.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_RFR0.
static const field_t hw_sai_2ch_rfr0[] =
{
    {
        "RFP",
        "FIFO read pointer for receive data channel.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RCP",
        "When FIFO Combine mode is enabled for reads, indicates that this data "
        "channel is the next FIFO to be read.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFP",
        "FIFO write pointer for receive data channel.",
        16, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_RFR1.
static const field_t hw_sai_2ch_rfr1[] =
{
    {
        "RFP",
        "FIFO read pointer for receive data channel.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RCP",
        "When FIFO Combine mode is enabled for reads, indicates that this data "
        "channel is the next FIFO to be read.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFP",
        "FIFO write pointer for receive data channel.",
        16, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_2CH_RMR.
static const field_t hw_sai_2ch_rmr[] =
{
    {
        "RWM",
        "Configures whether the receive word is masked (received data ignored a"
        "nd not written to receive FIFO) for the corresponding word in the fram"
        "e.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SAI_2CH module.
static const reg_t hw_sai_2ch[] =
{
    {
        "TCSR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_sai_2ch_tcsr
    },
    {
        "TCR1",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sai_2ch_tcr1
    },
    {
        "TCR2",
        "This register must not be altered when TCSR[TE] is set.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_sai_2ch_tcr2
    },
    {
        "TCR3",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_sai_2ch_tcr3
    },
    {
        "TCR4",
        "This register must not be altered when TCSR[TE] is set.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_sai_2ch_tcr4
    },
    {
        "TCR5",
        "This register must not be altered when TCSR[TE] is set.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_sai_2ch_tcr5
    },
    {
        "TDR0",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sai_2ch_tdr0
    },
    {
        "TDR1",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sai_2ch_tdr1
    },
    {
        "TFR0",
        "The MSB of the read and write pointers is used to distinguish between "
        "FIFO full and empty conditions.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sai_2ch_tfr0
    },
    {
        "TFR1",
        "The MSB of the read and write pointers is used to distinguish between "
        "FIFO full and empty conditions.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sai_2ch_tfr1
    },
    {
        "TMR",
        "This register is double-buffered and updates: When TCSR[TE] is first s"
        "et At the end of each frame.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sai_2ch_tmr
    },
    {
        "RCSR",
        "",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_sai_2ch_rcsr
    },
    {
        "RCR1",
        "",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sai_2ch_rcr1
    },
    {
        "RCR2",
        "This register must not be altered when RCSR[RE] is set.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_sai_2ch_rcr2
    },
    {
        "RCR3",
        "",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_sai_2ch_rcr3
    },
    {
        "RCR4",
        "This register must not be altered when RCSR[RE] is set.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_sai_2ch_rcr4
    },
    {
        "RCR5",
        "This register must not be altered when RCSR[RE] is set.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_sai_2ch_rcr5
    },
    {
        "RDR0",
        "",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sai_2ch_rdr0
    },
    {
        "RDR1",
        "",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sai_2ch_rdr1
    },
    {
        "RFR0",
        "The MSB of the read and write pointers is used to distinguish between "
        "FIFO full and empty conditions.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sai_2ch_rfr0
    },
    {
        "RFR1",
        "The MSB of the read and write pointers is used to distinguish between "
        "FIFO full and empty conditions.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sai_2ch_rfr1
    },
    {
        "RMR",
        "This register is double-buffered and updates: When RCSR[RE] is first s"
        "et At the end of each frame This allows the masked words in each frame"
        " to change from frame to frame.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sai_2ch_rmr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SAI_4CH
#endif

// Bitfields in register SAI_4CH_TCSR.
static const field_t hw_sai_4ch_tcsr[] =
{
    {
        "FRDE",
        "Enables/disables DMA requests.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWDE",
        "Enables/disables DMA requests.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRIE",
        "Enables/disables FIFO request interrupts.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWIE",
        "Enables/disables FIFO warning interrupts.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FEIE",
        "Enables/disables FIFO error interrupts.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEIE",
        "Enables/disables sync error interrupts.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSIE",
        "Enables/disables word start interrupts.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRF",
        "Indicates that the number of words in an enabled transmit channel FIFO"
        " is less than or equal to the transmit FIFO watermark.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FWF",
        "Indicates that an enabled transmit FIFO is empty.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FEF",
        "Indicates that an enabled transmit FIFO has underrun.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEF",
        "Indicates that an error in the externally-generated frame sync has bee"
        "n detected.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSF",
        "Indicates that the start of the configured word has been detected.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SR",
        "When set, resets the internal transmitter logic including the FIFO poi"
        "nters.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FR",
        "Resets the FIFO pointers.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BCE",
        "Enables the transmit bit clock, separately from the TE.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGE",
        "Enables/disables transmitter operation in Debug mode.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPE",
        "Configures transmitter operation in Stop mode.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE",
        "Enables/disables the transmitter.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_TCR1.
static const field_t hw_sai_4ch_tcr1[] =
{
    {
        "TFW",
        "Configures the watermark level for all enabled transmit channels.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_TCR2.
static const field_t hw_sai_4ch_tcr2[] =
{
    {
        "DIV",
        "Divides down the audio master clock to generate the bit clock when con"
        "figured for an internal bit clock.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Configures the direction of the bit clock.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCP",
        "Configures the polarity of the bit clock.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSEL",
        "Selects the audio Master Clock option used to generate an internally g"
        "enerated bit clock.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCI",
        "When this field is set and using an internally generated bit clock in "
        "either synchronous or asynchronous mode, the bit clock actually used b"
        "y the transmitter is delayed by the pad output delay (the transmitter "
        "is clocked by the pad input as if the clock was externally generated).",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "This field swaps the bit clock used by the transmitter.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC",
        "Configures between asynchronous and synchronous modes of operation.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_TCR3.
static const field_t hw_sai_4ch_tcr3[] =
{
    {
        "WDFL",
        "Configures which word sets the start of word flag.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCE",
        "Enables the corresponding data channel for transmit operation.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CFR",
        "Resets the FIFO pointers for a specific channel.",
        24, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_TCR4.
static const field_t hw_sai_4ch_tcr4[] =
{
    {
        "FSD",
        "Configures the direction of the frame sync.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSP",
        "Configures the polarity of the frame sync.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ONDEM",
        "When set, and the frame sync is generated internally, a frame sync is "
        "only generated when the FIFO warning flag is clear.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSE",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MF",
        "Configures whether the LSB or the MSB is transmitted first.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYWD",
        "Configures the length of the frame sync in number of bit clocks.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRSZ",
        "Configures the number of words in each frame.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPACK",
        "Enables packing of 8-bit data or 16-bit data into each 32-bit FIFO wor"
        "d.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCOMB",
        "When FIFO combine mode is enabled for FIFO writes, software writing to"
        " any FIFO data register will alternate the write among the enabled dat"
        "a channel FIFOs.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCONT",
        "Configures when the SAI will continue transmitting after a FIFO error "
        "has been detected.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_TCR5.
static const field_t hw_sai_4ch_tcr5[] =
{
    {
        "FBT",
        "Configures the bit index for the first bit transmitted for each word i"
        "n the frame.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "W0W",
        "Configures the number of bits in the first word in each frame.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WNW",
        "Configures the number of bits in each word, for each word except the f"
        "irst in the frame.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_TDR0.
static const field_t hw_sai_4ch_tdr0[] =
{
    {
        "TDR",
        "Writes to this register when the transmit FIFO is not full will push t"
        "he data written into the transmit data FIFO.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_TDR1.
static const field_t hw_sai_4ch_tdr1[] =
{
    {
        "TDR",
        "Writes to this register when the transmit FIFO is not full will push t"
        "he data written into the transmit data FIFO.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_TDR2.
static const field_t hw_sai_4ch_tdr2[] =
{
    {
        "TDR",
        "Writes to this register when the transmit FIFO is not full will push t"
        "he data written into the transmit data FIFO.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_TDR3.
static const field_t hw_sai_4ch_tdr3[] =
{
    {
        "TDR",
        "Writes to this register when the transmit FIFO is not full will push t"
        "he data written into the transmit data FIFO.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_TFR0.
static const field_t hw_sai_4ch_tfr0[] =
{
    {
        "RFP",
        "FIFO read pointer for transmit data channel.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFP",
        "FIFO write pointer for transmit data channel.",
        16, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WCP",
        "When FIFO Combine mode is enabled for writes, indicates that this data"
        " channel is the next FIFO to be written.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_TFR1.
static const field_t hw_sai_4ch_tfr1[] =
{
    {
        "RFP",
        "FIFO read pointer for transmit data channel.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFP",
        "FIFO write pointer for transmit data channel.",
        16, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WCP",
        "When FIFO Combine mode is enabled for writes, indicates that this data"
        " channel is the next FIFO to be written.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_TFR2.
static const field_t hw_sai_4ch_tfr2[] =
{
    {
        "RFP",
        "FIFO read pointer for transmit data channel.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFP",
        "FIFO write pointer for transmit data channel.",
        16, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WCP",
        "When FIFO Combine mode is enabled for writes, indicates that this data"
        " channel is the next FIFO to be written.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_TFR3.
static const field_t hw_sai_4ch_tfr3[] =
{
    {
        "RFP",
        "FIFO read pointer for transmit data channel.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFP",
        "FIFO write pointer for transmit data channel.",
        16, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WCP",
        "When FIFO Combine mode is enabled for writes, indicates that this data"
        " channel is the next FIFO to be written.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_TMR.
static const field_t hw_sai_4ch_tmr[] =
{
    {
        "TWM",
        "Configures whether the transmit word is masked (transmit data pins are"
        " tri-stated and transmit data not read from FIFO) for the correspondin"
        "g word in the frame.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_RCSR.
static const field_t hw_sai_4ch_rcsr[] =
{
    {
        "FRDE",
        "Enables/disables DMA requests.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWDE",
        "Enables/disables DMA requests.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRIE",
        "Enables/disables FIFO request interrupts.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWIE",
        "Enables/disables FIFO warning interrupts.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FEIE",
        "Enables/disables FIFO error interrupts.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEIE",
        "Enables/disables sync error interrupts.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSIE",
        "Enables/disables word start interrupts.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRF",
        "Indicates that the number of words in an enabled receive channel FIFO "
        "is greater than the receive FIFO watermark.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FWF",
        "Indicates that an enabled receive FIFO is full.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FEF",
        "Indicates that an enabled receive FIFO has overflowed.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEF",
        "Indicates that an error in the externally-generated frame sync has bee"
        "n detected.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSF",
        "Indicates that the start of the configured word has been detected.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SR",
        "Resets the internal receiver logic including the FIFO pointers.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FR",
        "Resets the FIFO pointers.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BCE",
        "Enables the receive bit clock, separately from RE.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGE",
        "Enables/disables receiver operation in Debug mode.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPE",
        "Configures receiver operation in Stop mode.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE",
        "Enables/disables the receiver.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_RCR1.
static const field_t hw_sai_4ch_rcr1[] =
{
    {
        "RFW",
        "Configures the watermark level for all enabled receiver channels.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_RCR2.
static const field_t hw_sai_4ch_rcr2[] =
{
    {
        "DIV",
        "Divides down the audio master clock to generate the bit clock when con"
        "figured for an internal bit clock.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Configures the direction of the bit clock.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCP",
        "Configures the polarity of the bit clock.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSEL",
        "Selects the audio Master Clock option used to generate an internally g"
        "enerated bit clock.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCI",
        "When this field is set and using an internally generated bit clock in "
        "either synchronous or asynchronous mode, the bit clock actually used b"
        "y the receiver is delayed by the pad output delay (the receiver is clo"
        "cked by the pad input as if the clock was externally generated).",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "This field swaps the bit clock used by the receiver.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC",
        "Configures between asynchronous and synchronous modes of operation.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_RCR3.
static const field_t hw_sai_4ch_rcr3[] =
{
    {
        "WDFL",
        "Configures which word the start of word flag is set.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCE",
        "Enables the corresponding data channel for receive operation.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CFR",
        "Resets the FIFO pointers for a specific channel.",
        24, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_RCR4.
static const field_t hw_sai_4ch_rcr4[] =
{
    {
        "FSD",
        "Configures the direction of the frame sync.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSP",
        "Configures the polarity of the frame sync.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ONDEM",
        "When set, and the frame sync is generated internally, a frame sync is "
        "only generated when the FIFO warning flag is clear.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSE",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MF",
        "Configures whether the LSB or the MSB is received first.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYWD",
        "Configures the length of the frame sync in number of bit clocks.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRSZ",
        "Configures the number of words in each frame.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPACK",
        "Enables packing of 8-bit data or 16-bit data into each 32-bit FIFO wor"
        "d.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCOMB",
        "When FIFO combine mode is enabled for FIFO reads, software reading any"
        " FIFO data register will alternate the read among the enabled data cha"
        "nnel FIFOs.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCONT",
        "Configures when the SAI will continue receiving after a FIFO error has"
        " been detected.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_RCR5.
static const field_t hw_sai_4ch_rcr5[] =
{
    {
        "FBT",
        "Configures the bit index for the first bit received for each word in t"
        "he frame.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "W0W",
        "Configures the number of bits in the first word in each frame.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WNW",
        "Configures the number of bits in each word, for each word except the f"
        "irst in the frame.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_RDR0.
static const field_t hw_sai_4ch_rdr0[] =
{
    {
        "RDR",
        "Reads from this register when the receive FIFO is not empty will retur"
        "n the data from the top of the receive FIFO.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_RDR1.
static const field_t hw_sai_4ch_rdr1[] =
{
    {
        "RDR",
        "Reads from this register when the receive FIFO is not empty will retur"
        "n the data from the top of the receive FIFO.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_RDR2.
static const field_t hw_sai_4ch_rdr2[] =
{
    {
        "RDR",
        "Reads from this register when the receive FIFO is not empty will retur"
        "n the data from the top of the receive FIFO.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_RDR3.
static const field_t hw_sai_4ch_rdr3[] =
{
    {
        "RDR",
        "Reads from this register when the receive FIFO is not empty will retur"
        "n the data from the top of the receive FIFO.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_RFR0.
static const field_t hw_sai_4ch_rfr0[] =
{
    {
        "RFP",
        "FIFO read pointer for receive data channel.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RCP",
        "When FIFO Combine mode is enabled for reads, indicates that this data "
        "channel is the next FIFO to be read.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFP",
        "FIFO write pointer for receive data channel.",
        16, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_RFR1.
static const field_t hw_sai_4ch_rfr1[] =
{
    {
        "RFP",
        "FIFO read pointer for receive data channel.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RCP",
        "When FIFO Combine mode is enabled for reads, indicates that this data "
        "channel is the next FIFO to be read.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFP",
        "FIFO write pointer for receive data channel.",
        16, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_RFR2.
static const field_t hw_sai_4ch_rfr2[] =
{
    {
        "RFP",
        "FIFO read pointer for receive data channel.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RCP",
        "When FIFO Combine mode is enabled for reads, indicates that this data "
        "channel is the next FIFO to be read.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFP",
        "FIFO write pointer for receive data channel.",
        16, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_RFR3.
static const field_t hw_sai_4ch_rfr3[] =
{
    {
        "RFP",
        "FIFO read pointer for receive data channel.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RCP",
        "When FIFO Combine mode is enabled for reads, indicates that this data "
        "channel is the next FIFO to be read.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFP",
        "FIFO write pointer for receive data channel.",
        16, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SAI_4CH_RMR.
static const field_t hw_sai_4ch_rmr[] =
{
    {
        "RWM",
        "Configures whether the receive word is masked (received data ignored a"
        "nd not written to receive FIFO) for the corresponding word in the fram"
        "e.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SAI_4CH module.
static const reg_t hw_sai_4ch[] =
{
    {
        "TCSR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_sai_4ch_tcsr
    },
    {
        "TCR1",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sai_4ch_tcr1
    },
    {
        "TCR2",
        "This register must not be altered when TCSR[TE] is set.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_sai_4ch_tcr2
    },
    {
        "TCR3",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_sai_4ch_tcr3
    },
    {
        "TCR4",
        "This register must not be altered when TCSR[TE] is set.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_sai_4ch_tcr4
    },
    {
        "TCR5",
        "This register must not be altered when TCSR[TE] is set.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_sai_4ch_tcr5
    },
    {
        "TDR0",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sai_4ch_tdr0
    },
    {
        "TDR1",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sai_4ch_tdr1
    },
    {
        "TDR2",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sai_4ch_tdr2
    },
    {
        "TDR3",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sai_4ch_tdr3
    },
    {
        "TFR0",
        "The MSB of the read and write pointers is used to distinguish between "
        "FIFO full and empty conditions.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sai_4ch_tfr0
    },
    {
        "TFR1",
        "The MSB of the read and write pointers is used to distinguish between "
        "FIFO full and empty conditions.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sai_4ch_tfr1
    },
    {
        "TFR2",
        "The MSB of the read and write pointers is used to distinguish between "
        "FIFO full and empty conditions.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sai_4ch_tfr2
    },
    {
        "TFR3",
        "The MSB of the read and write pointers is used to distinguish between "
        "FIFO full and empty conditions.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sai_4ch_tfr3
    },
    {
        "TMR",
        "This register is double-buffered and updates: When TCSR[TE] is first s"
        "et At the end of each frame.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sai_4ch_tmr
    },
    {
        "RCSR",
        "",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_sai_4ch_rcsr
    },
    {
        "RCR1",
        "",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sai_4ch_rcr1
    },
    {
        "RCR2",
        "This register must not be altered when RCSR[RE] is set.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_sai_4ch_rcr2
    },
    {
        "RCR3",
        "",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_sai_4ch_rcr3
    },
    {
        "RCR4",
        "This register must not be altered when RCSR[RE] is set.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_sai_4ch_rcr4
    },
    {
        "RCR5",
        "This register must not be altered when RCSR[RE] is set.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_sai_4ch_rcr5
    },
    {
        "RDR0",
        "",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sai_4ch_rdr0
    },
    {
        "RDR1",
        "",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sai_4ch_rdr1
    },
    {
        "RDR2",
        "",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sai_4ch_rdr2
    },
    {
        "RDR3",
        "",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sai_4ch_rdr3
    },
    {
        "RFR0",
        "The MSB of the read and write pointers is used to distinguish between "
        "FIFO full and empty conditions.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sai_4ch_rfr0
    },
    {
        "RFR1",
        "The MSB of the read and write pointers is used to distinguish between "
        "FIFO full and empty conditions.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sai_4ch_rfr1
    },
    {
        "RFR2",
        "The MSB of the read and write pointers is used to distinguish between "
        "FIFO full and empty conditions.",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sai_4ch_rfr2
    },
    {
        "RFR3",
        "The MSB of the read and write pointers is used to distinguish between "
        "FIFO full and empty conditions.",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sai_4ch_rfr3
    },
    {
        "RMR",
        "This register is double-buffered and updates: When RCSR[RE] is first s"
        "et At the end of each frame This allows the masked words in each frame"
        " to change from frame to frame.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sai_4ch_rmr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark IOMUXC0
#endif

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA0.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta0[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA1.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta1[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA2.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta2[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA3.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta3[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA4.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta4[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA5.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta5[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA6.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta6[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA7.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta7[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA8.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta8[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA9.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta9[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA10.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta10[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA11.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta11[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA12.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta12[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA13.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta13[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA14.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta14[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA15.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta15[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA16.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta16[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA17.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta17[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA18.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta18[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA19.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta19[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA20.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta20[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA21.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta21[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA22.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta22[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA23.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta23[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA24.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta24[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA25.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta25[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA26.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta26[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA27.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta27[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA28.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta28[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA29.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta29[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA30.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta30[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTA31.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_pta31[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB0.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb0[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB1.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb1[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB2.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb2[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB3.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb3[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB4.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb4[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB5.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb5[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB6.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb6[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB7.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb7[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB8.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb8[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB9.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb9[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB10.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb10[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB11.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb11[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB12.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb12[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB13.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb13[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB14.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb14[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB15.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb15[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB16.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb16[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB17.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb17[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB18.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb18[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_PTB19.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_ptb19[] =
{
    {
        "PS",
        "Select one out of next values for pad: PADn",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFE",
        "Select one out of next values for pad: PADn",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFCS",
        "Select one out of next values for pad: PADn",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFD",
        "Select one out of next values for pad: PADn",
        22, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPSPI0_IPP_IND_LPSPI_PCS0_SELECT_INPUT.
static const field_t hw_iomuxc0_lpspi0_ipp_ind_lpspi_pcs0_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPSPI0_IPP_IND_LPSPI_PCS1_SELECT_INPUT.
static const field_t hw_iomuxc0_lpspi0_ipp_ind_lpspi_pcs1_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPSPI0_IPP_IND_LPSPI_PCS2_SELECT_INPUT.
static const field_t hw_iomuxc0_lpspi0_ipp_ind_lpspi_pcs2_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPSPI0_IPP_IND_LPSPI_PCS3_SELECT_INPUT.
static const field_t hw_iomuxc0_lpspi0_ipp_ind_lpspi_pcs3_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPSPI0_IPP_IND_LPSPI_SCK_SELECT_INPUT.
static const field_t hw_iomuxc0_lpspi0_ipp_ind_lpspi_sck_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPSPI0_IPP_IND_LPSPI_SDI_SELECT_INPUT.
static const field_t hw_iomuxc0_lpspi0_ipp_ind_lpspi_sdi_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPSPI0_IPP_IND_LPSPI_SDO_SELECT_INPUT.
static const field_t hw_iomuxc0_lpspi0_ipp_ind_lpspi_sdo_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPSPI1_IPP_IND_LPSPI_PCS0_SELECT_INPUT.
static const field_t hw_iomuxc0_lpspi1_ipp_ind_lpspi_pcs0_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPSPI1_IPP_IND_LPSPI_PCS1_SELECT_INPUT.
static const field_t hw_iomuxc0_lpspi1_ipp_ind_lpspi_pcs1_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPSPI1_IPP_IND_LPSPI_PCS2_SELECT_INPUT.
static const field_t hw_iomuxc0_lpspi1_ipp_ind_lpspi_pcs2_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPSPI1_IPP_IND_LPSPI_PCS3_SELECT_INPUT.
static const field_t hw_iomuxc0_lpspi1_ipp_ind_lpspi_pcs3_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPSPI1_IPP_IND_LPSPI_SCK_SELECT_INPUT.
static const field_t hw_iomuxc0_lpspi1_ipp_ind_lpspi_sck_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPSPI1_IPP_IND_LPSPI_SDI_SELECT_INPUT.
static const field_t hw_iomuxc0_lpspi1_ipp_ind_lpspi_sdi_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPSPI1_IPP_IND_LPSPI_SDO_SELECT_INPUT.
static const field_t hw_iomuxc0_lpspi1_ipp_ind_lpspi_sdo_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM0_IPP_IND_LPTPM_CH0_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm0_ipp_ind_lptpm_ch0_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM0_IPP_IND_LPTPM_CH1_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm0_ipp_ind_lptpm_ch1_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM0_IPP_IND_LPTPM_CH2_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm0_ipp_ind_lptpm_ch2_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM0_IPP_IND_LPTPM_CH3_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm0_ipp_ind_lptpm_ch3_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM0_IPP_IND_LPTPM_CH4_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm0_ipp_ind_lptpm_ch4_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM0_IPP_IND_LPTPM_CH5_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm0_ipp_ind_lptpm_ch5_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM1_IPP_IND_LPTPM_CH0_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm1_ipp_ind_lptpm_ch0_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM1_IPP_IND_LPTPM_CH1_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm1_ipp_ind_lptpm_ch1_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM2_IPP_IND_LPTPM_CH0_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm2_ipp_ind_lptpm_ch0_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM2_IPP_IND_LPTPM_CH1_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm2_ipp_ind_lptpm_ch1_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM3_IPP_IND_LPTPM_CH0_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm3_ipp_ind_lptpm_ch0_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM3_IPP_IND_LPTPM_CH1_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm3_ipp_ind_lptpm_ch1_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM3_IPP_IND_LPTPM_CH2_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm3_ipp_ind_lptpm_ch2_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM3_IPP_IND_LPTPM_CH3_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm3_ipp_ind_lptpm_ch3_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM3_IPP_IND_LPTPM_CH4_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm3_ipp_ind_lptpm_ch4_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM3_IPP_IND_LPTPM_CH5_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm3_ipp_ind_lptpm_ch5_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPI2C0_IPP_IND_LPI2C_HREQ_SELECT_INPUT.
static const field_t hw_iomuxc0_lpi2c0_ipp_ind_lpi2c_hreq_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPI2C0_IPP_IND_LPI2C_SCL_SELECT_INPUT.
static const field_t hw_iomuxc0_lpi2c0_ipp_ind_lpi2c_scl_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPI2C0_IPP_IND_LPI2C_SDA_SELECT_INPUT.
static const field_t hw_iomuxc0_lpi2c0_ipp_ind_lpi2c_sda_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPI2C1_IPP_IND_LPI2C_HREQ_SELECT_INPUT.
static const field_t hw_iomuxc0_lpi2c1_ipp_ind_lpi2c_hreq_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPI2C1_IPP_IND_LPI2C_SCL_SELECT_INPUT.
static const field_t hw_iomuxc0_lpi2c1_ipp_ind_lpi2c_scl_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPI2C1_IPP_IND_LPI2C_SDA_SELECT_INPUT.
static const field_t hw_iomuxc0_lpi2c1_ipp_ind_lpi2c_sda_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPI2C2_IPP_IND_LPI2C_HREQ_SELECT_INPUT.
static const field_t hw_iomuxc0_lpi2c2_ipp_ind_lpi2c_hreq_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPI2C2_IPP_IND_LPI2C_SCL_SELECT_INPUT.
static const field_t hw_iomuxc0_lpi2c2_ipp_ind_lpi2c_scl_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPI2C2_IPP_IND_LPI2C_SDA_SELECT_INPUT.
static const field_t hw_iomuxc0_lpi2c2_ipp_ind_lpi2c_sda_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPI2C3_IPP_IND_LPI2C_HREQ_SELECT_INPUT.
static const field_t hw_iomuxc0_lpi2c3_ipp_ind_lpi2c_hreq_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPI2C3_IPP_IND_LPI2C_SCL_SELECT_INPUT.
static const field_t hw_iomuxc0_lpi2c3_ipp_ind_lpi2c_scl_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPI2C3_IPP_IND_LPI2C_SDA_SELECT_INPUT.
static const field_t hw_iomuxc0_lpi2c3_ipp_ind_lpi2c_sda_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM0_IPP_IND_LPTPM_CLK_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm0_ipp_ind_lptpm_clk_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM1_IPP_IND_LPTPM_CLK_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm1_ipp_ind_lptpm_clk_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM3_IPP_IND_LPTPM_CLK_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm3_ipp_ind_lptpm_clk_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_PCC_AIPS0_IPP_IND_EXTCLK55_SELECT_INPUT.
static const field_t hw_iomuxc0_pcc_aips0_ipp_ind_extclk55_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SAI0_IPP_IND_SAI_RXBCLK_SELECT_INPUT.
static const field_t hw_iomuxc0_sai0_ipp_ind_sai_rxbclk_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SAI0_IPP_IND_SAI_RXSYNC_SELECT_INPUT.
static const field_t hw_iomuxc0_sai0_ipp_ind_sai_rxsync_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SAI0_IPP_IND_SAI_TXBCLK_SELECT_INPUT.
static const field_t hw_iomuxc0_sai0_ipp_ind_sai_txbclk_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SAI0_IPP_IND_SAI_TXSYNC_SELECT_INPUT.
static const field_t hw_iomuxc0_sai0_ipp_ind_sai_txsync_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_PCC_AIPS1_IPP_IND_EXTCLK42_SELECT_INPUT.
static const field_t hw_iomuxc0_pcc_aips1_ipp_ind_extclk42_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SAI1_IPP_IND_SAI_RXBCLK_SELECT_INPUT.
static const field_t hw_iomuxc0_sai1_ipp_ind_sai_rxbclk_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SAI1_IPP_IND_SAI_RXSYNC_SELECT_INPUT.
static const field_t hw_iomuxc0_sai1_ipp_ind_sai_rxsync_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SAI1_IPP_IND_SAI_TXBCLK_SELECT_INPUT.
static const field_t hw_iomuxc0_sai1_ipp_ind_sai_txbclk_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SAI1_IPP_IND_SAI_TXSYNC_SELECT_INPUT.
static const field_t hw_iomuxc0_sai1_ipp_ind_sai_txsync_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SAI0_IPP_IND_SAI_RXDATA0_SELECT_INPUT.
static const field_t hw_iomuxc0_sai0_ipp_ind_sai_rxdata0_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SAI0_IPP_IND_SAI_RXDATA1_SELECT_INPUT.
static const field_t hw_iomuxc0_sai0_ipp_ind_sai_rxdata1_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SAI1_IPP_IND_SAI_RXDATA0_SELECT_INPUT.
static const field_t hw_iomuxc0_sai1_ipp_ind_sai_rxdata0_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SAI1_IPP_IND_SAI_RXDATA1_SELECT_INPUT.
static const field_t hw_iomuxc0_sai1_ipp_ind_sai_rxdata1_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SAI1_IPP_IND_SAI_RXDATA2_SELECT_INPUT.
static const field_t hw_iomuxc0_sai1_ipp_ind_sai_rxdata2_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SAI1_IPP_IND_SAI_RXDATA3_SELECT_INPUT.
static const field_t hw_iomuxc0_sai1_ipp_ind_sai_rxdata3_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPTPM2_IPP_IND_LPTPM_CLK_SELECT_INPUT.
static const field_t hw_iomuxc0_lptpm2_ipp_ind_lptpm_clk_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPUART0_IPP_IND_LPUART_CTS_B_SELECT_INPUT.
static const field_t hw_iomuxc0_lpuart0_ipp_ind_lpuart_cts_b_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPUART0_IPP_IND_LPUART_RXD_SELECT_INPUT.
static const field_t hw_iomuxc0_lpuart0_ipp_ind_lpuart_rxd_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPUART0_IPP_IND_LPUART_TXD_SELECT_INPUT.
static const field_t hw_iomuxc0_lpuart0_ipp_ind_lpuart_txd_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPUART1_IPP_IND_LPUART_CTS_B_SELECT_INPUT.
static const field_t hw_iomuxc0_lpuart1_ipp_ind_lpuart_cts_b_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPUART1_IPP_IND_LPUART_RXD_SELECT_INPUT.
static const field_t hw_iomuxc0_lpuart1_ipp_ind_lpuart_rxd_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPUART1_IPP_IND_LPUART_TXD_SELECT_INPUT.
static const field_t hw_iomuxc0_lpuart1_ipp_ind_lpuart_txd_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPUART2_IPP_IND_LPUART_CTS_B_SELECT_INPUT.
static const field_t hw_iomuxc0_lpuart2_ipp_ind_lpuart_cts_b_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPUART2_IPP_IND_LPUART_RXD_SELECT_INPUT.
static const field_t hw_iomuxc0_lpuart2_ipp_ind_lpuart_rxd_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPUART2_IPP_IND_LPUART_TXD_SELECT_INPUT.
static const field_t hw_iomuxc0_lpuart2_ipp_ind_lpuart_txd_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPUART3_IPP_IND_LPUART_CTS_B_SELECT_INPUT.
static const field_t hw_iomuxc0_lpuart3_ipp_ind_lpuart_cts_b_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPUART3_IPP_IND_LPUART_RXD_SELECT_INPUT.
static const field_t hw_iomuxc0_lpuart3_ipp_ind_lpuart_rxd_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_LPUART3_IPP_IND_LPUART_TXD_SELECT_INPUT.
static const field_t hw_iomuxc0_lpuart3_ipp_ind_lpuart_txd_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_D_IP_EWM_SYN_EWM_IN_SELECT_INPUT.
static const field_t hw_iomuxc0_d_ip_ewm_syn_ewm_in_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC0_SW_MUX_CTL_PAD_RESET0_b.
static const field_t hw_iomuxc0_sw_mux_ctl_pad_reset0_b[] =
{
    {
        "PS",
        "Select one out of next values for pad: RESET0_b",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: RESET0_b",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: RESET0_b",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: RESET0_b",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: RESET0_b",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a IOMUXC0 module.
static const reg_t hw_iomuxc0[] =
{
    {
        "SW_MUX_CTL_PAD_PTA0",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta0
    },
    {
        "SW_MUX_CTL_PAD_PTA1",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta1
    },
    {
        "SW_MUX_CTL_PAD_PTA2",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta2
    },
    {
        "SW_MUX_CTL_PAD_PTA3",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta3
    },
    {
        "SW_MUX_CTL_PAD_PTA4",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta4
    },
    {
        "SW_MUX_CTL_PAD_PTA5",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta5
    },
    {
        "SW_MUX_CTL_PAD_PTA6",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta6
    },
    {
        "SW_MUX_CTL_PAD_PTA7",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta7
    },
    {
        "SW_MUX_CTL_PAD_PTA8",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta8
    },
    {
        "SW_MUX_CTL_PAD_PTA9",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta9
    },
    {
        "SW_MUX_CTL_PAD_PTA10",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta10
    },
    {
        "SW_MUX_CTL_PAD_PTA11",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta11
    },
    {
        "SW_MUX_CTL_PAD_PTA12",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta12
    },
    {
        "SW_MUX_CTL_PAD_PTA13",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta13
    },
    {
        "SW_MUX_CTL_PAD_PTA14",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta14
    },
    {
        "SW_MUX_CTL_PAD_PTA15",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta15
    },
    {
        "SW_MUX_CTL_PAD_PTA16",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta16
    },
    {
        "SW_MUX_CTL_PAD_PTA17",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta17
    },
    {
        "SW_MUX_CTL_PAD_PTA18",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta18
    },
    {
        "SW_MUX_CTL_PAD_PTA19",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta19
    },
    {
        "SW_MUX_CTL_PAD_PTA20",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta20
    },
    {
        "SW_MUX_CTL_PAD_PTA21",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta21
    },
    {
        "SW_MUX_CTL_PAD_PTA22",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta22
    },
    {
        "SW_MUX_CTL_PAD_PTA23",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta23
    },
    {
        "SW_MUX_CTL_PAD_PTA24",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta24
    },
    {
        "SW_MUX_CTL_PAD_PTA25",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta25
    },
    {
        "SW_MUX_CTL_PAD_PTA26",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta26
    },
    {
        "SW_MUX_CTL_PAD_PTA27",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta27
    },
    {
        "SW_MUX_CTL_PAD_PTA28",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta28
    },
    {
        "SW_MUX_CTL_PAD_PTA29",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta29
    },
    {
        "SW_MUX_CTL_PAD_PTA30",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta30
    },
    {
        "SW_MUX_CTL_PAD_PTA31",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_pta31
    },
    {
        "SW_MUX_CTL_PAD_PTB0",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb0
    },
    {
        "SW_MUX_CTL_PAD_PTB1",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb1
    },
    {
        "SW_MUX_CTL_PAD_PTB2",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb2
    },
    {
        "SW_MUX_CTL_PAD_PTB3",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb3
    },
    {
        "SW_MUX_CTL_PAD_PTB4",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb4
    },
    {
        "SW_MUX_CTL_PAD_PTB5",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb5
    },
    {
        "SW_MUX_CTL_PAD_PTB6",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb6
    },
    {
        "SW_MUX_CTL_PAD_PTB7",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb7
    },
    {
        "SW_MUX_CTL_PAD_PTB8",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb8
    },
    {
        "SW_MUX_CTL_PAD_PTB9",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb9
    },
    {
        "SW_MUX_CTL_PAD_PTB10",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb10
    },
    {
        "SW_MUX_CTL_PAD_PTB11",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb11
    },
    {
        "SW_MUX_CTL_PAD_PTB12",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb12
    },
    {
        "SW_MUX_CTL_PAD_PTB13",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb13
    },
    {
        "SW_MUX_CTL_PAD_PTB14",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb14
    },
    {
        "SW_MUX_CTL_PAD_PTB15",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000bc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb15
    },
    {
        "SW_MUX_CTL_PAD_PTB16",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb16
    },
    {
        "SW_MUX_CTL_PAD_PTB17",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb17
    },
    {
        "SW_MUX_CTL_PAD_PTB18",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb18
    },
    {
        "SW_MUX_CTL_PAD_PTB19",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_ptb19
    },
    {
        "LPSPI0_IPP_IND_LPSPI_PCS0_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpspi0_ipp_ind_lpspi_pcs0_select_input
    },
    {
        "LPSPI0_IPP_IND_LPSPI_PCS1_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpspi0_ipp_ind_lpspi_pcs1_select_input
    },
    {
        "LPSPI0_IPP_IND_LPSPI_PCS2_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpspi0_ipp_ind_lpspi_pcs2_select_input
    },
    {
        "LPSPI0_IPP_IND_LPSPI_PCS3_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpspi0_ipp_ind_lpspi_pcs3_select_input
    },
    {
        "LPSPI0_IPP_IND_LPSPI_SCK_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpspi0_ipp_ind_lpspi_sck_select_input
    },
    {
        "LPSPI0_IPP_IND_LPSPI_SDI_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpspi0_ipp_ind_lpspi_sdi_select_input
    },
    {
        "LPSPI0_IPP_IND_LPSPI_SDO_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpspi0_ipp_ind_lpspi_sdo_select_input
    },
    {
        "LPSPI1_IPP_IND_LPSPI_PCS0_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpspi1_ipp_ind_lpspi_pcs0_select_input
    },
    {
        "LPSPI1_IPP_IND_LPSPI_PCS1_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpspi1_ipp_ind_lpspi_pcs1_select_input
    },
    {
        "LPSPI1_IPP_IND_LPSPI_PCS2_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpspi1_ipp_ind_lpspi_pcs2_select_input
    },
    {
        "LPSPI1_IPP_IND_LPSPI_PCS3_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpspi1_ipp_ind_lpspi_pcs3_select_input
    },
    {
        "LPSPI1_IPP_IND_LPSPI_SCK_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpspi1_ipp_ind_lpspi_sck_select_input
    },
    {
        "LPSPI1_IPP_IND_LPSPI_SDI_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpspi1_ipp_ind_lpspi_sdi_select_input
    },
    {
        "LPSPI1_IPP_IND_LPSPI_SDO_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpspi1_ipp_ind_lpspi_sdo_select_input
    },
    {
        "LPTPM0_IPP_IND_LPTPM_CH0_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm0_ipp_ind_lptpm_ch0_select_input
    },
    {
        "LPTPM0_IPP_IND_LPTPM_CH1_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm0_ipp_ind_lptpm_ch1_select_input
    },
    {
        "LPTPM0_IPP_IND_LPTPM_CH2_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm0_ipp_ind_lptpm_ch2_select_input
    },
    {
        "LPTPM0_IPP_IND_LPTPM_CH3_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm0_ipp_ind_lptpm_ch3_select_input
    },
    {
        "LPTPM0_IPP_IND_LPTPM_CH4_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm0_ipp_ind_lptpm_ch4_select_input
    },
    {
        "LPTPM0_IPP_IND_LPTPM_CH5_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm0_ipp_ind_lptpm_ch5_select_input
    },
    {
        "LPTPM1_IPP_IND_LPTPM_CH0_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm1_ipp_ind_lptpm_ch0_select_input
    },
    {
        "LPTPM1_IPP_IND_LPTPM_CH1_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm1_ipp_ind_lptpm_ch1_select_input
    },
    {
        "LPTPM2_IPP_IND_LPTPM_CH0_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm2_ipp_ind_lptpm_ch0_select_input
    },
    {
        "LPTPM2_IPP_IND_LPTPM_CH1_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm2_ipp_ind_lptpm_ch1_select_input
    },
    {
        "LPTPM3_IPP_IND_LPTPM_CH0_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm3_ipp_ind_lptpm_ch0_select_input
    },
    {
        "LPTPM3_IPP_IND_LPTPM_CH1_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm3_ipp_ind_lptpm_ch1_select_input
    },
    {
        "LPTPM3_IPP_IND_LPTPM_CH2_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm3_ipp_ind_lptpm_ch2_select_input
    },
    {
        "LPTPM3_IPP_IND_LPTPM_CH3_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm3_ipp_ind_lptpm_ch3_select_input
    },
    {
        "LPTPM3_IPP_IND_LPTPM_CH4_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm3_ipp_ind_lptpm_ch4_select_input
    },
    {
        "LPTPM3_IPP_IND_LPTPM_CH5_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm3_ipp_ind_lptpm_ch5_select_input
    },
    {
        "LPI2C0_IPP_IND_LPI2C_HREQ_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpi2c0_ipp_ind_lpi2c_hreq_select_input
    },
    {
        "LPI2C0_IPP_IND_LPI2C_SCL_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpi2c0_ipp_ind_lpi2c_scl_select_input
    },
    {
        "LPI2C0_IPP_IND_LPI2C_SDA_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpi2c0_ipp_ind_lpi2c_sda_select_input
    },
    {
        "LPI2C1_IPP_IND_LPI2C_HREQ_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpi2c1_ipp_ind_lpi2c_hreq_select_input
    },
    {
        "LPI2C1_IPP_IND_LPI2C_SCL_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000188, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpi2c1_ipp_ind_lpi2c_scl_select_input
    },
    {
        "LPI2C1_IPP_IND_LPI2C_SDA_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000018c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpi2c1_ipp_ind_lpi2c_sda_select_input
    },
    {
        "LPI2C2_IPP_IND_LPI2C_HREQ_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpi2c2_ipp_ind_lpi2c_hreq_select_input
    },
    {
        "LPI2C2_IPP_IND_LPI2C_SCL_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000194, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpi2c2_ipp_ind_lpi2c_scl_select_input
    },
    {
        "LPI2C2_IPP_IND_LPI2C_SDA_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000198, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpi2c2_ipp_ind_lpi2c_sda_select_input
    },
    {
        "LPI2C3_IPP_IND_LPI2C_HREQ_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000019c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpi2c3_ipp_ind_lpi2c_hreq_select_input
    },
    {
        "LPI2C3_IPP_IND_LPI2C_SCL_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpi2c3_ipp_ind_lpi2c_scl_select_input
    },
    {
        "LPI2C3_IPP_IND_LPI2C_SDA_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpi2c3_ipp_ind_lpi2c_sda_select_input
    },
    {
        "LPTPM0_IPP_IND_LPTPM_CLK_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm0_ipp_ind_lptpm_clk_select_input
    },
    {
        "LPTPM1_IPP_IND_LPTPM_CLK_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm1_ipp_ind_lptpm_clk_select_input
    },
    {
        "LPTPM3_IPP_IND_LPTPM_CLK_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm3_ipp_ind_lptpm_clk_select_input
    },
    {
        "PCC_AIPS0_IPP_IND_EXTCLK55_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_pcc_aips0_ipp_ind_extclk55_select_input
    },
    {
        "SAI0_IPP_IND_SAI_RXBCLK_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001b8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_sai0_ipp_ind_sai_rxbclk_select_input
    },
    {
        "SAI0_IPP_IND_SAI_RXSYNC_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_sai0_ipp_ind_sai_rxsync_select_input
    },
    {
        "SAI0_IPP_IND_SAI_TXBCLK_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_sai0_ipp_ind_sai_txbclk_select_input
    },
    {
        "SAI0_IPP_IND_SAI_TXSYNC_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001c4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_sai0_ipp_ind_sai_txsync_select_input
    },
    {
        "PCC_AIPS1_IPP_IND_EXTCLK42_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001c8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_pcc_aips1_ipp_ind_extclk42_select_input
    },
    {
        "SAI1_IPP_IND_SAI_RXBCLK_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001cc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_sai1_ipp_ind_sai_rxbclk_select_input
    },
    {
        "SAI1_IPP_IND_SAI_RXSYNC_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_sai1_ipp_ind_sai_rxsync_select_input
    },
    {
        "SAI1_IPP_IND_SAI_TXBCLK_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001d4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_sai1_ipp_ind_sai_txbclk_select_input
    },
    {
        "SAI1_IPP_IND_SAI_TXSYNC_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001d8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_sai1_ipp_ind_sai_txsync_select_input
    },
    {
        "SAI0_IPP_IND_SAI_RXDATA0_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001dc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_sai0_ipp_ind_sai_rxdata0_select_input
    },
    {
        "SAI0_IPP_IND_SAI_RXDATA1_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_sai0_ipp_ind_sai_rxdata1_select_input
    },
    {
        "SAI1_IPP_IND_SAI_RXDATA0_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001e4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_sai1_ipp_ind_sai_rxdata0_select_input
    },
    {
        "SAI1_IPP_IND_SAI_RXDATA1_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_sai1_ipp_ind_sai_rxdata1_select_input
    },
    {
        "SAI1_IPP_IND_SAI_RXDATA2_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_sai1_ipp_ind_sai_rxdata2_select_input
    },
    {
        "SAI1_IPP_IND_SAI_RXDATA3_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_sai1_ipp_ind_sai_rxdata3_select_input
    },
    {
        "LPTPM2_IPP_IND_LPTPM_CLK_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lptpm2_ipp_ind_lptpm_clk_select_input
    },
    {
        "LPUART0_IPP_IND_LPUART_CTS_B_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001f8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpuart0_ipp_ind_lpuart_cts_b_select_input
    },
    {
        "LPUART0_IPP_IND_LPUART_RXD_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000001fc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpuart0_ipp_ind_lpuart_rxd_select_input
    },
    {
        "LPUART0_IPP_IND_LPUART_TXD_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpuart0_ipp_ind_lpuart_txd_select_input
    },
    {
        "LPUART1_IPP_IND_LPUART_CTS_B_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpuart1_ipp_ind_lpuart_cts_b_select_input
    },
    {
        "LPUART1_IPP_IND_LPUART_RXD_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpuart1_ipp_ind_lpuart_rxd_select_input
    },
    {
        "LPUART1_IPP_IND_LPUART_TXD_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpuart1_ipp_ind_lpuart_txd_select_input
    },
    {
        "LPUART2_IPP_IND_LPUART_CTS_B_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpuart2_ipp_ind_lpuart_cts_b_select_input
    },
    {
        "LPUART2_IPP_IND_LPUART_RXD_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpuart2_ipp_ind_lpuart_rxd_select_input
    },
    {
        "LPUART2_IPP_IND_LPUART_TXD_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpuart2_ipp_ind_lpuart_txd_select_input
    },
    {
        "LPUART3_IPP_IND_LPUART_CTS_B_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpuart3_ipp_ind_lpuart_cts_b_select_input
    },
    {
        "LPUART3_IPP_IND_LPUART_RXD_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpuart3_ipp_ind_lpuart_rxd_select_input
    },
    {
        "LPUART3_IPP_IND_LPUART_TXD_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_lpuart3_ipp_ind_lpuart_txd_select_input
    },
    {
        "D_IP_EWM_SYN_EWM_IN_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc0_d_ip_ewm_syn_ewm_in_select_input
    },
    {
        "SW_MUX_CTL_PAD_RESET0_b",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000294, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_iomuxc0_sw_mux_ctl_pad_reset0_b
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark IOMUXC1
#endif

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC0.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc0[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC1.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc1[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC2.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc2[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC3.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc3[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC4.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc4[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC5.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc5[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC6.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc6[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC7.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc7[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC8.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc8[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC9.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc9[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC10.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc10[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC11.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc11[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC12.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc12[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC13.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc13[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC14.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc14[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC15.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc15[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC16.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc16[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC17.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc17[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC18.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc18[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTC19.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptc19[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED0.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved0[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED1.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved1[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED2.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved2[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED3.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved3[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED4.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved4[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED5.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved5[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED6.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved6[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED7.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved7[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED8.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved8[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED9.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved9[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED10.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved10[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED11.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved11[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTD0.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptd0[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTD1.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptd1[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTD2.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptd2[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTD3.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptd3[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTD4.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptd4[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTD5.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptd5[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTD6.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptd6[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTD7.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptd7[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTD8.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptd8[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTD9.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptd9[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTD10.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptd10[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTD11.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptd11[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED12.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved12[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED13.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved13[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED14.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved14[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED15.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved15[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED16.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved16[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED17.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved17[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED18.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved18[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED19.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved19[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED20.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved20[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED21.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved21[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED22.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved22[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED23.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved23[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED24.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved24[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED25.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved25[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED26.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved26[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED27.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved27[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED28.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved28[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED29.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved29[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED30.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved30[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED31.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved31[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTE0.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_pte0[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTE1.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_pte1[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTE2.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_pte2[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTE3.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_pte3[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTE4.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_pte4[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTE5.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_pte5[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTE6.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_pte6[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTE7.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_pte7[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTE8.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_pte8[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTE9.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_pte9[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTE10.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_pte10[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTE11.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_pte11[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTE12.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_pte12[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTE13.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_pte13[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTE14.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_pte14[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTE15.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_pte15[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED32.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved32[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED33.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved33[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED34.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved34[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED35.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved35[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED36.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved36[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED37.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved37[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED38.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved38[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED39.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved39[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED40.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved40[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED41.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved41[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED42.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved42[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED43.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved43[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED44.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved44[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED45.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved45[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED46.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved46[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESERVED47.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reserved47[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF0.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf0[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF1.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf1[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF2.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf2[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF3.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf3[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF4.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf4[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF5.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf5[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF6.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf6[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF7.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf7[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF8.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf8[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF9.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf9[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF10.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf10[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF11.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf11[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF12.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf12[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF13.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf13[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF14.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf14[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF15.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf15[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF16.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf16[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF17.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf17[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF18.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf18[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_PTF19.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_ptf19[] =
{
    {
        "PS",
        "Select one out of next values for pad: PTC0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: PADn",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: PADn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: PADn",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: PADn",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_MODE",
        "Selects one of the maximum sixteen modes available for any pad.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBE",
        "Select one out of next values for pad: PADn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBE",
        "Select one out of next values for pad: PADn",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_USDHC1_IPP_WP_ON_SELECT_INPUT.
static const field_t hw_iomuxc1_usdhc1_ipp_wp_on_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO0_SELECT_INPUT.
static const field_t hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio0_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO1_SELECT_INPUT.
static const field_t hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio1_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO2_SELECT_INPUT.
static const field_t hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio2_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO3_SELECT_INPUT.
static const field_t hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio3_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO4_SELECT_INPUT.
static const field_t hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio4_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO5_SELECT_INPUT.
static const field_t hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio5_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO6_SELECT_INPUT.
static const field_t hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio6_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO7_SELECT_INPUT.
static const field_t hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio7_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO8_SELECT_INPUT.
static const field_t hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio8_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO9_SELECT_INPUT.
static const field_t hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio9_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO10_SELECT_INPUT.
static const field_t hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio10_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO11_SELECT_INPUT.
static const field_t hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio11_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO12_SELECT_INPUT.
static const field_t hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio12_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO13_SELECT_INPUT.
static const field_t hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio13_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO14_SELECT_INPUT.
static const field_t hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio14_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO15_SELECT_INPUT.
static const field_t hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio15_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPUART4_IPP_IND_LPUART_CTS_B_SELECT_INPUT.
static const field_t hw_iomuxc1_lpuart4_ipp_ind_lpuart_cts_b_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPUART4_IPP_IND_LPUART_RXD_SELECT_INPUT.
static const field_t hw_iomuxc1_lpuart4_ipp_ind_lpuart_rxd_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPUART4_IPP_IND_LPUART_TXD_SELECT_INPUT.
static const field_t hw_iomuxc1_lpuart4_ipp_ind_lpuart_txd_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPUART5_IPP_IND_LPUART_CTS_B_SELECT_INPUT.
static const field_t hw_iomuxc1_lpuart5_ipp_ind_lpuart_cts_b_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPUART5_IPP_IND_LPUART_RXD_SELECT_INPUT.
static const field_t hw_iomuxc1_lpuart5_ipp_ind_lpuart_rxd_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPUART5_IPP_IND_LPUART_TXD_SELECT_INPUT.
static const field_t hw_iomuxc1_lpuart5_ipp_ind_lpuart_txd_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPUART6_IPP_IND_LPUART_CTS_B_SELECT_INPUT.
static const field_t hw_iomuxc1_lpuart6_ipp_ind_lpuart_cts_b_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPUART6_IPP_IND_LPUART_RXD_SELECT_INPUT.
static const field_t hw_iomuxc1_lpuart6_ipp_ind_lpuart_rxd_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPUART6_IPP_IND_LPUART_TXD_SELECT_INPUT.
static const field_t hw_iomuxc1_lpuart6_ipp_ind_lpuart_txd_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPUART7_IPP_IND_LPUART_CTS_B_SELECT_INPUT.
static const field_t hw_iomuxc1_lpuart7_ipp_ind_lpuart_cts_b_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPUART7_IPP_IND_LPUART_RXD_SELECT_INPUT.
static const field_t hw_iomuxc1_lpuart7_ipp_ind_lpuart_rxd_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPUART7_IPP_IND_LPUART_TXD_SELECT_INPUT.
static const field_t hw_iomuxc1_lpuart7_ipp_ind_lpuart_txd_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPI2C4_IPP_IND_LPI2C_HREQ_SELECT_INPUT.
static const field_t hw_iomuxc1_lpi2c4_ipp_ind_lpi2c_hreq_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPI2C4_IPP_IND_LPI2C_SCL_SELECT_INPUT.
static const field_t hw_iomuxc1_lpi2c4_ipp_ind_lpi2c_scl_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPI2C4_IPP_IND_LPI2C_SDA_SELECT_INPUT.
static const field_t hw_iomuxc1_lpi2c4_ipp_ind_lpi2c_sda_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM4_IPP_IND_LPTPM_CH0_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm4_ipp_ind_lptpm_ch0_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM4_IPP_IND_LPTPM_CH1_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm4_ipp_ind_lptpm_ch1_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM4_IPP_IND_LPTPM_CH2_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm4_ipp_ind_lptpm_ch2_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM4_IPP_IND_LPTPM_CH3_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm4_ipp_ind_lptpm_ch3_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM4_IPP_IND_LPTPM_CH4_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm4_ipp_ind_lptpm_ch4_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM4_IPP_IND_LPTPM_CH5_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm4_ipp_ind_lptpm_ch5_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM4_IPP_IND_LPTPM_CLK_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm4_ipp_ind_lptpm_clk_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPSPI2_IPP_IND_LPSPI_PCS0_SELECT_INPUT.
static const field_t hw_iomuxc1_lpspi2_ipp_ind_lpspi_pcs0_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPSPI2_IPP_IND_LPSPI_PCS1_SELECT_INPUT.
static const field_t hw_iomuxc1_lpspi2_ipp_ind_lpspi_pcs1_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPSPI2_IPP_IND_LPSPI_PCS2_SELECT_INPUT.
static const field_t hw_iomuxc1_lpspi2_ipp_ind_lpspi_pcs2_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPSPI2_IPP_IND_LPSPI_PCS3_SELECT_INPUT.
static const field_t hw_iomuxc1_lpspi2_ipp_ind_lpspi_pcs3_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPSPI2_IPP_IND_LPSPI_SCK_SELECT_INPUT.
static const field_t hw_iomuxc1_lpspi2_ipp_ind_lpspi_sck_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPSPI2_IPP_IND_LPSPI_SDI_SELECT_INPUT.
static const field_t hw_iomuxc1_lpspi2_ipp_ind_lpspi_sdi_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPSPI2_IPP_IND_LPSPI_SDO_SELECT_INPUT.
static const field_t hw_iomuxc1_lpspi2_ipp_ind_lpspi_sdo_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPI2C5_IPP_IND_LPI2C_HREQ_SELECT_INPUT.
static const field_t hw_iomuxc1_lpi2c5_ipp_ind_lpi2c_hreq_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPI2C5_IPP_IND_LPI2C_SCL_SELECT_INPUT.
static const field_t hw_iomuxc1_lpi2c5_ipp_ind_lpi2c_scl_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPI2C5_IPP_IND_LPI2C_SDA_SELECT_INPUT.
static const field_t hw_iomuxc1_lpi2c5_ipp_ind_lpi2c_sda_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM5_IPP_IND_LPTPM_CH0_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm5_ipp_ind_lptpm_ch0_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM5_IPP_IND_LPTPM_CH1_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm5_ipp_ind_lptpm_ch1_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM5_IPP_IND_LPTPM_CLK_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm5_ipp_ind_lptpm_clk_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM6_IPP_IND_LPTPM_CH0_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm6_ipp_ind_lptpm_ch0_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM6_IPP_IND_LPTPM_CH1_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm6_ipp_ind_lptpm_ch1_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM6_IPP_IND_LPTPM_CLK_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm6_ipp_ind_lptpm_clk_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM7_IPP_IND_LPTPM_CH0_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm7_ipp_ind_lptpm_ch0_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM7_IPP_IND_LPTPM_CH1_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm7_ipp_ind_lptpm_ch1_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM7_IPP_IND_LPTPM_CH2_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm7_ipp_ind_lptpm_ch2_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM7_IPP_IND_LPTPM_CH3_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm7_ipp_ind_lptpm_ch3_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM7_IPP_IND_LPTPM_CH4_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm7_ipp_ind_lptpm_ch4_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM7_IPP_IND_LPTPM_CH5_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm7_ipp_ind_lptpm_ch5_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPTPM7_IPP_IND_LPTPM_CLK_SELECT_INPUT.
static const field_t hw_iomuxc1_lptpm7_ipp_ind_lptpm_clk_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPI2C6_IPP_IND_LPI2C_HREQ_SELECT_INPUT.
static const field_t hw_iomuxc1_lpi2c6_ipp_ind_lpi2c_hreq_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPI2C6_IPP_IND_LPI2C_SCL_SELECT_INPUT.
static const field_t hw_iomuxc1_lpi2c6_ipp_ind_lpi2c_scl_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPI2C6_IPP_IND_LPI2C_SDA_SELECT_INPUT.
static const field_t hw_iomuxc1_lpi2c6_ipp_ind_lpi2c_sda_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPI2C7_IPP_IND_LPI2C_HREQ_SELECT_INPUT.
static const field_t hw_iomuxc1_lpi2c7_ipp_ind_lpi2c_hreq_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPI2C7_IPP_IND_LPI2C_SCL_SELECT_INPUT.
static const field_t hw_iomuxc1_lpi2c7_ipp_ind_lpi2c_scl_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPI2C7_IPP_IND_LPI2C_SDA_SELECT_INPUT.
static const field_t hw_iomuxc1_lpi2c7_ipp_ind_lpi2c_sda_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPSPI3_IPP_IND_LPSPI_PCS0_SELECT_INPUT.
static const field_t hw_iomuxc1_lpspi3_ipp_ind_lpspi_pcs0_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPSPI3_IPP_IND_LPSPI_PCS1_SELECT_INPUT.
static const field_t hw_iomuxc1_lpspi3_ipp_ind_lpspi_pcs1_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPSPI3_IPP_IND_LPSPI_PCS2_SELECT_INPUT.
static const field_t hw_iomuxc1_lpspi3_ipp_ind_lpspi_pcs2_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPSPI3_IPP_IND_LPSPI_PCS3_SELECT_INPUT.
static const field_t hw_iomuxc1_lpspi3_ipp_ind_lpspi_pcs3_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPSPI3_IPP_IND_LPSPI_SCK_SELECT_INPUT.
static const field_t hw_iomuxc1_lpspi3_ipp_ind_lpspi_sck_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPSPI3_IPP_IND_LPSPI_SDI_SELECT_INPUT.
static const field_t hw_iomuxc1_lpspi3_ipp_ind_lpspi_sdi_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_LPSPI3_IPP_IND_LPSPI_SDO_SELECT_INPUT.
static const field_t hw_iomuxc1_lpspi3_ipp_ind_lpspi_sdo_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_USDHC1_IPP_CARD_DET_SELECT_INPUT.
static const field_t hw_iomuxc1_usdhc1_ipp_card_det_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_USBO2_ULP1_IPP_IND_OTG_OC_SELECT_INPUT.
static const field_t hw_iomuxc1_usbo2_ulp1_ipp_ind_otg_oc_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_USBO2_ULP1_IPP_IND_OTG2_OC_SELECT_INPUT.
static const field_t hw_iomuxc1_usbo2_ulp1_ipp_ind_otg2_oc_select_input[] =
{
    {
        "DAISY",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERSION",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_SW_MUX_CTL_PAD_RESET1_b.
static const field_t hw_iomuxc1_sw_mux_ctl_pad_reset1_b[] =
{
    {
        "PS",
        "Select one out of next values for pad: RESET1_b",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Select one out of next values for pad: RESET1_b",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "Select one out of next values for pad: RESET1_b",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: RESET1_b",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: RESET1_b",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "When enabled, prevents writes to fields: PS, PE, SRE, ODE, DSE, MUX_MO"
        "DE and LK.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a IOMUXC1 module.
static const reg_t hw_iomuxc1[] =
{
    {
        "SW_MUX_CTL_PAD_PTC0",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc0
    },
    {
        "SW_MUX_CTL_PAD_PTC1",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc1
    },
    {
        "SW_MUX_CTL_PAD_PTC2",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc2
    },
    {
        "SW_MUX_CTL_PAD_PTC3",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc3
    },
    {
        "SW_MUX_CTL_PAD_PTC4",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc4
    },
    {
        "SW_MUX_CTL_PAD_PTC5",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc5
    },
    {
        "SW_MUX_CTL_PAD_PTC6",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc6
    },
    {
        "SW_MUX_CTL_PAD_PTC7",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc7
    },
    {
        "SW_MUX_CTL_PAD_PTC8",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc8
    },
    {
        "SW_MUX_CTL_PAD_PTC9",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc9
    },
    {
        "SW_MUX_CTL_PAD_PTC10",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc10
    },
    {
        "SW_MUX_CTL_PAD_PTC11",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc11
    },
    {
        "SW_MUX_CTL_PAD_PTC12",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc12
    },
    {
        "SW_MUX_CTL_PAD_PTC13",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc13
    },
    {
        "SW_MUX_CTL_PAD_PTC14",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc14
    },
    {
        "SW_MUX_CTL_PAD_PTC15",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc15
    },
    {
        "SW_MUX_CTL_PAD_PTC16",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc16
    },
    {
        "SW_MUX_CTL_PAD_PTC17",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc17
    },
    {
        "SW_MUX_CTL_PAD_PTC18",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc18
    },
    {
        "SW_MUX_CTL_PAD_PTC19",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptc19
    },
    {
        "SW_MUX_CTL_PAD_RESERVED0",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved0
    },
    {
        "SW_MUX_CTL_PAD_RESERVED1",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved1
    },
    {
        "SW_MUX_CTL_PAD_RESERVED2",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved2
    },
    {
        "SW_MUX_CTL_PAD_RESERVED3",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved3
    },
    {
        "SW_MUX_CTL_PAD_RESERVED4",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved4
    },
    {
        "SW_MUX_CTL_PAD_RESERVED5",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved5
    },
    {
        "SW_MUX_CTL_PAD_RESERVED6",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved6
    },
    {
        "SW_MUX_CTL_PAD_RESERVED7",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved7
    },
    {
        "SW_MUX_CTL_PAD_RESERVED8",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved8
    },
    {
        "SW_MUX_CTL_PAD_RESERVED9",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved9
    },
    {
        "SW_MUX_CTL_PAD_RESERVED10",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved10
    },
    {
        "SW_MUX_CTL_PAD_RESERVED11",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved11
    },
    {
        "SW_MUX_CTL_PAD_PTD0",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptd0
    },
    {
        "SW_MUX_CTL_PAD_PTD1",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptd1
    },
    {
        "SW_MUX_CTL_PAD_PTD2",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptd2
    },
    {
        "SW_MUX_CTL_PAD_PTD3",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptd3
    },
    {
        "SW_MUX_CTL_PAD_PTD4",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptd4
    },
    {
        "SW_MUX_CTL_PAD_PTD5",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptd5
    },
    {
        "SW_MUX_CTL_PAD_PTD6",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptd6
    },
    {
        "SW_MUX_CTL_PAD_PTD7",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptd7
    },
    {
        "SW_MUX_CTL_PAD_PTD8",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptd8
    },
    {
        "SW_MUX_CTL_PAD_PTD9",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptd9
    },
    {
        "SW_MUX_CTL_PAD_PTD10",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptd10
    },
    {
        "SW_MUX_CTL_PAD_PTD11",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptd11
    },
    {
        "SW_MUX_CTL_PAD_RESERVED12",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved12
    },
    {
        "SW_MUX_CTL_PAD_RESERVED13",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved13
    },
    {
        "SW_MUX_CTL_PAD_RESERVED14",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved14
    },
    {
        "SW_MUX_CTL_PAD_RESERVED15",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000bc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved15
    },
    {
        "SW_MUX_CTL_PAD_RESERVED16",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved16
    },
    {
        "SW_MUX_CTL_PAD_RESERVED17",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved17
    },
    {
        "SW_MUX_CTL_PAD_RESERVED18",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved18
    },
    {
        "SW_MUX_CTL_PAD_RESERVED19",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved19
    },
    {
        "SW_MUX_CTL_PAD_RESERVED20",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved20
    },
    {
        "SW_MUX_CTL_PAD_RESERVED21",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved21
    },
    {
        "SW_MUX_CTL_PAD_RESERVED22",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved22
    },
    {
        "SW_MUX_CTL_PAD_RESERVED23",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved23
    },
    {
        "SW_MUX_CTL_PAD_RESERVED24",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved24
    },
    {
        "SW_MUX_CTL_PAD_RESERVED25",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved25
    },
    {
        "SW_MUX_CTL_PAD_RESERVED26",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved26
    },
    {
        "SW_MUX_CTL_PAD_RESERVED27",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved27
    },
    {
        "SW_MUX_CTL_PAD_RESERVED28",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved28
    },
    {
        "SW_MUX_CTL_PAD_RESERVED29",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved29
    },
    {
        "SW_MUX_CTL_PAD_RESERVED30",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved30
    },
    {
        "SW_MUX_CTL_PAD_RESERVED31",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved31
    },
    {
        "SW_MUX_CTL_PAD_PTE0",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_pte0
    },
    {
        "SW_MUX_CTL_PAD_PTE1",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_pte1
    },
    {
        "SW_MUX_CTL_PAD_PTE2",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_pte2
    },
    {
        "SW_MUX_CTL_PAD_PTE3",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_pte3
    },
    {
        "SW_MUX_CTL_PAD_PTE4",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_pte4
    },
    {
        "SW_MUX_CTL_PAD_PTE5",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_pte5
    },
    {
        "SW_MUX_CTL_PAD_PTE6",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_pte6
    },
    {
        "SW_MUX_CTL_PAD_PTE7",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_pte7
    },
    {
        "SW_MUX_CTL_PAD_PTE8",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_pte8
    },
    {
        "SW_MUX_CTL_PAD_PTE9",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_pte9
    },
    {
        "SW_MUX_CTL_PAD_PTE10",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_pte10
    },
    {
        "SW_MUX_CTL_PAD_PTE11",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_pte11
    },
    {
        "SW_MUX_CTL_PAD_PTE12",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_pte12
    },
    {
        "SW_MUX_CTL_PAD_PTE13",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_pte13
    },
    {
        "SW_MUX_CTL_PAD_PTE14",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_pte14
    },
    {
        "SW_MUX_CTL_PAD_PTE15",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_pte15
    },
    {
        "SW_MUX_CTL_PAD_RESERVED32",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved32
    },
    {
        "SW_MUX_CTL_PAD_RESERVED33",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved33
    },
    {
        "SW_MUX_CTL_PAD_RESERVED34",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved34
    },
    {
        "SW_MUX_CTL_PAD_RESERVED35",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved35
    },
    {
        "SW_MUX_CTL_PAD_RESERVED36",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved36
    },
    {
        "SW_MUX_CTL_PAD_RESERVED37",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved37
    },
    {
        "SW_MUX_CTL_PAD_RESERVED38",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved38
    },
    {
        "SW_MUX_CTL_PAD_RESERVED39",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved39
    },
    {
        "SW_MUX_CTL_PAD_RESERVED40",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved40
    },
    {
        "SW_MUX_CTL_PAD_RESERVED41",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved41
    },
    {
        "SW_MUX_CTL_PAD_RESERVED42",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved42
    },
    {
        "SW_MUX_CTL_PAD_RESERVED43",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved43
    },
    {
        "SW_MUX_CTL_PAD_RESERVED44",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved44
    },
    {
        "SW_MUX_CTL_PAD_RESERVED45",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved45
    },
    {
        "SW_MUX_CTL_PAD_RESERVED46",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved46
    },
    {
        "SW_MUX_CTL_PAD_RESERVED47",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reserved47
    },
    {
        "SW_MUX_CTL_PAD_PTF0",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf0
    },
    {
        "SW_MUX_CTL_PAD_PTF1",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf1
    },
    {
        "SW_MUX_CTL_PAD_PTF2",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000188, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf2
    },
    {
        "SW_MUX_CTL_PAD_PTF3",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000018c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf3
    },
    {
        "SW_MUX_CTL_PAD_PTF4",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf4
    },
    {
        "SW_MUX_CTL_PAD_PTF5",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000194, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf5
    },
    {
        "SW_MUX_CTL_PAD_PTF6",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x00000198, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf6
    },
    {
        "SW_MUX_CTL_PAD_PTF7",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x0000019c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf7
    },
    {
        "SW_MUX_CTL_PAD_PTF8",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf8
    },
    {
        "SW_MUX_CTL_PAD_PTF9",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf9
    },
    {
        "SW_MUX_CTL_PAD_PTF10",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf10
    },
    {
        "SW_MUX_CTL_PAD_PTF11",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf11
    },
    {
        "SW_MUX_CTL_PAD_PTF12",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf12
    },
    {
        "SW_MUX_CTL_PAD_PTF13",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000001b4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf13
    },
    {
        "SW_MUX_CTL_PAD_PTF14",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000001b8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf14
    },
    {
        "SW_MUX_CTL_PAD_PTF15",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000001bc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf15
    },
    {
        "SW_MUX_CTL_PAD_PTF16",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf16
    },
    {
        "SW_MUX_CTL_PAD_PTF17",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000001c4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf17
    },
    {
        "SW_MUX_CTL_PAD_PTF18",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000001c8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf18
    },
    {
        "SW_MUX_CTL_PAD_PTF19",
        "This register is used to control the settings for a PAD (bit-wise deta"
        "ils given below) and select ALT modes using MUX_MODE bits.",
        4, // Width in bytes
        0x000001cc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_ptf19
    },
    {
        "USDHC1_IPP_WP_ON_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_usdhc1_ipp_wp_on_select_input
    },
    {
        "D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO0_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio0_select_input
    },
    {
        "D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO1_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio1_select_input
    },
    {
        "D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO2_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio2_select_input
    },
    {
        "D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO3_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio3_select_input
    },
    {
        "D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO4_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio4_select_input
    },
    {
        "D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO5_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio5_select_input
    },
    {
        "D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO6_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio6_select_input
    },
    {
        "D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO7_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio7_select_input
    },
    {
        "D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO8_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio8_select_input
    },
    {
        "D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO9_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio9_select_input
    },
    {
        "D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO10_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio10_select_input
    },
    {
        "D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO11_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio11_select_input
    },
    {
        "D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO12_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio12_select_input
    },
    {
        "D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO13_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio13_select_input
    },
    {
        "D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO14_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio14_select_input
    },
    {
        "D_IP_FLEXIO_SYN1_IPP_IND_FLEXIO15_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_d_ip_flexio_syn1_ipp_ind_flexio15_select_input
    },
    {
        "LPUART4_IPP_IND_LPUART_CTS_B_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpuart4_ipp_ind_lpuart_cts_b_select_input
    },
    {
        "LPUART4_IPP_IND_LPUART_RXD_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpuart4_ipp_ind_lpuart_rxd_select_input
    },
    {
        "LPUART4_IPP_IND_LPUART_TXD_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpuart4_ipp_ind_lpuart_txd_select_input
    },
    {
        "LPUART5_IPP_IND_LPUART_CTS_B_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpuart5_ipp_ind_lpuart_cts_b_select_input
    },
    {
        "LPUART5_IPP_IND_LPUART_RXD_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpuart5_ipp_ind_lpuart_rxd_select_input
    },
    {
        "LPUART5_IPP_IND_LPUART_TXD_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpuart5_ipp_ind_lpuart_txd_select_input
    },
    {
        "LPUART6_IPP_IND_LPUART_CTS_B_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpuart6_ipp_ind_lpuart_cts_b_select_input
    },
    {
        "LPUART6_IPP_IND_LPUART_RXD_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpuart6_ipp_ind_lpuart_rxd_select_input
    },
    {
        "LPUART6_IPP_IND_LPUART_TXD_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpuart6_ipp_ind_lpuart_txd_select_input
    },
    {
        "LPUART7_IPP_IND_LPUART_CTS_B_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpuart7_ipp_ind_lpuart_cts_b_select_input
    },
    {
        "LPUART7_IPP_IND_LPUART_RXD_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpuart7_ipp_ind_lpuart_rxd_select_input
    },
    {
        "LPUART7_IPP_IND_LPUART_TXD_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpuart7_ipp_ind_lpuart_txd_select_input
    },
    {
        "LPI2C4_IPP_IND_LPI2C_HREQ_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpi2c4_ipp_ind_lpi2c_hreq_select_input
    },
    {
        "LPI2C4_IPP_IND_LPI2C_SCL_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpi2c4_ipp_ind_lpi2c_scl_select_input
    },
    {
        "LPI2C4_IPP_IND_LPI2C_SDA_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000027c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpi2c4_ipp_ind_lpi2c_sda_select_input
    },
    {
        "LPTPM4_IPP_IND_LPTPM_CH0_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm4_ipp_ind_lptpm_ch0_select_input
    },
    {
        "LPTPM4_IPP_IND_LPTPM_CH1_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm4_ipp_ind_lptpm_ch1_select_input
    },
    {
        "LPTPM4_IPP_IND_LPTPM_CH2_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm4_ipp_ind_lptpm_ch2_select_input
    },
    {
        "LPTPM4_IPP_IND_LPTPM_CH3_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm4_ipp_ind_lptpm_ch3_select_input
    },
    {
        "LPTPM4_IPP_IND_LPTPM_CH4_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm4_ipp_ind_lptpm_ch4_select_input
    },
    {
        "LPTPM4_IPP_IND_LPTPM_CH5_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000294, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm4_ipp_ind_lptpm_ch5_select_input
    },
    {
        "LPTPM4_IPP_IND_LPTPM_CLK_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000298, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm4_ipp_ind_lptpm_clk_select_input
    },
    {
        "LPSPI2_IPP_IND_LPSPI_PCS0_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000029c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpspi2_ipp_ind_lpspi_pcs0_select_input
    },
    {
        "LPSPI2_IPP_IND_LPSPI_PCS1_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpspi2_ipp_ind_lpspi_pcs1_select_input
    },
    {
        "LPSPI2_IPP_IND_LPSPI_PCS2_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpspi2_ipp_ind_lpspi_pcs2_select_input
    },
    {
        "LPSPI2_IPP_IND_LPSPI_PCS3_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002a8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpspi2_ipp_ind_lpspi_pcs3_select_input
    },
    {
        "LPSPI2_IPP_IND_LPSPI_SCK_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002ac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpspi2_ipp_ind_lpspi_sck_select_input
    },
    {
        "LPSPI2_IPP_IND_LPSPI_SDI_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpspi2_ipp_ind_lpspi_sdi_select_input
    },
    {
        "LPSPI2_IPP_IND_LPSPI_SDO_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpspi2_ipp_ind_lpspi_sdo_select_input
    },
    {
        "LPI2C5_IPP_IND_LPI2C_HREQ_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002b8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpi2c5_ipp_ind_lpi2c_hreq_select_input
    },
    {
        "LPI2C5_IPP_IND_LPI2C_SCL_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpi2c5_ipp_ind_lpi2c_scl_select_input
    },
    {
        "LPI2C5_IPP_IND_LPI2C_SDA_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002c0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpi2c5_ipp_ind_lpi2c_sda_select_input
    },
    {
        "LPTPM5_IPP_IND_LPTPM_CH0_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002c4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm5_ipp_ind_lptpm_ch0_select_input
    },
    {
        "LPTPM5_IPP_IND_LPTPM_CH1_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002c8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm5_ipp_ind_lptpm_ch1_select_input
    },
    {
        "LPTPM5_IPP_IND_LPTPM_CLK_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002cc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm5_ipp_ind_lptpm_clk_select_input
    },
    {
        "LPTPM6_IPP_IND_LPTPM_CH0_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm6_ipp_ind_lptpm_ch0_select_input
    },
    {
        "LPTPM6_IPP_IND_LPTPM_CH1_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002d4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm6_ipp_ind_lptpm_ch1_select_input
    },
    {
        "LPTPM6_IPP_IND_LPTPM_CLK_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002d8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm6_ipp_ind_lptpm_clk_select_input
    },
    {
        "LPTPM7_IPP_IND_LPTPM_CH0_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002dc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm7_ipp_ind_lptpm_ch0_select_input
    },
    {
        "LPTPM7_IPP_IND_LPTPM_CH1_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm7_ipp_ind_lptpm_ch1_select_input
    },
    {
        "LPTPM7_IPP_IND_LPTPM_CH2_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002e4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm7_ipp_ind_lptpm_ch2_select_input
    },
    {
        "LPTPM7_IPP_IND_LPTPM_CH3_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm7_ipp_ind_lptpm_ch3_select_input
    },
    {
        "LPTPM7_IPP_IND_LPTPM_CH4_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm7_ipp_ind_lptpm_ch4_select_input
    },
    {
        "LPTPM7_IPP_IND_LPTPM_CH5_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002f0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm7_ipp_ind_lptpm_ch5_select_input
    },
    {
        "LPTPM7_IPP_IND_LPTPM_CLK_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lptpm7_ipp_ind_lptpm_clk_select_input
    },
    {
        "LPI2C6_IPP_IND_LPI2C_HREQ_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002f8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpi2c6_ipp_ind_lpi2c_hreq_select_input
    },
    {
        "LPI2C6_IPP_IND_LPI2C_SCL_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x000002fc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpi2c6_ipp_ind_lpi2c_scl_select_input
    },
    {
        "LPI2C6_IPP_IND_LPI2C_SDA_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpi2c6_ipp_ind_lpi2c_sda_select_input
    },
    {
        "LPI2C7_IPP_IND_LPI2C_HREQ_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000304, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpi2c7_ipp_ind_lpi2c_hreq_select_input
    },
    {
        "LPI2C7_IPP_IND_LPI2C_SCL_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000308, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpi2c7_ipp_ind_lpi2c_scl_select_input
    },
    {
        "LPI2C7_IPP_IND_LPI2C_SDA_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000030c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpi2c7_ipp_ind_lpi2c_sda_select_input
    },
    {
        "LPSPI3_IPP_IND_LPSPI_PCS0_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000310, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpspi3_ipp_ind_lpspi_pcs0_select_input
    },
    {
        "LPSPI3_IPP_IND_LPSPI_PCS1_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000314, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpspi3_ipp_ind_lpspi_pcs1_select_input
    },
    {
        "LPSPI3_IPP_IND_LPSPI_PCS2_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000318, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpspi3_ipp_ind_lpspi_pcs2_select_input
    },
    {
        "LPSPI3_IPP_IND_LPSPI_PCS3_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000031c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpspi3_ipp_ind_lpspi_pcs3_select_input
    },
    {
        "LPSPI3_IPP_IND_LPSPI_SCK_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpspi3_ipp_ind_lpspi_sck_select_input
    },
    {
        "LPSPI3_IPP_IND_LPSPI_SDI_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000324, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpspi3_ipp_ind_lpspi_sdi_select_input
    },
    {
        "LPSPI3_IPP_IND_LPSPI_SDO_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000328, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_lpspi3_ipp_ind_lpspi_sdo_select_input
    },
    {
        "USDHC1_IPP_CARD_DET_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x0000032c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_usdhc1_ipp_card_det_select_input
    },
    {
        "USBO2_ULP1_IPP_IND_OTG_OC_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000330, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_usbo2_ulp1_ipp_ind_otg_oc_select_input
    },
    {
        "USBO2_ULP1_IPP_IND_OTG2_OC_SELECT_INPUT",
        "This register is used to select a source pad for a specific module inp"
        "ut function.",
        4, // Width in bytes
        0x00000334, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_usbo2_ulp1_ipp_ind_otg2_oc_select_input
    },
    {
        "SW_MUX_CTL_PAD_RESET1_b",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000039c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_iomuxc1_sw_mux_ctl_pad_reset1_b
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark IOMUXC1_DDR
#endif

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ0.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq0[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ1.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq1[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ2.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq2[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ3.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq3[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ4.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq4[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ5.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq5[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ6.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq6[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ7.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq7[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ8.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq8[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ9.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq9[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ10.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq10[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ11.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq11[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ12.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq12[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ13.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq13[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ14.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq14[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ15.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq15[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ16.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq16[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ17.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq17[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ18.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq18[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ19.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq19[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ20.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq20[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ21.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq21[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ22.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq22[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ23.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq23[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ24.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq24[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ25.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq25[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ26.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq26[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ27.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq27[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ28.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq28[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ29.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq29[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ30.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq30[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQ31.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq31[] =
{
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQS0.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dqs0[] =
{
    {
        "PUE",
        "Select one out of next values for pad: DDR_DQSn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: DDR_DQSn",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: DDR_DQSn",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: DDR_DQSn",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRPOINT_TRIM",
        "Select one out of next values for pad: DDR_DQSn",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQSn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQS1.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dqs1[] =
{
    {
        "PUE",
        "Select one out of next values for pad: DDR_DQSn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: DDR_DQSn",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: DDR_DQSn",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: DDR_DQSn",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRPOINT_TRIM",
        "Select one out of next values for pad: DDR_DQSn",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQSn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQS2.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dqs2[] =
{
    {
        "PUE",
        "Select one out of next values for pad: DDR_DQSn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: DDR_DQSn",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: DDR_DQSn",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: DDR_DQSn",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRPOINT_TRIM",
        "Select one out of next values for pad: DDR_DQSn",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQSn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQS3.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dqs3[] =
{
    {
        "PUE",
        "Select one out of next values for pad: DDR_DQSn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: DDR_DQSn",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: DDR_DQSn",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: DDR_DQSn",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRPOINT_TRIM",
        "Select one out of next values for pad: DDR_DQSn",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQSn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQM0.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dqm0[] =
{
    {
        "DSE",
        "Select one out of next values for pad: DDR_DQM0",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DDR_DQM0",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQM0",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQM0",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_DQM0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_DQM0",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQM1.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dqm1[] =
{
    {
        "DSE",
        "Select one out of next values for pad: DDR_DQM0",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DDR_DQM0",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQM0",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQM0",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_DQM0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_DQM0",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQM2.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dqm2[] =
{
    {
        "DSE",
        "Select one out of next values for pad: DDR_DQM0",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DDR_DQM0",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQM0",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQM0",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_DQM0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_DQM0",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_DQM3.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dqm3[] =
{
    {
        "DSE",
        "Select one out of next values for pad: DDR_DQM0",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DDR_DQM0",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_DQM0",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_DQM0",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_DQM0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_DQM0",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_CA0.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca0[] =
{
    {
        "HYS",
        "Select one out of next values for pad: DDR_CAn",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_CAn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_CAn",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_CA1.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca1[] =
{
    {
        "HYS",
        "Select one out of next values for pad: DDR_CAn",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_CAn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_CAn",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_CA2.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca2[] =
{
    {
        "HYS",
        "Select one out of next values for pad: DDR_CAn",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_CAn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_CAn",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_CA3.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca3[] =
{
    {
        "HYS",
        "Select one out of next values for pad: DDR_CAn",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_CAn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_CAn",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_CA4.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca4[] =
{
    {
        "HYS",
        "Select one out of next values for pad: DDR_CAn",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_CAn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_CAn",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_CA5.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca5[] =
{
    {
        "HYS",
        "Select one out of next values for pad: DDR_CAn",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_CAn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_CAn",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_CA6.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca6[] =
{
    {
        "HYS",
        "Select one out of next values for pad: DDR_CAn",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_CAn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_CAn",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_CA7.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca7[] =
{
    {
        "HYS",
        "Select one out of next values for pad: DDR_CAn",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_CAn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_CAn",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_CA8.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca8[] =
{
    {
        "HYS",
        "Select one out of next values for pad: DDR_CAn",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_CAn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_CAn",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_CA9.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca9[] =
{
    {
        "HYS",
        "Select one out of next values for pad: DDR_CAn",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_CAn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_CAn",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_CS0_B.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_cs0_b[] =
{
    {
        "HYS",
        "Select one out of next values for pad: DDR_CAn",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_CAn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_CAn",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_CS1_B.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_cs1_b[] =
{
    {
        "HYS",
        "Select one out of next values for pad: DDR_CAn",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_CAn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_CAn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_CAn",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_CKE0.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_cke0[] =
{
    {
        "PUE",
        "Select one out of next values for pad: DDR_CKEn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: DDR_CKEn",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: DDR_CKEn",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DDR_CKEn",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_CKEn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_CKEn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_CKEn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_CKEn",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_CKE1.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_cke1[] =
{
    {
        "PUE",
        "Select one out of next values for pad: DDR_CKEn",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: DDR_CKEn",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: DDR_CKEn",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DDR_CKEn",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_CKEn",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_CKEn",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_CKEn",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_CKEn",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_CLK0.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_clk0[] =
{
    {
        "PUE",
        "Select one out of next values for pad: DDR_CLK0",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: DDR_CLK0",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: DDR_CLK0",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: DDR_CLK0",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DDR_CLK0",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRPOINT_TRIM",
        "Select one out of next values for pad: DDR_CLK0",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_CLK0",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_CLK0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_CLK0",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_ODT.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_odt[] =
{
    {
        "PUE",
        "Select one out of next values for pad: DDR_ODT",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: DDR_ODT",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: DDR_ODT",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: DDR_ODT",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DDR_ODT",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: DDR_ODT",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: DDR_ODT",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DDR_ODT",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: DDR_ODT",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_ZQ0.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_zq0[] =
{
    {
        "DDR_SELECT",
        "Select one out of next values for pad: DDR_ZQn",
        17, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_DDR_ZQ1.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_zq1[] =
{
    {
        "DDR_SELECT",
        "Select one out of next values for pad: DDR_ZQn",
        17, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_HSIC_DATA.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_hsic_data[] =
{
    {
        "PUE",
        "Select one out of next values for pad: HSIC_DATA",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: HSIC_DATA",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: HSIC_DATA",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: HSIC_DATA",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: HSIC_DATA",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: HSIC_DATA",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SELECT",
        "Select one out of next values for pad: HSIC_DATA",
        17, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: HSIC_DATA",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_PAD_HSIC_STROBE.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_pad_hsic_strobe[] =
{
    {
        "PUE",
        "Select one out of next values for pad: HSIC_STROBE",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: HSIC_STROBE",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: HSIC_STROBE",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: HSIC_STROBE",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCYCLE_TRIM",
        "Select one out of next values for pad: HSIC_STROBE",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TRIM",
        "Select one out of next values for pad: HSIC_STROBE",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SELECT",
        "Select one out of next values for pad: HSIC_STROBE",
        17, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_ODT",
        "Select one out of next values for pad: HSIC_STROBE",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_GRP_PUE.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_grp_pue[] =
{
    {
        "PUE",
        "Select one out of next values for group: PUE (Pads: DDR_CA0 DDR_CA1 DD"
        "R_CA2 DDR_CA3 DDR_CA4 DDR_CA5 DDR_CA6 DDR_CA7 DDR_CA8 DDR_CA9 DDR_CS0_"
        "B DDR_CS1_B DDR_DQM0 DDR_DQM1 DDR_DQM2 DDR_DQM3)",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_GRP_PUE_DAT.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_grp_pue_dat[] =
{
    {
        "PUE",
        "Select one out of next values for group: PUE_DAT (Pads: DDR_DQ0 DDR_DQ"
        "1 DDR_DQ10 DDR_DQ11 DDR_DQ12 DDR_DQ13 DDR_DQ14 DDR_DQ15 DDR_DQ16 DDR_D"
        "Q17 DDR_DQ18 DDR_DQ19 DDR_DQ2 DDR_DQ20 DDR_DQ21 DDR_DQ22 DDR_DQ23 DDR_"
        "DQ24 DDR_DQ25 DDR_DQ26 DDR_DQ27 DDR_DQ28 DDR_DQ29 DDR_DQ3 DDR_DQ30 DDR"
        "_DQ31 DDR_DQ4 DDR_DQ5 DDR_DQ6 DDR_DQ7 DDR_DQ8 DDR_DQ9)",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_GRP_PKE.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_grp_pke[] =
{
    {
        "PKE",
        "Select one out of next values for group: PKE (Pads: DDR_CA0 DDR_CA1 DD"
        "R_CA2 DDR_CA3 DDR_CA4 DDR_CA5 DDR_CA6 DDR_CA7 DDR_CA8 DDR_CA9 DDR_CS0_"
        "B DDR_CS1_B DDR_DQM0 DDR_DQM1 DDR_DQM2 DDR_DQM3)",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_GRP_PKE_DAT.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_grp_pke_dat[] =
{
    {
        "PKE",
        "Select one out of next values for group: PKE_DAT (Pads: DDR_DQ0 DDR_DQ"
        "1 DDR_DQ10 DDR_DQ11 DDR_DQ12 DDR_DQ13 DDR_DQ14 DDR_DQ15 DDR_DQ16 DDR_D"
        "Q17 DDR_DQ18 DDR_DQ19 DDR_DQ2 DDR_DQ20 DDR_DQ21 DDR_DQ22 DDR_DQ23 DDR_"
        "DQ24 DDR_DQ25 DDR_DQ26 DDR_DQ27 DDR_DQ28 DDR_DQ29 DDR_DQ3 DDR_DQ30 DDR"
        "_DQ31 DDR_DQ4 DDR_DQ5 DDR_DQ6 DDR_DQ7 DDR_DQ8 DDR_DQ9)",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_GRP_PUS.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_grp_pus[] =
{
    {
        "PUS",
        "Select one out of next values for group: PUS (Pads: DDR_CA0 DDR_CA1 DD"
        "R_CA2 DDR_CA3 DDR_CA4 DDR_CA5 DDR_CA6 DDR_CA7 DDR_CA8 DDR_CA9 DDR_CS0_"
        "B DDR_CS1_B DDR_DQ0 DDR_DQ1 DDR_DQ10 DDR_DQ11 DDR_DQ12 DDR_DQ13 DDR_DQ"
        "14 DDR_DQ15 DDR_DQ16 DDR_DQ17 DDR_DQ18 DDR_DQ19 DDR_DQ2 DDR_DQ20 DDR_D"
        "Q21 DDR_DQ22 DDR_DQ23 DDR_DQ24 DDR_DQ25 DDR_DQ26 DDR_DQ27 DDR_DQ28 DDR"
        "_DQ29 DDR_DQ3 DDR_DQ30 DDR_DQ31 DDR_DQ4 DDR_DQ5 DDR_DQ6 DDR_DQ7 DDR_DQ"
        "8 DDR_DQ9 DDR_DQM0 DDR_DQM1 DDR_DQM2 DDR_DQM3)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_GRP_DS_ADDR.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_grp_ds_addr[] =
{
    {
        "DSE",
        "Select one out of next values for group: DS_ADDR (Pads: DDR_CA0 DDR_CA"
        "1 DDR_CA2 DDR_CA3 DDR_CA4 DDR_CA5 DDR_CA6 DDR_CA7 DDR_CA8 DDR_CA9)",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_GRP_DS_CTRL.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_grp_ds_ctrl[] =
{
    {
        "DSE",
        "Select one out of next values for group: DS_CTRL (Pads: DDR_CKE0 DDR_C"
        "KE1 DDR_CS0_B DDR_CS1_B)",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_GRP_DS_DAT0.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_grp_ds_dat0[] =
{
    {
        "DSE",
        "Select one out of next values for group: DS_DAT0 (Pads: DDR_DQ0 DDR_DQ"
        "1 DDR_DQ2 DDR_DQ3 DDR_DQ4 DDR_DQ5 DDR_DQ6 DDR_DQ7)",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_GRP_DS_DAT1.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_grp_ds_dat1[] =
{
    {
        "DSE",
        "Select one out of next values for group: DS_DAT1 (Pads: DDR_DQ10 DDR_D"
        "Q11 DDR_DQ12 DDR_DQ13 DDR_DQ14 DDR_DQ15 DDR_DQ8 DDR_DQ9)",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_GRP_DS_DAT2.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_grp_ds_dat2[] =
{
    {
        "DSE",
        "Select one out of next values for group: DS_DAT2 (Pads: DDR_DQ16 DDR_D"
        "Q17 DDR_DQ18 DDR_DQ19 DDR_DQ20 DDR_DQ21 DDR_DQ22 DDR_DQ23)",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_GRP_DS_DAT3.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_grp_ds_dat3[] =
{
    {
        "DSE",
        "Select one out of next values for group: DS_DAT3 (Pads: DDR_DQ24 DDR_D"
        "Q25 DDR_DQ26 DDR_DQ27 DDR_DQ28 DDR_DQ29 DDR_DQ30 DDR_DQ31)",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_GRP_HYS.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_grp_hys[] =
{
    {
        "HYS",
        "Select one out of next values for group: HYS (Pads: DDR_DQ0 DDR_DQ1 DD"
        "R_DQ10 DDR_DQ11 DDR_DQ12 DDR_DQ13 DDR_DQ14 DDR_DQ15 DDR_DQ16 DDR_DQ17 "
        "DDR_DQ18 DDR_DQ19 DDR_DQ2 DDR_DQ20 DDR_DQ21 DDR_DQ22 DDR_DQ23 DDR_DQ24"
        " DDR_DQ25 DDR_DQ26 DDR_DQ27 DDR_DQ28 DDR_DQ29 DDR_DQ3 DDR_DQ30 DDR_DQ3"
        "1 DDR_DQ4 DDR_DQ5 DDR_DQ6 DDR_DQ7 DDR_DQ8 DDR_DQ9 DDR_DQS0 DDR_DQS1 DD"
        "R_DQS2 DDR_DQS3)",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_GRP_INSEL_DAT.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_grp_insel_dat[] =
{
    {
        "DDR_INPUT",
        "Select one out of next values for group: INSEL_DAT (Pads: DDR_DQ0 DDR_"
        "DQ1 DDR_DQ10 DDR_DQ11 DDR_DQ12 DDR_DQ13 DDR_DQ14 DDR_DQ15 DDR_DQ16 DDR"
        "_DQ17 DDR_DQ18 DDR_DQ19 DDR_DQ2 DDR_DQ20 DDR_DQ21 DDR_DQ22 DDR_DQ23 DD"
        "R_DQ24 DDR_DQ25 DDR_DQ26 DDR_DQ27 DDR_DQ28 DDR_DQ29 DDR_DQ3 DDR_DQ30 D"
        "DR_DQ31 DDR_DQ4 DDR_DQ5 DDR_DQ6 DDR_DQ7 DDR_DQ8 DDR_DQ9)",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_GRP_INSEL_DQS.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_grp_insel_dqs[] =
{
    {
        "DDR_INPUT",
        "Select one out of next values for group: INSEL_DQS (Pads: DDR_DQS0 DDR"
        "_DQS1 DDR_DQS2 DDR_DQS3)",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC1_DDR_SW_PAD_CTL_GRP_DDRTYPE.
static const field_t hw_iomuxc1_ddr_sw_pad_ctl_grp_ddrtype[] =
{
    {
        "DDR_SELECT",
        "Select one out of next values for group: DDRTYPE (Pads: DDR_CA0 DDR_CA"
        "1 DDR_CA2 DDR_CA3 DDR_CA4 DDR_CA5 DDR_CA6 DDR_CA7 DDR_CA8 DDR_CA9 DDR_"
        "CKE0 DDR_CKE1 DDR_CLK0 DDR_CS0_B DDR_CS1_B DDR_DQ0 DDR_DQ1 DDR_DQ10 DD"
        "R_DQ11 DDR_DQ12 DDR_DQ13 DDR_DQ14 DDR_DQ15 DDR_DQ16 DDR_DQ17 DDR_DQ18 "
        "DDR_DQ19 DDR_DQ2 DDR_DQ20 DDR_DQ21 DDR_DQ22 DDR_DQ23 DDR_DQ24 DDR_DQ25"
        " DDR_DQ26 DDR_DQ27 DDR_DQ28 DDR_DQ29 DDR_DQ3 DDR_DQ30 DDR_DQ31 DDR_DQ4"
        " DDR_DQ5 DDR_DQ6 DDR_DQ7 DDR_DQ8 DDR_DQ9 DDR_DQM0 DDR_DQM1 DDR_DQM2 DD"
        "R_DQM3 DDR_DQS0 DDR_DQS1 DDR_DQS2 DDR_DQS3 DDR_ODT)",
        17, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a IOMUXC1_DDR module.
static const reg_t hw_iomuxc1_ddr[] =
{
    {
        "SW_PAD_CTL_PAD_DDR_DQ0",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq0
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ1",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq1
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ2",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq2
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ3",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq3
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ4",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq4
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ5",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq5
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ6",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq6
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ7",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq7
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ8",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq8
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ9",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq9
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ10",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq10
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ11",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq11
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ12",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq12
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ13",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq13
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ14",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq14
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ15",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq15
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ16",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq16
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ17",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq17
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ18",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq18
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ19",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq19
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ20",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq20
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ21",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq21
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ22",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq22
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ23",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq23
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ24",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq24
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ25",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq25
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ26",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq26
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ27",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq27
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ28",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq28
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ29",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq29
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ30",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq30
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQ31",
        "This control register applies to DDR data pads : DDR_DQ0 ~ DDR_DQ31.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dq31
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQS0",
        "This control register applies to DDR_DQS0 ~ DDR_DQS3 pads.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dqs0
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQS1",
        "This control register applies to DDR_DQS0 ~ DDR_DQS3 pads.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dqs1
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQS2",
        "This control register applies to DDR_DQS0 ~ DDR_DQS3 pads.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dqs2
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQS3",
        "This control register applies to DDR_DQS0 ~ DDR_DQS3 pads.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dqs3
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQM0",
        "This control register applies to DDR_DQM0 ~ DDR_DQM3 pads.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dqm0
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQM1",
        "This control register applies to DDR_DQM0 ~ DDR_DQM3 pads.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dqm1
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQM2",
        "This control register applies to DDR_DQM0 ~ DDR_DQM3 pads.",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dqm2
    },
    {
        "SW_PAD_CTL_PAD_DDR_DQM3",
        "This control register applies to DDR_DQM0 ~ DDR_DQM3 pads.",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_dqm3
    },
    {
        "SW_PAD_CTL_PAD_DDR_CA0",
        "This control register applies to DDR Address - DDR_CA0 ~ DDR_CA9 and D"
        "DR CS0_B, DDR_CS1_B pads.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca0
    },
    {
        "SW_PAD_CTL_PAD_DDR_CA1",
        "This control register applies to DDR Address - DDR_CA0 ~ DDR_CA9 and D"
        "DR CS0_B, DDR_CS1_B pads.",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca1
    },
    {
        "SW_PAD_CTL_PAD_DDR_CA2",
        "This control register applies to DDR Address - DDR_CA0 ~ DDR_CA9 and D"
        "DR CS0_B, DDR_CS1_B pads.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca2
    },
    {
        "SW_PAD_CTL_PAD_DDR_CA3",
        "This control register applies to DDR Address - DDR_CA0 ~ DDR_CA9 and D"
        "DR CS0_B, DDR_CS1_B pads.",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca3
    },
    {
        "SW_PAD_CTL_PAD_DDR_CA4",
        "This control register applies to DDR Address - DDR_CA0 ~ DDR_CA9 and D"
        "DR CS0_B, DDR_CS1_B pads.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca4
    },
    {
        "SW_PAD_CTL_PAD_DDR_CA5",
        "This control register applies to DDR Address - DDR_CA0 ~ DDR_CA9 and D"
        "DR CS0_B, DDR_CS1_B pads.",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca5
    },
    {
        "SW_PAD_CTL_PAD_DDR_CA6",
        "This control register applies to DDR Address - DDR_CA0 ~ DDR_CA9 and D"
        "DR CS0_B, DDR_CS1_B pads.",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca6
    },
    {
        "SW_PAD_CTL_PAD_DDR_CA7",
        "This control register applies to DDR Address - DDR_CA0 ~ DDR_CA9 and D"
        "DR CS0_B, DDR_CS1_B pads.",
        4, // Width in bytes
        0x000000bc, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca7
    },
    {
        "SW_PAD_CTL_PAD_DDR_CA8",
        "This control register applies to DDR Address - DDR_CA0 ~ DDR_CA9 and D"
        "DR CS0_B, DDR_CS1_B pads.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca8
    },
    {
        "SW_PAD_CTL_PAD_DDR_CA9",
        "This control register applies to DDR Address - DDR_CA0 ~ DDR_CA9 and D"
        "DR CS0_B, DDR_CS1_B pads.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_ca9
    },
    {
        "SW_PAD_CTL_PAD_DDR_CS0_B",
        "This control register applies to DDR Address - DDR_CA0 ~ DDR_CA9 and D"
        "DR CS0_B, DDR_CS1_B pads.",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_cs0_b
    },
    {
        "SW_PAD_CTL_PAD_DDR_CS1_B",
        "This control register applies to DDR Address - DDR_CA0 ~ DDR_CA9 and D"
        "DR CS0_B, DDR_CS1_B pads.",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_cs1_b
    },
    {
        "SW_PAD_CTL_PAD_DDR_CKE0",
        "This control register applies to DDR_CKE0 and DDR_CKE1 pads.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_cke0
    },
    {
        "SW_PAD_CTL_PAD_DDR_CKE1",
        "This control register applies to DDR_CKE0 and DDR_CKE1 pads.",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_cke1
    },
    {
        "SW_PAD_CTL_PAD_DDR_CLK0",
        "This control register applies to DDR_CLK0 pad.",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_clk0
    },
    {
        "SW_PAD_CTL_PAD_DDR_ODT",
        "This control register applies to DDR_ODT pad.",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_odt
    },
    {
        "SW_PAD_CTL_PAD_DDR_ZQ0",
        "This control register applies to DDR_ZQ0 and DDR_ZQ1 pads.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_zq0
    },
    {
        "SW_PAD_CTL_PAD_DDR_ZQ1",
        "This control register applies to DDR_ZQ0 and DDR_ZQ1 pads.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_ddr_zq1
    },
    {
        "SW_PAD_CTL_PAD_HSIC_DATA",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_hsic_data
    },
    {
        "SW_PAD_CTL_PAD_HSIC_STROBE",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_pad_hsic_strobe
    },
    {
        "SW_PAD_CTL_GRP_PUE",
        "SW_GRP Register",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_grp_pue
    },
    {
        "SW_PAD_CTL_GRP_PUE_DAT",
        "SW_GRP Register",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_grp_pue_dat
    },
    {
        "SW_PAD_CTL_GRP_PKE",
        "SW_GRP Register",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_grp_pke
    },
    {
        "SW_PAD_CTL_GRP_PKE_DAT",
        "SW_GRP Register",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_grp_pke_dat
    },
    {
        "SW_PAD_CTL_GRP_PUS",
        "SW_GRP Register",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_grp_pus
    },
    {
        "SW_PAD_CTL_GRP_DS_ADDR",
        "SW_GRP Register",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_grp_ds_addr
    },
    {
        "SW_PAD_CTL_GRP_DS_CTRL",
        "SW_GRP Register",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_grp_ds_ctrl
    },
    {
        "SW_PAD_CTL_GRP_DS_DAT0",
        "SW_GRP Register",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_grp_ds_dat0
    },
    {
        "SW_PAD_CTL_GRP_DS_DAT1",
        "SW_GRP Register",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_grp_ds_dat1
    },
    {
        "SW_PAD_CTL_GRP_DS_DAT2",
        "SW_GRP Register",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_grp_ds_dat2
    },
    {
        "SW_PAD_CTL_GRP_DS_DAT3",
        "SW_GRP Register",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_grp_ds_dat3
    },
    {
        "SW_PAD_CTL_GRP_HYS",
        "SW_GRP Register",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_grp_hys
    },
    {
        "SW_PAD_CTL_GRP_INSEL_DAT",
        "SW_GRP Register",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_grp_insel_dat
    },
    {
        "SW_PAD_CTL_GRP_INSEL_DQS",
        "SW_GRP Register",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_grp_insel_dqs
    },
    {
        "SW_PAD_CTL_GRP_DDRTYPE",
        "SW_GRP Register",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc1_ddr_sw_pad_ctl_grp_ddrtype
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LCDIF
#endif

// Bitfields in register LCDIF_CTRL.
static const field_t hw_lcdif_ctrl[] =
{
    {
        "RUN",
        "When this bit is set by software, the eLCDIF will begin transferring d"
        "ata between the SoC and the display.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_24_BIT",
        "Used only when WORD_LENGTH = 3, i.e.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_18_BIT",
        "Used only when WORD_LENGTH = 2, i.e.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_16_BIT",
        "When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit dat"
        "a is in ARGB555 format.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "MASTER",
        "Set this bit to make the eLCDIF act as a bus master.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "Input data format.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCD_DATABUS_WIDTH",
        "LCD Data bus transfer width.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSC_DATA_SWIZZLE",
        "This field specifies how to swap the bytes after the data has been con"
        "verted into an internal representation of 24 bits per pixel and before"
        " it is transmitted over the LCD interface bus.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INPUT_DATA_SWIZZLE",
        "This field specifies how to swap the bytes fetched by the bus master i"
        "nterface.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_MODE",
        "Set this bit to 1 to make the hardware go into the DOTCLK mode, i.e.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_COUNT",
        "When this bit is 0, it means that eLCDIF will stop the block operation"
        " and turn off the RUN bit after the amount of data indicated by the LC"
        "DIF_TRANSFER_COUNT register has been transferred out.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHIFT_NUM_BITS",
        "The data to be transmitted is shifted left or right by this number of "
        "bits.",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SHIFT_DIR",
        "Use this bit to determine the direction of shift of transmit data.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCBCR422_INPUT",
        "Zero implies input data is in RGB color space.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "This bit must be set to zero to enable normal operation of the eLCDIF.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL_SET.
static const field_t hw_lcdif_ctrl_set[] =
{
    {
        "RUN",
        "When this bit is set by software, the eLCDIF will begin transferring d"
        "ata between the SoC and the display.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_24_BIT",
        "Used only when WORD_LENGTH = 3, i.e.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_18_BIT",
        "Used only when WORD_LENGTH = 2, i.e.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_16_BIT",
        "When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit dat"
        "a is in ARGB555 format.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "MASTER",
        "Set this bit to make the eLCDIF act as a bus master.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "Input data format.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCD_DATABUS_WIDTH",
        "LCD Data bus transfer width.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSC_DATA_SWIZZLE",
        "This field specifies how to swap the bytes after the data has been con"
        "verted into an internal representation of 24 bits per pixel and before"
        " it is transmitted over the LCD interface bus.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INPUT_DATA_SWIZZLE",
        "This field specifies how to swap the bytes fetched by the bus master i"
        "nterface.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_MODE",
        "Set this bit to 1 to make the hardware go into the DOTCLK mode, i.e.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_COUNT",
        "When this bit is 0, it means that eLCDIF will stop the block operation"
        " and turn off the RUN bit after the amount of data indicated by the LC"
        "DIF_TRANSFER_COUNT register has been transferred out.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHIFT_NUM_BITS",
        "The data to be transmitted is shifted left or right by this number of "
        "bits.",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SHIFT_DIR",
        "Use this bit to determine the direction of shift of transmit data.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCBCR422_INPUT",
        "Zero implies input data is in RGB color space.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "This bit must be set to zero to enable normal operation of the eLCDIF.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL_CLR.
static const field_t hw_lcdif_ctrl_clr[] =
{
    {
        "RUN",
        "When this bit is set by software, the eLCDIF will begin transferring d"
        "ata between the SoC and the display.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_24_BIT",
        "Used only when WORD_LENGTH = 3, i.e.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_18_BIT",
        "Used only when WORD_LENGTH = 2, i.e.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_16_BIT",
        "When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit dat"
        "a is in ARGB555 format.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "MASTER",
        "Set this bit to make the eLCDIF act as a bus master.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "Input data format.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCD_DATABUS_WIDTH",
        "LCD Data bus transfer width.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSC_DATA_SWIZZLE",
        "This field specifies how to swap the bytes after the data has been con"
        "verted into an internal representation of 24 bits per pixel and before"
        " it is transmitted over the LCD interface bus.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INPUT_DATA_SWIZZLE",
        "This field specifies how to swap the bytes fetched by the bus master i"
        "nterface.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_MODE",
        "Set this bit to 1 to make the hardware go into the DOTCLK mode, i.e.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_COUNT",
        "When this bit is 0, it means that eLCDIF will stop the block operation"
        " and turn off the RUN bit after the amount of data indicated by the LC"
        "DIF_TRANSFER_COUNT register has been transferred out.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHIFT_NUM_BITS",
        "The data to be transmitted is shifted left or right by this number of "
        "bits.",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SHIFT_DIR",
        "Use this bit to determine the direction of shift of transmit data.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCBCR422_INPUT",
        "Zero implies input data is in RGB color space.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "This bit must be set to zero to enable normal operation of the eLCDIF.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL_TOG.
static const field_t hw_lcdif_ctrl_tog[] =
{
    {
        "RUN",
        "When this bit is set by software, the eLCDIF will begin transferring d"
        "ata between the SoC and the display.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_24_BIT",
        "Used only when WORD_LENGTH = 3, i.e.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_18_BIT",
        "Used only when WORD_LENGTH = 2, i.e.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_16_BIT",
        "When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit dat"
        "a is in ARGB555 format.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "MASTER",
        "Set this bit to make the eLCDIF act as a bus master.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "Input data format.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCD_DATABUS_WIDTH",
        "LCD Data bus transfer width.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSC_DATA_SWIZZLE",
        "This field specifies how to swap the bytes after the data has been con"
        "verted into an internal representation of 24 bits per pixel and before"
        " it is transmitted over the LCD interface bus.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INPUT_DATA_SWIZZLE",
        "This field specifies how to swap the bytes fetched by the bus master i"
        "nterface.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_MODE",
        "Set this bit to 1 to make the hardware go into the DOTCLK mode, i.e.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_COUNT",
        "When this bit is 0, it means that eLCDIF will stop the block operation"
        " and turn off the RUN bit after the amount of data indicated by the LC"
        "DIF_TRANSFER_COUNT register has been transferred out.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHIFT_NUM_BITS",
        "The data to be transmitted is shifted left or right by this number of "
        "bits.",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SHIFT_DIR",
        "Use this bit to determine the direction of shift of transmit data.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCBCR422_INPUT",
        "Zero implies input data is in RGB color space.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "This bit must be set to zero to enable normal operation of the eLCDIF.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL1.
static const field_t hw_lcdif_ctrl1[] =
{
    {
        "RESET",
        "Reset bit for the external LCD controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        3, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "VSYNC_EDGE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_EDGE_IRQ_EN",
        "This bit is set to enable an interrupt every time the hardware encount"
        "ers the leading VSYNC edge in the VSYNC and DOTCLK modes, or the begin"
        "ning of every field in DVI mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ_EN",
        "This bit is set to 1 enable an interrupt every time the hardware enter"
        "s in the vertical blanking state.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ_EN",
        "This bit is set to enable an underflow interrupt in the TXFIFO in the "
        "write mode.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ_EN",
        "This bit is set to enable an overflow interrupt in the TXFIFO in the w"
        "rite mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYTE_PACKING_FORMAT",
        "This bitfield is used to show which data bytes in a 32-bit word are va"
        "lid.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ON_ALTERNATE_FIELDS",
        "If this bit is set, the eLCDIF block will assert the cur_frame_done in"
        "terrupt only on alternate fields, otherwise it will issue the interrup"
        "t on both odd and even field.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_CLEAR",
        "Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO"
        " and the RXFIFO.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_INTERLACE_FROM_SECOND_FIELD",
        "The default is to grab the odd lines first and then the even lines.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTERLACE_FIELDS",
        "Set this bit if it is required that the eLCDIF block fetches odd lines"
        " in one field and even lines in the other field.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECOVER_ON_UNDERFLOW",
        "Set this bit to enable the eLCDIF block to recover in the next field/f"
        "rame if there was an underflow in the current field/frame.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ_EN",
        "This bit is set to enable bus master error interrupt in the eLCDIF mas"
        "ter mode.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        28, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL1_SET.
static const field_t hw_lcdif_ctrl1_set[] =
{
    {
        "RESET",
        "Reset bit for the external LCD controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        3, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "VSYNC_EDGE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_EDGE_IRQ_EN",
        "This bit is set to enable an interrupt every time the hardware encount"
        "ers the leading VSYNC edge in the VSYNC and DOTCLK modes, or the begin"
        "ning of every field in DVI mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ_EN",
        "This bit is set to 1 enable an interrupt every time the hardware enter"
        "s in the vertical blanking state.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ_EN",
        "This bit is set to enable an underflow interrupt in the TXFIFO in the "
        "write mode.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ_EN",
        "This bit is set to enable an overflow interrupt in the TXFIFO in the w"
        "rite mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYTE_PACKING_FORMAT",
        "This bitfield is used to show which data bytes in a 32-bit word are va"
        "lid.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ON_ALTERNATE_FIELDS",
        "If this bit is set, the eLCDIF block will assert the cur_frame_done in"
        "terrupt only on alternate fields, otherwise it will issue the interrup"
        "t on both odd and even field.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_CLEAR",
        "Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO"
        " and the RXFIFO.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_INTERLACE_FROM_SECOND_FIELD",
        "The default is to grab the odd lines first and then the even lines.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTERLACE_FIELDS",
        "Set this bit if it is required that the eLCDIF block fetches odd lines"
        " in one field and even lines in the other field.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECOVER_ON_UNDERFLOW",
        "Set this bit to enable the eLCDIF block to recover in the next field/f"
        "rame if there was an underflow in the current field/frame.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ_EN",
        "This bit is set to enable bus master error interrupt in the eLCDIF mas"
        "ter mode.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        28, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL1_CLR.
static const field_t hw_lcdif_ctrl1_clr[] =
{
    {
        "RESET",
        "Reset bit for the external LCD controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        3, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "VSYNC_EDGE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_EDGE_IRQ_EN",
        "This bit is set to enable an interrupt every time the hardware encount"
        "ers the leading VSYNC edge in the VSYNC and DOTCLK modes, or the begin"
        "ning of every field in DVI mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ_EN",
        "This bit is set to 1 enable an interrupt every time the hardware enter"
        "s in the vertical blanking state.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ_EN",
        "This bit is set to enable an underflow interrupt in the TXFIFO in the "
        "write mode.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ_EN",
        "This bit is set to enable an overflow interrupt in the TXFIFO in the w"
        "rite mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYTE_PACKING_FORMAT",
        "This bitfield is used to show which data bytes in a 32-bit word are va"
        "lid.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ON_ALTERNATE_FIELDS",
        "If this bit is set, the eLCDIF block will assert the cur_frame_done in"
        "terrupt only on alternate fields, otherwise it will issue the interrup"
        "t on both odd and even field.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_CLEAR",
        "Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO"
        " and the RXFIFO.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_INTERLACE_FROM_SECOND_FIELD",
        "The default is to grab the odd lines first and then the even lines.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTERLACE_FIELDS",
        "Set this bit if it is required that the eLCDIF block fetches odd lines"
        " in one field and even lines in the other field.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECOVER_ON_UNDERFLOW",
        "Set this bit to enable the eLCDIF block to recover in the next field/f"
        "rame if there was an underflow in the current field/frame.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ_EN",
        "This bit is set to enable bus master error interrupt in the eLCDIF mas"
        "ter mode.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        28, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL1_TOG.
static const field_t hw_lcdif_ctrl1_tog[] =
{
    {
        "RESET",
        "Reset bit for the external LCD controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        3, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "VSYNC_EDGE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_EDGE_IRQ_EN",
        "This bit is set to enable an interrupt every time the hardware encount"
        "ers the leading VSYNC edge in the VSYNC and DOTCLK modes, or the begin"
        "ning of every field in DVI mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ_EN",
        "This bit is set to 1 enable an interrupt every time the hardware enter"
        "s in the vertical blanking state.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ_EN",
        "This bit is set to enable an underflow interrupt in the TXFIFO in the "
        "write mode.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ_EN",
        "This bit is set to enable an overflow interrupt in the TXFIFO in the w"
        "rite mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYTE_PACKING_FORMAT",
        "This bitfield is used to show which data bytes in a 32-bit word are va"
        "lid.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ON_ALTERNATE_FIELDS",
        "If this bit is set, the eLCDIF block will assert the cur_frame_done in"
        "terrupt only on alternate fields, otherwise it will issue the interrup"
        "t on both odd and even field.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_CLEAR",
        "Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO"
        " and the RXFIFO.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_INTERLACE_FROM_SECOND_FIELD",
        "The default is to grab the odd lines first and then the even lines.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTERLACE_FIELDS",
        "Set this bit if it is required that the eLCDIF block fetches odd lines"
        " in one field and even lines in the other field.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECOVER_ON_UNDERFLOW",
        "Set this bit to enable the eLCDIF block to recover in the next field/f"
        "rame if there was an underflow in the current field/frame.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ_EN",
        "This bit is set to enable bus master error interrupt in the eLCDIF mas"
        "ter mode.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        28, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL2.
static const field_t hw_lcdif_ctrl2[] =
{
    {
        "RSRVD0",
        "Reserved bits.",
        0, // LSB
        11, // MSB
        false, // Readable
        false // Writable
    },
    {
        "EVEN_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " EVEN lines (line numbers 2,4,6,.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD3",
        "Reserved bits.",
        15, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ODD_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " ODD lines (line numbers 1,3,5,.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD4",
        "Reserved bits.",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BURST_LEN_8",
        "By default, when the eLCDIF is in the bus master mode, it will issue A"
        "XI bursts of length 16 (except when in packed 24 bpp mode, it will iss"
        "ue bursts of length 15).",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTSTANDING_REQS",
        "This bitfield indicates the maximum number of outstanding transactions"
        " that eLCDIF should request when it is acting as a bus master.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD5",
        "Reserved bits.",
        24, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL2_SET.
static const field_t hw_lcdif_ctrl2_set[] =
{
    {
        "RSRVD0",
        "Reserved bits.",
        0, // LSB
        11, // MSB
        false, // Readable
        false // Writable
    },
    {
        "EVEN_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " EVEN lines (line numbers 2,4,6,.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD3",
        "Reserved bits.",
        15, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ODD_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " ODD lines (line numbers 1,3,5,.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD4",
        "Reserved bits.",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BURST_LEN_8",
        "By default, when the eLCDIF is in the bus master mode, it will issue A"
        "XI bursts of length 16 (except when in packed 24 bpp mode, it will iss"
        "ue bursts of length 15).",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTSTANDING_REQS",
        "This bitfield indicates the maximum number of outstanding transactions"
        " that eLCDIF should request when it is acting as a bus master.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD5",
        "Reserved bits.",
        24, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL2_CLR.
static const field_t hw_lcdif_ctrl2_clr[] =
{
    {
        "RSRVD0",
        "Reserved bits.",
        0, // LSB
        11, // MSB
        false, // Readable
        false // Writable
    },
    {
        "EVEN_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " EVEN lines (line numbers 2,4,6,.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD3",
        "Reserved bits.",
        15, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ODD_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " ODD lines (line numbers 1,3,5,.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD4",
        "Reserved bits.",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BURST_LEN_8",
        "By default, when the eLCDIF is in the bus master mode, it will issue A"
        "XI bursts of length 16 (except when in packed 24 bpp mode, it will iss"
        "ue bursts of length 15).",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTSTANDING_REQS",
        "This bitfield indicates the maximum number of outstanding transactions"
        " that eLCDIF should request when it is acting as a bus master.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD5",
        "Reserved bits.",
        24, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL2_TOG.
static const field_t hw_lcdif_ctrl2_tog[] =
{
    {
        "RSRVD0",
        "Reserved bits.",
        0, // LSB
        11, // MSB
        false, // Readable
        false // Writable
    },
    {
        "EVEN_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " EVEN lines (line numbers 2,4,6,.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD3",
        "Reserved bits.",
        15, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ODD_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " ODD lines (line numbers 1,3,5,.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD4",
        "Reserved bits.",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BURST_LEN_8",
        "By default, when the eLCDIF is in the bus master mode, it will issue A"
        "XI bursts of length 16 (except when in packed 24 bpp mode, it will iss"
        "ue bursts of length 15).",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTSTANDING_REQS",
        "This bitfield indicates the maximum number of outstanding transactions"
        " that eLCDIF should request when it is acting as a bus master.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD5",
        "Reserved bits.",
        24, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_TRANSFER_COUNT.
static const field_t hw_lcdif_transfer_count[] =
{
    {
        "H_COUNT",
        "Total valid data (pixels) in each horizontal line.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "V_COUNT",
        "Number of horizontal lines per frame which contain valid data.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CUR_BUF.
static const field_t hw_lcdif_cur_buf[] =
{
    {
        "ADDR",
        "Address of the current frame being transmitted by eLCDIF.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_NEXT_BUF.
static const field_t hw_lcdif_next_buf[] =
{
    {
        "ADDR",
        "Address of the next frame that will be transmitted by eLCDIF.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL0.
static const field_t hw_lcdif_vdctrl0[] =
{
    {
        "VSYNC_PULSE_WIDTH",
        "Number of units for which VSYNC signal is active.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE_MODE",
        "When this bit is 0, the first field (VSYNC period) will end in half a "
        "horizontal line and the second field will begin with half a horizontal"
        " line.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE",
        "Setting this bit to 1 will make the total VSYNC period equal to the VS"
        "YNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i.e.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PULSE_WIDTH_UNIT",
        "Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pi"
        "x_clk) cycles.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PERIOD_UNIT",
        "Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk"
        ") cycles.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        22, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ENABLE_POL",
        "Default 0 active low during valid data transfer on each horizontal lin"
        "e.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_POL",
        "Default is data launched at negative edge of DOTCLK and captured at po"
        "sitive edge.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "Default 0 active low during HSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the HSYNC period.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_POL",
        "Default 0 active low during VSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the VSYNC period.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PRESENT",
        "Setting this bit to 1 will make the hardware generate the ENABLE signa"
        "l in the DOTCLK mode, thereby making it the true RGB interface along w"
        "ith the remaining three signals VSYNC, HSYNC and DOTCLK.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_OEB",
        "0 means the VSYNC signal is an output, 1 means it is an input.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL0_SET.
static const field_t hw_lcdif_vdctrl0_set[] =
{
    {
        "VSYNC_PULSE_WIDTH",
        "Number of units for which VSYNC signal is active.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE_MODE",
        "When this bit is 0, the first field (VSYNC period) will end in half a "
        "horizontal line and the second field will begin with half a horizontal"
        " line.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE",
        "Setting this bit to 1 will make the total VSYNC period equal to the VS"
        "YNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i.e.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PULSE_WIDTH_UNIT",
        "Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pi"
        "x_clk) cycles.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PERIOD_UNIT",
        "Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk"
        ") cycles.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        22, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ENABLE_POL",
        "Default 0 active low during valid data transfer on each horizontal lin"
        "e.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_POL",
        "Default is data launched at negative edge of DOTCLK and captured at po"
        "sitive edge.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "Default 0 active low during HSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the HSYNC period.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_POL",
        "Default 0 active low during VSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the VSYNC period.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PRESENT",
        "Setting this bit to 1 will make the hardware generate the ENABLE signa"
        "l in the DOTCLK mode, thereby making it the true RGB interface along w"
        "ith the remaining three signals VSYNC, HSYNC and DOTCLK.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_OEB",
        "0 means the VSYNC signal is an output, 1 means it is an input.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL0_CLR.
static const field_t hw_lcdif_vdctrl0_clr[] =
{
    {
        "VSYNC_PULSE_WIDTH",
        "Number of units for which VSYNC signal is active.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE_MODE",
        "When this bit is 0, the first field (VSYNC period) will end in half a "
        "horizontal line and the second field will begin with half a horizontal"
        " line.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE",
        "Setting this bit to 1 will make the total VSYNC period equal to the VS"
        "YNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i.e.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PULSE_WIDTH_UNIT",
        "Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pi"
        "x_clk) cycles.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PERIOD_UNIT",
        "Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk"
        ") cycles.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        22, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ENABLE_POL",
        "Default 0 active low during valid data transfer on each horizontal lin"
        "e.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_POL",
        "Default is data launched at negative edge of DOTCLK and captured at po"
        "sitive edge.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "Default 0 active low during HSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the HSYNC period.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_POL",
        "Default 0 active low during VSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the VSYNC period.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PRESENT",
        "Setting this bit to 1 will make the hardware generate the ENABLE signa"
        "l in the DOTCLK mode, thereby making it the true RGB interface along w"
        "ith the remaining three signals VSYNC, HSYNC and DOTCLK.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_OEB",
        "0 means the VSYNC signal is an output, 1 means it is an input.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL0_TOG.
static const field_t hw_lcdif_vdctrl0_tog[] =
{
    {
        "VSYNC_PULSE_WIDTH",
        "Number of units for which VSYNC signal is active.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE_MODE",
        "When this bit is 0, the first field (VSYNC period) will end in half a "
        "horizontal line and the second field will begin with half a horizontal"
        " line.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE",
        "Setting this bit to 1 will make the total VSYNC period equal to the VS"
        "YNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i.e.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PULSE_WIDTH_UNIT",
        "Default 0 for counting VSYNC_PULSE_WIDTH in terms of DISPLAY CLOCK (pi"
        "x_clk) cycles.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PERIOD_UNIT",
        "Default 0 for counting VSYNC_PERIOD in terms of DISPLAY CLOCK (pix_clk"
        ") cycles.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        22, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ENABLE_POL",
        "Default 0 active low during valid data transfer on each horizontal lin"
        "e.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_POL",
        "Default is data launched at negative edge of DOTCLK and captured at po"
        "sitive edge.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "Default 0 active low during HSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the HSYNC period.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_POL",
        "Default 0 active low during VSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the VSYNC period.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PRESENT",
        "Setting this bit to 1 will make the hardware generate the ENABLE signa"
        "l in the DOTCLK mode, thereby making it the true RGB interface along w"
        "ith the remaining three signals VSYNC, HSYNC and DOTCLK.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_OEB",
        "0 means the VSYNC signal is an output, 1 means it is an input.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL1.
static const field_t hw_lcdif_vdctrl1[] =
{
    {
        "VSYNC_PERIOD",
        "Total number of units between two positive or two negative edges of th"
        "e VSYNC signal.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL2.
static const field_t hw_lcdif_vdctrl2[] =
{
    {
        "HSYNC_PERIOD",
        "Total number of DISPLAY CLOCK (pix_clk) cycles between two positive or"
        " two negative edges of the HSYNC signal.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_PULSE_WIDTH",
        "Number of DISPLAY CLOCK (pix_clk) cycles for which HSYNC signal is act"
        "ive.",
        18, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL3.
static const field_t hw_lcdif_vdctrl3[] =
{
    {
        "VERTICAL_WAIT_CNT",
        "In the VSYNC interface mode, wait for this number of DISPLAY CLOCK (pi"
        "x_clk) cycles from the falling VSYNC edge (or rising if VSYNC_POL is 1"
        ") before starting LCD transactions and is applicable only if WAIT_FOR_"
        "VSYNC_EDGE is set.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HORIZONTAL_WAIT_CNT",
        "In the DOTCLK mode, wait for this number of clocks from falling edge ("
        "or rising if HSYNC_POL is 1) of HSYNC signal to account for horizontal"
        " back porch plus the number of DOTCLKs before the moving picture infor"
        "mation begins.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_ONLY",
        "This bit must be set to 1 in the VSYNC mode of operation, and 0 in the"
        " DOTCLK mode of operation.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_SYNC_SIGNALS",
        "When this bit is set, the eLCDIF block will internally mux HSYNC with "
        "LCD_D14, DOTCLK with LCD_D13 and ENABLE with LCD_D12, otherwise these "
        "signals will go out on separate pins.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL4.
static const field_t hw_lcdif_vdctrl4[] =
{
    {
        "DOTCLK_H_VALID_DATA_CNT",
        "Total number of DISPLAY CLOCK (pix_clk) cycles on each horizontal line"
        " that carry valid data in DOTCLK mode.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC_SIGNALS_ON",
        "Set this field to 1 if the LCD controller requires that the VSYNC or V"
        "SYNC/HSYNC/DOTCLK control signals should be active at least one frame "
        "before the data transfers actually start and remain active at least on"
        "e frame after the data transfers end.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        19, // LSB
        28, // MSB
        false, // Readable
        false // Writable
    },
    {
        "DOTCLK_DLY_SEL",
        "This bitfield selects the amount of time by which the DOTCLK signal sh"
        "ould be delayed before coming out of the LCD_DOTCK pin.",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_BM_ERROR_STAT.
static const field_t hw_lcdif_bm_error_stat[] =
{
    {
        "ADDR",
        "Virtual address at which bus master error occurred.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CRC_STAT.
static const field_t hw_lcdif_crc_stat[] =
{
    {
        "CRC_VALUE",
        "Calculated CRC value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_STAT.
static const field_t hw_lcdif_stat[] =
{
    {
        "LFIFO_COUNT",
        "Read only view of the current count in Latency buffer (LFIFO).",
        0, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        9, // LSB
        24, // MSB
        false, // Readable
        false // Writable
    },
    {
        "TXFIFO_EMPTY",
        "Read only view of the signals that indicates LCD TXFIFO is empty.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXFIFO_FULL",
        "Read only view of the signals that indicates LCD TXFIFO is full.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LFIFO_EMPTY",
        "Read only view of the signals that indicates LCD LFIFO is empty.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LFIFO_FULL",
        "Read only view of the signals that indicates LCD LFIFO is full.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRESENT",
        "0: eLCDIF not present on this product 1: eLCDIF is present.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_AS_CTRL.
static const field_t hw_lcdif_as_ctrl[] =
{
    {
        "AS_ENABLE",
        "When this bit is set by software, the LCDIF will start fetching AS buf"
        "fer data in bus master mode and combine it with another buffer.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA_CTRL",
        "Determines how the alpha value is constructed for this alpha surface.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_COLORKEY",
        "Indicates that colorkey functionality is enabled for this alpha surfac"
        "e.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FORMAT",
        "Indicates the input buffer format for AS.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA",
        "Alpha modifier used when the ALPHA_MULTIPLY or ALPHA_OVERRIDE values a"
        "re programmed in REG_AS_CTRL[ALPHA_CTRL].",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROP",
        "Indicates a raster operation to perform when enabled.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA_INVERT",
        "Setting this bit to logic 0 will not alter the alpha value.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INPUT_DATA_SWIZZLE",
        "This field specifies how to swap the bytes either in the HW_LCDIF_DATA"
        " register or those fetched by the AXI master part of LCDIF.",
        21, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS_DISABLE",
        "When this bit is set by software, the LCDIF will disable PS buffer dat"
        "a.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RVDS1",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_AS_BUF.
static const field_t hw_lcdif_as_buf[] =
{
    {
        "ADDR",
        "Address pointer for the alpha surface 0 buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_AS_NEXT_BUF.
static const field_t hw_lcdif_as_next_buf[] =
{
    {
        "ADDR",
        "Address of the next frame that will be transmitted by eLCDIF.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_AS_CLRKEYLOW.
static const field_t hw_lcdif_as_clrkeylow[] =
{
    {
        "PIXEL",
        "Low range of RGB color key applied to AS buffer",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_AS_CLRKEYHIGH.
static const field_t hw_lcdif_as_clrkeyhigh[] =
{
    {
        "PIXEL",
        "High range of RGB color key applied to AS buffer",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a LCDIF module.
static const reg_t hw_lcdif[] =
{
    {
        "CTRL",
        "The LCD Interface Control Register provides overall control of the eLC"
        "DIF block.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_lcdif_ctrl
    },
    {
        "CTRL_SET",
        "The LCD Interface Control Register provides overall control of the eLC"
        "DIF block.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_lcdif_ctrl_set
    },
    {
        "CTRL_CLR",
        "The LCD Interface Control Register provides overall control of the eLC"
        "DIF block.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_lcdif_ctrl_clr
    },
    {
        "CTRL_TOG",
        "The LCD Interface Control Register provides overall control of the eLC"
        "DIF block.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_lcdif_ctrl_tog
    },
    {
        "CTRL1",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_lcdif_ctrl1
    },
    {
        "CTRL1_SET",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_lcdif_ctrl1_set
    },
    {
        "CTRL1_CLR",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_lcdif_ctrl1_clr
    },
    {
        "CTRL1_TOG",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_lcdif_ctrl1_tog
    },
    {
        "CTRL2",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_lcdif_ctrl2
    },
    {
        "CTRL2_SET",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_lcdif_ctrl2_set
    },
    {
        "CTRL2_CLR",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_lcdif_ctrl2_clr
    },
    {
        "CTRL2_TOG",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_lcdif_ctrl2_tog
    },
    {
        "TRANSFER_COUNT",
        "This register tells the eLCDIF how much data will be sent for this fra"
        "me, or transaction.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_transfer_count
    },
    {
        "CUR_BUF",
        "This register indicates the address of the current frame being transmi"
        "tted by eLCDIF.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_cur_buf
    },
    {
        "NEXT_BUF",
        "This register indicates the address of next frame that will be transmi"
        "tted by eLCDIF.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_next_buf
    },
    {
        "VDCTRL0",
        "This register is used to control the VSYNC and DOTCLK modes of the LCD"
        "IF so as to work with different types of LCDs like moving picture disp"
        "lays and delta pixel displays.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_lcdif_vdctrl0
    },
    {
        "VDCTRL0_SET",
        "This register is used to control the VSYNC and DOTCLK modes of the LCD"
        "IF so as to work with different types of LCDs like moving picture disp"
        "lays and delta pixel displays.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_lcdif_vdctrl0_set
    },
    {
        "VDCTRL0_CLR",
        "This register is used to control the VSYNC and DOTCLK modes of the LCD"
        "IF so as to work with different types of LCDs like moving picture disp"
        "lays and delta pixel displays.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_lcdif_vdctrl0_clr
    },
    {
        "VDCTRL0_TOG",
        "This register is used to control the VSYNC and DOTCLK modes of the LCD"
        "IF so as to work with different types of LCDs like moving picture disp"
        "lays and delta pixel displays.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_lcdif_vdctrl0_tog
    },
    {
        "VDCTRL1",
        "This register is used to control the VSYNC signal in the VSYNC and DOT"
        "CLK modes of the block.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_vdctrl1
    },
    {
        "VDCTRL2",
        "This register is used to control the HSYNC signal in the DOTCLK mode o"
        "f the block.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_vdctrl2
    },
    {
        "VDCTRL3",
        "This register is used to determine the vertical and horizontal wait co"
        "unts.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_lcdif_vdctrl3
    },
    {
        "VDCTRL4",
        "This register is used to control the DOTCLK mode of the block.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_vdctrl4
    },
    {
        "BM_ERROR_STAT",
        "This register reflects the virtual address at which the AXI master rec"
        "eived an error response from the slave.",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_bm_error_stat
    },
    {
        "CRC_STAT",
        "This register reflects the CRC value of each frame sent out by eLCDIF.",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_crc_stat
    },
    {
        "STAT",
        "The LCD interface status register can be used to check the current sta"
        "tus of the eLCDIF block.",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_lcdif_stat
    },
    {
        "AS_CTRL",
        "The Alpha Surface Parameter register provides additional controls for "
        "AS.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_lcdif_as_ctrl
    },
    {
        "AS_BUF",
        "This register is used to indicate the base address of the AS buffer.",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_as_buf
    },
    {
        "AS_NEXT_BUF",
        "When the LCDIF is behaving as a master, this address points to the add"
        "ress of the next frame of data that will be sent out via the LCDIF.",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_as_next_buf
    },
    {
        "AS_CLRKEYLOW",
        "If a pixel in the current overlay image with a color that falls in the"
        " range from the ASCOLORKEYLOW to ASCOLORKEYHIGH range, it will use the"
        " PS pixel value for that location.",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_as_clrkeylow
    },
    {
        "AS_CLRKEYHIGH",
        "If a pixel in the current overlay image with a color that falls in the"
        " range from the ASCOLORKEYLOW to ASCOLORKEYHIGH range, it will use the"
        " PS pixel value for that location.",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_as_clrkeyhigh
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LLWU
#endif

// Bitfields in register LLWU_VERID.
static const field_t hw_llwu_verid[] =
{
    {
        "FEATURE",
        "This read only field returns the feature set number.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read only field returns the minor version number for the module s"
        "pecification.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read only field returns the major version number for the module s"
        "pecification.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LLWU_PARAM.
static const field_t hw_llwu_param[] =
{
    {
        "FILTERS",
        "Number of Pin Filters implemented",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMAS",
        "Number of DMA wakeup sources supported",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MODULES",
        "Number of Module wakeup sources supported",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PINS",
        "Number of Pin wakeup sources supported",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LLWU_PE1.
static const field_t hw_llwu_pe1[] =
{
    {
        "WUPE0",
        "Enables and configures the edge detection for the wakeup pin.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE1",
        "Enables and configures the edge detection for the wakeup pin.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE2",
        "Enables and configures the edge detection for the wakeup pin.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE3",
        "Enables and configures the edge detection for the wakeup pin.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE4",
        "Enables and configures the edge detection for the wakeup pin.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE5",
        "Enables and configures the edge detection for the wakeup pin.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE6",
        "Enables and configures the edge detection for the wakeup pin.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE7",
        "Enables and configures the edge detection for the wakeup pin.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE8",
        "Enables and configures the edge detection for the wakeup pin.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE9",
        "Enables and configures the edge detection for the wakeup pin.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE10",
        "Enables and configures the edge detection for the wakeup pin.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE11",
        "Enables and configures the edge detection for the wakeup pin.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE12",
        "Enables and configures the edge detection for the wakeup pin.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE13",
        "Enables and configures the edge detection for the wakeup pin.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE14",
        "Enables and configures the edge detection for the wakeup pin.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE15",
        "Enables and configures the edge detection for the wakeup pin.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LLWU_PE2.
static const field_t hw_llwu_pe2[] =
{
    {
        "WUPE16",
        "Enables and configures the edge detection for the wakeup pin.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE17",
        "Enables and configures the edge detection for the wakeup pin.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE18",
        "Enables and configures the edge detection for the wakeup pin.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE19",
        "Enables and configures the edge detection for the wakeup pin.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE20",
        "Enables and configures the edge detection for the wakeup pin.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE21",
        "Enables and configures the edge detection for the wakeup pin.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE22",
        "Enables and configures the edge detection for the wakeup pin.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE23",
        "Enables and configures the edge detection for the wakeup pin.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE24",
        "Enables and configures the edge detection for the wakeup pin.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE25",
        "Enables and configures the edge detection for the wakeup pin.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE26",
        "Enables and configures the edge detection for the wakeup pin.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE27",
        "Enables and configures the edge detection for the wakeup pin.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE28",
        "Enables and configures the edge detection for the wakeup pin.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE29",
        "Enables and configures the edge detection for the wakeup pin.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE30",
        "Enables and configures the edge detection for the wakeup pin.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUPE31",
        "Enables and configures the edge detection for the wakeup pin.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LLWU_ME.
static const field_t hw_llwu_me[] =
{
    {
        "WUME0",
        "Enables an internal module as a wakeup source input.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUME1",
        "Enables an internal module as a wakeup source input.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUME2",
        "Enables an internal module as a wakeup source input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUME3",
        "Enables an internal module as a wakeup source input.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUME4",
        "Enables an internal module as a wakeup source input.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUME5",
        "Enables an internal module as a wakeup source input.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUME6",
        "Enables an internal module as a wakeup source input.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUME7",
        "Enables an internal module as a wakeup source input.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LLWU_DE.
static const field_t hw_llwu_de[] =
{
    {
        "WUDE0",
        "Enables an internal module as a DMA/Trigger wakeup source.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUDE1",
        "Enables an internal module as a DMA/Trigger wakeup source.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUDE2",
        "Enables an internal module as a DMA/Trigger wakeup source.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUDE3",
        "Enables an internal module as a DMA/Trigger wakeup source.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUDE4",
        "Enables an internal module as a DMA/Trigger wakeup source.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUDE5",
        "Enables an internal module as a DMA/Trigger wakeup source.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUDE6",
        "Enables an internal module as a DMA/Trigger wakeup source.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUDE7",
        "Enables an internal module as a DMA/Trigger wakeup source.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LLWU_PF.
static const field_t hw_llwu_pf[] =
{
    {
        "WUF0",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF1",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF2",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF3",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF4",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF5",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF6",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF7",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF8",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF9",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF10",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF11",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF12",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF13",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF14",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF15",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF16",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF17",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF18",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF19",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF20",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF21",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF22",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF23",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF24",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF25",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF26",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF27",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF28",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF29",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF30",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WUF31",
        "Indicates that an enabled external wakeup pin was a source of exiting "
        "a low-leakage power mode.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LLWU_MF.
static const field_t hw_llwu_mf[] =
{
    {
        "MWUF0",
        "Indicates that an enabled internal peripheral was a source of exiting "
        "a low-leakage power mode.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MWUF1",
        "Indicates that an enabled internal peripheral was a source of exiting "
        "a low-leakage power mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MWUF2",
        "Indicates that an enabled internal peripheral was a source of exiting "
        "a low-leakage power mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MWUF3",
        "Indicates that an enabled internal peripheral was a source of exiting "
        "a low-leakage power mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MWUF4",
        "Indicates that an enabled internal peripheral was a source of exiting "
        "a low-leakage power mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MWUF5",
        "Indicates that an enabled internal peripheral was a source of exiting "
        "a low-leakage power mode.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MWUF6",
        "Indicates that an enabled internal peripheral was a source of exiting "
        "a low-leakage power mode.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MWUF7",
        "Indicates that an enabled internal peripheral was a source of exiting "
        "a low-leakage power mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LLWU_FILT.
static const field_t hw_llwu_filt[] =
{
    {
        "FILTSEL1",
        "Selects 1 of the wakeup pins to be muxed into filter 1.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTE1",
        "Controls the digital filter 1 options for the external pin detect.",
        5, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTF1",
        "Indicates that the filtered external wakeup pin, selected by FILTSEL, "
        "was a source of exiting a low-leakage power mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTSEL2",
        "Selects 1 of the wakeup pins to be muxed into filter 2.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTE2",
        "Controls the digital filter 2 options for the external pin detect.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTF2",
        "Indicates that the filtered external wakeup pin, selected by FILTSEL, "
        "was a source of exiting a low-leakage power mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTSEL3",
        "Selects 1 of the wakeup pins to be muxed into filter 3.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTE3",
        "Controls the digital filter 3 options for the external pin detect.",
        21, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTF3",
        "Indicates that the filtered external wakeup pin, selected by FILTSEL, "
        "was a source of exiting a low-leakage power mode.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTSEL4",
        "Selects 1 of the wakeup pins to be muxed into filter 4.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTE4",
        "Controls the digital filter 4 options for the external pin detect.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTF4",
        "Indicates that the filtered external wakeup pin, selected by FILTSEL, "
        "was a source of exiting a low-leakage power mode.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a LLWU module.
static const reg_t hw_llwu[] =
{
    {
        "VERID",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_llwu_verid
    },
    {
        "PARAM",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_llwu_param
    },
    {
        "PE1",
        "LLWU_PE1 contains the field to enable and select the edge detect type "
        "for the external wakeup input pins LLWU_P15-LLWU_P0.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_llwu_pe1
    },
    {
        "PE2",
        "LLWU_PE2 contains the field to enable and select the edge detect type "
        "for the external wakeup input pins LLWU_P31-LLWU_P16.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_llwu_pe2
    },
    {
        "ME",
        "LLWU_ME contains the bits to enable an internal module interrupt as a "
        "wakeup source for inputs LLWU_M7IF - LLWU_M0IF.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_llwu_me
    },
    {
        "DE",
        "LLWU_DE contains the bits to enable an internal module DMA/Trigger req"
        "uest as a wakeup source for inputs LLWU_M7DR - LLWU_M0DR .",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_llwu_de
    },
    {
        "PF",
        "LLWU_PF contains the wakeup flags indicating which wakeup source cause"
        "d the MCU to exit LLS or VLLS mode.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_llwu_pf
    },
    {
        "MF",
        "LLWU_MF contains the wakeup flags indicating which internal module int"
        "errupt caused the MCU to exit LLS or VLLS mode.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_llwu_mf
    },
    {
        "FILT",
        "LLWU_FILT is a control and status register that is used to enable/disa"
        "ble the digital filter features for an external pin.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_llwu_filt
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LMEM
#endif

// Bitfields in register LMEM_PCCCR.
static const field_t hw_lmem_pcccr[] =
{
    {
        "ENCACHE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENWRBUF",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCCR2",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCCR3",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVW0",
        "If the PUSHW0 and INVW0 bits are set, then after setting the GO bit, p"
        "ush all modified lines in way 0 and invalidate all lines in way 0 (cle"
        "ar way 0).",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUSHW0",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVW1",
        "If the PUSHW1 and INVW1 bits are set, then after setting the GO bit, p"
        "ush all modified lines in way 1 and invalidate all lines in way 1 (cle"
        "ar way 1).",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUSHW1",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GO",
        "Setting this bit initiates the cache command indicated by bits 27-24.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LMEM_PCCLCR.
static const field_t hw_lmem_pcclcr[] =
{
    {
        "LGO",
        "Setting this bit initiates the cache line command indicated by bits 27"
        "-24.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CACHEADDR",
        "CLCR[11:5] bits are used to access the tag arrays CLCR[11:3] bits are "
        "used to access the data arrays",
        3, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSEL",
        "Selects the way for line commands.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDSEL",
        "Selects tag or data for search and read or write commands.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCIVB",
        "If command used cache address and way, then this bit shows the initial"
        " state of the valid bit If command used physical address and a hit, th"
        "en this bit shows the initial state of the valid bit.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCIMB",
        "If command used cache address and way, then this bit shows the initial"
        " state of the modified bit If command used physical address and a hit,"
        " then this bit shows the initial state of the modified bit.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCWAY",
        "Indicates the way used by the line command.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCMD",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LADSEL",
        "When using the cache address, the way must also be specified in CLCR[W"
        "SEL].",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LACC",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LMEM_PCCSAR.
static const field_t hw_lmem_pccsar[] =
{
    {
        "LGO",
        "Setting this bit initiates the cache line command indicated by bits 27"
        "-24.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHYADDR",
        "PHYADDR represents bits [31:3] of the system address.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LMEM_PCCCVR.
static const field_t hw_lmem_pcccvr[] =
{
    {
        "DATA",
        "For tag search, read or write: CCVR[31:12] bits are used for tag array"
        " R/W value CCVR[11:5] bits are used for tag set address on reads; unus"
        "ed on writes CCVR[4:2] bits are reserved CCVR[1] tag modify bit CCVR[0"
        "] tag valid bit For data search, read or write: CCVR[31:0] bits are us"
        "ed for data array R/W value",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a LMEM module.
static const reg_t hw_lmem[] =
{
    {
        "PCCCR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_lmem_pcccr
    },
    {
        "PCCLCR",
        "This register defines specific line-sized cache operations to be perfo"
        "rmed using a specific cache line address or a physical address.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_lmem_pcclcr
    },
    {
        "PCCSAR",
        "The CSAR register is used to define the explicit cache address or the "
        "physical address for line-sized commands specified in the CLCR[LADSEL]"
        " bit.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lmem_pccsar
    },
    {
        "PCCCVR",
        "The CCVR register is used to source write data or return read data for"
        " the commands specified in the CLCR register.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lmem_pcccvr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LPI2C_4FIFO
#endif

// Bitfields in register LPI2C_4FIFO_VERID.
static const field_t hw_lpi2c_4fifo_verid[] =
{
    {
        "FEATURE",
        "This read only field returns the feature set number.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read only field returns the minor version number for the specific"
        "ation.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read only field returns the major version number for the specific"
        "ation.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_PARAM.
static const field_t hw_lpi2c_4fifo_param[] =
{
    {
        "MTXFIFO",
        "Configures the number of words in the master transmit FIFO to 2MTXFIFO"
        ".",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MRXFIFO",
        "Configures the number of words in the master receive FIFO to 2MRXFIFO.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_MCR.
static const field_t hw_lpi2c_4fifo_mcr[] =
{
    {
        "MEN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        "Reset all internal master logic and registers, except the Master Contr"
        "ol Register.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZEN",
        "Enables or disables Doze mode for the master.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTF",
        "",
        8, // LSB
        8, // MSB
        false, // Readable
        false // Writable
    },
    {
        "RRF",
        "",
        9, // LSB
        9, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_MSR.
static const field_t hw_lpi2c_4fifo_msr[] =
{
    {
        "TDF",
        "The Transmit Data Flag is set whenever the number of words in the tran"
        "smit FIFO is equal or less than TXWATER.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDF",
        "The Receive Data Flag is set whenever the number of words in the recei"
        "ve FIFO is greater than RXWATER.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EPF",
        "This flag will set when the LPI2C master generates either a repeated S"
        "TART or a STOP condition.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDF",
        "This flag will set when the LPI2C master generates a STOP condition.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NDF",
        "This flag will set if the LPI2C master detects a NACK when transmittin"
        "g an address or data.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALF",
        "This flag will set if the LPI2C master transmits a logic one and detec"
        "ts a logic zero on the I2C bus, or if it detects a START or STOP condi"
        "tion while it is transmitting data.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FEF",
        "Detects an attempt to send or receive data without first generating a "
        "(repeated) START condition.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLTF",
        "Will set when the SCL and/or SDA input is low for more than PINLOW cyc"
        "les, even when the LPI2C master is idle.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMF",
        "Indicates that the received data has matched the MATCH0 and/or MATCH1 "
        "fields as configured by MATCFG.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MBF",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BBF",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_MIER.
static const field_t hw_lpi2c_4fifo_mier[] =
{
    {
        "TDIE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDIE",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPIE",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDIE",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NDIE",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALIE",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FEIE",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLTIE",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMIE",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_MDER.
static const field_t hw_lpi2c_4fifo_mder[] =
{
    {
        "TDDE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDDE",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_MCCR0.
static const field_t hw_lpi2c_4fifo_mccr0[] =
{
    {
        "CLKLO",
        "Minimum number of cycles (minus one) that the SCL clock is driven low "
        "by the master.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKHI",
        "Minimum number of cycles (minus one) that the SCL clock is driven high"
        " by the master.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SETHOLD",
        "Minimum number of cycles (minus one) that is used by the master as the"
        " hold time for a START condition, setup and hold time for a repeated S"
        "TART condition and setup time for a STOP condition.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATAVD",
        "Minimum number of cycles (minus one) that is used as the data hold tim"
        "e for SDA.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_MCCR1.
static const field_t hw_lpi2c_4fifo_mccr1[] =
{
    {
        "CLKLO",
        "Minimum number of cycles (minus one) that the SCL clock is driven low "
        "by the master.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKHI",
        "Minimum number of cycles (minus one) that the SCL clock is driven high"
        " by the master.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SETHOLD",
        "Minimum number of cycles (minus one) that is used by the master as the"
        " hold time for a START condition, setup and hold time for a repeated S"
        "TART condition and setup time for a STOP condition.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATAVD",
        "Minimum number of cycles (minus one) that is used as the data hold tim"
        "e for SDA.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_MCFGR1.
static const field_t hw_lpi2c_4fifo_mcfgr1[] =
{
    {
        "PRESCALE",
        "Configures the clock prescaler used for all LPI2C master logic, except"
        " the digital glitch filters.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTOSTOP",
        "When enabled, a STOP condition is generated whenever the LPI2C master "
        "is busy and the transmit FIFO is empty.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IGNACK",
        "When set, the received NACK field is ignored and assumed to be ACK.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMECFG",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MATCFG",
        "Configures the condition that will cause the DMF to set.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "Configures the pin mode.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_MTDR.
static const field_t hw_lpi2c_4fifo_mtdr[] =
{
    {
        "DATA",
        "Performing an 8-bit write to DATA will zero extend the CMD field.",
        0, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CMD",
        "",
        8, // LSB
        10, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_MRDR.
static const field_t hw_lpi2c_4fifo_mrdr[] =
{
    {
        "DATA",
        "Reading this register returns the data received by the I2C master that"
        " has not been discarded.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXEMPTY",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_MFCR.
static const field_t hw_lpi2c_4fifo_mfcr[] =
{
    {
        "TXWATER",
        "The Transmit Data Flag is set whenever the number of words in the tran"
        "smit FIFO is equal or less than TXWATER.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXWATER",
        "The Receive Data Flag is set whenever the number of words in the recei"
        "ve FIFO is greater than RXWATER.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_MFSR.
static const field_t hw_lpi2c_4fifo_mfsr[] =
{
    {
        "TXCOUNT",
        "Returns the number of words in the transmit FIFO.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXCOUNT",
        "Returns the number of words in the receive FIFO.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_MCFGR3.
static const field_t hw_lpi2c_4fifo_mcfgr3[] =
{
    {
        "PINLOW",
        "Configures the pin low timeout flag in clock cycles.",
        8, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_MDMR.
static const field_t hw_lpi2c_4fifo_mdmr[] =
{
    {
        "MATCH0",
        "Compared against the received data when receive data match is enabled.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MATCH1",
        "Compared against the received data when receive data match is enabled.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_MCFGR2.
static const field_t hw_lpi2c_4fifo_mcfgr2[] =
{
    {
        "BUSIDLE",
        "Configures the bus idle timeout period in clock cycles.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTSCL",
        "Configures the I2C master digital glitch filters for SCL input, a conf"
        "iguration of 0 will disable the glitch filter.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTSDA",
        "Configures the I2C master digital glitch filters for SDA input, a conf"
        "iguration of 0 will disable the glitch filter.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_SCR.
static const field_t hw_lpi2c_4fifo_scr[] =
{
    {
        "SEN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTEN",
        "This bit should only be updated when the I2C Slave is disabled.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTDZ",
        "This bit should only be updated when the I2C Slave is disabled.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTF",
        "",
        8, // LSB
        8, // MSB
        false, // Readable
        false // Writable
    },
    {
        "RRF",
        "",
        9, // LSB
        9, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_SSR.
static const field_t hw_lpi2c_4fifo_ssr[] =
{
    {
        "TDF",
        "This flag is cleared by writing the transmit data register.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDF",
        "This flag is cleared by reading the receive data register.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AVF",
        "This flag is cleared by reading the address status register.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAF",
        "This flag is cleared by writing the transmit ACK register.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSF",
        "This flag will set when the LPI2C slave detects a repeated START condi"
        "tion, provided the LPI2C slave matched the last address byte.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDF",
        "This flag will set when the LPI2C slave detects a STOP condition, prov"
        "ided the LPI2C slave matched the last address byte.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BEF",
        "This flag will set if the LPI2C slave transmits a logic one and detect"
        "s a logic zero on the I2C bus.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FEF",
        "FIFO error flag can only set when clock stretching is disabled.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AM0F",
        "Indicates that the received address has matched the ADDR0 field as con"
        "figured by ADDRCFG.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AM1F",
        "Indicates that the received address has matched the ADDR1 field or ADD"
        "R0 to ADDR1 range as configured by ADDRCFG.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GCF",
        "This flag is cleared by reading the Address Status Register.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SARF",
        "This flag is cleared by reading the Address Status Register.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBF",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BBF",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_SIER.
static const field_t hw_lpi2c_4fifo_sier[] =
{
    {
        "TDIE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDIE",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVIE",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAIE",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSIE",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDIE",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BEIE",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FEIE",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AM0IE",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AM1F",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GCIE",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SARIE",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_SDER.
static const field_t hw_lpi2c_4fifo_sder[] =
{
    {
        "TDDE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDDE",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVDE",
        "The Address Valid DMA request is shared with the Receive Data DMA requ"
        "est.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_SCFGR1.
static const field_t hw_lpi2c_4fifo_scfgr1[] =
{
    {
        "ADRSTALL",
        "Enables SCL clock stretching when the address valid flag is asserted.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXSTALL",
        "Enables SCL clock stretching when receive data flag is set during a sl"
        "ave-receive transfer.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXDSTALL",
        "Enables SCL clock stretching when the transmit data flag is set during"
        " a slave-transmit transfer.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACKSTALL",
        "Enables SCL clock stretching during slave-transmit address byte(s) and"
        " slave-receiver address and data byte(s) to allow software to write th"
        "e Transmit ACK Register before the ACK or NACK is transmitted.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GCEN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SAEN",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCFG",
        "The transmit data flag will always assert before a NACK is detected at"
        " the end of a slave-transmit transfer.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXCFG",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IGNACK",
        "When set, the LPI2C slave will continue transfers after a NACK is dete"
        "cted.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSMEN",
        "Enables detection of the High-speed Mode master code of slave address "
        "0000_1XX, but does not cause an address match on this code.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRCFG",
        "Configures the condition that will cause an address to match.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_SAMR.
static const field_t hw_lpi2c_4fifo_samr[] =
{
    {
        "ADDR0",
        "Compared against the received address to detect the Slave Address.",
        1, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR1",
        "Compared against the received address to detect the Slave Address.",
        17, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_STDR.
static const field_t hw_lpi2c_4fifo_stdr[] =
{
    {
        "DATA",
        "Writing this register will store I2C slave transmit data in the transm"
        "it register.",
        0, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_SRDR.
static const field_t hw_lpi2c_4fifo_srdr[] =
{
    {
        "DATA",
        "Reading this register returns the data received by the I2C slave.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXEMPTY",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SOF",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_MCFGR0.
static const field_t hw_lpi2c_4fifo_mcfgr0[] =
{
    {
        "HREN",
        "When enabled, the LPI2C master will only initiate a START condition if"
        " the host request input is asserted and the bus is idle.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HRPOL",
        "Configures the polarity of the host request input pin.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HRSEL",
        "Selects the source of the host request input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIRFIFO",
        "When enabled, the transmit FIFO read pointer is saved to a temporary r"
        "egister.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMO",
        "When enabled, all received data that does not cause DMF to set is disc"
        "arded.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_STAR.
static const field_t hw_lpi2c_4fifo_star[] =
{
    {
        "TXNACK",
        "When ACKSTALL is set, must be written once for each matching address b"
        "yte and each received word.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_SASR.
static const field_t hw_lpi2c_4fifo_sasr[] =
{
    {
        "RADDR",
        "RADDR updates whenever the AMF is set and the AMF is cleared by readin"
        "g this register.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ANV",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPI2C_4FIFO_SCFGR2.
static const field_t hw_lpi2c_4fifo_scfgr2[] =
{
    {
        "CLKHOLD",
        "Configures the minimum clock hold time for the I2C slave, when clock s"
        "tretching is enabled.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATAVD",
        "Configures the SDA data valid delay time for the I2C slave equal to FI"
        "LTSCL+DATAVD+3 cycles.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTSCL",
        "Configures the I2C slave digital glitch filters for SCL input, a confi"
        "guration of 0 will disable the glitch filter.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTSDA",
        "Configures the I2C slave digital glitch filters for SDA input, a confi"
        "guration of 0 will disable the glitch filter.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a LPI2C_4FIFO module.
static const reg_t hw_lpi2c_4fifo[] =
{
    {
        "VERID",
        ".",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_lpi2c_4fifo_verid
    },
    {
        "PARAM",
        ".",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lpi2c_4fifo_param
    },
    {
        "MCR",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_lpi2c_4fifo_mcr
    },
    {
        "MSR",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_lpi2c_4fifo_msr
    },
    {
        "MIER",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_lpi2c_4fifo_mier
    },
    {
        "MDER",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lpi2c_4fifo_mder
    },
    {
        "MCCR0",
        "The MCCR0 cannot be changed when the I2C master is enabled and is used"
        " for standard, fast, fast-mode plus and ultra-fast transfers.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lpi2c_4fifo_mccr0
    },
    {
        "MCCR1",
        "The MCCR1 cannot be changed when the I2C master is enabled and is used"
        " for high speed mode transfers.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lpi2c_4fifo_mccr1
    },
    {
        "MCFGR1",
        "The MCFGR1 should only be written when the I2C Master is disabled.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_lpi2c_4fifo_mcfgr1
    },
    {
        "MTDR",
        "An 8-bit write to the CMD field will store the data in the Command FIF"
        "O, but does not increment the FIFO write pointer.",
        4, // Width in bytes
        0x00000060, // Base address offset
        false, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lpi2c_4fifo_mtdr
    },
    {
        "MRDR",
        "",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lpi2c_4fifo_mrdr
    },
    {
        "MFCR",
        "The Master FIFO control register is only used in Stop mode when the MF"
        "CR register is static (i.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lpi2c_4fifo_mfcr
    },
    {
        "MFSR",
        "",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lpi2c_4fifo_mfsr
    },
    {
        "MCFGR3",
        "The MCFGR3 should only be written when the I2C Master is disabled.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lpi2c_4fifo_mcfgr3
    },
    {
        "MDMR",
        "The MDMR should only be written when the I2C Master is disabled or idl"
        "e.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lpi2c_4fifo_mdmr
    },
    {
        "MCFGR2",
        "The MCFGR2 should only be written when the I2C Master is disabled.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_lpi2c_4fifo_mcfgr2
    },
    {
        "SCR",
        "",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_lpi2c_4fifo_scr
    },
    {
        "SSR",
        "",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_lpi2c_4fifo_ssr
    },
    {
        "SIER",
        "",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_lpi2c_4fifo_sier
    },
    {
        "SDER",
        "",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_lpi2c_4fifo_sder
    },
    {
        "SCFGR1",
        "The SCFGR1 should only be written when the I2C Slave is disabled.",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_lpi2c_4fifo_scfgr1
    },
    {
        "SAMR",
        "The SAMR should only be written when the I2C Slave is disabled.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lpi2c_4fifo_samr
    },
    {
        "STDR",
        "Clock stretching (enabled or disabled) affects when the transmit data "
        "is transferred.",
        4, // Width in bytes
        0x00000160, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_lpi2c_4fifo_stdr
    },
    {
        "SRDR",
        "",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_lpi2c_4fifo_srdr
    },
    {
        "MCFGR0",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_lpi2c_4fifo_mcfgr0
    },
    {
        "STAR",
        "The Slave Transmit ACK Register can only be written when the ACK SCL S"
        "tall bit is set in Slave Configuration Register 1 (SCFGR1[ACKSTALL].",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lpi2c_4fifo_star
    },
    {
        "SASR",
        "",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lpi2c_4fifo_sasr
    },
    {
        "SCFGR2",
        "The SCFGR2 should only be written when the I2C Slave is disabled.",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lpi2c_4fifo_scfgr2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LPIT_4CH_32B
#endif

// Bitfields in register LPIT_4CH_32B_VERID.
static const field_t hw_lpit_4ch_32b_verid[] =
{
    {
        "FEATURE",
        "This read only field returns the feature set number.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read only field returns the minor version number for the module s"
        "pecification",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read only field returns the major version number for the module s"
        "pecification",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_PARAM.
static const field_t hw_lpit_4ch_32b_param[] =
{
    {
        "CHANNEL",
        "Number of timer channels implemented.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EXT_TRIG",
        "Number of external triggers implemented.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_MCR.
static const field_t hw_lpit_4ch_32b_mcr[] =
{
    {
        "M_CEN",
        "Enables the peripheral clock to the module timers.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_RST",
        "Resets all channels and registers, except the Module Control Register.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZE_EN",
        "Allows the timer channels to be stopped or continue to run when the de"
        "vice enters the DOZE mode",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBG_EN",
        "Allows the timer channels to be stopped when the device enters the Deb"
        "ug mode",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_MSR.
static const field_t hw_lpit_4ch_32b_msr[] =
{
    {
        "TIF0",
        "In compare modes, sets to 1 at the end of the timer period.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIF1",
        "In compare modes, sets to 1 at the end of the timer period.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIF2",
        "In compare modes, sets to 1 at the end of the timer period.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIF3",
        "In compare modes, sets to 1 at the end of the timer period.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_MIER.
static const field_t hw_lpit_4ch_32b_mier[] =
{
    {
        "TIE0",
        "Enables interrupt generation when this bit is set to 1 and if correspo"
        "nding Timer Interrupt Flag is asserted.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE1",
        "Enables interrupt generation when this bit is set to 1 and if correspo"
        "nding Timer Interrupt Flag is asserted.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE2",
        "Enables interrupt generation when this bit is set to 1 and if correspo"
        "nding Timer Interrupt Flag is asserted.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE3",
        "Enables interrupt generation when this bit is set to 1 and if correspo"
        "nding Timer Interrupt Flag is asserted.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_TVAL0.
static const field_t hw_lpit_4ch_32b_tval0[] =
{
    {
        "TMR_VAL",
        "In compare modes, TMR_VAL is the timer channel start value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_CVAL0.
static const field_t hw_lpit_4ch_32b_cval0[] =
{
    {
        "TMR_CUR_VAL",
        "Represents the current timer value, if the timer is enabled.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_TCTRL0.
static const field_t hw_lpit_4ch_32b_tctrl0[] =
{
    {
        "T_EN",
        "Enables or disables the Timer Channel",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHAIN",
        "When enabled, timer channel will decrement when channel N-1 trigger as"
        "serts.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Configures the Channel Timer Mode of Operation.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSOT",
        "This bit controls when the timer starts decrementing.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSOI",
        "Controls whether the channel timer will stop after it (the channel tim"
        "er) times out or not.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TROT",
        "When set, the LPIT timer will reload when a rising edge is detected on"
        " the selected trigger input.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRG_SRC",
        "Selects between internal or external trigger sources.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRG_SEL",
        "Selects the trigger to use for starting and/or reloading the LPIT time"
        "r.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_TVAL1.
static const field_t hw_lpit_4ch_32b_tval1[] =
{
    {
        "TMR_VAL",
        "In compare modes, TMR_VAL is the timer channel start value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_CVAL1.
static const field_t hw_lpit_4ch_32b_cval1[] =
{
    {
        "TMR_CUR_VAL",
        "Represents the current timer value, if the timer is enabled.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_TCTRL1.
static const field_t hw_lpit_4ch_32b_tctrl1[] =
{
    {
        "T_EN",
        "Enables or disables the Timer Channel",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHAIN",
        "When enabled, timer channel will decrement when channel N-1 trigger as"
        "serts.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Configures the Channel Timer Mode of Operation.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSOT",
        "This bit controls when the timer starts decrementing.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSOI",
        "Controls whether the channel timer will stop after it (the channel tim"
        "er) times out or not.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TROT",
        "When set, the LPIT timer will reload when a rising edge is detected on"
        " the selected trigger input.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRG_SRC",
        "Selects between internal or external trigger sources.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRG_SEL",
        "Selects the trigger to use for starting and/or reloading the LPIT time"
        "r.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_TVAL2.
static const field_t hw_lpit_4ch_32b_tval2[] =
{
    {
        "TMR_VAL",
        "In compare modes, TMR_VAL is the timer channel start value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_CVAL2.
static const field_t hw_lpit_4ch_32b_cval2[] =
{
    {
        "TMR_CUR_VAL",
        "Represents the current timer value, if the timer is enabled.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_TCTRL2.
static const field_t hw_lpit_4ch_32b_tctrl2[] =
{
    {
        "T_EN",
        "Enables or disables the Timer Channel",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHAIN",
        "When enabled, timer channel will decrement when channel N-1 trigger as"
        "serts.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Configures the Channel Timer Mode of Operation.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSOT",
        "This bit controls when the timer starts decrementing.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSOI",
        "Controls whether the channel timer will stop after it (the channel tim"
        "er) times out or not.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TROT",
        "When set, the LPIT timer will reload when a rising edge is detected on"
        " the selected trigger input.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRG_SRC",
        "Selects between internal or external trigger sources.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRG_SEL",
        "Selects the trigger to use for starting and/or reloading the LPIT time"
        "r.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_TVAL3.
static const field_t hw_lpit_4ch_32b_tval3[] =
{
    {
        "TMR_VAL",
        "In compare modes, TMR_VAL is the timer channel start value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_CVAL3.
static const field_t hw_lpit_4ch_32b_cval3[] =
{
    {
        "TMR_CUR_VAL",
        "Represents the current timer value, if the timer is enabled.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_TCTRL3.
static const field_t hw_lpit_4ch_32b_tctrl3[] =
{
    {
        "T_EN",
        "Enables or disables the Timer Channel",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHAIN",
        "When enabled, timer channel will decrement when channel N-1 trigger as"
        "serts.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Configures the Channel Timer Mode of Operation.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSOT",
        "This bit controls when the timer starts decrementing.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSOI",
        "Controls whether the channel timer will stop after it (the channel tim"
        "er) times out or not.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TROT",
        "When set, the LPIT timer will reload when a rising edge is detected on"
        " the selected trigger input.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRG_SRC",
        "Selects between internal or external trigger sources.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRG_SEL",
        "Selects the trigger to use for starting and/or reloading the LPIT time"
        "r.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_SETTEN.
static const field_t hw_lpit_4ch_32b_setten[] =
{
    {
        "SET_T_EN_0",
        "Writing '1' to this bit will enable the timer channel 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SET_T_EN_1",
        "Writing '1' to this bit will enable the timer channel 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SET_T_EN_2",
        "Writing '1' to this bit will enable the timer channel 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SET_T_EN_3",
        "Writing '1' to this bit will enable the timer channel 3.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPIT_4CH_32B_CLRTEN.
static const field_t hw_lpit_4ch_32b_clrten[] =
{
    {
        "CLR_T_EN_0",
        "Writing a '1' to this bit will disable the timer channel 0.",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CLR_T_EN_1",
        "Writing a '1' to this bit will disable the timer channel 1.",
        1, // LSB
        1, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CLR_T_EN_2",
        "Writing a '1' to this bit will disable the timer channel 2.",
        2, // LSB
        2, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CLR_T_EN_3",
        "Writing a '1' to this bit will disable the timer channel 3.",
        3, // LSB
        3, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a LPIT_4CH_32B module.
static const reg_t hw_lpit_4ch_32b[] =
{
    {
        "VERID",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_lpit_4ch_32b_verid
    },
    {
        "PARAM",
        "This register provides details on the parameter settings that were use"
        "d while including this module in the device.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lpit_4ch_32b_param
    },
    {
        "MCR",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lpit_4ch_32b_mcr
    },
    {
        "MSR",
        "Unless the M_CEN bit in MCR register is set (=1), reading or writing t"
        "his register will generate a transfer error.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lpit_4ch_32b_msr
    },
    {
        "MIER",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lpit_4ch_32b_mier
    },
    {
        "TVAL0",
        "In compare modes, the TVALn registers select the timeout period for th"
        "e timer channels.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lpit_4ch_32b_tval0
    },
    {
        "CVAL0",
        "These registers indicate the current timer counter value.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_lpit_4ch_32b_cval0
    },
    {
        "TCTRL0",
        "These registers contain the control bits for each timer channel.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_lpit_4ch_32b_tctrl0
    },
    {
        "TVAL1",
        "In compare modes, the TVALn registers select the timeout period for th"
        "e timer channels.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lpit_4ch_32b_tval1
    },
    {
        "CVAL1",
        "These registers indicate the current timer counter value.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_lpit_4ch_32b_cval1
    },
    {
        "TCTRL1",
        "These registers contain the control bits for each timer channel.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_lpit_4ch_32b_tctrl1
    },
    {
        "TVAL2",
        "In compare modes, the TVALn registers select the timeout period for th"
        "e timer channels.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lpit_4ch_32b_tval2
    },
    {
        "CVAL2",
        "These registers indicate the current timer counter value.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_lpit_4ch_32b_cval2
    },
    {
        "TCTRL2",
        "These registers contain the control bits for each timer channel.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_lpit_4ch_32b_tctrl2
    },
    {
        "TVAL3",
        "In compare modes, the TVALn registers select the timeout period for th"
        "e timer channels.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lpit_4ch_32b_tval3
    },
    {
        "CVAL3",
        "These registers indicate the current timer counter value.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_lpit_4ch_32b_cval3
    },
    {
        "TCTRL3",
        "These registers contain the control bits for each timer channel.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_lpit_4ch_32b_tctrl3
    },
    {
        "SETTEN",
        "This register allows simulataneous enabling of timer channels.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lpit_4ch_32b_setten
    },
    {
        "CLRTEN",
        "Unless the M_CEN bit in MCR register is set (=1), reading or writing t"
        "his register will generate a transfer error.",
        4, // Width in bytes
        0x00000018, // Base address offset
        false, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lpit_4ch_32b_clrten
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LPSPI_4FIFO_30MHZ_MASTER
#endif

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_VERID.
static const field_t hw_lpspi_4fifo_30mhz_master_verid[] =
{
    {
        "FEATURE",
        "This read-only field returns the feature set number.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read-only field returns the minor version number for the module s"
        "pecification.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read-only field returns the major version number for the module s"
        "pecification.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_PARAM.
static const field_t hw_lpspi_4fifo_30mhz_master_param[] =
{
    {
        "TXFIFO",
        "Sets the maximum number of words in the transmit FIFO, which is 2TXFIF"
        "O.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFIFO",
        "Sets the maximum number of words in the receive FIFO, which is 2RXFIFO"
        ".",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_CR.
static const field_t hw_lpspi_4fifo_30mhz_master_cr[] =
{
    {
        "MEN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        "Reset all internal logic and registers, except the Control Register.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZEN",
        "Enables or disables Doze mode",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTF",
        "",
        8, // LSB
        8, // MSB
        false, // Readable
        false // Writable
    },
    {
        "RRF",
        "",
        9, // LSB
        9, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_SR.
static const field_t hw_lpspi_4fifo_30mhz_master_sr[] =
{
    {
        "TDF",
        "The Transmit Data Flag is set whenever the number of words in the tran"
        "smit FIFO is equal or less than TXWATER.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDF",
        "The Receive Data Flag is set whenever the number of words in the recei"
        "ve FIFO is greater than RXWATER.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WCF",
        "This flag will set when the last bit of a received word is sampled.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCF",
        "This flag will set at the end of each frame transfer, when the PCS neg"
        "ates.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCF",
        "This flag will set in master mode when the LPSPI returns to idle state"
        " with the transmit FIFO empty.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEF",
        "This flag will set when the Transmit FIFO underruns.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF",
        "This flag will set when the Receiver FIFO overflows.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMF",
        "Indicates that the received data has matched the MATCH0 and/or MATCH1 "
        "fields as configured by MATCFG.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MBF",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_IER.
static const field_t hw_lpspi_4fifo_30mhz_master_ier[] =
{
    {
        "TDIE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDIE",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCIE",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCIE",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCIE",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEIE",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REIE",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMIE",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_DER.
static const field_t hw_lpspi_4fifo_30mhz_master_der[] =
{
    {
        "TDDE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDDE",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_CFGR1.
static const field_t hw_lpspi_4fifo_30mhz_master_cfgr1[] =
{
    {
        "MASTER",
        "Configures the LPSPI in master or slave mode.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SAMPLE",
        "When set, the LPSPI master will sample the input data on a delayed LPS"
        "PI_SCK edge.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTOPCS",
        "The LPSPI slave normally requires the PCS to negate between frames for"
        " correct operation.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NOSTALL",
        "In master mode, the LPSPI will stall transfers when the transmit FIFO "
        "is empty or receive FIFO is full ensuring that no transmit FIFO underr"
        "un or receive FIFO overrun can occur.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCSPOL",
        "Configures the polarity of each Peripheral Chip Select pin.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MATCFG",
        "Configures the condition that will cause the DMF to set.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "Configures which pins are used for input and output data during single"
        " bit transfers.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTCFG",
        "Configures if the output data is tristated between accesses (LPSPI_PCS"
        " is negated).",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCSCFG",
        "PCSCFG must be set if performing 4-bit transfers.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_TDR.
static const field_t hw_lpspi_4fifo_30mhz_master_tdr[] =
{
    {
        "DATA",
        "Both 8-bit and 16-bit writes of transmit data will zero extend the dat"
        "a written and push the data into the transmit FIFO.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_RDR.
static const field_t hw_lpspi_4fifo_30mhz_master_rdr[] =
{
    {
        "DATA",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_FCR.
static const field_t hw_lpspi_4fifo_30mhz_master_fcr[] =
{
    {
        "TXWATER",
        "The Transmit Data Flag is set whenever the number of words in the tran"
        "smit FIFO is equal or less than TXWATER.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXWATER",
        "The Receive Data Flag is set whenever the number of words in the recei"
        "ve FIFO is greater than RXWATER.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_FSR.
static const field_t hw_lpspi_4fifo_30mhz_master_fsr[] =
{
    {
        "TXCOUNT",
        "Returns the number of words currently stored in the transmit FIFO.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXCOUNT",
        "Returns the number of words currently stored in the receive FIFO.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_TCR.
static const field_t hw_lpspi_4fifo_30mhz_master_tcr[] =
{
    {
        "FRAMESZ",
        "Configures the frame size in number of bits equal to (FRAMESZ + 1).",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIDTH",
        "Either RXMSK or TXMSK must be set for 2-bit or 4-bit transfers.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXMSK",
        "When set, transmit data is masked (no data is loaded from transmit FIF"
        "O and output pin is tristated).",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXMSK",
        "When set, receive data is masked (receive data is not stored in receiv"
        "e FIFO).",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CONTC",
        "In master mode, this bit allows the command word to be changed within "
        "a continuous transfer.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CONT",
        "In master mode, continuous transfer will keep the PCS asserted at the "
        "end of the frame size, until a command word is received that starts a "
        "new frame.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYSW",
        "Byte swap will swap the contents of [31:24] with [7:0] and [23:16] wit"
        "h [15:8] for each transmit data word read from the FIFO and each recei"
        "ved data word stored to the FIFO (or compared with match registers).",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LSBF",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "Configures the peripheral chip select used for the transfer.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESCALE",
        "Prescaler applied to the clock configuration register for all SPI bus "
        "transfers.",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPHA",
        "This field is only updated between frames.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPOL",
        "This field is only updated between frames.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_DMR0.
static const field_t hw_lpspi_4fifo_30mhz_master_dmr0[] =
{
    {
        "MATCH0",
        "Compared against the received data when receive data match is enabled.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_RSR.
static const field_t hw_lpspi_4fifo_30mhz_master_rsr[] =
{
    {
        "SOF",
        "Indicates that this is the first data word received after LPSPI_PCS as"
        "sertion.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXEMPTY",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_CFGR0.
static const field_t hw_lpspi_4fifo_30mhz_master_cfgr0[] =
{
    {
        "HREN",
        "When enabled in master mode, the LPSPI will only start a new SPI bus t"
        "ransfer if the host request input is asserted.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HRPOL",
        "Configures the polarity of the host request pin.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HRSEL",
        "Selects the source of the host request input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIRFIFO",
        "When enabled, the transmit FIFO read pointer is saved to a temporary r"
        "egister.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMO",
        "When enabled, all received data that does not cause DMF to set is disc"
        "arded.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_DMR1.
static const field_t hw_lpspi_4fifo_30mhz_master_dmr1[] =
{
    {
        "MATCH1",
        "Compared against the received data when receive data match is enabled.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_4FIFO_30MHZ_MASTER_CCR.
static const field_t hw_lpspi_4fifo_30mhz_master_ccr[] =
{
    {
        "SCKDIV",
        "Configures the divide ratio of the SCK pin in master mode.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBT",
        "Configures the delay in master mode from the PCS negation to the next "
        "PCS assertion.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCSSCK",
        "Configures the delay in master mode from the PCS assertion to the firs"
        "t SCK edge.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCKPCS",
        "Configures the delay in master mode from the last SCK edge to the PCS "
        "negation.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a LPSPI_4FIFO_30MHZ_MASTER module.
static const reg_t hw_lpspi_4fifo_30mhz_master[] =
{
    {
        "VERID",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_verid
    },
    {
        "PARAM",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_param
    },
    {
        "CR",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_cr
    },
    {
        "SR",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_sr
    },
    {
        "IER",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_ier
    },
    {
        "DER",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_der
    },
    {
        "CFGR1",
        "The CFGR1 should only be written when the LPSPI is disabled.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_cfgr1
    },
    {
        "TDR",
        "Writes to either the Transmit Command Register or Transmit Data Regist"
        "er will push the data into the transmit FIFO, in the order that it was"
        " written.",
        4, // Width in bytes
        0x00000064, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_tdr
    },
    {
        "RDR",
        "",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_rdr
    },
    {
        "FCR",
        "",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_fcr
    },
    {
        "FSR",
        "",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_fsr
    },
    {
        "TCR",
        "Writes to either the Transmit Command Register or Transmit Data Regist"
        "er will push the data into the transmit FIFO, in the order that they a"
        "re written.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_tcr
    },
    {
        "DMR0",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_dmr0
    },
    {
        "RSR",
        "",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_rsr
    },
    {
        "CFGR0",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_cfgr0
    },
    {
        "DMR1",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_dmr1
    },
    {
        "CCR",
        "The CCR is only used in master mode and cannot be changed when the LPS"
        "PI is enabled.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lpspi_4fifo_30mhz_master_ccr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LPSPI_16FIFO_60MHZ_MASTER
#endif

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_VERID.
static const field_t hw_lpspi_16fifo_60mhz_master_verid[] =
{
    {
        "FEATURE",
        "This read-only field returns the feature set number.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read-only field returns the minor version number for the module s"
        "pecification.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read-only field returns the major version number for the module s"
        "pecification.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_PARAM.
static const field_t hw_lpspi_16fifo_60mhz_master_param[] =
{
    {
        "TXFIFO",
        "Sets the maximum number of words in the transmit FIFO, which is 2TXFIF"
        "O.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFIFO",
        "Sets the maximum number of words in the receive FIFO, which is 2RXFIFO"
        ".",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_CR.
static const field_t hw_lpspi_16fifo_60mhz_master_cr[] =
{
    {
        "MEN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        "Reset all internal logic and registers, except the Control Register.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZEN",
        "Enables or disables Doze mode",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTF",
        "",
        8, // LSB
        8, // MSB
        false, // Readable
        false // Writable
    },
    {
        "RRF",
        "",
        9, // LSB
        9, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_SR.
static const field_t hw_lpspi_16fifo_60mhz_master_sr[] =
{
    {
        "TDF",
        "The Transmit Data Flag is set whenever the number of words in the tran"
        "smit FIFO is equal or less than TXWATER.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDF",
        "The Receive Data Flag is set whenever the number of words in the recei"
        "ve FIFO is greater than RXWATER.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WCF",
        "This flag will set when the last bit of a received word is sampled.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCF",
        "This flag will set at the end of each frame transfer, when the PCS neg"
        "ates.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCF",
        "This flag will set in master mode when the LPSPI returns to idle state"
        " with the transmit FIFO empty.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEF",
        "This flag will set when the Transmit FIFO underruns.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF",
        "This flag will set when the Receiver FIFO overflows.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMF",
        "Indicates that the received data has matched the MATCH0 and/or MATCH1 "
        "fields as configured by MATCFG.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MBF",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_IER.
static const field_t hw_lpspi_16fifo_60mhz_master_ier[] =
{
    {
        "TDIE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDIE",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCIE",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCIE",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCIE",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEIE",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REIE",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMIE",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_DER.
static const field_t hw_lpspi_16fifo_60mhz_master_der[] =
{
    {
        "TDDE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDDE",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_CFGR1.
static const field_t hw_lpspi_16fifo_60mhz_master_cfgr1[] =
{
    {
        "MASTER",
        "Configures the LPSPI in master or slave mode.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SAMPLE",
        "When set, the LPSPI master will sample the input data on a delayed LPS"
        "PI_SCK edge.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTOPCS",
        "The LPSPI slave normally requires the PCS to negate between frames for"
        " correct operation.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NOSTALL",
        "In master mode, the LPSPI will stall transfers when the transmit FIFO "
        "is empty or receive FIFO is full ensuring that no transmit FIFO underr"
        "un or receive FIFO overrun can occur.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCSPOL",
        "Configures the polarity of each Peripheral Chip Select pin.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MATCFG",
        "Configures the condition that will cause the DMF to set.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINCFG",
        "Configures which pins are used for input and output data during single"
        " bit transfers.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTCFG",
        "Configures if the output data is tristated between accesses (LPSPI_PCS"
        " is negated).",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCSCFG",
        "PCSCFG must be set if performing 4-bit transfers.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_TDR.
static const field_t hw_lpspi_16fifo_60mhz_master_tdr[] =
{
    {
        "DATA",
        "Both 8-bit and 16-bit writes of transmit data will zero extend the dat"
        "a written and push the data into the transmit FIFO.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_RDR.
static const field_t hw_lpspi_16fifo_60mhz_master_rdr[] =
{
    {
        "DATA",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_FCR.
static const field_t hw_lpspi_16fifo_60mhz_master_fcr[] =
{
    {
        "TXWATER",
        "The Transmit Data Flag is set whenever the number of words in the tran"
        "smit FIFO is equal or less than TXWATER.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXWATER",
        "The Receive Data Flag is set whenever the number of words in the recei"
        "ve FIFO is greater than RXWATER.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_FSR.
static const field_t hw_lpspi_16fifo_60mhz_master_fsr[] =
{
    {
        "TXCOUNT",
        "Returns the number of words currently stored in the transmit FIFO.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXCOUNT",
        "Returns the number of words currently stored in the receive FIFO.",
        16, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_TCR.
static const field_t hw_lpspi_16fifo_60mhz_master_tcr[] =
{
    {
        "FRAMESZ",
        "Configures the frame size in number of bits equal to (FRAMESZ + 1).",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIDTH",
        "Either RXMSK or TXMSK must be set for 2-bit or 4-bit transfers.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXMSK",
        "When set, transmit data is masked (no data is loaded from transmit FIF"
        "O and output pin is tristated).",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXMSK",
        "When set, receive data is masked (receive data is not stored in receiv"
        "e FIFO).",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CONTC",
        "In master mode, this bit allows the command word to be changed within "
        "a continuous transfer.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CONT",
        "In master mode, continuous transfer will keep the PCS asserted at the "
        "end of the frame size, until a command word is received that starts a "
        "new frame.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYSW",
        "Byte swap will swap the contents of [31:24] with [7:0] and [23:16] wit"
        "h [15:8] for each transmit data word read from the FIFO and each recei"
        "ved data word stored to the FIFO (or compared with match registers).",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LSBF",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "Configures the peripheral chip select used for the transfer.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESCALE",
        "Prescaler applied to the clock configuration register for all SPI bus "
        "transfers.",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPHA",
        "This field is only updated between frames.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPOL",
        "This field is only updated between frames.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_DMR0.
static const field_t hw_lpspi_16fifo_60mhz_master_dmr0[] =
{
    {
        "MATCH0",
        "Compared against the received data when receive data match is enabled.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_RSR.
static const field_t hw_lpspi_16fifo_60mhz_master_rsr[] =
{
    {
        "SOF",
        "Indicates that this is the first data word received after LPSPI_PCS as"
        "sertion.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXEMPTY",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_CFGR0.
static const field_t hw_lpspi_16fifo_60mhz_master_cfgr0[] =
{
    {
        "HREN",
        "When enabled in master mode, the LPSPI will only start a new SPI bus t"
        "ransfer if the host request input is asserted.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HRPOL",
        "Configures the polarity of the host request pin.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HRSEL",
        "Selects the source of the host request input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIRFIFO",
        "When enabled, the transmit FIFO read pointer is saved to a temporary r"
        "egister.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMO",
        "When enabled, all received data that does not cause DMF to set is disc"
        "arded.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_DMR1.
static const field_t hw_lpspi_16fifo_60mhz_master_dmr1[] =
{
    {
        "MATCH1",
        "Compared against the received data when receive data match is enabled.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPSPI_16FIFO_60MHZ_MASTER_CCR.
static const field_t hw_lpspi_16fifo_60mhz_master_ccr[] =
{
    {
        "SCKDIV",
        "Configures the divide ratio of the SCK pin in master mode.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBT",
        "Configures the delay in master mode from the PCS negation to the next "
        "PCS assertion.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCSSCK",
        "Configures the delay in master mode from the PCS assertion to the firs"
        "t SCK edge.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCKPCS",
        "Configures the delay in master mode from the last SCK edge to the PCS "
        "negation.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a LPSPI_16FIFO_60MHZ_MASTER module.
static const reg_t hw_lpspi_16fifo_60mhz_master[] =
{
    {
        "VERID",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_verid
    },
    {
        "PARAM",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_param
    },
    {
        "CR",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_cr
    },
    {
        "SR",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_sr
    },
    {
        "IER",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_ier
    },
    {
        "DER",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_der
    },
    {
        "CFGR1",
        "The CFGR1 should only be written when the LPSPI is disabled.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_cfgr1
    },
    {
        "TDR",
        "Writes to either the Transmit Command Register or Transmit Data Regist"
        "er will push the data into the transmit FIFO, in the order that it was"
        " written.",
        4, // Width in bytes
        0x00000064, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_tdr
    },
    {
        "RDR",
        "",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_rdr
    },
    {
        "FCR",
        "",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_fcr
    },
    {
        "FSR",
        "",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_fsr
    },
    {
        "TCR",
        "Writes to either the Transmit Command Register or Transmit Data Regist"
        "er will push the data into the transmit FIFO, in the order that they a"
        "re written.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_tcr
    },
    {
        "DMR0",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_dmr0
    },
    {
        "RSR",
        "",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_rsr
    },
    {
        "CFGR0",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_cfgr0
    },
    {
        "DMR1",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_dmr1
    },
    {
        "CCR",
        "The CCR is only used in master mode and cannot be changed when the LPS"
        "PI is enabled.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lpspi_16fifo_60mhz_master_ccr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LPTIMER_16B_1CH
#endif

// Bitfields in register LPTIMER_16B_1CH_CSR.
static const field_t hw_lptimer_16b_1ch_csr[] =
{
    {
        "TEN",
        "When TEN is clear, it resets the LPTMR internal logic, including the C"
        "NR and TCF.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMS",
        "Configures the mode of the LPTMR.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFC",
        "When clear, TFC configures the CNR to reset whenever TCF is set.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPP",
        "Configures the polarity of the input source in Pulse Counter mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPS",
        "Configures the input source to be used in Pulse Counter mode.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE",
        "When TIE is set, the LPTMR Interrupt is generated whenever TCF is also"
        " set.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCF",
        "TCF is set when the LPTMR is enabled and the CNR equals the CMR and in"
        "crements.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDRE",
        "When TDRE is set, the LPTMR DMA Request is generated whenever TCF is a"
        "lso set and the TCF is cleared when the DMA Controller is done.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTIMER_16B_1CH_PSR.
static const field_t hw_lptimer_16b_1ch_psr[] =
{
    {
        "PCS",
        "Selects the clock to be used by the LPTMR prescaler/glitch filter.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PBYP",
        "When PBYP is set, the selected prescaler clock in Time Counter mode or"
        " selected input source in Pulse Counter mode directly clocks the CNR.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESCALE",
        "Configures the size of the Prescaler in Time Counter mode or width of "
        "the glitch filter in Pulse Counter mode.",
        3, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTIMER_16B_1CH_CMR.
static const field_t hw_lptimer_16b_1ch_cmr[] =
{
    {
        "COMPARE",
        "When the LPTMR is enabled and the CNR equals the value in the CMR and "
        "increments, TCF is set and the hardware trigger asserts until the next"
        " time the CNR increments.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTIMER_16B_1CH_CNR.
static const field_t hw_lptimer_16b_1ch_cnr[] =
{
    {
        "COUNTER",
        "The CNR returns the current value of the LPTMR counter at the time thi"
        "s register was last written.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a LPTIMER_16B_1CH module.
static const reg_t hw_lptimer_16b_1ch[] =
{
    {
        "CSR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_lptimer_16b_1ch_csr
    },
    {
        "PSR",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_lptimer_16b_1ch_psr
    },
    {
        "CMR",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lptimer_16b_1ch_cmr
    },
    {
        "CNR",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lptimer_16b_1ch_cnr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LPUART_4W_FIFO
#endif

// Bitfields in register LPUART_4W_FIFO_BAUD.
static const field_t hw_lpuart_4w_fifo_baud[] =
{
    {
        "SBR",
        "The 13 bits in SBR[12:0] set the modulo divide rate for the baud rate "
        "generator.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBNS",
        "SBNS determines whether data characters are one or two stop bits.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEDGIE",
        "Enables the receive input active edge, RXEDGIF, to generate interrupt "
        "requests.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBKDIE",
        "LBKDIE enables the LIN break detect flag, LBKDIF, to generate interrup"
        "t requests.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESYNCDIS",
        "When set, disables the resynchronization of the received data word whe"
        "n a data one followed by data zero transition is detected.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOTHEDGE",
        "Enables sampling of the received data on both edges of the baud rate c"
        "lock, effectively doubling the number of times the receiver samples th"
        "e input data for a given oversampling ratio.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MATCFG",
        "Configures the match addressing mode used.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIDMAE",
        "RIDMAE configures the receiver idle flag, LPUART_STAT[IDLE], to genera"
        "te a DMA request.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMAE",
        "RDMAE configures the receiver data register full flag, LPUART_STAT[RDR"
        "F], to generate a DMA request.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMAE",
        "TDMAE configures the transmit data register empty flag, LPUART_STAT[TD"
        "RE], to generate a DMA request.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSR",
        "This field configures the oversampling ratio for the receiver.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M10",
        "The M10 bit causes a tenth bit to be part of the serial transmission.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAEN2",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAEN1",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_4W_FIFO_STAT.
static const field_t hw_lpuart_4w_fifo_stat[] =
{
    {
        "MA2F",
        "MA2F is set whenever the next character to be read from LPUART_DATA ma"
        "tches MA2.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MA1F",
        "MA1F is set whenever the next character to be read from LPUART_DATA ma"
        "tches MA1.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PF",
        "PF is set whenever the next character to be read from LPUART_DATA was "
        "received when parity is enabled (PE = 1) and the parity bit in the rec"
        "eived character does not agree with the expected parity value.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FE",
        "FE is set whenever the next character to be read from LPUART_DATA was "
        "received with logic 0 detected where a stop bit was expected.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NF",
        "The advanced sampling technique used in the receiver takes three sampl"
        "es in each of the received bits.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OR",
        "OR is set when software fails to prevent the receive data register fro"
        "m overflowing with data.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE",
        "IDLE is set when the LPUART receive line becomes idle for a full chara"
        "cter time after a period of activity.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDRF",
        "When the receive FIFO is enabled, RDRF is set when the number of dataw"
        "ords in the receive buffer is greater than the number indicated by LPU"
        "ART_WATER[RXWATER].",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TC",
        "TC is cleared when there is a transmission in progress or when a pream"
        "ble or break character is loaded.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDRE",
        "When the transmit FIFO is enabled, TDRE will set when the number of da"
        "tawords in the transmit FIFO (LPUART_DATA) is equal to or less than th"
        "e number indicated by LPUART_WATER[TXWATER]).",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RAF",
        "RAF is set when the receiver detects the beginning of a valid start bi"
        "t, and RAF is cleared automatically when the receiver detects an idle "
        "line.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LBKDE",
        "LBKDE selects a longer break character detection length.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRK13",
        "BRK13 selects a longer transmitted break character length.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWUID",
        "For RWU on idle character, RWUID controls whether the idle character t"
        "hat wakes up the receiver sets the IDLE bit.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXINV",
        "Setting this bit reverses the polarity of the received data input.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSBF",
        "Setting this bit reverses the order of the bits that are transmitted a"
        "nd received on the wire.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEDGIF",
        "RXEDGIF is set whenever the receiver is enabled and an active edge, fa"
        "lling if RXINV = 0, rising if RXINV=1, on the RXD pin occurs.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBKDIF",
        "LBKDIF is set when the LIN break detect circuitry is enabled and a LIN"
        " break character is detected.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_4W_FIFO_CTRL.
static const field_t hw_lpuart_4w_fifo_ctrl[] =
{
    {
        "PT",
        "Provided parity is enabled (PE = 1), this bit selects even or odd pari"
        "ty.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Enables hardware parity generation and checking.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ILT",
        "Determines when the receiver starts counting logic 1s as idle characte"
        "r bits.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKE",
        "Determines which condition wakes the LPUART when RWU=1: Address mark i"
        "n the bit preceding the stop bit (or bit preceding the parity bit when"
        " parity is enabled) of the received data character, or An idle conditi"
        "on on the receive pin input signal.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRC",
        "This field has no meaning or effect unless the LOOPS field is set.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZEEN",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOPS",
        "When LOOPS is set, the RXD pin is disconnected from the LPUART and the"
        " transmitter output is internally connected to the receiver input.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLECFG",
        "Configures the number of idle characters that must be received before "
        "the IDLE flag is set.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M7",
        "This bit should only be changed when the transmitter and receiver are "
        "both disabled.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MA2IE",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MA1IE",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBK",
        "Writing a 1 and then a 0 to SBK queues a break character in the transm"
        "it data stream.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWU",
        "This field can be set to place the LPUART receiver in a standby state.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE",
        "Enables the LPUART receiver.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE",
        "Enables the LPUART transmitter.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ILIE",
        "ILIE enables the idle line flag, STAT[IDLE], to generate interrupt req"
        "uests.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIE",
        "Enables STAT[RDRF] to generate interrupt requests.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCIE",
        "TCIE enables the transmission complete flag, TC, to generate interrupt"
        " requests.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE",
        "Enables STAT[TDRE] to generate interrupt requests.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEIE",
        "This bit enables the parity error flag (PF) to generate hardware inter"
        "rupt requests.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FEIE",
        "This bit enables the framing error flag (FE) to generate hardware inte"
        "rrupt requests.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEIE",
        "This bit enables the noise flag (NF) to generate hardware interrupt re"
        "quests.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ORIE",
        "This bit enables the overrun flag (OR) to generate hardware interrupt "
        "requests.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXINV",
        "Setting this bit reverses the polarity of the transmitted data output.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXDIR",
        "When the LPUART is configured for single-wire half-duplex operation (L"
        "OOPS = RSRC = 1), this bit determines the direction of data at the TXD"
        " pin.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R9T8",
        "R9 is the tenth data bit received when the LPUART is configured for 10"
        "-bit data formats.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R8T9",
        "R8 is the ninth data bit received when the LPUART is configured for 9-"
        "bit or 10-bit data formats.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_4W_FIFO_DATA.
static const field_t hw_lpuart_4w_fifo_data[] =
{
    {
        "R0T0",
        "Read receive data buffer 0 or write transmit data buffer 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R1T1",
        "Read receive data buffer 1 or write transmit data buffer 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R2T2",
        "Read receive data buffer 2 or write transmit data buffer 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R3T3",
        "Read receive data buffer 3 or write transmit data buffer 3.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R4T4",
        "Read receive data buffer 4 or write transmit data buffer 4.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R5T5",
        "Read receive data buffer 5 or write transmit data buffer 5.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R6T6",
        "Read receive data buffer 6 or write transmit data buffer 6.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R7T7",
        "Read receive data buffer 7 or write transmit data buffer 7.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R8T8",
        "Read receive data buffer 8 or write transmit data buffer 8.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R9T9",
        "Read receive data buffer 9 or write transmit data buffer 9.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLINE",
        "Indicates the receiver line was idle before receiving the character in"
        " DATA[9:0].",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXEMPT",
        "Asserts when there is no data in the receive buffer.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FRETSC",
        "For reads, indicates the current received dataword contained in DATA[R"
        "9:R0] was received with a frame error.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PARITYE",
        "The current received dataword contained in DATA[R9:R0] was received wi"
        "th a parity error.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NOISY",
        "The current received dataword contained in DATA[R9:R0] was received wi"
        "th noise.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_4W_FIFO_MATCH.
static const field_t hw_lpuart_4w_fifo_match[] =
{
    {
        "MA1",
        "The MA1 and MA2 registers are compared to input data addresses when th"
        "e most significant bit is set and the associated BAUD[MAEN] bit is set"
        ".",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MA2",
        "The MA1 and MA2 registers are compared to input data addresses when th"
        "e most significant bit is set and the associated BAUD[MAEN] bit is set"
        ".",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_4W_FIFO_MODIR.
static const field_t hw_lpuart_4w_fifo_modir[] =
{
    {
        "TXCTSE",
        "TXCTSE controls the operation of the transmitter.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRTSE",
        "Controls RTS before and after a transmission.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRTSPOL",
        "Controls the polarity of the transmitter RTS.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXRTSE",
        "Allows the RTS output to control the CTS input of the transmitting dev"
        "ice to prevent receiver overrun.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCTSC",
        "Configures if the CTS state is checked at the start of each character "
        "or only when the transmitter is idle.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCTSSRC",
        "Configures the source of the CTS input.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTSWATER",
        "Configures the assertion and negation of the RX RTS_B output.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNP",
        "Configures whether the LPUART transmits a 1/OSR, 2/OSR, 3/OSR or 4/OSR"
        " narrow pulse when IR is enabled.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IREN",
        "Enables/disables the infrared modulation/demodulation.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_4W_FIFO_FIFO.
static const field_t hw_lpuart_4w_fifo_fifo[] =
{
    {
        "RXFIFOSIZE",
        "The maximum number of receive datawords that can be stored in the rece"
        "ive buffer before an overrun occurs.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFE",
        "When this field is set, the built in FIFO structure for the receive bu"
        "ffer is enabled.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOSIZE",
        "The maximum number of transmit datawords that can be stored in the tra"
        "nsmit buffer.",
        4, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXFE",
        "When this field is set, the built in FIFO structure for the transmit b"
        "uffer is enabled.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXUFE",
        "When this field is set, the RXUF flag generates an interrupt to the ho"
        "st.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXOFE",
        "When this field is set, the TXOF flag generates an interrupt to the ho"
        "st.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXIDEN",
        "When set, enables the assertion of RDRF when the receiver is idle for "
        "a number of idle characters and the FIFO is not empty.",
        10, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFLUSH",
        "Writing to this field causes all data that is stored in the receive FI"
        "FO/buffer to be flushed.",
        14, // LSB
        14, // MSB
        false, // Readable
        false // Writable
    },
    {
        "TXFLUSH",
        "Writing to this field causes all data that is stored in the transmit F"
        "IFO/buffer to be flushed.",
        15, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "RXUF",
        "Indicates that more data has been read from the receive buffer than wa"
        "s present.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXOF",
        "Indicates that more data has been written to the transmit buffer than "
        "it can hold.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEMPT",
        "Asserts when there is no data in the receive FIFO/Buffer.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXEMPT",
        "Asserts when there is no data in the Transmit FIFO/buffer.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_4W_FIFO_WATER.
static const field_t hw_lpuart_4w_fifo_water[] =
{
    {
        "TXWATER",
        "When the number of datawords in the transmit FIFO/buffer is equal to o"
        "r less than the value in this register field, an interrupt or a DMA re"
        "quest is generated.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCOUNT",
        "The value in this register indicates the number of datawords that are "
        "in the transmit FIFO/buffer.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXWATER",
        "When the number of datawords in the receive FIFO/buffer is greater tha"
        "n the value in this register field, an interrupt or a DMA request is g"
        "enerated.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXCOUNT",
        "The value in this register indicates the number of datawords that are "
        "in the receive FIFO/buffer.",
        24, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_4W_FIFO_VERID.
static const field_t hw_lpuart_4w_fifo_verid[] =
{
    {
        "FEATURE",
        "This read only field returns the feature set number.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read only field returns the minor version number for the module s"
        "pecification.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read only field returns the major version number for the module s"
        "pecification.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_4W_FIFO_PARAM.
static const field_t hw_lpuart_4w_fifo_param[] =
{
    {
        "TXFIFO",
        "The number of words in the transmit FIFO is 2^TXFIFO.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFIFO",
        "The number of words in the receive FIFO is 2^RXFIFO.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_4W_FIFO_GLOBAL.
static const field_t hw_lpuart_4w_fifo_global[] =
{
    {
        "RST",
        "Reset all internal logic and registers, except the Global Register.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_4W_FIFO_PINCFG.
static const field_t hw_lpuart_4w_fifo_pincfg[] =
{
    {
        "TRGSEL",
        "Configures the input trigger usage.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a LPUART_4W_FIFO module.
static const reg_t hw_lpuart_4w_fifo[] =
{
    {
        "BAUD",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_lpuart_4w_fifo_baud
    },
    {
        "STAT",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_lpuart_4w_fifo_stat
    },
    {
        "CTRL",
        "This read/write register controls various optional features of the LPU"
        "ART system.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        28, // Number of bitfields
        hw_lpuart_4w_fifo_ctrl
    },
    {
        "DATA",
        "This register is two separate registers.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_lpuart_4w_fifo_data
    },
    {
        "MATCH",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lpuart_4w_fifo_match
    },
    {
        "MODIR",
        "The MODEM register controls options for setting the modem configuratio"
        "n.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_lpuart_4w_fifo_modir
    },
    {
        "FIFO",
        "This register provides the ability for the programmer to turn on and o"
        "ff FIFO functionality.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_lpuart_4w_fifo_fifo
    },
    {
        "WATER",
        "This register provides the ability to set a programmable threshold for"
        " notification of needing additional transmit data.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lpuart_4w_fifo_water
    },
    {
        "VERID",
        "The Version ID register indicates the version integrated for this inst"
        "ance on the device and also indicates inclusion/exclusion of several o"
        "ptional features.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_lpuart_4w_fifo_verid
    },
    {
        "PARAM",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lpuart_4w_fifo_param
    },
    {
        "GLOBAL",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lpuart_4w_fifo_global
    },
    {
        "PINCFG",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lpuart_4w_fifo_pincfg
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LPUART_8W_FIFO
#endif

// Bitfields in register LPUART_8W_FIFO_BAUD.
static const field_t hw_lpuart_8w_fifo_baud[] =
{
    {
        "SBR",
        "The 13 bits in SBR[12:0] set the modulo divide rate for the baud rate "
        "generator.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBNS",
        "SBNS determines whether data characters are one or two stop bits.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEDGIE",
        "Enables the receive input active edge, RXEDGIF, to generate interrupt "
        "requests.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBKDIE",
        "LBKDIE enables the LIN break detect flag, LBKDIF, to generate interrup"
        "t requests.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESYNCDIS",
        "When set, disables the resynchronization of the received data word whe"
        "n a data one followed by data zero transition is detected.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOTHEDGE",
        "Enables sampling of the received data on both edges of the baud rate c"
        "lock, effectively doubling the number of times the receiver samples th"
        "e input data for a given oversampling ratio.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MATCFG",
        "Configures the match addressing mode used.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIDMAE",
        "RIDMAE configures the receiver idle flag, LPUART_STAT[IDLE], to genera"
        "te a DMA request.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDMAE",
        "RDMAE configures the receiver data register full flag, LPUART_STAT[RDR"
        "F], to generate a DMA request.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDMAE",
        "TDMAE configures the transmit data register empty flag, LPUART_STAT[TD"
        "RE], to generate a DMA request.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSR",
        "This field configures the oversampling ratio for the receiver.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M10",
        "The M10 bit causes a tenth bit to be part of the serial transmission.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAEN2",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAEN1",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_8W_FIFO_STAT.
static const field_t hw_lpuart_8w_fifo_stat[] =
{
    {
        "MA2F",
        "MA2F is set whenever the next character to be read from LPUART_DATA ma"
        "tches MA2.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MA1F",
        "MA1F is set whenever the next character to be read from LPUART_DATA ma"
        "tches MA1.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PF",
        "PF is set whenever the next character to be read from LPUART_DATA was "
        "received when parity is enabled (PE = 1) and the parity bit in the rec"
        "eived character does not agree with the expected parity value.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FE",
        "FE is set whenever the next character to be read from LPUART_DATA was "
        "received with logic 0 detected where a stop bit was expected.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NF",
        "The advanced sampling technique used in the receiver takes three sampl"
        "es in each of the received bits.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OR",
        "OR is set when software fails to prevent the receive data register fro"
        "m overflowing with data.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE",
        "IDLE is set when the LPUART receive line becomes idle for a full chara"
        "cter time after a period of activity.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDRF",
        "When the receive FIFO is enabled, RDRF is set when the number of dataw"
        "ords in the receive buffer is greater than the number indicated by LPU"
        "ART_WATER[RXWATER].",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TC",
        "TC is cleared when there is a transmission in progress or when a pream"
        "ble or break character is loaded.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDRE",
        "When the transmit FIFO is enabled, TDRE will set when the number of da"
        "tawords in the transmit FIFO (LPUART_DATA) is equal to or less than th"
        "e number indicated by LPUART_WATER[TXWATER]).",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RAF",
        "RAF is set when the receiver detects the beginning of a valid start bi"
        "t, and RAF is cleared automatically when the receiver detects an idle "
        "line.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LBKDE",
        "LBKDE selects a longer break character detection length.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRK13",
        "BRK13 selects a longer transmitted break character length.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWUID",
        "For RWU on idle character, RWUID controls whether the idle character t"
        "hat wakes up the receiver sets the IDLE bit.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXINV",
        "Setting this bit reverses the polarity of the received data input.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSBF",
        "Setting this bit reverses the order of the bits that are transmitted a"
        "nd received on the wire.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEDGIF",
        "RXEDGIF is set whenever the receiver is enabled and an active edge, fa"
        "lling if RXINV = 0, rising if RXINV=1, on the RXD pin occurs.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBKDIF",
        "LBKDIF is set when the LIN break detect circuitry is enabled and a LIN"
        " break character is detected.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_8W_FIFO_CTRL.
static const field_t hw_lpuart_8w_fifo_ctrl[] =
{
    {
        "PT",
        "Provided parity is enabled (PE = 1), this bit selects even or odd pari"
        "ty.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Enables hardware parity generation and checking.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ILT",
        "Determines when the receiver starts counting logic 1s as idle characte"
        "r bits.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKE",
        "Determines which condition wakes the LPUART when RWU=1: Address mark i"
        "n the bit preceding the stop bit (or bit preceding the parity bit when"
        " parity is enabled) of the received data character, or An idle conditi"
        "on on the receive pin input signal.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRC",
        "This field has no meaning or effect unless the LOOPS field is set.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZEEN",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOPS",
        "When LOOPS is set, the RXD pin is disconnected from the LPUART and the"
        " transmitter output is internally connected to the receiver input.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLECFG",
        "Configures the number of idle characters that must be received before "
        "the IDLE flag is set.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M7",
        "This bit should only be changed when the transmitter and receiver are "
        "both disabled.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MA2IE",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MA1IE",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBK",
        "Writing a 1 and then a 0 to SBK queues a break character in the transm"
        "it data stream.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWU",
        "This field can be set to place the LPUART receiver in a standby state.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE",
        "Enables the LPUART receiver.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE",
        "Enables the LPUART transmitter.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ILIE",
        "ILIE enables the idle line flag, STAT[IDLE], to generate interrupt req"
        "uests.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIE",
        "Enables STAT[RDRF] to generate interrupt requests.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCIE",
        "TCIE enables the transmission complete flag, TC, to generate interrupt"
        " requests.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE",
        "Enables STAT[TDRE] to generate interrupt requests.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEIE",
        "This bit enables the parity error flag (PF) to generate hardware inter"
        "rupt requests.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FEIE",
        "This bit enables the framing error flag (FE) to generate hardware inte"
        "rrupt requests.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEIE",
        "This bit enables the noise flag (NF) to generate hardware interrupt re"
        "quests.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ORIE",
        "This bit enables the overrun flag (OR) to generate hardware interrupt "
        "requests.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXINV",
        "Setting this bit reverses the polarity of the transmitted data output.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXDIR",
        "When the LPUART is configured for single-wire half-duplex operation (L"
        "OOPS = RSRC = 1), this bit determines the direction of data at the TXD"
        " pin.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R9T8",
        "R9 is the tenth data bit received when the LPUART is configured for 10"
        "-bit data formats.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R8T9",
        "R8 is the ninth data bit received when the LPUART is configured for 9-"
        "bit or 10-bit data formats.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_8W_FIFO_DATA.
static const field_t hw_lpuart_8w_fifo_data[] =
{
    {
        "R0T0",
        "Read receive data buffer 0 or write transmit data buffer 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R1T1",
        "Read receive data buffer 1 or write transmit data buffer 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R2T2",
        "Read receive data buffer 2 or write transmit data buffer 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R3T3",
        "Read receive data buffer 3 or write transmit data buffer 3.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R4T4",
        "Read receive data buffer 4 or write transmit data buffer 4.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R5T5",
        "Read receive data buffer 5 or write transmit data buffer 5.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R6T6",
        "Read receive data buffer 6 or write transmit data buffer 6.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R7T7",
        "Read receive data buffer 7 or write transmit data buffer 7.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R8T8",
        "Read receive data buffer 8 or write transmit data buffer 8.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "R9T9",
        "Read receive data buffer 9 or write transmit data buffer 9.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLINE",
        "Indicates the receiver line was idle before receiving the character in"
        " DATA[9:0].",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXEMPT",
        "Asserts when there is no data in the receive buffer.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FRETSC",
        "For reads, indicates the current received dataword contained in DATA[R"
        "9:R0] was received with a frame error.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PARITYE",
        "The current received dataword contained in DATA[R9:R0] was received wi"
        "th a parity error.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NOISY",
        "The current received dataword contained in DATA[R9:R0] was received wi"
        "th noise.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_8W_FIFO_MATCH.
static const field_t hw_lpuart_8w_fifo_match[] =
{
    {
        "MA1",
        "The MA1 and MA2 registers are compared to input data addresses when th"
        "e most significant bit is set and the associated BAUD[MAEN] bit is set"
        ".",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MA2",
        "The MA1 and MA2 registers are compared to input data addresses when th"
        "e most significant bit is set and the associated BAUD[MAEN] bit is set"
        ".",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_8W_FIFO_MODIR.
static const field_t hw_lpuart_8w_fifo_modir[] =
{
    {
        "TXCTSE",
        "TXCTSE controls the operation of the transmitter.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRTSE",
        "Controls RTS before and after a transmission.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRTSPOL",
        "Controls the polarity of the transmitter RTS.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXRTSE",
        "Allows the RTS output to control the CTS input of the transmitting dev"
        "ice to prevent receiver overrun.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCTSC",
        "Configures if the CTS state is checked at the start of each character "
        "or only when the transmitter is idle.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCTSSRC",
        "Configures the source of the CTS input.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTSWATER",
        "Configures the assertion and negation of the RX RTS_B output.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNP",
        "Configures whether the LPUART transmits a 1/OSR, 2/OSR, 3/OSR or 4/OSR"
        " narrow pulse when IR is enabled.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IREN",
        "Enables/disables the infrared modulation/demodulation.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_8W_FIFO_FIFO.
static const field_t hw_lpuart_8w_fifo_fifo[] =
{
    {
        "RXFIFOSIZE",
        "The maximum number of receive datawords that can be stored in the rece"
        "ive buffer before an overrun occurs.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFE",
        "When this field is set, the built in FIFO structure for the receive bu"
        "ffer is enabled.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOSIZE",
        "The maximum number of transmit datawords that can be stored in the tra"
        "nsmit buffer.",
        4, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXFE",
        "When this field is set, the built in FIFO structure for the transmit b"
        "uffer is enabled.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXUFE",
        "When this field is set, the RXUF flag generates an interrupt to the ho"
        "st.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXOFE",
        "When this field is set, the TXOF flag generates an interrupt to the ho"
        "st.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXIDEN",
        "When set, enables the assertion of RDRF when the receiver is idle for "
        "a number of idle characters and the FIFO is not empty.",
        10, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFLUSH",
        "Writing to this field causes all data that is stored in the receive FI"
        "FO/buffer to be flushed.",
        14, // LSB
        14, // MSB
        false, // Readable
        false // Writable
    },
    {
        "TXFLUSH",
        "Writing to this field causes all data that is stored in the transmit F"
        "IFO/buffer to be flushed.",
        15, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "RXUF",
        "Indicates that more data has been read from the receive buffer than wa"
        "s present.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXOF",
        "Indicates that more data has been written to the transmit buffer than "
        "it can hold.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEMPT",
        "Asserts when there is no data in the receive FIFO/Buffer.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXEMPT",
        "Asserts when there is no data in the Transmit FIFO/buffer.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_8W_FIFO_WATER.
static const field_t hw_lpuart_8w_fifo_water[] =
{
    {
        "TXWATER",
        "When the number of datawords in the transmit FIFO/buffer is equal to o"
        "r less than the value in this register field, an interrupt or a DMA re"
        "quest is generated.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCOUNT",
        "The value in this register indicates the number of datawords that are "
        "in the transmit FIFO/buffer.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXWATER",
        "When the number of datawords in the receive FIFO/buffer is greater tha"
        "n the value in this register field, an interrupt or a DMA request is g"
        "enerated.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXCOUNT",
        "The value in this register indicates the number of datawords that are "
        "in the receive FIFO/buffer.",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_8W_FIFO_VERID.
static const field_t hw_lpuart_8w_fifo_verid[] =
{
    {
        "FEATURE",
        "This read only field returns the feature set number.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read only field returns the minor version number for the module s"
        "pecification.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read only field returns the major version number for the module s"
        "pecification.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_8W_FIFO_PARAM.
static const field_t hw_lpuart_8w_fifo_param[] =
{
    {
        "TXFIFO",
        "The number of words in the transmit FIFO is 2^TXFIFO.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFIFO",
        "The number of words in the receive FIFO is 2^RXFIFO.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_8W_FIFO_GLOBAL.
static const field_t hw_lpuart_8w_fifo_global[] =
{
    {
        "RST",
        "Reset all internal logic and registers, except the Global Register.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPUART_8W_FIFO_PINCFG.
static const field_t hw_lpuart_8w_fifo_pincfg[] =
{
    {
        "TRGSEL",
        "Configures the input trigger usage.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a LPUART_8W_FIFO module.
static const reg_t hw_lpuart_8w_fifo[] =
{
    {
        "BAUD",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_lpuart_8w_fifo_baud
    },
    {
        "STAT",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_lpuart_8w_fifo_stat
    },
    {
        "CTRL",
        "This read/write register controls various optional features of the LPU"
        "ART system.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        28, // Number of bitfields
        hw_lpuart_8w_fifo_ctrl
    },
    {
        "DATA",
        "This register is two separate registers.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_lpuart_8w_fifo_data
    },
    {
        "MATCH",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lpuart_8w_fifo_match
    },
    {
        "MODIR",
        "The MODEM register controls options for setting the modem configuratio"
        "n.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_lpuart_8w_fifo_modir
    },
    {
        "FIFO",
        "This register provides the ability for the programmer to turn on and o"
        "ff FIFO functionality.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_lpuart_8w_fifo_fifo
    },
    {
        "WATER",
        "This register provides the ability to set a programmable threshold for"
        " notification of needing additional transmit data.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lpuart_8w_fifo_water
    },
    {
        "VERID",
        "The Version ID register indicates the version integrated for this inst"
        "ance on the device and also indicates inclusion/exclusion of several o"
        "ptional features.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_lpuart_8w_fifo_verid
    },
    {
        "PARAM",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lpuart_8w_fifo_param
    },
    {
        "GLOBAL",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lpuart_8w_fifo_global
    },
    {
        "PINCFG",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lpuart_8w_fifo_pincfg
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MCM
#endif

// Bitfields in register MCM_PLASC.
static const field_t hw_mcm_plasc[] =
{
    {
        "ASC",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MCM_PLAMC.
static const field_t hw_mcm_plamc[] =
{
    {
        "AMC",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MCM_PLACR.
static const field_t hw_mcm_placr[] =
{
    {
        "ARB",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCRAMU_PRIORITY",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCRAMU_WRITE_PROTECT",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCRAML_PRIORITY",
        "",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCRAML_WRITE_PROTECT",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MCM_FADR.
static const field_t hw_mcm_fadr[] =
{
    {
        "ADDRESS",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MCM_FATR.
static const field_t hw_mcm_fatr[] =
{
    {
        "BEDA",
        "Indicates the type of cache write buffer access when the error was det"
        "ected.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BEMD",
        "Indicates the privilege level of the cache write buffer access when th"
        "e error was detected.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BESZ",
        "Indicates the size of the cache write buffer access when the error was"
        " detected.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BEWT",
        "Indicates the type of system bus access when the error was detected.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BEMN",
        "Crossbar switch bus master number of the captured cache write buffer b"
        "us error.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BEOVR",
        "Indicates if anothercache write buffer bus error is detected before sy"
        "stem software has retrieved all the error information from the origina"
        "l event, this overrun flag is set.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MCM_FDR.
static const field_t hw_mcm_fdr[] =
{
    {
        "DATA",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a MCM module.
static const reg_t hw_mcm[] =
{
    {
        "PLASC",
        "PLASC is a 16-bit read-only register identifying the presence/absence "
        "of bus slave connections to the device's crossbar switch.",
        2, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mcm_plasc
    },
    {
        "PLAMC",
        "PLAMC is a 16-bit read-only register identifying the presence/absence "
        "of bus master connections to the device's crossbar switch.",
        2, // Width in bytes
        0x0000000a, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mcm_plamc
    },
    {
        "PLACR",
        "The PLACR register selects the arbitration policy for the crossbar mas"
        "ters.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_mcm_placr
    },
    {
        "FADR",
        "When a properly-enabled cache write buffer error interrupt event is de"
        "tected, the faulting address is captured in the MCM_FADR register.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mcm_fadr
    },
    {
        "FATR",
        "When a properly-enabled cache write buffer error interrupt event is de"
        "tected, the faulting attributes are captured in the MCM_FATR register.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_mcm_fatr
    },
    {
        "FDR",
        "When a properly-enabled cache write buffer error interrupt event is de"
        "tected, the faulting data is captured in the MCM_FDR register.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mcm_fdr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MIPI_DSI_HOST
#endif

// Bitfields in register MIPI_DSI_HOST_DSI_HOST_CFG_NUM_LANES.
static const field_t hw_mipi_dsi_host_dsi_host_cfg_num_lanes[] =
{
    {
        "DSI_HOST_CFG_NUM_LANES",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DSI_HOST_CFG_NONCONTINUOUS_CLK.
static const field_t hw_mipi_dsi_host_dsi_host_cfg_noncontinuous_clk[] =
{
    {
        "DSI_HOST_CFG_NONCONTINUOUS_CLK",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DSI_HOST_CFG_T_PRE.
static const field_t hw_mipi_dsi_host_dsi_host_cfg_t_pre[] =
{
    {
        "DSI_HOST_CFG_T_PRE",
        "",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DSI_HOST_CFG_T_POST.
static const field_t hw_mipi_dsi_host_dsi_host_cfg_t_post[] =
{
    {
        "DSI_HOST_CFG_T_POST",
        "",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DSI_HOST_CFG_TX_GAP.
static const field_t hw_mipi_dsi_host_dsi_host_cfg_tx_gap[] =
{
    {
        "DSI_HOST_CFG_TX_GAP",
        "",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DSI_HOST_CFG_AUTOINSERT_EOTP.
static const field_t hw_mipi_dsi_host_dsi_host_cfg_autoinsert_eotp[] =
{
    {
        "DSI_HOST_CFG_AUTOINSERT_EOTP",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DSI_HOST_CFG_EXTRA_CMDS_AFTER_EOTP.
static const field_t hw_mipi_dsi_host_dsi_host_cfg_extra_cmds_after_eotp[] =
{
    {
        "DSI_HOST_CFG_EXTRA_CMDS_AFTER_EOTP",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DSI_HOST_CFG_HTX_TO_COUNT.
static const field_t hw_mipi_dsi_host_dsi_host_cfg_htx_to_count[] =
{
    {
        "DSI_HOST_CFG_HTX_TO_COUNT",
        "",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DSI_HOST_CFG_LRX_H_TO_COUNT.
static const field_t hw_mipi_dsi_host_dsi_host_cfg_lrx_h_to_count[] =
{
    {
        "DSI_HOST_CFG_LRX_H_TO_COUNT",
        "",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DSI_HOST_CFG_BTA_H_TO_COUNT.
static const field_t hw_mipi_dsi_host_dsi_host_cfg_bta_h_to_count[] =
{
    {
        "DSI_HOST_CFG_BTA_H_TO_COUNT",
        "",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DSI_HOST_CFG_TWAKEUP.
static const field_t hw_mipi_dsi_host_dsi_host_cfg_twakeup[] =
{
    {
        "DSI_HOST_CFG_TWAKEUP",
        "",
        0, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DSI_HOST_CFG_STATUS_OUT.
static const field_t hw_mipi_dsi_host_dsi_host_cfg_status_out[] =
{
    {
        "SOT_ERROR",
        "SoT Error - Start of Transmission (SoT) Error from peripheral error re"
        "port, cleared upon read.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SOT_SYNC_ERROR",
        "SoT Sync Error - Start of Transmission (SoT) Sync Error from periphera"
        "l error report, cleared upon read",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EOT_SYNC_ERROR",
        "EoT Sync Error - End of Transmission (EoT) Sync Error from peripheral "
        "error report, cleared upon read",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ESCAPE_MODE_ENTRY_CMD_ERROR",
        "Escape Mode Entry Command Error - Escape Mode Entry Command Error from"
        " peripheral error report, cleared upon read",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LP_TX_SYNC_ERROR",
        "Low-Power Transmit Sync Error - Low Power Transmit Sync error from per"
        "ipheral error report, cleared upon read.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PERIPH_TIMEOUT_ERROR",
        "Peripheral Timeout Error - Peripheral Timeout error from peripheral er"
        "ror report, cleared upon read",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FALSE_CONTROL_ERROR",
        "False Control Error - False Control Error from peripheral error report"
        ", cleared upon read",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CONTENTION_DETECT",
        "Contention Detected - Contention Detection from peripheral error repor"
        "t, cleared upon read",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ECC_ERROR_SINGLE_BIT",
        "ECC single bit error from peripheral error report, cleared upon read.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ECC_ERROR_MULTI_BIT",
        "ECC Error, multi-bit (detected, not corrected) - ECC multi-bit error f"
        "rom peripheral error report, cleared upon read",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHECKSUM_ERROR",
        "Checksum Error (long packet only) - Checksum error from peripheral err"
        "or report, cleared upon read",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DSI_HOST_RX_ERROR_STATUS.
static const field_t hw_mipi_dsi_host_dsi_host_rx_error_status[] =
{
    {
        "DSI_HOST_RX_ERROR_STATUS",
        "",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a MIPI_DSI_HOST module.
static const reg_t hw_mipi_dsi_host[] =
{
    {
        "DSI_HOST_CFG_NUM_LANES",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dsi_host_cfg_num_lanes
    },
    {
        "DSI_HOST_CFG_NONCONTINUOUS_CLK",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dsi_host_cfg_noncontinuous_clk
    },
    {
        "DSI_HOST_CFG_T_PRE",
        "Please refer to the MIPI Alliance Specification for D-PHY (Global Oper"
        "ation Timing Parameters) for details on calculating the parameter desc"
        "ribed below",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dsi_host_cfg_t_pre
    },
    {
        "DSI_HOST_CFG_T_POST",
        "Please refer to the MIPI Alliance Specification for D-PHY (Global Oper"
        "ation Timing Parameters) for details on calculating the parameter desc"
        "ribed below",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dsi_host_cfg_t_post
    },
    {
        "DSI_HOST_CFG_TX_GAP",
        "Please refer to the MIPI Alliance Specification for D-PHY (Global Oper"
        "ation Timing Parameters) for details on calculating the parameter desc"
        "ribed below",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dsi_host_cfg_tx_gap
    },
    {
        "DSI_HOST_CFG_AUTOINSERT_EOTP",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dsi_host_cfg_autoinsert_eotp
    },
    {
        "DSI_HOST_CFG_EXTRA_CMDS_AFTER_EOTP",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dsi_host_cfg_extra_cmds_after_eotp
    },
    {
        "DSI_HOST_CFG_HTX_TO_COUNT",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dsi_host_cfg_htx_to_count
    },
    {
        "DSI_HOST_CFG_LRX_H_TO_COUNT",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dsi_host_cfg_lrx_h_to_count
    },
    {
        "DSI_HOST_CFG_BTA_H_TO_COUNT",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dsi_host_cfg_bta_h_to_count
    },
    {
        "DSI_HOST_CFG_TWAKEUP",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dsi_host_cfg_twakeup
    },
    {
        "DSI_HOST_CFG_STATUS_OUT",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        false, // Writable
        11, // Number of bitfields
        hw_mipi_dsi_host_dsi_host_cfg_status_out
    },
    {
        "DSI_HOST_RX_ERROR_STATUS",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dsi_host_rx_error_status
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MIPI_DSI_HOST_APB_PKT_IF
#endif

// Bitfields in register MIPI_DSI_HOST_APB_PKT_IF_DSI_HOST_TX_PAYLOAD.
static const field_t hw_mipi_dsi_host_apb_pkt_if_dsi_host_tx_payload[] =
{
    {
        "DSI_HOST_TX_PAYLOAD",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_APB_PKT_IF_DSI_HOST_PKT_CONTROL.
static const field_t hw_mipi_dsi_host_apb_pkt_if_dsi_host_pkt_control[] =
{
    {
        "DSI_HOST_PKT_CONTROL",
        "",
        0, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_APB_PKT_IF_DSI_HOST_SEND_PACKET.
static const field_t hw_mipi_dsi_host_apb_pkt_if_dsi_host_send_packet[] =
{
    {
        "DSI_HOST_SEND_PACKET",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_APB_PKT_IF_DSI_HOST_PKT_STATUS.
static const field_t hw_mipi_dsi_host_apb_pkt_if_dsi_host_pkt_status[] =
{
    {
        "DSI_HOST_PKT_STATUS",
        "",
        0, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_APB_PKT_IF_DSI_HOST_PKT_FIFO_WR_LEVEL.
static const field_t hw_mipi_dsi_host_apb_pkt_if_dsi_host_pkt_fifo_wr_level[] =
{
    {
        "DSI_HOST_PKT_FIFO_WR_LEVEL",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_APB_PKT_IF_DSI_HOST_PKT_FIFO_RD_LEVEL.
static const field_t hw_mipi_dsi_host_apb_pkt_if_dsi_host_pkt_fifo_rd_level[] =
{
    {
        "DSI_HOST_PKT_FIFO_RD_LEVEL",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_APB_PKT_IF_DSI_HOST_PKT_RX_PAYLOAD.
static const field_t hw_mipi_dsi_host_apb_pkt_if_dsi_host_pkt_rx_payload[] =
{
    {
        "DSI_HOST_PKT_RX_PAYLOAD",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_APB_PKT_IF_DSI_HOST_PKT_RX_PKT_HEADER.
static const field_t hw_mipi_dsi_host_apb_pkt_if_dsi_host_pkt_rx_pkt_header[] =
{
    {
        "DSI_HOST_PKT_RX_PKT_HEADER",
        "",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_APB_PKT_IF_DSI_HOST_IRQ_STATUS.
static const field_t hw_mipi_dsi_host_apb_pkt_if_dsi_host_irq_status[] =
{
    {
        "DSI_HOST_IRQ_STATUS",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_APB_PKT_IF_DSI_HOST_IRQ_STATUS2.
static const field_t hw_mipi_dsi_host_apb_pkt_if_dsi_host_irq_status2[] =
{
    {
        "DSI_HOST_IRQ_STATUS2",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_APB_PKT_IF_DSI_HOST_IRQ_MASK.
static const field_t hw_mipi_dsi_host_apb_pkt_if_dsi_host_irq_mask[] =
{
    {
        "DSI_HOST_IRQ_MASK",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_APB_PKT_IF_DSI_HOST_IRQ_MASK2.
static const field_t hw_mipi_dsi_host_apb_pkt_if_dsi_host_irq_mask2[] =
{
    {
        "DSI_HOST_IRQ_MASK2",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a MIPI_DSI_HOST_APB_PKT_IF module.
static const reg_t hw_mipi_dsi_host_apb_pkt_if[] =
{
    {
        "DSI_HOST_TX_PAYLOAD",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_apb_pkt_if_dsi_host_tx_payload
    },
    {
        "DSI_HOST_PKT_CONTROL",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_apb_pkt_if_dsi_host_pkt_control
    },
    {
        "DSI_HOST_SEND_PACKET",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_apb_pkt_if_dsi_host_send_packet
    },
    {
        "DSI_HOST_PKT_STATUS",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_apb_pkt_if_dsi_host_pkt_status
    },
    {
        "DSI_HOST_PKT_FIFO_WR_LEVEL",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_apb_pkt_if_dsi_host_pkt_fifo_wr_level
    },
    {
        "DSI_HOST_PKT_FIFO_RD_LEVEL",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_apb_pkt_if_dsi_host_pkt_fifo_rd_level
    },
    {
        "DSI_HOST_PKT_RX_PAYLOAD",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_apb_pkt_if_dsi_host_pkt_rx_payload
    },
    {
        "DSI_HOST_PKT_RX_PKT_HEADER",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_apb_pkt_if_dsi_host_pkt_rx_pkt_header
    },
    {
        "DSI_HOST_IRQ_STATUS",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_apb_pkt_if_dsi_host_irq_status
    },
    {
        "DSI_HOST_IRQ_STATUS2",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_apb_pkt_if_dsi_host_irq_status2
    },
    {
        "DSI_HOST_IRQ_MASK",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_apb_pkt_if_dsi_host_irq_mask
    },
    {
        "DSI_HOST_IRQ_MASK2",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_apb_pkt_if_dsi_host_irq_mask2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MIPI_DSI_HOST_DPI_INTFC
#endif

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_PIXEL_PAYLOAD_SIZE.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_pixel_payload_size[] =
{
    {
        "DSI_HOST_CFG_DPI_PIXEL_PAYLOAD_SIZE",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_PIXEL_FIFO_SEND_LEVEL.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_pixel_fifo_send_level[] =
{
    {
        "DSI_HOST_CFG_DPI_PIXEL_FIFO_SEND_LEVEL",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_INTERFACE_COLOR_CODING.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_interface_color_coding[] =
{
    {
        "DSI_HOST_CFG_DPI_INTERFACE_COLOR_CODING",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_PIXEL_FORMAT.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_pixel_format[] =
{
    {
        "DSI_HOST_CFG_DPI_PIXEL_FORMAT",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_VSYNC_POLARITY.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_vsync_polarity[] =
{
    {
        "DSI_HOST_CFG_DPI_VSYNC_POLARITY",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_HSYNC_POLARITY.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_hsync_polarity[] =
{
    {
        "DSI_HOST_CFG_DPI_HSYNC_POLARITY",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_VIDEO_MODE.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_video_mode[] =
{
    {
        "DSI_HOST_CFG_DPI_VIDEO_MODE",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_HFP.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_hfp[] =
{
    {
        "DSI_HOST_CFG_DPI_HFP",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_HBP.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_hbp[] =
{
    {
        "DSI_HOST_CFG_DPI_HBP",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_HSA.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_hsa[] =
{
    {
        "DSI_HOST_CFG_DPI_HSA",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_ENABLE_MULT_PKTS.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_enable_mult_pkts[] =
{
    {
        "DSI_HOST_CFG_DPI_ENABLE_MULT_PKTS",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_VBP.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_vbp[] =
{
    {
        "DSI_HOST_CFG_DPI_VBP",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_VFP.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_vfp[] =
{
    {
        "DSI_HOST_CFG_DPI_VFP",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_BLLP_MODE.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_bllp_mode[] =
{
    {
        "DSI_HOST_CFG_DPI_BLLP_MODE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_USE_NULL_PKT_BLLP.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_use_null_pkt_bllp[] =
{
    {
        "DSI_HOST_CFG_DPI_USE_NULL_PKT_BLLP",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_VACTIVE.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_vactive[] =
{
    {
        "DSI_HOST_CFG_DPI_VACTIVE",
        "",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_DPI_INTFC_DSI_HOST_CFG_DPI_VC.
static const field_t hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_vc[] =
{
    {
        "DSI_HOST_CFG_DPI_VC",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a MIPI_DSI_HOST_DPI_INTFC module.
static const reg_t hw_mipi_dsi_host_dpi_intfc[] =
{
    {
        "DSI_HOST_CFG_DPI_PIXEL_PAYLOAD_SIZE",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_pixel_payload_size
    },
    {
        "DSI_HOST_CFG_DPI_PIXEL_FIFO_SEND_LEVEL",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_pixel_fifo_send_level
    },
    {
        "DSI_HOST_CFG_DPI_INTERFACE_COLOR_CODING",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_interface_color_coding
    },
    {
        "DSI_HOST_CFG_DPI_PIXEL_FORMAT",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_pixel_format
    },
    {
        "DSI_HOST_CFG_DPI_VSYNC_POLARITY",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_vsync_polarity
    },
    {
        "DSI_HOST_CFG_DPI_HSYNC_POLARITY",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_hsync_polarity
    },
    {
        "DSI_HOST_CFG_DPI_VIDEO_MODE",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_video_mode
    },
    {
        "DSI_HOST_CFG_DPI_HFP",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_hfp
    },
    {
        "DSI_HOST_CFG_DPI_HBP",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_hbp
    },
    {
        "DSI_HOST_CFG_DPI_HSA",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_hsa
    },
    {
        "DSI_HOST_CFG_DPI_ENABLE_MULT_PKTS",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_enable_mult_pkts
    },
    {
        "DSI_HOST_CFG_DPI_VBP",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_vbp
    },
    {
        "DSI_HOST_CFG_DPI_VFP",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_vfp
    },
    {
        "DSI_HOST_CFG_DPI_BLLP_MODE",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_bllp_mode
    },
    {
        "DSI_HOST_CFG_DPI_USE_NULL_PKT_BLLP",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_use_null_pkt_bllp
    },
    {
        "DSI_HOST_CFG_DPI_VACTIVE",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_vactive
    },
    {
        "DSI_HOST_CFG_DPI_VC",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_dpi_intfc_dsi_host_cfg_dpi_vc
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC
#endif

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_PD_DPHY.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_pd_dphy[] =
{
    {
        "DPHY_PD_DPHY",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_M_PRG_HS_PREPARE.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_m_prg_hs_prepare[] =
{
    {
        "DPHY_M_PRG_HS_PREPARE",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_MC_PRG_HS_PREPARE.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_mc_prg_hs_prepare[] =
{
    {
        "DPHY_MC_PRG_HS_PREPARE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_M_PRG_HS_ZERO.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_m_prg_hs_zero[] =
{
    {
        "DPHY_M_PRG_HS_ZERO",
        "",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_MC_PRG_HS_ZERO.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_mc_prg_hs_zero[] =
{
    {
        "DPHY_MC_PRG_HS_ZERO",
        "",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_M_PRG_HS_TRAIL.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_m_prg_hs_trail[] =
{
    {
        "DPHY_M_PRG_HS_TRAIL",
        "",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_MC_PRG_HS_TRAIL.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_mc_prg_hs_trail[] =
{
    {
        "DPHY_MC_PRG_HS_TRAIL",
        "",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_PD_PLL.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_pd_pll[] =
{
    {
        "PD",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_TST.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_tst[] =
{
    {
        "TST",
        "",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_CN.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_cn[] =
{
    {
        "CN",
        "DPHY PLL Input Divider.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_CM.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_cm[] =
{
    {
        "CM",
        "DPHY PLL Feedback Divider.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_CO.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_co[] =
{
    {
        "CO",
        "DPHY PLL Output Divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_LOCK.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_lock[] =
{
    {
        "LOCK",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_LOCK_BYP.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_lock_byp[] =
{
    {
        "DPHY_LOCK_BYP",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_RTERM_SEL.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_rterm_sel[] =
{
    {
        "DPHY_RTERM_SEL",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_AUTO_PD_EN.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_auto_pd_en[] =
{
    {
        "DPHY_AUTO_PD_EN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_RXLPRP.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_rxlprp[] =
{
    {
        "DPHY_RXLPRP",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC_DPHY_RXCDRP.
static const field_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_rxcdrp[] =
{
    {
        "DPHY_RXCDRP",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC module.
static const reg_t hw_mipi_dsi_host_fsl_ip1_dphy_intfc[] =
{
    {
        "DPHY_PD_DPHY",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_pd_dphy
    },
    {
        "DPHY_M_PRG_HS_PREPARE",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_m_prg_hs_prepare
    },
    {
        "DPHY_MC_PRG_HS_PREPARE",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_mc_prg_hs_prepare
    },
    {
        "DPHY_M_PRG_HS_ZERO",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_m_prg_hs_zero
    },
    {
        "DPHY_MC_PRG_HS_ZERO",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_mc_prg_hs_zero
    },
    {
        "DPHY_M_PRG_HS_TRAIL",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_m_prg_hs_trail
    },
    {
        "DPHY_MC_PRG_HS_TRAIL",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_mc_prg_hs_trail
    },
    {
        "DPHY_PD_PLL",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_pd_pll
    },
    {
        "DPHY_TST",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_tst
    },
    {
        "DPHY_CN",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_cn
    },
    {
        "DPHY_CM",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_cm
    },
    {
        "DPHY_CO",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_co
    },
    {
        "DPHY_LOCK",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_lock
    },
    {
        "DPHY_LOCK_BYP",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_lock_byp
    },
    {
        "DPHY_RTERM_SEL",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_rterm_sel
    },
    {
        "DPHY_AUTO_PD_EN",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_auto_pd_en
    },
    {
        "DPHY_RXLPRP",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_rxlprp
    },
    {
        "DPHY_RXCDRP",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mipi_dsi_host_fsl_ip1_dphy_intfc_dphy_rxcdrp
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MMCAU
#endif

// Bitfields in register MMCAU_CASR.
static const field_t hw_mmcau_casr[] =
{
    {
        "IC",
        "Indicates an illegal instruction has been executed.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPE",
        "Indicates whether the DES parity error is detected.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VER",
        "Indicates CAU version.",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMCAU_CAA.
static const field_t hw_mmcau_caa[] =
{
    {
        "ACC",
        "Stores results of various CAU commands.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMCAU_CA0.
static const field_t hw_mmcau_ca0[] =
{
    {
        "CAN",
        "Used by the CAU commands.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMCAU_CA1.
static const field_t hw_mmcau_ca1[] =
{
    {
        "CAN",
        "Used by the CAU commands.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMCAU_CA2.
static const field_t hw_mmcau_ca2[] =
{
    {
        "CAN",
        "Used by the CAU commands.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMCAU_CA3.
static const field_t hw_mmcau_ca3[] =
{
    {
        "CAN",
        "Used by the CAU commands.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMCAU_CA4.
static const field_t hw_mmcau_ca4[] =
{
    {
        "CAN",
        "Used by the CAU commands.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMCAU_CA5.
static const field_t hw_mmcau_ca5[] =
{
    {
        "CAN",
        "Used by the CAU commands.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMCAU_CA6.
static const field_t hw_mmcau_ca6[] =
{
    {
        "CAN",
        "Used by the CAU commands.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMCAU_CA7.
static const field_t hw_mmcau_ca7[] =
{
    {
        "CAN",
        "Used by the CAU commands.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMCAU_CA8.
static const field_t hw_mmcau_ca8[] =
{
    {
        "CAN",
        "Used by the CAU commands.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a MMCAU module.
static const reg_t hw_mmcau[] =
{
    {
        "CASR",
        "CASR contains the status and configuration for the CAU.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mmcau_casr
    },
    {
        "CAA",
        "Commands use the CAU accumulator for storage of results and as an oper"
        "and for the cryptographic algorithms.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmcau_caa
    },
    {
        "CA0",
        "The General Purpose Register is used in the CAU commands for storage o"
        "f results and as operands for various cryptographic algorithms.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmcau_ca0
    },
    {
        "CA1",
        "The General Purpose Register is used in the CAU commands for storage o"
        "f results and as operands for various cryptographic algorithms.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmcau_ca1
    },
    {
        "CA2",
        "The General Purpose Register is used in the CAU commands for storage o"
        "f results and as operands for various cryptographic algorithms.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmcau_ca2
    },
    {
        "CA3",
        "The General Purpose Register is used in the CAU commands for storage o"
        "f results and as operands for various cryptographic algorithms.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmcau_ca3
    },
    {
        "CA4",
        "The General Purpose Register is used in the CAU commands for storage o"
        "f results and as operands for various cryptographic algorithms.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmcau_ca4
    },
    {
        "CA5",
        "The General Purpose Register is used in the CAU commands for storage o"
        "f results and as operands for various cryptographic algorithms.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmcau_ca5
    },
    {
        "CA6",
        "The General Purpose Register is used in the CAU commands for storage o"
        "f results and as operands for various cryptographic algorithms.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmcau_ca6
    },
    {
        "CA7",
        "The General Purpose Register is used in the CAU commands for storage o"
        "f results and as operands for various cryptographic algorithms.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmcau_ca7
    },
    {
        "CA8",
        "The General Purpose Register is used in the CAU commands for storage o"
        "f results and as operands for various cryptographic algorithms.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmcau_ca8
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MMDC
#endif

// Bitfields in register MMDC_MDCTL.
static const field_t hw_mmdc_mdctl[] =
{
    {
        "DSIZ",
        "DDR data bus size.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COL",
        "Column Address Width.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROW",
        "Row Address Width.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDE_1",
        "MMDC Enable CS1.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDE_0",
        "MMDC Enable CS0.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDPDC.
static const field_t hw_mmdc_mdpdc[] =
{
    {
        "TCKSRE",
        "Valid clock cycles after self-refresh entry.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCKSRX",
        "Valid clock cycles before self-refresh exit.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOTH_CS_PD",
        "Parallel power down entry to both chip selects.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOW_PD",
        "Slow/fast power down.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWDT_0",
        "Power Down Timer - Chip Select 0.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWDT_1",
        "Power Down Timer - Chip Select 1.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCKE",
        "CKE minimum pulse width.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRCT_0",
        "Precharge Timer - Chip Select 0.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRCT_1",
        "Precharge Timer - Chip Select 1.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG0.
static const field_t hw_mmdc_mdcfg0[] =
{
    {
        "TCL",
        "CAS Read Latency.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFAW",
        "Four Active Window (all banks).",
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPDLL",
        "Exit precharge power down with DLL frozen to commands requiring DLL.",
        9, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXP",
        "Exit power down with DLL-on to any valid command.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "Exit self refresh to non READ command.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRFC",
        "Refresh command to Active or Refresh command time.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG1.
static const field_t hw_mmdc_mdcfg1[] =
{
    {
        "TCWL",
        "CAS Write Latency.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMRD",
        "Mode Register Set command cycle (all banks).",
        5, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWR",
        "WRITE recovery time (same bank).",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRPA",
        "Precharge-all command period.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRAS",
        "Active to Precharge command period (same bank).",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRC",
        "Active to Active or Refresh command period (same bank).",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRP",
        "Precharge command period (same bank).",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRCD",
        "Active command to internal read or write delay time (same bank).",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG2.
static const field_t hw_mmdc_mdcfg2[] =
{
    {
        "TRRD",
        "Active to Active command period (all banks).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWTR",
        "Internal WRITE to READ command delay (same bank).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRTP",
        "Internal READ command to Precharge command delay (same bank).",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDLLK",
        "DLL locking time.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDMISC.
static const field_t hw_mmdc_mdmisc[] =
{
    {
        "RST",
        "Software Reset.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TYPE",
        "DDR TYPE.",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_4_BANK",
        "Number of banks per DDR device.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RALAT",
        "Read Additional Latency.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MIF3_MODE",
        "Command prediction working mode.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPDDR2_S2",
        "LPDDR2 S2 device type indication.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BI_ON",
        "Bank Interleaving On.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WALAT",
        "Write Additional latency.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LHD",
        "Latency hiding disable.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CALIB_PER_CS",
        "Number of chip-select for calibration process.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CK1_GATING",
        "Gating the secondary DDR clock.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS1_RDY",
        "External status device on CS1.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CS0_RDY",
        "External status device on CS0.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDSCR.
static const field_t hw_mmdc_mdscr[] =
{
    {
        "CMD_BA",
        "Bank Address.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_CS",
        "Chip Select.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD",
        "Command.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MRR_READ_DATA_VALID",
        "MRR read data valid.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CON_ACK",
        "Configuration acknowledge.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CON_REQ",
        "Configuration request.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_ADDR_LSB_MR_ADDR",
        "Command/Address LSB.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_ADDR_MSB_MR_OP",
        "Command/Address MSB.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDREF.
static const field_t hw_mmdc_mdref[] =
{
    {
        "START_REF",
        "Manual start of refresh cycle.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFR",
        "Refresh Rate.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_SEL",
        "Refresh Selector.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_CNT",
        "Refresh Counter at DDR clock period If REF_SEL equals '2' a refresh cy"
        "cle will begin every amount of DDR cycles configured in this field.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDRWD.
static const field_t hw_mmdc_mdrwd[] =
{
    {
        "RTR_DIFF",
        "Read to read delay for different chip-select.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTW_DIFF",
        "Read to write delay for different chip-select.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WTW_DIFF",
        "Write to write delay for different chip-select.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WTR_DIFF",
        "Write to read delay for different chip-select.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTW_SAME",
        "Read to write delay for the same chip-select.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDAI",
        "Device auto initialization period.",
        16, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDOR.
static const field_t hw_mmdc_mdor[] =
{
    {
        "RST_TO_CKE",
        "LPDDR2: Idle time after first CKE assertion (JEDEC value is 200 us).",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDE_TO_RST",
        "LPDDR2 mode: This field is not relevant and should remain in its defau"
        "lt reset value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPR",
        "LPDDR2/3: Not relevant to this mode and should remain in default reset"
        " value.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDMRR.
static const field_t hw_mmdc_mdmrr[] =
{
    {
        "MRR_READ_DATA0",
        "MRR DATA that arrived on DQ[7:0]",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MRR_READ_DATA1",
        "MRR DATA that arrived on DQ[15:8]",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MRR_READ_DATA2",
        "MRR DATA that arrived on DQ[23:16]",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MRR_READ_DATA3",
        "MRR DATA that arrived on DQ[31:24]",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG3LP.
static const field_t hw_mmdc_mdcfg3lp[] =
{
    {
        "TRPAB_LP",
        "Precharge (all banks) command period.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRPPB_LP",
        "Precharge (per bank) command period (same bank).",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRCD_LP",
        "Active command to internal read or write delay time (same bank).",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_LP",
        "Active to Active or Refresh command period (same bank).",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDMR4.
static const field_t hw_mmdc_mdmr4[] =
{
    {
        "UPDATE_DE_REQ",
        "Update Derated Values Request.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_DE_ACK",
        "Update Derated Values Acknowledge.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRCD_DE",
        "tRCD derating value.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRC_DE",
        "tRC derating value.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRAS_DE",
        "tRAS derating value.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRP_DE",
        "tRP derating value.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRRD_DE",
        "tRRD derating value.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDASP.
static const field_t hw_mmdc_mdasp[] =
{
    {
        "CS0_END",
        "CS0_END.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAARCR.
static const field_t hw_mmdc_maarcr[] =
{
    {
        "ARCR_GUARD",
        "ARCR Guard.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_DYN_MAX",
        "ARCR Dynamic Maximum.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_DYN_JMP",
        "ARCR Dynamic Jump.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_ACC_HIT",
        "ARCR Access Hit Rate.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_PAG_HIT",
        "ARCR Page Hit Rate.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_RCH_EN",
        "This bit defines whether Real time channel is activated and bypassed a"
        "ll other pending accesses, So accesses with QoS=='F' will be granted t"
        "he highest priority in the optimization/reordering mechanism Default v"
        "alue is 0x1 - encoding 1 (Enabled)",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_EXC_ERR_EN",
        "This bit defines whether exclusive read/write access violation of AXI "
        "6.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_SEC_ERR_EN",
        "This bit defines whether security read/write access violation result i"
        "n SLV Error response or in OKAY response Default value is 0x1 - encodi"
        "ng 1(response is SLV Error, rresp/bresp=2'b10)",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_SEC_ERR_LOCK",
        "Once set, this bit locks ARCR_SEC_ERR_EN and prevents from its updatin"
        "g.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAPSR.
static const field_t hw_mmdc_mapsr[] =
{
    {
        "PSD",
        "Automatic Power Saving Disable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSS",
        "Power Saving Status.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RIS",
        "Read Idle Status.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WIS",
        "Write Idle Status.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PST",
        "Automatic Power saving timer.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPMD",
        "General LPMD request.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFS",
        "General DVFS request.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPACK",
        "General low-power acknowledge.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DVACK",
        "General DVFS acknowledge.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAEXIDR0.
static const field_t hw_mmdc_maexidr0[] =
{
    {
        "EXC_ID_MONITOR0",
        "This field defines ID for Exclusive monitor#0.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXC_ID_MONITOR1",
        "This field defines ID for Exclusive monitor#1.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAEXIDR1.
static const field_t hw_mmdc_maexidr1[] =
{
    {
        "EXC_ID_MONITOR2",
        "This field defines ID for Exclusive monitor#2.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXC_ID_MONITOR3",
        "This field defines ID for Exclusive monitor#3.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPCR0.
static const field_t hw_mmdc_madpcr0[] =
{
    {
        "DBG_EN",
        "Debug and Profiling Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBG_RST",
        "Debug and Profiling Reset.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRF_FRZ",
        "Profiling freeze.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CYC_OVF",
        "Total Profiling Cycles Count Overflow.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROFILE_SEL",
        "Profile source select bit For the profile tool to work correctly this "
        "bit must be set to match the NoC scheduler setting.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBS_EN",
        "Step By Step debug Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBS",
        "Step By Step trigger.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPCR1.
static const field_t hw_mmdc_madpcr1[] =
{
    {
        "PRF_AXI_ID",
        "Profiling AXI ID.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRF_AXI_ID_MASK",
        "Profiling AXI ID Mask.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR0.
static const field_t hw_mmdc_madpsr0[] =
{
    {
        "CYC_COUNT",
        "Total Profiling cycle Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR1.
static const field_t hw_mmdc_madpsr1[] =
{
    {
        "BUSY_COUNT",
        "Profiling Busy Cycles Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR2.
static const field_t hw_mmdc_madpsr2[] =
{
    {
        "RD_ACC_COUNT",
        "Profiling Read Access Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR3.
static const field_t hw_mmdc_madpsr3[] =
{
    {
        "WR_ACC_COUNT",
        "Profiling Write Access Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR4.
static const field_t hw_mmdc_madpsr4[] =
{
    {
        "RD_BYTES_COUNT",
        "Profiling Read Bytes Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR5.
static const field_t hw_mmdc_madpsr5[] =
{
    {
        "WR_BYTES_COUNT",
        "Profiling Write Bytes Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MASBS0.
static const field_t hw_mmdc_masbs0[] =
{
    {
        "SBS_ADDR",
        "Step By Step Address.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MASBS1.
static const field_t hw_mmdc_masbs1[] =
{
    {
        "SBS_VLD",
        "Step By Step Valid.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_TYPE",
        "Step By Step Request Type.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_LOCK",
        "Step By Step Lock.",
        2, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_PROT",
        "Step By Step Protection.",
        4, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_SIZE",
        "Step By Step Size.",
        7, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_BURST",
        "Step By Step Burst.",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_BUFF",
        "Step By Step Buffered.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_LEN",
        "Step By Step Length.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_AXI_ID",
        "Step By Step AXI ID.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAGENP.
static const field_t hw_mmdc_magenp[] =
{
    {
        "GP31_GP0",
        "General purpose read/write bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPZQHWCTRL.
static const field_t hw_mmdc_mpzqhwctrl[] =
{
    {
        "ZQ_MODE",
        "ZQ calibration mode:",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_HW_PER",
        "ZQ periodic calibration time.",
        2, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_HW_PU_RES",
        "ZQ automatic calibration pull-up result.",
        6, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZQ_HW_PD_RES",
        "ZQ HW calibration pull-down result.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZQ_HW_FOR",
        "Force ZQ automatic calibration process with the i.MX ZQ calibration pa"
        "d.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZQ_INIT",
        "Device ZQ long/init time.",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZQ_OPER",
        "Device ZQ long/oper time.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZQ_CS",
        "Device ZQ short time.",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_EARLY_COMPARATOR_EN_TIMER",
        "ZQ early comparator enable timer.",
        27, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPZQSWCTRL.
static const field_t hw_mmdc_mpzqswctrl[] =
{
    {
        "ZQ_SW_FOR",
        "ZQ SW calibration enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_SW_RES",
        "ZQ software calibration result.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZQ_SW_PU_VAL",
        "ZQ software pull-up resistance.",
        2, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_SW_PD_VAL",
        "ZQ software pull-down resistance.",
        7, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_SW_PD",
        "ZQ software PU/PD calibration.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USE_ZQ_SW_VAL",
        "Use SW ZQ configured value for I/O pads resistor controls.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_CMP_OUT_SMP",
        "Defines the amount of cycles between driving the ZQ signals to the ZQ "
        "pad and till sampling the comparator enable output while performing ZQ"
        " calibration process with the i.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY0DL.
static const field_t hw_mmdc_mprddqby0dl[] =
{
    {
        "RD_DQ0_DEL",
        "Read dqs0 to dq0 delay fine-tuning.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ1_DEL",
        "Read dqs0 to dq1 delay fine-tuning.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ2_DEL",
        "Read dqs0 to dq2 delay fine-tuning.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ3_DEL",
        "Read dqs0 to dq3 delay fine-tuning.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ4_DEL",
        "Read dqs0 to dq4 delay fine-tuning.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ5_DEL",
        "Read dqs0 to dq5 delay fine-tuning.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ6_DEL",
        "Read dqs0 to dq6 delay fine-tuning.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ7_DEL",
        "Read dqs0 to dq7 delay fine-tuning.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY1DL.
static const field_t hw_mmdc_mprddqby1dl[] =
{
    {
        "RD_DQ8_DEL",
        "Read dqs1 to dq8 delay fine-tuning.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ9_DEL",
        "Read dqs1 to dq9 delay fine-tuning.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ10_DEL",
        "Read dqs1 to dq10 delay fine-tuning.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ11_DEL",
        "Read dqs1 to dq11 delay fine-tuning.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ12_DEL",
        "Read dqs1 to dq12 delay fine-tuning.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ13_DEL",
        "Read dqs1 to dq13 delay fine-tuning.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ14_DEL",
        "Read dqs1 to dq14 delay fine-tuning.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ15_DEL",
        "Read dqs1 to dq15 delay fine-tuning.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY2DL.
static const field_t hw_mmdc_mprddqby2dl[] =
{
    {
        "RD_DQ16_DEL",
        "Read dqs2 to dq16 delay fine-tuning.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ17_DEL",
        "Read dqs2 to dq17 delay fine-tuning.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ18_DEL",
        "Read dqs2 to dq18 delay fine-tuning.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ19_DEL",
        "Read dqs2 to dq19 delay fine-tuning.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ20_DEL",
        "Read dqs2 to dq20 delay fine-tuning.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ21_DEL",
        "Read dqs2 to dq21 delay fine-tuning.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ22_DEL",
        "Read dqs2 to dq22 delay fine-tuning.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ23_DEL",
        "Read dqs2 to dq23 delay fine-tuning.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY3DL.
static const field_t hw_mmdc_mprddqby3dl[] =
{
    {
        "RD_DQ24_DEL",
        "Read dqs3 to dq24 delay fine-tuning.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ25_DEL",
        "Read dqs3 to dq25 delay fine-tuning.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ26_DEL",
        "Read dqs3 to dq26 delay fine-tuning.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ27_DEL",
        "Read dqs3 to dq27 delay fine-tuning.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ28_DEL",
        "Read dqs3 to dq28 delay fine-tuning.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ29_DEL",
        "Read dqs3 to dq29 delay fine-tuning.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ30_DEL",
        "Read dqs3 to dq30 delay fine-tuning.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ31_DEL",
        "Read dqs3 to dq31 delay fine-tuning.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGCTRL0.
static const field_t hw_mmdc_mpdgctrl0[] =
{
    {
        "DG_DL_ABS_OFFSET0",
        "Absolute read DQS gating delay offset for Byte0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL0",
        "Read DQS gating half cycles delay for Byte0 .",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_DG_ERR",
        "HW DQS gating error.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_ABS_OFFSET1",
        "Absolute read DQS gating delay offset for Byte1.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_EXT_UP",
        "DG extend upper boundary.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL1",
        "Read DQS gating half cycles delay for Byte1 .",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_DG_EN",
        "Enable automatic read DQS gating calibration.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_DIS",
        "Read DQS gating disable.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_CMP_CYC",
        "Read DQS gating sample cycle.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST_RD_FIFO",
        "Reset Read Data FIFO and associated pointers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGCTRL1.
static const field_t hw_mmdc_mpdgctrl1[] =
{
    {
        "DG_DL_ABS_OFFSET2",
        "Absolute read DQS gating delay offset for Byte2.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL2",
        "Read DQS gating half cycles delay for Byte2 .",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_DL_ABS_OFFSET3",
        "Absolute read DQS gating delay offset for Byte3.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL3",
        "Read DQS gating half cycles delay for Byte3 .",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGDLST0.
static const field_t hw_mmdc_mpdgdlst0[] =
{
    {
        "DG_DL_UNIT_NUM0",
        "This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_UNIT_NUM1",
        "This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_UNIT_NUM2",
        "This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_UNIT_NUM3",
        "This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 3.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLCTL.
static const field_t hw_mmdc_mprddlctl[] =
{
    {
        "RD_DL_ABS_OFFSET0",
        "Absolute read delay offset for Byte0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DL_ABS_OFFSET1",
        "Absolute read delay offset for Byte1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DL_ABS_OFFSET2",
        "Absolute read delay offset for Byte2.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DL_ABS_OFFSET3",
        "Absolute read delay offset for Byte3.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLST.
static const field_t hw_mmdc_mprddlst[] =
{
    {
        "RD_DL_UNIT_NUM0",
        "This field reflects the number of delay units that are actually used b"
        "y read delay-line 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DL_UNIT_NUM1",
        "This field reflects the number of delay units that are actually used b"
        "y read delay-line 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DL_UNIT_NUM2",
        "This field reflects the number of delay units that are actually used b"
        "y read delay-line 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DL_UNIT_NUM3",
        "This field reflects the number of delay units that are actually used b"
        "y read delay-line 3.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLCTL.
static const field_t hw_mmdc_mpwrdlctl[] =
{
    {
        "WR_DL_ABS_OFFSET0",
        "Absolute write delay offset for Byte0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DL_ABS_OFFSET1",
        "Absolute write delay offset for Byte1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DL_ABS_OFFSET2",
        "Absolute write delay offset for Byte2.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DL_ABS_OFFSET3",
        "Absolute write delay offset for Byte3.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLST.
static const field_t hw_mmdc_mpwrdlst[] =
{
    {
        "WR_DL_UNIT_NUM0",
        "This field reflects the number of delay units that are actually used b"
        "y write delay-line 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DL_UNIT_NUM1",
        "This field reflects the number of delay units that are actually used b"
        "y write delay-line 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DL_UNIT_NUM2",
        "This field reflects the number of delay units that are actually used b"
        "y write delay-line 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DL_UNIT_NUM3",
        "This field reflects the number of delay units that are actually used b"
        "y write delay-line 3.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSDCTRL.
static const field_t hw_mmdc_mpsdctrl[] =
{
    {
        "SDCLK0_DEL",
        "DDR clock0 delay fine tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDCLK1_DEL",
        "DDR clock1 delay fine tuning.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPZQLP2CTL.
static const field_t hw_mmdc_mpzqlp2ctl[] =
{
    {
        "ZQ_LP2_HW_ZQINIT",
        "This register defines the period in cycles that it takes the memory de"
        "vice to perform a Init ZQ calibration.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_LP2_HW_ZQCL",
        "This register defines the period in cycles that it takes the memory de"
        "vice to perform a long ZQ calibration.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_LP2_HW_ZQCS",
        "This register defines the period in cycles that it takes the memory de"
        "vice to perform a short ZQ calibration.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLHWCTL.
static const field_t hw_mmdc_mprddlhwctl[] =
{
    {
        "HW_RD_DL_ERR0",
        "Automatic (HW) read calibration error of Byte0.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_ERR1",
        "Automatic (HW) read calibration error of Byte1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_ERR2",
        "Automatic (HW) read calibration error of Byte2.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_ERR3",
        "Automatic (HW) read calibration error of Byte3.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_EN",
        "Enable automatic (HW) read calibration.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_RD_DL_CMP_CYC",
        "Automatic (HW) read sample cycle.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLHWCTL.
static const field_t hw_mmdc_mpwrdlhwctl[] =
{
    {
        "HW_WR_DL_ERR0",
        "Automatic (HW) write calibration error of Byte0.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_ERR1",
        "Automatic (HW) write calibration error of Byte1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_ERR2",
        "Automatic (HW) write calibration error of Byte2.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_ERR3",
        "Automatic (HW) write calibration error of Byte3.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_EN",
        "Enable automatic (HW) write calibration.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_WR_DL_CMP_CYC",
        "Write sample cycle.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLHWST0.
static const field_t hw_mmdc_mprddlhwst0[] =
{
    {
        "HW_RD_DL_LOW0",
        "Automatic (HW) read calibration result of the lower boundary of Byte0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP0",
        "Automatic (HW) read calibration result of the upper boundary of Byte0.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_LOW1",
        "Automatic (HW) read calibration result of the lower boundary of Byte1.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP1",
        "Automatic (HW) read calibration result of the upper boundary of Byte1.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLHWST1.
static const field_t hw_mmdc_mprddlhwst1[] =
{
    {
        "HW_RD_DL_LOW2",
        "Automatic (HW) read calibration result of the lower boundary of Byte2.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP2",
        "Automatic (HW) read calibration result of the upper boundary of Byte2.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_LOW3",
        "Automatic (HW) read calibration result of the lower boundary of Byte3.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP3",
        "Automatic (HW) read calibration result of the upper boundary of Byte3.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLHWST0.
static const field_t hw_mmdc_mpwrdlhwst0[] =
{
    {
        "HW_WR_DL_LOW0",
        "Automatic (HW) write calibration result of the lower boundary of Byte0"
        ".",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP0",
        "Automatic (HW) write calibration result of the upper boundary of Byte0"
        ".",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_LOW1",
        "Automatic (HW) write calibration result of the lower boundary of Byte1"
        ".",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP1",
        "Automatic (HW) write automatic (HW) write calibration result of the up"
        "per boundary of Byte1.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLHWST1.
static const field_t hw_mmdc_mpwrdlhwst1[] =
{
    {
        "HW_WR_DL_LOW2",
        "Automatic (HW) write calibration result of the lower boundary of Byte2"
        ".",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP2",
        "Automatic (HW) write calibration result of the upper boundary of Byte2"
        ".",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_LOW3",
        "Automatic (HW) write calibration result of the lower boundary of Byte3"
        ".",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP3",
        "Automatic (HW) write calibration result of the upper boundary of Byte3"
        ".",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST0.
static const field_t hw_mmdc_mpdghwst0[] =
{
    {
        "HW_DG_LOW0",
        "HW DQS gating calibration result of the lower boundary of Byte0.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP0",
        "HW DQS gating calibration result of the upper boundary of Byte0.",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST1.
static const field_t hw_mmdc_mpdghwst1[] =
{
    {
        "HW_DG_LOW1",
        "HW DQS gating calibration result of the lower boundary of Byte1.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP1",
        "HW DQS gating calibration result of the upper boundary of Byte1.",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST2.
static const field_t hw_mmdc_mpdghwst2[] =
{
    {
        "HW_DG_LOW2",
        "HW DQS gating calibration result of the lower boundary of Byte2.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP2",
        "HW DQS gating calibration result of the upper boundary of Byte2.",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST3.
static const field_t hw_mmdc_mpdghwst3[] =
{
    {
        "HW_DG_LOW3",
        "HW DQS gating calibration result of the lower boundary of Byte3.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP3",
        "HW DQS gating calibration result of the upper boundary of Byte3.",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPPDCMPR1.
static const field_t hw_mmdc_mppdcmpr1[] =
{
    {
        "PDV1",
        "MMDC Pre defined compare value2.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDV2",
        "MMDC Pre defined compare value2.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPPDCMPR2.
static const field_t hw_mmdc_mppdcmpr2[] =
{
    {
        "MPR_CMP",
        "DQ calibration (LPDDR2/LPDDR3) compare enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MPR_FULL_CMP",
        "DQ calibration (LPDDR2/LPDDR3) full compare enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_LEVEL_PATTERN",
        "DQ calibration (LPDDR2/LPDDR3) read compare pattern.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CA_DL_ABS_OFFSET",
        "Absolute CA (Command/Address of LPDDRR2) offset.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_CA_DL_UNIT",
        "This field reflects the number of delay units that are actually used b"
        "y CA(Command/Address of LPDDR2) delay-line",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDAR0.
static const field_t hw_mmdc_mpswdar0[] =
{
    {
        "SW_DUMMY_WR",
        "SW dummy write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_DUMMY_RD",
        "SW dummy read.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_DUM_CMP0",
        "SW dummy read byte0 compare results.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW_DUM_CMP1",
        "SW dummy read byte1 compare results.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW_DUM_CMP2",
        "SW dummy read byte2 compare results.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW_DUM_CMP3",
        "SW dummy read byte3 compare results.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR0.
static const field_t hw_mmdc_mpswdrdr0[] =
{
    {
        "DUM_RD0",
        "Dummy read data0.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR1.
static const field_t hw_mmdc_mpswdrdr1[] =
{
    {
        "DUM_RD1",
        "Dummy read data1.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR2.
static const field_t hw_mmdc_mpswdrdr2[] =
{
    {
        "DUM_RD2",
        "Dummy read data2.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR3.
static const field_t hw_mmdc_mpswdrdr3[] =
{
    {
        "DUM_RD3",
        "Dummy read data3.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR4.
static const field_t hw_mmdc_mpswdrdr4[] =
{
    {
        "DUM_RD4",
        "Dummy read data4.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR5.
static const field_t hw_mmdc_mpswdrdr5[] =
{
    {
        "DUM_RD5",
        "Dummy read data5.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR6.
static const field_t hw_mmdc_mpswdrdr6[] =
{
    {
        "DUM_RD6",
        "Dummy read data6.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR7.
static const field_t hw_mmdc_mpswdrdr7[] =
{
    {
        "DUM_RD7",
        "Dummy read data7.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPMUR0.
static const field_t hw_mmdc_mpmur0[] =
{
    {
        "MU_BYP_VAL",
        "Number of delay units for measurement bypass.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MU_BYP_EN",
        "Measure unit bypass enable.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRC_MSR",
        "Force measurement on delay-lines.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MU_UNIT_DEL_NUM",
        "Number of delay units measured per cycle.",
        16, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDCCR.
static const field_t hw_mmdc_mpdccr[] =
{
    {
        "WR_DQS0_FT_DCC",
        "Write DQS duty cycle fine tuning control of Byte0.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQS1_FT_DCC",
        "Write DQS duty cycle fine tuning control of Byte1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQS2_FT_DCC",
        "Write DQS duty cycle fine tuning control of Byte1.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQS3_FT_DCC",
        "Write DQS duty cycle fine tuning control of Byte0.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CK_FT0_DCC",
        "Primary duty cycle fine tuning control of DDR clock.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CK_FT1_DCC",
        "Secondary duty cycle fine tuning control of DDR clock.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQS0_FT_DCC",
        "Read DQS duty cycle fine tuning control of Byte0.",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQS1_FT_DCC",
        "Read DQS duty cycle fine tuning control of Byte1.",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQS2_FT_DCC",
        "Read DQS duty cycle fine tuning control of Byte2.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQS3_FT_DCC",
        "Read DQS duty cycle fine tuning control of Byte3.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a MMDC module.
static const reg_t hw_mmdc[] =
{
    {
        "MDCTL",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdctl
    },
    {
        "MDPDC",
        "PRCT field encoding PRCT[2:0] Precharge Timer 000 Disabled (Bit field "
        "reset value) 001 2 clocks 010 4 clocks 011 8 clocks 100 16 clocks 101 "
        "32 clocks 110 64 clocks 111 128 clocks PWDT field encoding PWDT[3:0] P"
        "ower Down Time-out 0000 Disabled (bit field reset value) 0001 16 cycle"
        "s 0010 32 cycles 0011 64 cycles 0100 128 cycles 0101 256 cycles 0110 5"
        "12 cycles 0111 1024 cycles 1000 2048 cycles 1001 4096 cycles 1010 8196"
        " cycles 1011 16384 cycles 1100 32768 cycles 1101-1111 Reserved",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mdpdc
    },
    {
        "MDCFG0",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdcfg0
    },
    {
        "MDCFG1",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mdcfg1
    },
    {
        "MDCFG2",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mdcfg2
    },
    {
        "MDMISC",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_mmdc_mdmisc
    },
    {
        "MDSCR",
        "This register is used to issue special commands manually toward the ex"
        "ternal DDR device (such as load mode register, manual self refresh, ma"
        "nual precharge and so on).",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mdscr
    },
    {
        "MDREF",
        "This register determines the refresh scheme that will be executed towa"
        "rd the DDR device.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mdref
    },
    {
        "MDRWD",
        "This register determines the delay between back to back read and write"
        " accesses.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdrwd
    },
    {
        "MDOR",
        "This register defines delays that must be kept when MMDC exits reset.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mmdc_mdor
    },
    {
        "MDMRR",
        "This register contains data that was collected after issuing MRR comma"
        "nd.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mdmrr
    },
    {
        "MDCFG3LP",
        "This register is relevant only for LPDDR2/3 mode.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mdcfg3lp
    },
    {
        "MDMR4",
        "This register is relevant only for LPDDR2 mode.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_mmdc_mdmr4
    },
    {
        "MDASP",
        "This register defines the partitioning between chip select 0 and chip "
        "select 1.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmdc_mdasp
    },
    {
        "MAARCR",
        "This register determines the values of the weights used for the re-ord"
        "ering arbitration engine.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_maarcr
    },
    {
        "MAPSR",
        "The MAPSR determines the power saving features of MMDC.",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mapsr
    },
    {
        "MAEXIDR0",
        "This register defines the ID to be monitored for exclusive accesses of"
        " monitor0 and monitor1.",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_maexidr0
    },
    {
        "MAEXIDR1",
        "This register defines the ID to be monitored for exclusive accesses of"
        " monitor2 and monitor3.",
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_maexidr1
    },
    {
        "MADPCR0",
        "",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_mmdc_madpcr0
    },
    {
        "MADPCR1",
        "",
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_madpcr1
    },
    {
        "MADPSR0",
        "",
        4, // Width in bytes
        0x00000418, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr0
    },
    {
        "MADPSR1",
        "The register reflects the total cycles during which the MMDC state mac"
        "hines were busy (both writes and reads).",
        4, // Width in bytes
        0x0000041c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr1
    },
    {
        "MADPSR2",
        "This register reflects the total number of read accesses (per AXI ID) "
        "toward MMDC.",
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr2
    },
    {
        "MADPSR3",
        "This register reflects the total number of write accesses (per AXI ID)"
        " toward MMDC.",
        4, // Width in bytes
        0x00000424, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr3
    },
    {
        "MADPSR4",
        "This register reflects the total number of bytes that were transferred"
        " during read access (per AXI ID) toward MMDC.",
        4, // Width in bytes
        0x00000428, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr4
    },
    {
        "MADPSR5",
        "This register reflects the total number of bytes that were transferred"
        " during write access (per AXI ID) toward MMDC.",
        4, // Width in bytes
        0x0000042c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr5
    },
    {
        "MASBS0",
        "",
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_masbs0
    },
    {
        "MASBS1",
        "",
        4, // Width in bytes
        0x00000434, // Base address offset
        true, // Readable
        false, // Writable
        9, // Number of bitfields
        hw_mmdc_masbs1
    },
    {
        "MAGENP",
        "This register is a general 32 bit read/write register.",
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmdc_magenp
    },
    {
        "MPZQHWCTRL",
        "",
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpzqhwctrl
    },
    {
        "MPZQSWCTRL",
        "",
        4, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_mmdc_mpzqswctrl
    },
    {
        "MPRDDQBY0DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte0 relative to the read DQS.",
        4, // Width in bytes
        0x0000081c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby0dl
    },
    {
        "MPRDDQBY1DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte1 relative to the read DQS",
        4, // Width in bytes
        0x00000820, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby1dl
    },
    {
        "MPRDDQBY2DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte2 relative to the read DQS",
        4, // Width in bytes
        0x00000824, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby2dl
    },
    {
        "MPRDDQBY3DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte3 relative to the read DQS.",
        4, // Width in bytes
        0x00000828, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby3dl
    },
    {
        "MPDGCTRL0",
        "",
        4, // Width in bytes
        0x0000083c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_mmdc_mpdgctrl0
    },
    {
        "MPDGCTRL1",
        "",
        4, // Width in bytes
        0x00000840, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpdgctrl1
    },
    {
        "MPDGDLST0",
        "This register holds the status of the 4 dqs gating delay-lines.",
        4, // Width in bytes
        0x00000844, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpdgdlst0
    },
    {
        "MPRDDLCTL",
        "This register controls read delay-lines functionality; it determines D"
        "QS delay relative to the associated DQ read access.",
        4, // Width in bytes
        0x00000848, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlctl
    },
    {
        "MPRDDLST",
        "This register holds the status of the 4 read delay-lines.",
        4, // Width in bytes
        0x0000084c, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlst
    },
    {
        "MPWRDLCTL",
        "This register controls write delay-lines functionality, it determines "
        "DQ/DM delay relative to the associated DQS in write access.",
        4, // Width in bytes
        0x00000850, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlctl
    },
    {
        "MPWRDLST",
        "This register holds the status of the 4 write delay-line.",
        4, // Width in bytes
        0x00000854, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlst
    },
    {
        "MPSDCTRL",
        "This register controls the fine tuning of the primary clock (CK0).",
        4, // Width in bytes
        0x00000858, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_mpsdctrl
    },
    {
        "MPZQLP2CTL",
        "This register controls the idle time that takes the LPDDR2/3 device to"
        " perform ZQ calibration",
        4, // Width in bytes
        0x0000085c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mmdc_mpzqlp2ctl
    },
    {
        "MPRDDLHWCTL",
        "",
        4, // Width in bytes
        0x00000860, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mprddlhwctl
    },
    {
        "MPWRDLHWCTL",
        "",
        4, // Width in bytes
        0x00000864, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpwrdlhwctl
    },
    {
        "MPRDDLHWST0",
        "",
        4, // Width in bytes
        0x00000868, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlhwst0
    },
    {
        "MPRDDLHWST1",
        "",
        4, // Width in bytes
        0x0000086c, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlhwst1
    },
    {
        "MPWRDLHWST0",
        "",
        4, // Width in bytes
        0x00000870, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlhwst0
    },
    {
        "MPWRDLHWST1",
        "",
        4, // Width in bytes
        0x00000874, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlhwst1
    },
    {
        "MPDGHWST0",
        "",
        4, // Width in bytes
        0x0000087c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst0
    },
    {
        "MPDGHWST1",
        "",
        4, // Width in bytes
        0x00000880, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst1
    },
    {
        "MPDGHWST2",
        "",
        4, // Width in bytes
        0x00000884, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst2
    },
    {
        "MPDGHWST3",
        "",
        4, // Width in bytes
        0x00000888, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst3
    },
    {
        "MPPDCMPR1",
        "This register holds the MMDC pre-defined compare value that will be us"
        "ed during automatic read, read DQS gating and write calibration proces"
        "s.",
        4, // Width in bytes
        0x0000088c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_mppdcmpr1
    },
    {
        "MPPDCMPR2",
        "",
        4, // Width in bytes
        0x00000890, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_mmdc_mppdcmpr2
    },
    {
        "MPSWDAR0",
        "",
        4, // Width in bytes
        0x00000894, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpswdar0
    },
    {
        "MPSWDRDR0",
        "",
        4, // Width in bytes
        0x00000898, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr0
    },
    {
        "MPSWDRDR1",
        "",
        4, // Width in bytes
        0x0000089c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr1
    },
    {
        "MPSWDRDR2",
        "",
        4, // Width in bytes
        0x000008a0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr2
    },
    {
        "MPSWDRDR3",
        "",
        4, // Width in bytes
        0x000008a4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr3
    },
    {
        "MPSWDRDR4",
        "",
        4, // Width in bytes
        0x000008a8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr4
    },
    {
        "MPSWDRDR5",
        "",
        4, // Width in bytes
        0x000008ac, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr5
    },
    {
        "MPSWDRDR6",
        "",
        4, // Width in bytes
        0x000008b0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr6
    },
    {
        "MPSWDRDR7",
        "",
        4, // Width in bytes
        0x000008b4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr7
    },
    {
        "MPMUR0",
        "",
        4, // Width in bytes
        0x000008b8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpmur0
    },
    {
        "MPDCCR",
        "MMDC1_MPDCCR only affects SDCLK0.",
        4, // Width in bytes
        0x000008c0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_mmdc_mpdccr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MSMC1
#endif

// Bitfields in register MSMC1_PMPROT.
static const field_t hw_msmc1_pmprot[] =
{
    {
        "AVLLS",
        "When set, allows the PMCTRL[STOPM] field to be written to VLLS.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALLS",
        "When set, allows the PMCTRL[STOPM] field to be written to LLS.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVLP",
        "When set, allows the PMCTRL[RUNM] field to be written to VLPR and/or t"
        "he PMCTRL[STOPM] field to be written with VLPS.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHSRUN",
        "When set, allows the PMCTRL[RUNM] field to be written to HSRUN.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC1_PMCTRL.
static const field_t hw_msmc1_pmctrl[] =
{
    {
        "STOPM",
        "Selects the desired stop mode when a core enters deepsleep.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUNM",
        "When written, causes entry into the selected run mode.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSTOPO",
        "These bits control whether a Partial Stop mode is entered when STOPM=S"
        "TOP.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPA",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC1_PMSTAT.
static const field_t hw_msmc1_pmstat[] =
{
    {
        "PMSTAT",
        "When debug is enabled, the PMSTAT will not update to STOP or VLPS When"
        " a Partial Stop Option is enabled, the PMSTAT will not update to STOP "
        "or VLPS",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC1_VERID.
static const field_t hw_msmc1_verid[] =
{
    {
        "FEATURE",
        "This read only field returns the feature set number.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read only field returns the minor version number for the module s"
        "pecification.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read only field returns the major version number for the module s"
        "pecification.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC1_PARAM.
static const field_t hw_msmc1_param[] =
{
    {
        "PWRD_INDPT",
        "When set, means each core is able to enter power modes independently o"
        "f the other.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC1_SRS.
static const field_t hw_msmc1_srs[] =
{
    {
        "WAKEUP",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "POR",
        "SRAM contents cannot be guaranteed following a POR reset source.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LVD",
        "SRAM contents cannot be guaranteed following a LVD reset source.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HVD",
        "SRAM contents cannot be guaranteed following a HVD reset source.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WARM",
        "Warm Reset flag will assert if any of the system reset sources in this"
        " register assert (SRS[31:8]).",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FATAL",
        "Fatal Reset will assert if the system reset source was fatal.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORE",
        "Indicates the last reset was a reset that only reset the core.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MDM",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSTACK",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STOPACK",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SCG",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WDOG",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCKUP",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VBAT",
        "VBAT POR will generate a system reset.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "JTAG",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SECVIO",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAMPER",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC1_RPC.
static const field_t hw_msmc1_rpc[] =
{
    {
        "FILTCFG",
        "Configures the width of the reset pin filter from 1 to 32 slow clock c"
        "ycles.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTEN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC1_SSRS.
static const field_t hw_msmc1_ssrs[] =
{
    {
        "WAKEUP",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POR",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVD",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HVD",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WARM",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FATAL",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MDM",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTACK",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPACK",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCG",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCKUP",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBAT",
        "VBAT POR will generate a system reset.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "JTAG",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SECVIO",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAMPER",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC1_SRIE.
static const field_t hw_msmc1_srie[] =
{
    {
        "PIN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MDM",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPACK",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCKUP",
        "Note that interrupts cannot be serviced by a core in the lockup state.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBAT",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC1_SRIF.
static const field_t hw_msmc1_srif[] =
{
    {
        "PIN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MDM",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPACK",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCKUP",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBAT",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC1_CSRE.
static const field_t hw_msmc1_csre[] =
{
    {
        "PIN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MDM",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPACK",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCKUP",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBAT",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC1_MR.
static const field_t hw_msmc1_mr[] =
{
    {
        "BOOTCFG",
        "The definition of this field is device specific.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC1_FM.
static const field_t hw_msmc1_fm[] =
{
    {
        "FORCECFG",
        "This register can force the corresponding bit in the Mode Register to "
        "assert on next system reset.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a MSMC1 module.
static const reg_t hw_msmc1[] =
{
    {
        "PMPROT",
        "This register provides protection for entry into any run or stop power"
        " mode.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_msmc1_pmprot
    },
    {
        "PMCTRL",
        "The PMCTRL register controls entry into low-power Run and Stop modes, "
        "provided that the selected power mode is allowed via an appropriate se"
        "tting of the protection (PMPROT) register.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_msmc1_pmctrl
    },
    {
        "PMSTAT",
        "PMSTAT is a read-only, one-hot register which indicates the current po"
        "wer mode of the system.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_msmc1_pmstat
    },
    {
        "VERID",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_msmc1_verid
    },
    {
        "PARAM",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_msmc1_param
    },
    {
        "SRS",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        19, // Number of bitfields
        hw_msmc1_srs
    },
    {
        "RPC",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_msmc1_rpc
    },
    {
        "SSRS",
        "The SSRS are only reset on POR/LVD/HVD/WAKEUP and remain set until cle"
        "ared by software.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_msmc1_ssrs
    },
    {
        "SRIE",
        "This registers delays the assertion of a system reset for between 9 an"
        "d 10 LPO clock cycles while an interrupt is generated.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_msmc1_srie
    },
    {
        "SRIF",
        "This registers returns the source of the reset interrupt.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_msmc1_srif
    },
    {
        "CSRE",
        "This registers delays the assertion of a system reset for between 9 an"
        "d 10 LPO clock cycles while a core software reset is generated.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_msmc1_csre
    },
    {
        "MR",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_msmc1_mr
    },
    {
        "FM",
        "",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_msmc1_fm
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MSMC2
#endif

// Bitfields in register MSMC2_PMPROT.
static const field_t hw_msmc2_pmprot[] =
{
    {
        "AVLLS",
        "When set, allows the PMCTRL[STOPM] field to be written to VLLS.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALLS",
        "When set, allows the PMCTRL[STOPM] field to be written to LLS.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVLP",
        "When set, allows the PMCTRL[RUNM] field to be written to VLPR and/or t"
        "he PMCTRL[STOPM] field to be written with VLPS.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHSRUN",
        "When set, allows the PMCTRL[RUNM] field to be written to HSRUN.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC2_PMCTRL.
static const field_t hw_msmc2_pmctrl[] =
{
    {
        "STOPM",
        "Selects the desired stop mode when a core enters deepsleep.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUNM",
        "When written, causes entry into the selected run mode.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSTOPO",
        "These bits control whether a Partial Stop mode is entered when STOPM=S"
        "TOP.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPA",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC2_PMSTAT.
static const field_t hw_msmc2_pmstat[] =
{
    {
        "PMSTAT",
        "When debug is enabled, the PMSTAT will not update to STOP or VLPS When"
        " a Partial Stop Option is enabled, the PMSTAT will not update to STOP "
        "or VLPS",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC2_VERID.
static const field_t hw_msmc2_verid[] =
{
    {
        "FEATURE",
        "This read only field returns the feature set number.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read only field returns the minor version number for the module s"
        "pecification.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read only field returns the major version number for the module s"
        "pecification.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC2_PARAM.
static const field_t hw_msmc2_param[] =
{
    {
        "PWRD_INDPT",
        "When set, means each core is able to enter power modes independently o"
        "f the other.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC2_SRS.
static const field_t hw_msmc2_srs[] =
{
    {
        "WAKEUP",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "POR",
        "SRAM contents cannot be guaranteed following a POR reset source.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LVD",
        "SRAM contents cannot be guaranteed following a LVD reset source.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HVD",
        "SRAM contents cannot be guaranteed following a HVD reset source.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WARM",
        "Warm Reset flag will assert if any of the system reset sources in this"
        " register assert (SRS[31:8]).",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FATAL",
        "Fatal Reset will assert if the system reset source was fatal.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORE",
        "Indicates the last reset was a reset that only reset the core.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MDM",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSTACK",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STOPACK",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SCG",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WDOG",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORE0",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VBAT",
        "VBAT POR will generate a system reset.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "JTAG",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TZWDG",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SECVIO",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAMPER",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC2_RPC.
static const field_t hw_msmc2_rpc[] =
{
    {
        "FILTCFG",
        "Configures the width of the reset pin filter from 1 to 32 slow clock c"
        "ycles.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FILTEN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC2_SSRS.
static const field_t hw_msmc2_ssrs[] =
{
    {
        "WAKEUP",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POR",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVD",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HVD",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WARM",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FATAL",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MDM",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTACK",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPACK",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCG",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE0",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBAT",
        "VBAT POR will generate a system reset.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "JTAG",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZWDG",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SECVIO",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAMPER",
        "This is a fatal reset source and SRAM contents are not guaranteed.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC2_SRIE.
static const field_t hw_msmc2_srie[] =
{
    {
        "PIN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MDM",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPACK",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE0",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBAT",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC2_SRIF.
static const field_t hw_msmc2_srif[] =
{
    {
        "PIN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MDM",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPACK",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE0",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBAT",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC2_CSRE.
static const field_t hw_msmc2_csre[] =
{
    {
        "PIN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MDM",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPACK",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE0",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBAT",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC2_MR.
static const field_t hw_msmc2_mr[] =
{
    {
        "BOOTCFG",
        "The definition of this field is device specific.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MSMC2_FM.
static const field_t hw_msmc2_fm[] =
{
    {
        "FORCECFG",
        "This register can force the corresponding bit in the Mode Register to "
        "assert on next system reset.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a MSMC2 module.
static const reg_t hw_msmc2[] =
{
    {
        "PMPROT",
        "This register provides protection for entry into any run or stop power"
        " mode.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_msmc2_pmprot
    },
    {
        "PMCTRL",
        "The PMCTRL register controls entry into low-power Run and Stop modes, "
        "provided that the selected power mode is allowed via an appropriate se"
        "tting of the protection (PMPROT) register.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_msmc2_pmctrl
    },
    {
        "PMSTAT",
        "PMSTAT is a read-only, one-hot register which indicates the current po"
        "wer mode of the system.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_msmc2_pmstat
    },
    {
        "VERID",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_msmc2_verid
    },
    {
        "PARAM",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_msmc2_param
    },
    {
        "SRS",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        20, // Number of bitfields
        hw_msmc2_srs
    },
    {
        "RPC",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_msmc2_rpc
    },
    {
        "SSRS",
        "The SSRS are only reset on POR/LVD/HVD/WAKEUP and remain set until cle"
        "ared by software.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_msmc2_ssrs
    },
    {
        "SRIE",
        "This registers delays the assertion of a system reset for between 9 an"
        "d 10 LPO clock cycles while an interrupt is generated.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_msmc2_srie
    },
    {
        "SRIF",
        "This registers returns the source of the reset interrupt.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_msmc2_srif
    },
    {
        "CSRE",
        "This registers delays the assertion of a system reset for between 9 an"
        "d 10 LPO clock cycles while a core software reset is generated.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_msmc2_csre
    },
    {
        "MR",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_msmc2_mr
    },
    {
        "FM",
        "",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_msmc2_fm
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MUA
#endif

// Bitfields in register MUA_VER.
static const field_t hw_mua_ver[] =
{
    {
        "FEATURE",
        "This read only field returns the feature set number for MUA.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read only field returns the minor version number for MUA.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read only field returns the major version number for MUA.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MUA_PAR.
static const field_t hw_mua_par[] =
{
    { 0 } // Terminator
};

// Bitfields in register MUA_RR0.
static const field_t hw_mua_rr0[] =
{
    {
        "DATA",
        "MUA Receive Register.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MUA_RR1.
static const field_t hw_mua_rr1[] =
{
    {
        "DATA",
        "MUA Receive Register.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MUA_RR2.
static const field_t hw_mua_rr2[] =
{
    {
        "DATA",
        "MUA Receive Register.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MUA_RR3.
static const field_t hw_mua_rr3[] =
{
    {
        "DATA",
        "MUA Receive Register.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MUA_SR.
static const field_t hw_mua_sr[] =
{
    {
        "FN",
        "For n = {0, 1, 2} MUA Side Flag n.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NMIC",
        "Processor A Non-Maskable-Interrupt Clear.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EP",
        "MUA Side Event Pending.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PM",
        "Processor B-side Power Mode.",
        5, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RS",
        "MUB Reset State.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FUP",
        "MUA Flags Update Pending.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDIP",
        "Processor B Reset De-asserted Interrupt Pending.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAIP",
        "Processor B Reset Asserted Interrupt Pending.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEN",
        "For n = {0, 1, 2, 3} MUA Transmit Register n Empty.",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RFN",
        "For n = {0, 1, 2, 3} MUA Receive Register n Full.",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GIPN",
        "For n = {0, 1, 2, 3} MUA General Interrupt Request n Pending.",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MUA_CR.
static const field_t hw_mua_cr[] =
{
    {
        "FN",
        "For n = {0, 1, 2} MUA to MUB Flag n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NMI",
        "MUB Non-maskable Interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BHR",
        "Processor B Hardware Reset.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUR",
        "MU Reset.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDIE",
        "Processor B Reset De-assertion Interrupt Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTH",
        "When set, will cause Processor B to be held in reset following any res"
        "et event.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKE",
        "When set, forces MUB platform clock to remain enabled even after MUB h"
        "as entered a stop mode.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BBOOT",
        "Configures the boot source for Processor B.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAIE",
        "Processor B Reset Assertion Interrupt Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GIRN",
        "For n = {0, 1, 2, 3} MUA General Purpose Interrupt Request n.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIEN",
        "For n = {0, 1, 2, 3} MUA Transmit Interrupt Enable n.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIEN",
        "For n = {0, 1, 2, 3} MUA Receive Interrupt Enable n.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GIEN",
        "For n = {0, 1, 2, 3} MUA General Purpose Interrupt Enable n.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MUA_TR0.
static const field_t hw_mua_tr0[] =
{
    {
        "DATA",
        "MUA Transmit Register Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MUA_TR1.
static const field_t hw_mua_tr1[] =
{
    {
        "DATA",
        "MUA Transmit Register Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MUA_TR2.
static const field_t hw_mua_tr2[] =
{
    {
        "DATA",
        "MUA Transmit Register Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MUA_TR3.
static const field_t hw_mua_tr3[] =
{
    {
        "DATA",
        "MUA Transmit Register Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a MUA module.
static const reg_t hw_mua[] =
{
    {
        "VER",
        "Use Version ID register to determine the version ID and feature set nu"
        "mber of MUA.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_mua_ver
    },
    {
        "PAR",
        "Use Parameter register to determine the parameter settings of MUB.",
        4, // Width in bytes
        0x00000008, // Base address offset
        false, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_mua_par
    },
    {
        "RR0",
        "Use MUA Receive Register (RRn, 32-bit, read-only) to receive a message"
        " or data from the MUB.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mua_rr0
    },
    {
        "RR1",
        "Use MUA Receive Register (RRn, 32-bit, read-only) to receive a message"
        " or data from the MUB.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mua_rr1
    },
    {
        "RR2",
        "Use MUA Receive Register (RRn, 32-bit, read-only) to receive a message"
        " or data from the MUB.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mua_rr2
    },
    {
        "RR3",
        "Use MUA Receive Register (RRn, 32-bit, read-only) to receive a message"
        " or data from the MUB.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mua_rr3
    },
    {
        "SR",
        "Use the Processor A Status Register (SR, 32-bit, read-write) to show i"
        "nterrupt status from the Processor B, general purpose flags , and to s"
        "et dual function control-status bits.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_mua_sr
    },
    {
        "CR",
        "Use the Control Register (CR, 32-bit, read-write) to enable the MU int"
        "errupts on the MUA-side, and trigger events and interrupts on the MUB-"
        "side (general purpose interrupt, flag update).",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_mua_cr
    },
    {
        "TR0",
        "Use MUA Transmit Register (TRn, 32-bit, write-only) to transmit a mess"
        "age or data to MUB.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mua_tr0
    },
    {
        "TR1",
        "Use MUA Transmit Register (TRn, 32-bit, write-only) to transmit a mess"
        "age or data to MUB.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mua_tr1
    },
    {
        "TR2",
        "Use MUA Transmit Register (TRn, 32-bit, write-only) to transmit a mess"
        "age or data to MUB.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mua_tr2
    },
    {
        "TR3",
        "Use MUA Transmit Register (TRn, 32-bit, write-only) to transmit a mess"
        "age or data to MUB.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mua_tr3
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark OCOTP_CTRL
#endif

// Bitfields in register OCOTP_CTRL_HW_OCOTP_CTRL.
static const field_t hw_ocotp_ctrl_hw_ocotp_ctrl[] =
{
    {
        "ADDR",
        "OTP write and read access address register.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY",
        "OTP controller status bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR",
        "Set by the controller when an access to a locked region(OTP or shadow "
        "register) is requested.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELOAD_SHADOWS",
        "Set to force re-loading the shadow registers (HW/SW capability and LOC"
        "K).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUPPADD",
        "This bit should be set when programming or reading supplymentary addre"
        "ss space.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORDLOCK",
        "indicate if word has to to be locked when programming.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_UNLOCK",
        "Write 0x3E77 to enable OTP write accesses.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_CTRL_SET.
static const field_t hw_ocotp_ctrl_hw_ocotp_ctrl_set[] =
{
    {
        "ADDR",
        "OTP write and read access address register.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY",
        "OTP controller status bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR",
        "Set by the controller when an access to a locked region(OTP or shadow "
        "register) is requested.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELOAD_SHADOWS",
        "Set to force re-loading the shadow registers (HW/SW capability and LOC"
        "K).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUPPADD",
        "This bit should be set when programming or reading supplymentary addre"
        "ss space.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORDLOCK",
        "indicate if word has to to be locked when programming.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_UNLOCK",
        "Write 0x3E77 to enable OTP write accesses.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_CTRL_CLR.
static const field_t hw_ocotp_ctrl_hw_ocotp_ctrl_clr[] =
{
    {
        "ADDR",
        "OTP write and read access address register.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY",
        "OTP controller status bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR",
        "Set by the controller when an access to a locked region(OTP or shadow "
        "register) is requested.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELOAD_SHADOWS",
        "Set to force re-loading the shadow registers (HW/SW capability and LOC"
        "K).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUPPADD",
        "This bit should be set when programming or reading supplymentary addre"
        "ss space.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORDLOCK",
        "indicate if word has to to be locked when programming.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_UNLOCK",
        "Write 0x3E77 to enable OTP write accesses.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_CTRL_TOG.
static const field_t hw_ocotp_ctrl_hw_ocotp_ctrl_tog[] =
{
    {
        "ADDR",
        "OTP write and read access address register.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY",
        "OTP controller status bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR",
        "Set by the controller when an access to a locked region(OTP or shadow "
        "register) is requested.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELOAD_SHADOWS",
        "Set to force re-loading the shadow registers (HW/SW capability and LOC"
        "K).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUPPADD",
        "This bit should be set when programming or reading supplymentary addre"
        "ss space.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORDLOCK",
        "indicate if word has to to be locked when programming.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_UNLOCK",
        "Write 0x3E77 to enable OTP write accesses.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_PDN.
static const field_t hw_ocotp_ctrl_hw_ocotp_pdn[] =
{
    {
        "PDN",
        "This bit indicates PDN value of OTP memory.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_DATA.
static const field_t hw_ocotp_ctrl_hw_ocotp_data[] =
{
    {
        "DATA",
        "Used to initiate a write to OTP.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_READ_CTRL.
static const field_t hw_ocotp_ctrl_hw_ocotp_read_ctrl[] =
{
    {
        "READ_FUSE",
        "Used to initiate a read to OTP.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved",
        1, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_READ_FUSE_DATA.
static const field_t hw_ocotp_ctrl_hw_ocotp_read_fuse_data[] =
{
    {
        "DATA",
        "The data read from OTP",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_SW_STICKY.
static const field_t hw_ocotp_ctrl_hw_ocotp_sw_sticky[] =
{
    {
        "RSVD0",
        "Reserved",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SRK_REVOKE_LOCK",
        "Shadow register write and OTP write lock for SRK_REVOKE region.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIELD_RETURN_LOCK",
        "Shadow register write and OTP write lock for FIELD_RETURN region.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_SCS.
static const field_t hw_ocotp_ctrl_hw_ocotp_scs[] =
{
    {
        "HAB_JDE",
        "HAB JTAG Debug Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPARE",
        "Unallocated read/write bits for implementation specific software use.",
        1, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "When set, all of the bits in this register are locked and can not be c"
        "hanged through SW programming.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_SCS_SET.
static const field_t hw_ocotp_ctrl_hw_ocotp_scs_set[] =
{
    {
        "HAB_JDE",
        "HAB JTAG Debug Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPARE",
        "Unallocated read/write bits for implementation specific software use.",
        1, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "When set, all of the bits in this register are locked and can not be c"
        "hanged through SW programming.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_SCS_CLR.
static const field_t hw_ocotp_ctrl_hw_ocotp_scs_clr[] =
{
    {
        "HAB_JDE",
        "HAB JTAG Debug Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPARE",
        "Unallocated read/write bits for implementation specific software use.",
        1, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "When set, all of the bits in this register are locked and can not be c"
        "hanged through SW programming.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_SCS_TOG.
static const field_t hw_ocotp_ctrl_hw_ocotp_scs_tog[] =
{
    {
        "HAB_JDE",
        "HAB JTAG Debug Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPARE",
        "Unallocated read/write bits for implementation specific software use.",
        1, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "When set, all of the bits in this register are locked and can not be c"
        "hanged through SW programming.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_OUT_STATUS.
static const field_t hw_ocotp_ctrl_hw_ocotp_out_status[] =
{
    {
        "DOUT_40_32",
        "Store dout[40:32] from OTP memory when reading one fuse word.",
        0, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEC",
        "Indicates one error has been corrected in data or ECC syndrome when re"
        "ading one fuse word.This bit can only be set by the controller.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DED",
        "Indicates 2 errors have been detected (no correction) when reading one"
        " fuse word.This bit can only be set by the controller.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCKED",
        "Indicates if word is locked or not when programming or reading.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROGFAIL",
        "Indicates programming is failed.This bit can only be set by the contro"
        "ller.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK",
        "indicates operation acknowledgement from OTP memory",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PWOK",
        "Indicates that power vdd and vdd1 of OTP memory are in operating range"
        ".",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FLAGSTATE",
        "Indicates OTP memory current state.",
        15, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEC_RELOAD",
        "Indicates single error correction ever happens in reset reload or relo"
        "ad by setting HW_OCOTP_CTRL[RELOAD_SHADOWS] bit.This bit can only be s"
        "et by the controller.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DED_RELOAD",
        "Indicates double error detection ever happens in reset reload or reloa"
        "d by setting HW_OCOTP_CTRL[RELOAD_SHADOWS] bit.This bit can only be se"
        "t by the controller.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_OUT_STATUS_SET.
static const field_t hw_ocotp_ctrl_hw_ocotp_out_status_set[] =
{
    {
        "DOUT_40_32",
        "Store dout[40:32] from OTP memory when reading one fuse word.",
        0, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEC",
        "Indicates one error has been corrected in data or ECC syndrome when re"
        "ading one fuse word.This bit can only be set by the controller.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DED",
        "Indicates 2 errors have been detected (no correction) when reading one"
        " fuse word.This bit can only be set by the controller.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCKED",
        "Indicates if word is locked or not when programming or reading.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROGFAIL",
        "Indicates programming is failed.This bit can only be set by the contro"
        "ller.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK",
        "indicates operation acknowledgement from OTP memory",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PWOK",
        "Indicates that power vdd and vdd1 of OTP memory are in operating range"
        ".",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FLAGSTATE",
        "Indicates OTP memory current state.",
        15, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEC_RELOAD",
        "Indicates single error correction ever happens in reset reload or relo"
        "ad by setting HW_OCOTP_CTRL[RELOAD_SHADOWS] bit.This bit can only be s"
        "et by the controller.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DED_RELOAD",
        "Indicates double error detection ever happens in reset reload or reloa"
        "d by setting HW_OCOTP_CTRL[RELOAD_SHADOWS] bit.This bit can only be se"
        "t by the controller.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_OUT_STATUS_CLR.
static const field_t hw_ocotp_ctrl_hw_ocotp_out_status_clr[] =
{
    {
        "DOUT_40_32",
        "Store dout[40:32] from OTP memory when reading one fuse word.",
        0, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEC",
        "Indicates one error has been corrected in data or ECC syndrome when re"
        "ading one fuse word.This bit can only be set by the controller.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DED",
        "Indicates 2 errors have been detected (no correction) when reading one"
        " fuse word.This bit can only be set by the controller.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCKED",
        "Indicates if word is locked or not when programming or reading.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROGFAIL",
        "Indicates programming is failed.This bit can only be set by the contro"
        "ller.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK",
        "indicates operation acknowledgement from OTP memory",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PWOK",
        "Indicates that power vdd and vdd1 of OTP memory are in operating range"
        ".",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FLAGSTATE",
        "Indicates OTP memory current state.",
        15, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEC_RELOAD",
        "Indicates single error correction ever happens in reset reload or relo"
        "ad by setting HW_OCOTP_CTRL[RELOAD_SHADOWS] bit.This bit can only be s"
        "et by the controller.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DED_RELOAD",
        "Indicates double error detection ever happens in reset reload or reloa"
        "d by setting HW_OCOTP_CTRL[RELOAD_SHADOWS] bit.This bit can only be se"
        "t by the controller.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_OUT_STATUS_TOG.
static const field_t hw_ocotp_ctrl_hw_ocotp_out_status_tog[] =
{
    {
        "DOUT_40_32",
        "Store dout[40:32] from OTP memory when reading one fuse word.",
        0, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEC",
        "Indicates one error has been corrected in data or ECC syndrome when re"
        "ading one fuse word.This bit can only be set by the controller.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DED",
        "Indicates 2 errors have been detected (no correction) when reading one"
        " fuse word.This bit can only be set by the controller.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCKED",
        "Indicates if word is locked or not when programming or reading.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROGFAIL",
        "Indicates programming is failed.This bit can only be set by the contro"
        "ller.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACK",
        "indicates operation acknowledgement from OTP memory",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PWOK",
        "Indicates that power vdd and vdd1 of OTP memory are in operating range"
        ".",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FLAGSTATE",
        "Indicates OTP memory current state.",
        15, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEC_RELOAD",
        "Indicates single error correction ever happens in reset reload or relo"
        "ad by setting HW_OCOTP_CTRL[RELOAD_SHADOWS] bit.This bit can only be s"
        "et by the controller.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DED_RELOAD",
        "Indicates double error detection ever happens in reset reload or reloa"
        "d by setting HW_OCOTP_CTRL[RELOAD_SHADOWS] bit.This bit can only be se"
        "t by the controller.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_STARTWORD.
static const field_t hw_ocotp_ctrl_hw_ocotp_startword[] =
{
    {
        "STARTWORD",
        "Stores output startword value from OTP memory",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_VERSION.
static const field_t hw_ocotp_ctrl_hw_ocotp_version[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_LOCK0.
static const field_t hw_ocotp_ctrl_hw_ocotp_lock0[] =
{
    {
        "BITS",
        "Status of shadow register and OTP write/read lock .",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_BOOT3.
static const field_t hw_ocotp_ctrl_hw_ocotp_boot3[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 2, word 3 (ADDR = 0x13).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_BOOT4.
static const field_t hw_ocotp_ctrl_hw_ocotp_boot4[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 2, word 4 (ADDR = 0x14).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_BOOT5.
static const field_t hw_ocotp_ctrl_hw_ocotp_boot5[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 2, word 5 (ADDR = 0x15).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_BOOT6.
static const field_t hw_ocotp_ctrl_hw_ocotp_boot6[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 2, word 6 (ADDR = 0x16).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_BOOT7.
static const field_t hw_ocotp_ctrl_hw_ocotp_boot7[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 2, word 7 (ADDR = 0x17).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_ANA2.
static const field_t hw_ocotp_ctrl_hw_ocotp_ana2[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 3, word 6 (ADDR = 0x1e).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_ANA3.
static const field_t hw_ocotp_ctrl_hw_ocotp_ana3[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 3, word 7 (ADDR = 0x1f).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_GP00.
static const field_t hw_ocotp_ctrl_hw_ocotp_gp00[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 7, word 2 (ADDR = 0x3a).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_GP01.
static const field_t hw_ocotp_ctrl_hw_ocotp_gp01[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 7, word 3 (ADDR = 0x3b).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_GP02.
static const field_t hw_ocotp_ctrl_hw_ocotp_gp02[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 7, word 4 (ADDR = 0x3c).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_GP03.
static const field_t hw_ocotp_ctrl_hw_ocotp_gp03[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 7, word 5 (ADDR = 0x3d).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_GP04.
static const field_t hw_ocotp_ctrl_hw_ocotp_gp04[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 7, word 6 (ADDR = 0x3e).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_HW_OCOTP_GP05.
static const field_t hw_ocotp_ctrl_hw_ocotp_gp05[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 7, word 7 (ADDR = 0x3f).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a OCOTP_CTRL module.
static const reg_t hw_ocotp_ctrl[] =
{
    {
        "HW_OCOTP_CTRL",
        "The OCOTP Control and Status Register provides the necessary software "
        "interface for performing read and write operations to the On-Chip OTP "
        "(One-Time Programmable ROM).",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_ctrl
    },
    {
        "HW_OCOTP_CTRL_SET",
        "The OCOTP Control and Status Register provides the necessary software "
        "interface for performing read and write operations to the On-Chip OTP "
        "(One-Time Programmable ROM).",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_ctrl_set
    },
    {
        "HW_OCOTP_CTRL_CLR",
        "The OCOTP Control and Status Register provides the necessary software "
        "interface for performing read and write operations to the On-Chip OTP "
        "(One-Time Programmable ROM).",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_ctrl_clr
    },
    {
        "HW_OCOTP_CTRL_TOG",
        "The OCOTP Control and Status Register provides the necessary software "
        "interface for performing read and write operations to the On-Chip OTP "
        "(One-Time Programmable ROM).",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_ctrl_tog
    },
    {
        "HW_OCOTP_PDN",
        "This register specifies PDN control for eFUSE macro.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_pdn
    },
    {
        "HW_OCOTP_DATA",
        "This register is used in conjuction with HW_OCOTP_CTRL to perform one-"
        "time writes to the OTP.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_data
    },
    {
        "HW_OCOTP_READ_CTRL",
        "This register is used in conjuction with HW_OCOTP_CTRL to perform one "
        "time read to the OTP.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_read_ctrl
    },
    {
        "HW_OCOTP_READ_FUSE_DATA",
        "The data read from OTP",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_read_fuse_data
    },
    {
        "HW_OCOTP_SW_STICKY",
        "Some sticky bits are used by SW to lock some fuse area , shadow regist"
        "ers and other features.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_sw_sticky
    },
    {
        "HW_OCOTP_SCS",
        "This register holds volatile configuration values that can be set and "
        "locked by trusted software.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_scs
    },
    {
        "HW_OCOTP_SCS_SET",
        "This register holds volatile configuration values that can be set and "
        "locked by trusted software.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_scs_set
    },
    {
        "HW_OCOTP_SCS_CLR",
        "This register holds volatile configuration values that can be set and "
        "locked by trusted software.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_scs_clr
    },
    {
        "HW_OCOTP_SCS_TOG",
        "This register holds volatile configuration values that can be set and "
        "locked by trusted software.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_scs_tog
    },
    {
        "HW_OCOTP_OUT_STATUS",
        "This register stores output signals of OTP memory for programming and "
        "reading OTP memory.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_out_status
    },
    {
        "HW_OCOTP_OUT_STATUS_SET",
        "This register stores output signals of OTP memory for programming and "
        "reading OTP memory.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_out_status_set
    },
    {
        "HW_OCOTP_OUT_STATUS_CLR",
        "This register stores output signals of OTP memory for programming and "
        "reading OTP memory.",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_out_status_clr
    },
    {
        "HW_OCOTP_OUT_STATUS_TOG",
        "This register stores output signals of OTP memory for programming and "
        "reading OTP memory.",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_out_status_tog
    },
    {
        "HW_OCOTP_STARTWORD",
        "This register stores output startword value from OTP memory.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_startword
    },
    {
        "HW_OCOTP_VERSION",
        "This register indicates the RTL version in use.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_version
    },
    {
        "HW_OCOTP_LOCK0",
        "Shadowed memory mapped access to OTP Bank 1, word 0 (ADDR = 0x08).",
        4, // Width in bytes
        0x00000480, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_lock0
    },
    {
        "HW_OCOTP_BOOT3",
        "Shadowed memory mapped access to OTP Bank 2, word 3 (ADDR = 0x13).",
        4, // Width in bytes
        0x00000530, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_boot3
    },
    {
        "HW_OCOTP_BOOT4",
        "Shadowed memory mapped access to OTP Bank 2, word 4 (ADDR = 0x14).",
        4, // Width in bytes
        0x00000540, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_boot4
    },
    {
        "HW_OCOTP_BOOT5",
        "Shadowed memory mapped access to OTP Bank 2, word 5 (ADDR = 0x15).",
        4, // Width in bytes
        0x00000550, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_boot5
    },
    {
        "HW_OCOTP_BOOT6",
        "Shadowed memory mapped access to OTP Bank 2, word 6 (ADDR = 0x16).",
        4, // Width in bytes
        0x00000560, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_boot6
    },
    {
        "HW_OCOTP_BOOT7",
        "Shadowed memory mapped access to OTP Bank 2, word 7 (ADDR = 0x17).",
        4, // Width in bytes
        0x00000570, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_boot7
    },
    {
        "HW_OCOTP_ANA2",
        "Shadowed memory mapped access to OTP bank 3, word 6 (ADDR = 0x1e).",
        4, // Width in bytes
        0x000005e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_ana2
    },
    {
        "HW_OCOTP_ANA3",
        "Shadowed memory mapped access to OTP bank 3, word 7 (ADDR = 0x1f).",
        4, // Width in bytes
        0x000005f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_ana3
    },
    {
        "HW_OCOTP_GP00",
        "Shadowed memory mapped access to OTP Bank 7, word 2 (ADDR = 0x3a).",
        4, // Width in bytes
        0x000007a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_gp00
    },
    {
        "HW_OCOTP_GP01",
        "Shadowed memory mapped access to OTP Bank7, word 3 (ADDR = 0x3b).",
        4, // Width in bytes
        0x000007b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_gp01
    },
    {
        "HW_OCOTP_GP02",
        "Shadowed memory mapped access to OTP Bank 7, word 4 (ADDR = 0x3c).",
        4, // Width in bytes
        0x000007c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_gp02
    },
    {
        "HW_OCOTP_GP03",
        "Shadowed memory mapped access to OTP Bank 7, word 5 (ADDR = 0x3d).",
        4, // Width in bytes
        0x000007d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_gp03
    },
    {
        "HW_OCOTP_GP04",
        "Shadowed memory mapped access to OTP Bank 7, word 6 (ADDR = 0x3e).",
        4, // Width in bytes
        0x000007e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_gp04
    },
    {
        "HW_OCOTP_GP05",
        "Shadowed memory mapped access to OTP Bank 7, word 7 (ADDR = 0x3f).",
        4, // Width in bytes
        0x000007f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ctrl_hw_ocotp_gp05
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PCC_1
#endif

// Bitfields in register PCC_1_PCC_DMA0.
static const field_t hw_pcc_1_pcc_dma0[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_RGPIO2P0.
static const field_t hw_pcc_1_pcc_rgpio2p0[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_XRDC.
static const field_t hw_pcc_1_pcc_xrdc[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_SEMA42_0.
static const field_t hw_pcc_1_pcc_sema42_0[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_DMA_MUX0.
static const field_t hw_pcc_1_pcc_dma_mux0[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_MU_A.
static const field_t hw_pcc_1_pcc_mu_a[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_WDOG0.
static const field_t hw_pcc_1_pcc_wdog0[] =
{
    {
        "PCD",
        "This read/write bit field is used for peripherals that require a clock"
        " divider.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAC",
        "This read/write bit field sets the fraction multiply value for the fra"
        "ctional clock divider used as a clock source.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_CRC.
static const field_t hw_pcc_1_pcc_crc[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_LTC.
static const field_t hw_pcc_1_pcc_ltc[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_TRNG.
static const field_t hw_pcc_1_pcc_trng[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_LPIT0.
static const field_t hw_pcc_1_pcc_lpit0[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_LPTIMER0.
static const field_t hw_pcc_1_pcc_lptimer0[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_LPTIMER1.
static const field_t hw_pcc_1_pcc_lptimer1[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_TPM0.
static const field_t hw_pcc_1_pcc_tpm0[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_TPM1.
static const field_t hw_pcc_1_pcc_tpm1[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_FLEXIO0.
static const field_t hw_pcc_1_pcc_flexio0[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_LPI2C0.
static const field_t hw_pcc_1_pcc_lpi2c0[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_LPI2C1.
static const field_t hw_pcc_1_pcc_lpi2c1[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_LPI2C2.
static const field_t hw_pcc_1_pcc_lpi2c2[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_LPI2C3.
static const field_t hw_pcc_1_pcc_lpi2c3[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_SAI0.
static const field_t hw_pcc_1_pcc_sai0[] =
{
    {
        "PCD",
        "This read/write bit field is used for peripherals that require a clock"
        " divider.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_LPSPI0.
static const field_t hw_pcc_1_pcc_lpspi0[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_LPSPI1.
static const field_t hw_pcc_1_pcc_lpspi1[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_LPUART0.
static const field_t hw_pcc_1_pcc_lpuart0[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_LPUART1.
static const field_t hw_pcc_1_pcc_lpuart1[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_PCTLA.
static const field_t hw_pcc_1_pcc_pctla[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_PCTLB.
static const field_t hw_pcc_1_pcc_pctlb[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_ADC0.
static const field_t hw_pcc_1_pcc_adc0[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_CMP0.
static const field_t hw_pcc_1_pcc_cmp0[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_CMP1.
static const field_t hw_pcc_1_pcc_cmp1[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_DAC0.
static const field_t hw_pcc_1_pcc_dac0[] =
{
    {
        "PCD",
        "This read/write bit field is used for peripherals that require a clock"
        " divider.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAC",
        "This read/write bit field sets the fraction multiply value for the fra"
        "ctional clock divider used as a clock source.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_1_PCC_DAC1.
static const field_t hw_pcc_1_pcc_dac1[] =
{
    {
        "PCD",
        "This read/write bit field is used for peripherals that require a clock"
        " divider.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAC",
        "This read/write bit field sets the fraction multiply value for the fra"
        "ctional clock divider used as a clock source.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a PCC_1 module.
static const reg_t hw_pcc_1[] =
{
    {
        "PCC_DMA0",
        "PCC Register",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_1_pcc_dma0
    },
    {
        "PCC_RGPIO2P0",
        "PCC Register",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_1_pcc_rgpio2p0
    },
    {
        "PCC_XRDC",
        "PCC Register",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_1_pcc_xrdc
    },
    {
        "PCC_SEMA42_0",
        "PCC Register",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_1_pcc_sema42_0
    },
    {
        "PCC_DMA_MUX0",
        "PCC Register",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_1_pcc_dma_mux0
    },
    {
        "PCC_MU_A",
        "PCC Register",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_1_pcc_mu_a
    },
    {
        "PCC_WDOG0",
        "PCC Register",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pcc_1_pcc_wdog0
    },
    {
        "PCC_CRC",
        "PCC Register",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_1_pcc_crc
    },
    {
        "PCC_LTC",
        "PCC Register",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_1_pcc_ltc
    },
    {
        "PCC_TRNG",
        "PCC Register",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_1_pcc_trng
    },
    {
        "PCC_LPIT0",
        "PCC Register",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_1_pcc_lpit0
    },
    {
        "PCC_LPTIMER0",
        "PCC Register",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_1_pcc_lptimer0
    },
    {
        "PCC_LPTIMER1",
        "PCC Register",
        4, // Width in bytes
        0x000000bc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_1_pcc_lptimer1
    },
    {
        "PCC_TPM0",
        "PCC Register",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_1_pcc_tpm0
    },
    {
        "PCC_TPM1",
        "PCC Register",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_1_pcc_tpm1
    },
    {
        "PCC_FLEXIO0",
        "PCC Register",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_1_pcc_flexio0
    },
    {
        "PCC_LPI2C0",
        "PCC Register",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_1_pcc_lpi2c0
    },
    {
        "PCC_LPI2C1",
        "PCC Register",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_1_pcc_lpi2c1
    },
    {
        "PCC_LPI2C2",
        "PCC Register",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_1_pcc_lpi2c2
    },
    {
        "PCC_LPI2C3",
        "PCC Register",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_1_pcc_lpi2c3
    },
    {
        "PCC_SAI0",
        "PCC Register",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pcc_1_pcc_sai0
    },
    {
        "PCC_LPSPI0",
        "PCC Register",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_1_pcc_lpspi0
    },
    {
        "PCC_LPSPI1",
        "PCC Register",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_1_pcc_lpspi1
    },
    {
        "PCC_LPUART0",
        "PCC Register",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_1_pcc_lpuart0
    },
    {
        "PCC_LPUART1",
        "PCC Register",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_1_pcc_lpuart1
    },
    {
        "PCC_PCTLA",
        "PCC Register",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_1_pcc_pctla
    },
    {
        "PCC_PCTLB",
        "PCC Register",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_1_pcc_pctlb
    },
    {
        "PCC_ADC0",
        "PCC Register",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_1_pcc_adc0
    },
    {
        "PCC_CMP0",
        "PCC Register",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_1_pcc_cmp0
    },
    {
        "PCC_CMP1",
        "PCC Register",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_1_pcc_cmp1
    },
    {
        "PCC_DAC0",
        "PCC Register",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pcc_1_pcc_dac0
    },
    {
        "PCC_DAC1",
        "PCC Register",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pcc_1_pcc_dac1
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PCC_2
#endif

// Bitfields in register PCC_2_PCC_TPIU.
static const field_t hw_pcc_2_pcc_tpiu[] =
{
    {
        "PCD",
        "This read/write bit field is used for peripherals that require a clock"
        " divider.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAC",
        "This read/write bit field sets the fraction multiply value for the fra"
        "ctional clock divider used as a clock source.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_2_PCC_QSPI_OTFAD.
static const field_t hw_pcc_2_pcc_qspi_otfad[] =
{
    {
        "PCD",
        "This read/write bit field is used for peripherals that require a clock"
        " divider.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAC",
        "This read/write bit field sets the fraction multiply value for the fra"
        "ctional clock divider used as a clock source.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_2_PCC_TPM2.
static const field_t hw_pcc_2_pcc_tpm2[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_2_PCC_TPM3.
static const field_t hw_pcc_2_pcc_tpm3[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_2_PCC_SAI1.
static const field_t hw_pcc_2_pcc_sai1[] =
{
    {
        "PCD",
        "This read/write bit field is used for peripherals that require a clock"
        " divider.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_2_PCC_LPUART2.
static const field_t hw_pcc_2_pcc_lpuart2[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_2_PCC_LPUART3.
static const field_t hw_pcc_2_pcc_lpuart3[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_2_PCC_ADC1.
static const field_t hw_pcc_2_pcc_adc1[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a PCC_2 module.
static const reg_t hw_pcc_2[] =
{
    {
        "PCC_TPIU",
        "PCC Register",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pcc_2_pcc_tpiu
    },
    {
        "PCC_QSPI_OTFAD",
        "PCC Register",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pcc_2_pcc_qspi_otfad
    },
    {
        "PCC_TPM2",
        "PCC Register",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_2_pcc_tpm2
    },
    {
        "PCC_TPM3",
        "PCC Register",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_2_pcc_tpm3
    },
    {
        "PCC_SAI1",
        "PCC Register",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pcc_2_pcc_sai1
    },
    {
        "PCC_LPUART2",
        "PCC Register",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_2_pcc_lpuart2
    },
    {
        "PCC_LPUART3",
        "PCC Register",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_2_pcc_lpuart3
    },
    {
        "PCC_ADC1",
        "PCC Register",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_2_pcc_adc1
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PCC_3
#endif

// Bitfields in register PCC_3_PCC_DMA1.
static const field_t hw_pcc_3_pcc_dma1[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_RGPIO2P1.
static const field_t hw_pcc_3_pcc_rgpio2p1[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_FLEXBUS.
static const field_t hw_pcc_3_pcc_flexbus[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_SEMA42_1.
static const field_t hw_pcc_3_pcc_sema42_1[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_DMA_MUX1.
static const field_t hw_pcc_3_pcc_dma_mux1[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_SNVS.
static const field_t hw_pcc_3_pcc_snvs[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_CAAM.
static const field_t hw_pcc_3_pcc_caam[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_TPM4.
static const field_t hw_pcc_3_pcc_tpm4[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_TPM5.
static const field_t hw_pcc_3_pcc_tpm5[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_LPIT1.
static const field_t hw_pcc_3_pcc_lpit1[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_LPSPI2.
static const field_t hw_pcc_3_pcc_lpspi2[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_LPSPI3.
static const field_t hw_pcc_3_pcc_lpspi3[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_LPI2C4.
static const field_t hw_pcc_3_pcc_lpi2c4[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_LPI2C5.
static const field_t hw_pcc_3_pcc_lpi2c5[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_LPUART4.
static const field_t hw_pcc_3_pcc_lpuart4[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_LPUART5.
static const field_t hw_pcc_3_pcc_lpuart5[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_FLEXIO1.
static const field_t hw_pcc_3_pcc_flexio1[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_USB0.
static const field_t hw_pcc_3_pcc_usb0[] =
{
    {
        "PCD",
        "This read/write bit field is used for peripherals that require a clock"
        " divider.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAC",
        "This read/write bit field sets the fraction multiply value for the fra"
        "ctional clock divider used as a clock source.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_USB1.
static const field_t hw_pcc_3_pcc_usb1[] =
{
    {
        "PCD",
        "This read/write bit field is used for peripherals that require a clock"
        " divider.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAC",
        "This read/write bit field sets the fraction multiply value for the fra"
        "ctional clock divider used as a clock source.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_USB_PHY.
static const field_t hw_pcc_3_pcc_usb_phy[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_USB_PL301.
static const field_t hw_pcc_3_pcc_usb_pl301[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_USDHC0.
static const field_t hw_pcc_3_pcc_usdhc0[] =
{
    {
        "PCD",
        "This read/write bit field is used for peripherals that require a clock"
        " divider.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAC",
        "This read/write bit field sets the fraction multiply value for the fra"
        "ctional clock divider used as a clock source.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_USDHC1.
static const field_t hw_pcc_3_pcc_usdhc1[] =
{
    {
        "PCD",
        "This read/write bit field is used for peripherals that require a clock"
        " divider.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAC",
        "This read/write bit field sets the fraction multiply value for the fra"
        "ctional clock divider used as a clock source.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_WDOG1.
static const field_t hw_pcc_3_pcc_wdog1[] =
{
    {
        "PCD",
        "This read/write bit field is used for peripherals that require a clock"
        " divider.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAC",
        "This read/write bit field sets the fraction multiply value for the fra"
        "ctional clock divider used as a clock source.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_3_PCC_WDOG2.
static const field_t hw_pcc_3_pcc_wdog2[] =
{
    {
        "PCD",
        "This read/write bit field is used for peripherals that require a clock"
        " divider.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAC",
        "This read/write bit field sets the fraction multiply value for the fra"
        "ctional clock divider used as a clock source.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a PCC_3 module.
static const reg_t hw_pcc_3[] =
{
    {
        "PCC_DMA1",
        "PCC Register",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_3_pcc_dma1
    },
    {
        "PCC_RGPIO2P1",
        "PCC Register",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_3_pcc_rgpio2p1
    },
    {
        "PCC_FLEXBUS",
        "PCC Register",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_3_pcc_flexbus
    },
    {
        "PCC_SEMA42_1",
        "PCC Register",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_3_pcc_sema42_1
    },
    {
        "PCC_DMA_MUX1",
        "PCC Register",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_3_pcc_dma_mux1
    },
    {
        "PCC_SNVS",
        "PCC Register",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_3_pcc_snvs
    },
    {
        "PCC_CAAM",
        "PCC Register",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_3_pcc_caam
    },
    {
        "PCC_TPM4",
        "PCC Register",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_3_pcc_tpm4
    },
    {
        "PCC_TPM5",
        "PCC Register",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_3_pcc_tpm5
    },
    {
        "PCC_LPIT1",
        "PCC Register",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_3_pcc_lpit1
    },
    {
        "PCC_LPSPI2",
        "PCC Register",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_3_pcc_lpspi2
    },
    {
        "PCC_LPSPI3",
        "PCC Register",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_3_pcc_lpspi3
    },
    {
        "PCC_LPI2C4",
        "PCC Register",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_3_pcc_lpi2c4
    },
    {
        "PCC_LPI2C5",
        "PCC Register",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_3_pcc_lpi2c5
    },
    {
        "PCC_LPUART4",
        "PCC Register",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_3_pcc_lpuart4
    },
    {
        "PCC_LPUART5",
        "PCC Register",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_3_pcc_lpuart5
    },
    {
        "PCC_FLEXIO1",
        "PCC Register",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_3_pcc_flexio1
    },
    {
        "PCC_USB0",
        "PCC Register",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pcc_3_pcc_usb0
    },
    {
        "PCC_USB1",
        "PCC Register",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pcc_3_pcc_usb1
    },
    {
        "PCC_USB_PHY",
        "PCC Register",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_3_pcc_usb_phy
    },
    {
        "PCC_USB_PL301",
        "PCC Register",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_3_pcc_usb_pl301
    },
    {
        "PCC_USDHC0",
        "PCC Register",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pcc_3_pcc_usdhc0
    },
    {
        "PCC_USDHC1",
        "PCC Register",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pcc_3_pcc_usdhc1
    },
    {
        "PCC_WDOG1",
        "PCC Register",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pcc_3_pcc_wdog1
    },
    {
        "PCC_WDOG2",
        "PCC Register",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pcc_3_pcc_wdog2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PCC_4
#endif

// Bitfields in register PCC_4_PCC_TPM6.
static const field_t hw_pcc_4_pcc_tpm6[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_4_PCC_TPM7.
static const field_t hw_pcc_4_pcc_tpm7[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_4_PCC_LPI2C6.
static const field_t hw_pcc_4_pcc_lpi2c6[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_4_PCC_LPI2C7.
static const field_t hw_pcc_4_pcc_lpi2c7[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_4_PCC_LPUART6.
static const field_t hw_pcc_4_pcc_lpuart6[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_4_PCC_LPUART7.
static const field_t hw_pcc_4_pcc_lpuart7[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_4_PCC_VIU.
static const field_t hw_pcc_4_pcc_viu[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_4_PCC_DSI.
static const field_t hw_pcc_4_pcc_dsi[] =
{
    {
        "PCD",
        "This read/write bit field is used for peripherals that require a clock"
        " divider.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAC",
        "This read/write bit field sets the fraction multiply value for the fra"
        "ctional clock divider used as a clock source.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_4_PCC_LCDIF.
static const field_t hw_pcc_4_pcc_lcdif[] =
{
    {
        "PCD",
        "This read/write bit field is used for peripherals that require a clock"
        " divider.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAC",
        "This read/write bit field sets the fraction multiply value for the fra"
        "ctional clock divider used as a clock source.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_4_PCC_MMDC.
static const field_t hw_pcc_4_pcc_mmdc[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_4_PCC_PCTLC.
static const field_t hw_pcc_4_pcc_pctlc[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_4_PCC_PCTLD.
static const field_t hw_pcc_4_pcc_pctld[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_4_PCC_PCTLE.
static const field_t hw_pcc_4_pcc_pctle[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_4_PCC_PCTLF.
static const field_t hw_pcc_4_pcc_pctlf[] =
{
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_4_PCC_GPU3D.
static const field_t hw_pcc_4_pcc_gpu3d[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PCC_4_PCC_GPU2D.
static const field_t hw_pcc_4_pcc_gpu2d[] =
{
    {
        "PCS",
        "This read/write bit field is used for peripherals that support various"
        " clock selections.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INUSE",
        "This read-only bit shows that this peripheral is being used by another"
        " core.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CGC",
        "This read/write bit enables the clock for the peripheral.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "This bit shows whether the peripheral is present on this device.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a PCC_4 module.
static const reg_t hw_pcc_4[] =
{
    {
        "PCC_TPM6",
        "PCC Register",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_4_pcc_tpm6
    },
    {
        "PCC_TPM7",
        "PCC Register",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_4_pcc_tpm7
    },
    {
        "PCC_LPI2C6",
        "PCC Register",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_4_pcc_lpi2c6
    },
    {
        "PCC_LPI2C7",
        "PCC Register",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_4_pcc_lpi2c7
    },
    {
        "PCC_LPUART6",
        "PCC Register",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_4_pcc_lpuart6
    },
    {
        "PCC_LPUART7",
        "PCC Register",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_4_pcc_lpuart7
    },
    {
        "PCC_VIU",
        "PCC Register",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_4_pcc_viu
    },
    {
        "PCC_DSI",
        "PCC Register",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pcc_4_pcc_dsi
    },
    {
        "PCC_LCDIF",
        "PCC Register",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pcc_4_pcc_lcdif
    },
    {
        "PCC_MMDC",
        "PCC Register",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_4_pcc_mmdc
    },
    {
        "PCC_PCTLC",
        "PCC Register",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_4_pcc_pctlc
    },
    {
        "PCC_PCTLD",
        "PCC Register",
        4, // Width in bytes
        0x000000bc, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_4_pcc_pctld
    },
    {
        "PCC_PCTLE",
        "PCC Register",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_4_pcc_pctle
    },
    {
        "PCC_PCTLF",
        "PCC Register",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pcc_4_pcc_pctlf
    },
    {
        "PCC_GPU3D",
        "PCC Register",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_4_pcc_gpu3d
    },
    {
        "PCC_GPU2D",
        "PCC Register",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pcc_4_pcc_gpu2d
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PMC0
#endif

// Bitfields in register PMC0_VERID.
static const field_t hw_pmc0_verid[] =
{
    {
        "FEATURE",
        "This read only field returns the feature set number.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read only field returns the minor version number for the module s"
        "pecification.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read only field returns the major version number for the module s"
        "pecification.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC0_HSRUN.
static const field_t hw_pmc0_hsrun[] =
{
    {
        "COREREGVL",
        "The valid values are between 0 and 50.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FBBEN",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC0_RUN.
static const field_t hw_pmc0_run[] =
{
    {
        "COREREGVL",
        "The valid values are between 0 and 50.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC0_VLPR.
static const field_t hw_pmc0_vlpr[] =
{
    {
        "ARRAYREG",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COREREG",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON1P2LVDHP",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON1P2HVDHP",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FBGHP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COREREGVL",
        "The valid values are between 0 and 50.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBBEN",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC0_STOP.
static const field_t hw_pmc0_stop[] =
{
    {
        "COREREGVL",
        "The valid values are between 0 and 50.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC0_VLPS.
static const field_t hw_pmc0_vlps[] =
{
    {
        "ARRAYREG",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COREREG",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON1P2LVDHP",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON1P2HVDHP",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FBGHP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COREREGVL",
        "The valid values are between 0 and 50.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBBEN",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC0_LLS.
static const field_t hw_pmc0_lls[] =
{
    {
        "ARRAYREG",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COREREG",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON1P2LVDHP",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON1P2HVDHP",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FBGHP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COREREGVL",
        "The valid values are between 0 and 50.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBBEN",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC0_VLLS.
static const field_t hw_pmc0_vlls[] =
{
    {
        "ARRAYREG",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON1P2LVDHP",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON1P2HVDHP",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FBGHP",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC0_STATUS.
static const field_t hw_pmc0_status[] =
{
    {
        "LVD1P2F",
        "This flag is set when a low-voltage event was detected by the 1.2V LVD"
        " monitor in the PMC 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LVD1P2V",
        "This bit is the current value of the 1.2V LVD monitor in the PMC 0.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HVD1P2F",
        "This flag is set when a high-voltage event was detected by the 1.2V HV"
        "D monitor in the PMC 0.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HVD1P2V",
        "This bit is the current value of the 1.2V HVD monitor in the PMC 0.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COREVLF",
        "This flag is one when the PMC is changing the Core Regulator Voltage L"
        "evel due a different value writing in the fields PMC0_RUN[COREREGVL] ("
        "or PMC0_HSRUN[COREREGVL], depending on the PMC 0 mode).",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SRAMF",
        "This flag indicates if a request to some SRAM enter(or exit) to some p"
        "ower mode is being processed.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC0_CTRL.
static const field_t hw_pmc0_ctrl[] =
{
    {
        "LVD1P2IE",
        "For more information see .",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVD1P2ACK",
        "Write 1 to the bit LVD1P2ACK clears the bit LVD1P2F in the register PM"
        "C0_STATUS and its interruption (if the interruption is enabled).",
        1, // LSB
        1, // MSB
        false, // Readable
        false // Writable
    },
    {
        "HVD1P2IE",
        "For more information see .",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HVD1P2ACK",
        "Write 1 to the bit HVD1P2ACK clears the bit HVD1P2F in the register PM"
        "C0_STATUS and its interruption (if the interruption is enabled).",
        3, // LSB
        3, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LVD1P2RE",
        "For more information see .",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HVD1P2RE",
        "For more information see .",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISOACK",
        "When 1 is written to this bit the isolation in the PADS is released.",
        14, // LSB
        14, // MSB
        false, // Readable
        false // Writable
    },
    {
        "SWRBBEN",
        "The power switches has a setup to use reverse back bias in its gate an"
        "d this way reduce the leakage.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PMC1ON",
        "When this bit field is asserted the PMC 1 is powered on.",
        24, // LSB
        24, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LDOOKDIS",
        "This bitfield selects whether or not the PMC will check the regulated "
        "output from the LDO Regulator during a mode transition, PMC 1 power-up"
        " or a voltage level change (PMC1 in RUN/HSRUN mode).",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOEN",
        "For more information see .",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC0_SRAMCTRL_0.
static const field_t hw_pmc0_sramctrl_0[] =
{
    {
        "SRAM_PD",
        "The bit i controls the power mode of the PMC 0 SRAM bank i.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC0_SRAMCTRL_1.
static const field_t hw_pmc0_sramctrl_1[] =
{
    {
        "SRAM_PDS",
        "The bit i controls the power mode of the PMC 0 SRAM bank i.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC0_SRAMCTRL_2.
static const field_t hw_pmc0_sramctrl_2[] =
{
    {
        "SRAM_STDY",
        "The bit i controls the PMC 0 SRAM bank i.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a PMC0 module.
static const reg_t hw_pmc0[] =
{
    {
        "VERID",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_pmc0_verid
    },
    {
        "HSRUN",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pmc0_hsrun
    },
    {
        "RUN",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pmc0_run
    },
    {
        "VLPR",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_pmc0_vlpr
    },
    {
        "STOP",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pmc0_stop
    },
    {
        "VLPS",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_pmc0_vlps
    },
    {
        "LLS",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_pmc0_lls
    },
    {
        "VLLS",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pmc0_vlls
    },
    {
        "STATUS",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_pmc0_status
    },
    {
        "CTRL",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_pmc0_ctrl
    },
    {
        "SRAMCTRL_0",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pmc0_sramctrl_0
    },
    {
        "SRAMCTRL_1",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pmc0_sramctrl_1
    },
    {
        "SRAMCTRL_2",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pmc0_sramctrl_2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PMC1
#endif

// Bitfields in register PMC1_VERID.
static const field_t hw_pmc1_verid[] =
{
    {
        "FEATURE",
        "This read only field returns the feature set number.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read only field returns the minor version number for the module s"
        "pecification.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read only field returns the major version number for the module s"
        "pecification.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC1_HSRUN.
static const field_t hw_pmc1_hsrun[] =
{
    {
        "LDOVL",
        "The valid values are between 0 and 50.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FBBEN",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC1_RUN.
static const field_t hw_pmc1_run[] =
{
    {
        "LDOVL",
        "The valid values are between 0 and 50.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC1_VLPR.
static const field_t hw_pmc1_vlpr[] =
{
    {
        "LDOM",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON1P2LVDHP",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON1P2HVDHP",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOVL",
        "The valid values are between 0 and 50.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC1_STATUS.
static const field_t hw_pmc1_status[] =
{
    {
        "LVD1P2F",
        "This flag is set when a low-voltage event was detected by the 1.2V LVD"
        " monitor in the PMC 1.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LVD1P2V",
        "This bit is the current value of the 1.2V LVD monitor in the PMC 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HVD1P2F",
        "This flag is set when a high-voltage event was detected by the 1.2V HV"
        "D monitor in the PMC 1.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HVD1P2V",
        "This bit is the current value of the 1.2V HVD monitor in the PMC 1.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LDOVLF",
        "This flag is asserted when the PMC is changing the LDO Voltage Level d"
        "ue a different value writing in the field PMC1_RUN[LDOVL] (or PMC1_HSR"
        "UN[LDOVL], depending on the PMC 1 mode).",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SRAMF",
        "This flag indicates if a request to some SRAM enter(or exit) to some p"
        "ower mode is being processed.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC1_CTRL.
static const field_t hw_pmc1_ctrl[] =
{
    {
        "LVD1P2IE",
        "For more information see .",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVD1P2ACK",
        "Write 1 to the bit LVD1P2ACK clears the bit LVD1P2F in the register PM"
        "C1_STATUS and its interruption (if the interruption is enabled).",
        1, // LSB
        1, // MSB
        false, // Readable
        false // Writable
    },
    {
        "HVD1P2IE",
        "For more information see .",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HVD1P2ACK",
        "Write 1 to the bit HVD1P2ACK clears the bit HVD1P2F in the register PM"
        "C1_STATUS and its interruption (if the interruption is enabled).",
        3, // LSB
        3, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LVD1P2RE",
        "For more information see .",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HVD1P2RE",
        "For more information see .",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISOACK",
        "When 1 is written to this bit, the isolation in the pads is released.",
        14, // LSB
        14, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC1_SRAMCTRL.
static const field_t hw_pmc1_sramctrl[] =
{
    {
        "SRAM_STDY",
        "The bit i controls the PMC 1 SRAM bank i.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC1_STOP.
static const field_t hw_pmc1_stop[] =
{
    {
        "LDOVL",
        "The valid values are between 0 and 50.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC1_VLPS.
static const field_t hw_pmc1_vlps[] =
{
    {
        "LDOM",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON1P2LVDHP",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON1P2HVDHP",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOVL",
        "The valid values are between 0 and 50.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBBEN",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC1_LLS.
static const field_t hw_pmc1_lls[] =
{
    {
        "LDOM",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON1P2LVDHP",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON1P2HVDHP",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDOVL",
        "The valid values are between 0 and 50.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBBEN",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMC1_VLLS.
static const field_t hw_pmc1_vlls[] =
{
    {
        "LDOM",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON1P2LVDHP",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MON1P2HVDHP",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a PMC1 module.
static const reg_t hw_pmc1[] =
{
    {
        "VERID",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_pmc1_verid
    },
    {
        "HSRUN",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pmc1_hsrun
    },
    {
        "RUN",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pmc1_run
    },
    {
        "VLPR",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pmc1_vlpr
    },
    {
        "STATUS",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_pmc1_status
    },
    {
        "CTRL",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_pmc1_ctrl
    },
    {
        "SRAMCTRL",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pmc1_sramctrl
    },
    {
        "STOP",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pmc1_stop
    },
    {
        "VLPS",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pmc1_vlps
    },
    {
        "LLS",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pmc1_lls
    },
    {
        "VLLS",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pmc1_vlls
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PORT
#endif

// Bitfields in register PORT_PCR0.
static const field_t hw_port_pcr0[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR1.
static const field_t hw_port_pcr1[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR2.
static const field_t hw_port_pcr2[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR3.
static const field_t hw_port_pcr3[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR4.
static const field_t hw_port_pcr4[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR5.
static const field_t hw_port_pcr5[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR6.
static const field_t hw_port_pcr6[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR7.
static const field_t hw_port_pcr7[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR8.
static const field_t hw_port_pcr8[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR9.
static const field_t hw_port_pcr9[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR10.
static const field_t hw_port_pcr10[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR11.
static const field_t hw_port_pcr11[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR12.
static const field_t hw_port_pcr12[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR13.
static const field_t hw_port_pcr13[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR14.
static const field_t hw_port_pcr14[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR15.
static const field_t hw_port_pcr15[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR16.
static const field_t hw_port_pcr16[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR17.
static const field_t hw_port_pcr17[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR18.
static const field_t hw_port_pcr18[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR19.
static const field_t hw_port_pcr19[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR20.
static const field_t hw_port_pcr20[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR21.
static const field_t hw_port_pcr21[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR22.
static const field_t hw_port_pcr22[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR23.
static const field_t hw_port_pcr23[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR24.
static const field_t hw_port_pcr24[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR25.
static const field_t hw_port_pcr25[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR26.
static const field_t hw_port_pcr26[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR27.
static const field_t hw_port_pcr27[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR28.
static const field_t hw_port_pcr28[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR29.
static const field_t hw_port_pcr29[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR30.
static const field_t hw_port_pcr30[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_PCR31.
static const field_t hw_port_pcr31[] =
{
    {
        "IRQC",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISF",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_GPCLR.
static const field_t hw_port_gpclr[] =
{
    {
        "GPWD",
        "GPWD field is written to PCRa[15:0] if GPWEn = 1 (a = n).",
        0, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "GPWE",
        "Selects which Pin Control Registers (15 through 0) bits update with th"
        "e value in GPWD.",
        16, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_GPCHR.
static const field_t hw_port_gpchr[] =
{
    {
        "GPWD",
        "GPWD field is written to PCRa[15:0] if GPWEn = 1 (a = n + 16).",
        0, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "GPWE",
        "Selects which Pin Control Registers (31 through 16) update with the va"
        "lue in GPWD.",
        16, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_GICLR.
static const field_t hw_port_giclr[] =
{
    {
        "GIWE",
        "Selects which upper 16-bits of Pin Control Registers (15 through 0) up"
        "date with the value in GIWD.",
        0, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "GIWD",
        "Write value that is written to upper 16-bits of the Pin Control Regist"
        "ers bits that are selected by GIWE.",
        16, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_GICHR.
static const field_t hw_port_gichr[] =
{
    {
        "GIWE",
        "Selects which upper 16-bits of Pin Control Registers (31 through 16) u"
        "pdate with the value in GIWD.",
        0, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "GIWD",
        "Write value that is written to upper 16-bits of the Pin Control Regist"
        "ers that are selected by GIWE.",
        16, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PORT_ISFR.
static const field_t hw_port_isfr[] =
{
    {
        "ISF",
        "Each bit in the field indicates the detection of the configured interr"
        "upt of the same number as the field.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a PORT module.
static const reg_t hw_port[] =
{
    {
        "PCR0",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr0
    },
    {
        "PCR1",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr1
    },
    {
        "PCR2",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr2
    },
    {
        "PCR3",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr3
    },
    {
        "PCR4",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr4
    },
    {
        "PCR5",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr5
    },
    {
        "PCR6",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr6
    },
    {
        "PCR7",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr7
    },
    {
        "PCR8",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr8
    },
    {
        "PCR9",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr9
    },
    {
        "PCR10",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr10
    },
    {
        "PCR11",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr11
    },
    {
        "PCR12",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr12
    },
    {
        "PCR13",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr13
    },
    {
        "PCR14",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr14
    },
    {
        "PCR15",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr15
    },
    {
        "PCR16",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr16
    },
    {
        "PCR17",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr17
    },
    {
        "PCR18",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr18
    },
    {
        "PCR19",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr19
    },
    {
        "PCR20",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr20
    },
    {
        "PCR21",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr21
    },
    {
        "PCR22",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr22
    },
    {
        "PCR23",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr23
    },
    {
        "PCR24",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr24
    },
    {
        "PCR25",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr25
    },
    {
        "PCR26",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr26
    },
    {
        "PCR27",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr27
    },
    {
        "PCR28",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr28
    },
    {
        "PCR29",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr29
    },
    {
        "PCR30",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr30
    },
    {
        "PCR31",
        "See the Signal Multiplexing and Pin Assignment chapter for the reset v"
        "alues for the pins on this device.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_pcr31
    },
    {
        "GPCLR",
        "Only 32-bit writes are supported to this register, any 16-bit or 8-bit"
        " writes are ignored.",
        4, // Width in bytes
        0x00000080, // Base address offset
        false, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_gpclr
    },
    {
        "GPCHR",
        "Only 32-bit writes are supported to this register, any 16-bit or 8-bit"
        " writes are ignored.",
        4, // Width in bytes
        0x00000084, // Base address offset
        false, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_gpchr
    },
    {
        "GICLR",
        "Only 32-bit writes are supported to this register, any 16-bit or 8-bit"
        " writes are ignored.",
        4, // Width in bytes
        0x00000088, // Base address offset
        false, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_giclr
    },
    {
        "GICHR",
        "Only 32-bit writes are supported to this register, any 16-bit or 8-bit"
        " writes are ignored.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        false, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_port_gichr
    },
    {
        "ISFR",
        "The pin interrupt configuration is valid in all digital pin muxing mod"
        "es.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_port_isfr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark QuadSPI
#endif

// Bitfields in register QuadSPI_QuadSPI0_MCR.
static const field_t hw_quadspi_quadspi0_mcr[] =
{
    {
        "SWRSTSD",
        "Software reset for serial flash domain",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWRSTHD",
        "Software reset for AHB domain",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "END_CFG",
        "Defines the endianness of the QuadSPI module.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DQS_LAT_EN",
        "DQS Latency Enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DQS_EN",
        "DQS enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_EN",
        "DDR mode enable",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_RXF",
        "Clear RX FIFO.",
        10, // LSB
        10, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CLR_TXF",
        "Clear TX FIFO/Buffer.",
        11, // LSB
        11, // MSB
        false, // Readable
        false // Writable
    },
    {
        "MDIS",
        "Module Disable.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISD2FA",
        "Idle Signal Drive IOFA[2] Flash A.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ISD3FA",
        "Idle Signal Drive IOFA[3] Flash A.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCLKCFG",
        "Serial Clock Configuration.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_IPCR.
static const field_t hw_quadspi_quadspi0_ipcr[] =
{
    {
        "IDATSZ",
        "IP data transfer size.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEQID",
        "Points to a sequence in the Look-up table.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_FLSHCR.
static const field_t hw_quadspi_quadspi0_flshcr[] =
{
    {
        "TCSS",
        "Serial flash CS setup time in terms of serial flash clock cycles.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSH",
        "Serial flash CS hold time in terms of serial flash clock cycles.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDH",
        "Serial flash data in hold time.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_BUF0CR.
static const field_t hw_quadspi_quadspi0_buf0cr[] =
{
    {
        "MSTRID",
        "Master ID.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADATSZ",
        "Defines the data transfer size in 8 bytes of an AHB triggered access t"
        "o serial flash.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_EN",
        "High Priority Enable.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_BUF1CR.
static const field_t hw_quadspi_quadspi0_buf1cr[] =
{
    {
        "MSTRID",
        "Master ID.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADATSZ",
        "Defines the data transfer size in 8 bytes of an AHB triggered access t"
        "o serial flash.For example, a value of 0x2 will set transfer size to 1"
        "6bytes.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_BUF2CR.
static const field_t hw_quadspi_quadspi0_buf2cr[] =
{
    {
        "MSTRID",
        "Master ID.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADATSZ",
        "Defines the data transfer size in 8 bytes of an AHB triggered access t"
        "o serial flash.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_BUF3CR.
static const field_t hw_quadspi_quadspi0_buf3cr[] =
{
    {
        "MSTRID",
        "Master ID.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADATSZ",
        "Defines the data transfer size in 8 Bytes of an AHB triggered access t"
        "o serial flash.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALLMST",
        "All master enable.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_BFGENCR.
static const field_t hw_quadspi_quadspi0_bfgencr[] =
{
    {
        "SEQID",
        "Points to a sequence in the Look-up-table.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_SOCCR.
static const field_t hw_quadspi_quadspi0_soccr[] =
{
    {
        "SOCCFG",
        "SOC Configuration For details, refer to chip-specific QuadSPI informat"
        "ion.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_BUF0IND.
static const field_t hw_quadspi_quadspi0_buf0ind[] =
{
    {
        "TPINDX0",
        "Top index of buffer 0.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_BUF1IND.
static const field_t hw_quadspi_quadspi0_buf1ind[] =
{
    {
        "TPINDX1",
        "Top index of buffer 1.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_BUF2IND.
static const field_t hw_quadspi_quadspi0_buf2ind[] =
{
    {
        "TPINDX2",
        "Top index of buffer 2.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_SFAR.
static const field_t hw_quadspi_quadspi0_sfar[] =
{
    {
        "SFADR",
        "Serial Flash Address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_SFACR.
static const field_t hw_quadspi_quadspi0_sfacr[] =
{
    {
        "CAS",
        "Defines the width of the column address.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WA",
        "Defines whether the serial flash is a byte addressable flash or a word"
        " addressable flash.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_SMPR.
static const field_t hw_quadspi_quadspi0_smpr[] =
{
    {
        "HSENA",
        "This bit enables the divide by 2 of the clock to the external serial f"
        "lash device for all commands, only in SDR.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSPHS",
        "Only relevant when HSENA bit is set.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSDLY",
        "Only relevant when HSENA bit is set.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSPHS",
        "Select the edge of the sampling clock valid for full speed commands.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLY",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDRSMP",
        "Select the sampling point for incoming data when serial flash is execu"
        "ting a DDR instruction.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBSR.
static const field_t hw_quadspi_quadspi0_rbsr[] =
{
    {
        "RDBFL",
        "RX Buffer Fill Level.",
        8, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDCTR",
        "Read Counter.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBCT.
static const field_t hw_quadspi_quadspi0_rbct[] =
{
    {
        "WMRK",
        "RX Buffer Watermark.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXBRD",
        "RX Buffer Readout.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_TBSR.
static const field_t hw_quadspi_quadspi0_tbsr[] =
{
    {
        "TRBFL",
        "TX Buffer Fill Level.",
        8, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRCTR",
        "Transmit Counter.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_TBDR.
static const field_t hw_quadspi_quadspi0_tbdr[] =
{
    {
        "TXDATA",
        "TX Data On write access the data is written into the next available en"
        "try of the TX Buffer and the QPSI_TBSR[TRBFL] field is updated accordi"
        "ngly.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_TBCT.
static const field_t hw_quadspi_quadspi0_tbct[] =
{
    {
        "WMRK",
        "Determines the watermark for the TX Buffer.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_SR.
static const field_t hw_quadspi_quadspi0_sr[] =
{
    {
        "BUSY",
        "Module Busy.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IP_ACC",
        "IP Access.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB_ACC",
        "AHB Access.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHBGNT",
        "AHB Command priority Granted: Asserted when another module has been gr"
        "anted priority of AHB Commands against IP Commands.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHBTRN",
        "AHB Access Transaction pending.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB0NE",
        "AHB 0 Buffer Not Empty.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB1NE",
        "AHB 1 Buffer Not Empty.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB2NE",
        "AHB 2 Buffer Not Empty.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB3NE",
        "AHB 3 Buffer Not Empty.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB0FUL",
        "AHB 0 Buffer Full.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB1FUL",
        "AHB 1 Buffer Full.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB2FUL",
        "AHB 2 Buffer Full.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB3FUL",
        "AHB 3 Buffer Full.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXWE",
        "RX Buffer Watermark Exceeded.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFULL",
        "RX Buffer Full.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXDMA",
        "RX Buffer DMA.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXEDA",
        "Asserted when TX Buffer contains enough data for any pop operation to "
        "take place.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXWA",
        "Asserted when the number of available spaces in TX buffer is greater t"
        "han or equal to the value give by QSPI_TBCT[WMRK].",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXDMA",
        "Asserted when TXFIFO fill via DMA is active i.e.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXFULL",
        "TX Buffer Full.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLPSMP",
        "Data learning pattern sampling point.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_FR.
static const field_t hw_quadspi_quadspi0_fr[] =
{
    {
        "TFF",
        "IP Command Transaction Finished Flag.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPGEF",
        "IP Command Trigger during AHB Grant Error Flag.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPIEF",
        "IP Command Trigger could not be executed Error Flag.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPAEF",
        "IP Command Trigger during AHB Access Error Flag.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABOF",
        "AHB Buffer Overflow Flag.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AIBSEF",
        "AHB Illegal Burst Size Error Flag.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AITEF",
        "AHB Illegal transaction error flag.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEF",
        "AHB Sequence Error Flag.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBDF",
        "RX Buffer Drain Flag.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBOF",
        "RX Buffer Overflow Flag.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ILLINE",
        "Illegal Instruction Error Flag.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TBUF",
        "TX Buffer Underrun Flag.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TBFF",
        "TX Buffer Fill Flag.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLPFF",
        "Data Learning Pattern Failure Flag.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RSER.
static const field_t hw_quadspi_quadspi0_rser[] =
{
    {
        "TFIE",
        "Transaction Finished Interrupt Enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPGEIE",
        "IP Command Trigger during AHB Grant Error Interrupt Enable",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPIEIE",
        "IP Command Trigger during IP Access Error Interrupt Enable",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPAEIE",
        "IP Command Trigger during AHB Access Error Interrupt Enable",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABOIE",
        "AHB Buffer Overflow Interrupt Enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AIBSIE",
        "AHB Illegal Burst Size Interrupt Enable",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AITIE",
        "AHB Illegal transaction interrupt enable.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEIE",
        "AHB Sequence Error Interrupt Enable: Triggered by ABSEF flags of QSPI_"
        "FR",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBDIE",
        "RX Buffer Drain Interrupt Enable: Enables generation of IRQ requests f"
        "or RX Buffer Drain.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBOIE",
        "RX Buffer Overflow Interrupt Enable",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBDDE",
        "RX Buffer Drain DMA Enable: Enables generation of DMA requests for RX "
        "Buffer Drain.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ILLINIE",
        "Illegal Instruction Error Interrupt Enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TBFDE",
        "Enables generation of DMA requests for TX Buffer fill.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TBUIE",
        "TX Buffer Underrun Interrupt Enable",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TBFIE",
        "TX Buffer Fill Interrupt Enable",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLPFIE",
        "Data Learning Pattern Failure Interrupt enable .",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_SPNDST.
static const field_t hw_quadspi_quadspi0_spndst[] =
{
    {
        "SUSPND",
        "When set, it signifies that a sequence is in suspended state",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPDBUF",
        "Suspended Buffer: Provides the suspended buffer number.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DATLFT",
        "Data left: Provides information about the amount of data left to be re"
        "ad in the suspended sequence.",
        9, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_SPTRCLR.
static const field_t hw_quadspi_quadspi0_sptrclr[] =
{
    {
        "BFPTRC",
        "Buffer Pointer Clear: 1: Clears the sequence pointer for AHB accesses "
        "as defined in QuadSPI_BFGENCR.",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "IPPTRC",
        "IP Pointer Clear: 1: Clears the sequence pointer for IP accesses as de"
        "fined in QuadSPI_IPCR This is a self-clearing field.",
        8, // LSB
        8, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_SFA1AD.
static const field_t hw_quadspi_quadspi0_sfa1ad[] =
{
    {
        "TPADA1",
        "Top address for Serial Flash A1.",
        10, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_SFA2AD.
static const field_t hw_quadspi_quadspi0_sfa2ad[] =
{
    {
        "TPADA2",
        "Top address for Serial Flash A2.",
        10, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_DLPR.
static const field_t hw_quadspi_quadspi0_dlpr[] =
{
    {
        "DLPV",
        "Data Learning Pattern Value: This value is used for data learning in D"
        "DR and DQS mode.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBDR0.
static const field_t hw_quadspi_quadspi0_rbdr0[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBDR1.
static const field_t hw_quadspi_quadspi0_rbdr1[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBDR2.
static const field_t hw_quadspi_quadspi0_rbdr2[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBDR3.
static const field_t hw_quadspi_quadspi0_rbdr3[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBDR4.
static const field_t hw_quadspi_quadspi0_rbdr4[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBDR5.
static const field_t hw_quadspi_quadspi0_rbdr5[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBDR6.
static const field_t hw_quadspi_quadspi0_rbdr6[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBDR7.
static const field_t hw_quadspi_quadspi0_rbdr7[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBDR8.
static const field_t hw_quadspi_quadspi0_rbdr8[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBDR9.
static const field_t hw_quadspi_quadspi0_rbdr9[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBDR10.
static const field_t hw_quadspi_quadspi0_rbdr10[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBDR11.
static const field_t hw_quadspi_quadspi0_rbdr11[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBDR12.
static const field_t hw_quadspi_quadspi0_rbdr12[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBDR13.
static const field_t hw_quadspi_quadspi0_rbdr13[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBDR14.
static const field_t hw_quadspi_quadspi0_rbdr14[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_RBDR15.
static const field_t hw_quadspi_quadspi0_rbdr15[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUTKEY.
static const field_t hw_quadspi_quadspi0_lutkey[] =
{
    {
        "KEY",
        "The key to lock or unlock the LUT.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LCKCR.
static const field_t hw_quadspi_quadspi0_lckcr[] =
{
    {
        "LOCK",
        "Locks the LUT when the following condition is met: This register is wr"
        "itten just after the LUTKEYLUT Key Register The LUT key register was w"
        "ritten with 0x5AF05AF0 key",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNLOCK",
        "Unlocks the LUT when the following two conditions are met: 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT0.
static const field_t hw_quadspi_quadspi0_lut0[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT1.
static const field_t hw_quadspi_quadspi0_lut1[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT2.
static const field_t hw_quadspi_quadspi0_lut2[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT3.
static const field_t hw_quadspi_quadspi0_lut3[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT4.
static const field_t hw_quadspi_quadspi0_lut4[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT5.
static const field_t hw_quadspi_quadspi0_lut5[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT6.
static const field_t hw_quadspi_quadspi0_lut6[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT7.
static const field_t hw_quadspi_quadspi0_lut7[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT8.
static const field_t hw_quadspi_quadspi0_lut8[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT9.
static const field_t hw_quadspi_quadspi0_lut9[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT10.
static const field_t hw_quadspi_quadspi0_lut10[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT11.
static const field_t hw_quadspi_quadspi0_lut11[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT12.
static const field_t hw_quadspi_quadspi0_lut12[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT13.
static const field_t hw_quadspi_quadspi0_lut13[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT14.
static const field_t hw_quadspi_quadspi0_lut14[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT15.
static const field_t hw_quadspi_quadspi0_lut15[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT16.
static const field_t hw_quadspi_quadspi0_lut16[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT17.
static const field_t hw_quadspi_quadspi0_lut17[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT18.
static const field_t hw_quadspi_quadspi0_lut18[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT19.
static const field_t hw_quadspi_quadspi0_lut19[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT20.
static const field_t hw_quadspi_quadspi0_lut20[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT21.
static const field_t hw_quadspi_quadspi0_lut21[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT22.
static const field_t hw_quadspi_quadspi0_lut22[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT23.
static const field_t hw_quadspi_quadspi0_lut23[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT24.
static const field_t hw_quadspi_quadspi0_lut24[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT25.
static const field_t hw_quadspi_quadspi0_lut25[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT26.
static const field_t hw_quadspi_quadspi0_lut26[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT27.
static const field_t hw_quadspi_quadspi0_lut27[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT28.
static const field_t hw_quadspi_quadspi0_lut28[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT29.
static const field_t hw_quadspi_quadspi0_lut29[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT30.
static const field_t hw_quadspi_quadspi0_lut30[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT31.
static const field_t hw_quadspi_quadspi0_lut31[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT32.
static const field_t hw_quadspi_quadspi0_lut32[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT33.
static const field_t hw_quadspi_quadspi0_lut33[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT34.
static const field_t hw_quadspi_quadspi0_lut34[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT35.
static const field_t hw_quadspi_quadspi0_lut35[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT36.
static const field_t hw_quadspi_quadspi0_lut36[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT37.
static const field_t hw_quadspi_quadspi0_lut37[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT38.
static const field_t hw_quadspi_quadspi0_lut38[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT39.
static const field_t hw_quadspi_quadspi0_lut39[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT40.
static const field_t hw_quadspi_quadspi0_lut40[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT41.
static const field_t hw_quadspi_quadspi0_lut41[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT42.
static const field_t hw_quadspi_quadspi0_lut42[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT43.
static const field_t hw_quadspi_quadspi0_lut43[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT44.
static const field_t hw_quadspi_quadspi0_lut44[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT45.
static const field_t hw_quadspi_quadspi0_lut45[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT46.
static const field_t hw_quadspi_quadspi0_lut46[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT47.
static const field_t hw_quadspi_quadspi0_lut47[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT48.
static const field_t hw_quadspi_quadspi0_lut48[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT49.
static const field_t hw_quadspi_quadspi0_lut49[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT50.
static const field_t hw_quadspi_quadspi0_lut50[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT51.
static const field_t hw_quadspi_quadspi0_lut51[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT52.
static const field_t hw_quadspi_quadspi0_lut52[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT53.
static const field_t hw_quadspi_quadspi0_lut53[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT54.
static const field_t hw_quadspi_quadspi0_lut54[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT55.
static const field_t hw_quadspi_quadspi0_lut55[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT56.
static const field_t hw_quadspi_quadspi0_lut56[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT57.
static const field_t hw_quadspi_quadspi0_lut57[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT58.
static const field_t hw_quadspi_quadspi0_lut58[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT59.
static const field_t hw_quadspi_quadspi0_lut59[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT60.
static const field_t hw_quadspi_quadspi0_lut60[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT61.
static const field_t hw_quadspi_quadspi0_lut61[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT62.
static const field_t hw_quadspi_quadspi0_lut62[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_QuadSPI0_LUT63.
static const field_t hw_quadspi_quadspi0_lut63[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a QUADSPI module.
static const reg_t hw_quadspi[] =
{
    {
        "QuadSPI0_MCR",
        "The QuadSPI_MCR holds configuration data associated with QuadSPI opera"
        "tion.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_quadspi_quadspi0_mcr
    },
    {
        "QuadSPI0_IPCR",
        "The IP configuration register provides all the configuration required "
        "for an IP initiated command.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_quadspi0_ipcr
    },
    {
        "QuadSPI0_FLSHCR",
        "The Flash configuration register contains the flash device specific ti"
        "mings that must be met by the QuadSPI controller for the device to fun"
        "ction correctly.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_quadspi_quadspi0_flshcr
    },
    {
        "QuadSPI0_BUF0CR",
        "This register provides the configuration for any access to buffer0.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_quadspi_quadspi0_buf0cr
    },
    {
        "QuadSPI0_BUF1CR",
        "This register provides the configuration for any access to buffer1.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_quadspi0_buf1cr
    },
    {
        "QuadSPI0_BUF2CR",
        "This register provides the configuration for any access to buffer2.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_quadspi0_buf2cr
    },
    {
        "QuadSPI0_BUF3CR",
        "This register provides the configuration for any access to buffer3.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_quadspi_quadspi0_buf3cr
    },
    {
        "QuadSPI0_BFGENCR",
        "This register provides the generic configuration to any of the buffer "
        "accesses.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_bfgencr
    },
    {
        "QuadSPI0_SOCCR",
        "This register is programmed at chip level for QuadSPI delay chain conf"
        "iguration.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_soccr
    },
    {
        "QuadSPI0_BUF0IND",
        "This register specifies the top index of buffer0, which defines its si"
        "ze.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_buf0ind
    },
    {
        "QuadSPI0_BUF1IND",
        "This register specifies the top index of buffer1, which defines its si"
        "ze.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_buf1ind
    },
    {
        "QuadSPI0_BUF2IND",
        "This register specifies the top index of buffer2, which defines its si"
        "ze.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_buf2ind
    },
    {
        "QuadSPI0_SFAR",
        "The module automatically translates this address on the memory map to "
        "the address on the flash itself.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_sfar
    },
    {
        "QuadSPI0_SFACR",
        "This register contains the serial flash specific address requirements "
        "that must be configured according to the flash connected, for the cont"
        "roller to function properly.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_quadspi0_sfacr
    },
    {
        "QuadSPI0_SMPR",
        "The Sampling Register allows configuration of how the incoming data fr"
        "om the external serial flash devices are sampled in the QuadSPI module"
        ".",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_smpr
    },
    {
        "QuadSPI0_RBSR",
        "This register contains information related to the receive data buffer.",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_quadspi_quadspi0_rbsr
    },
    {
        "QuadSPI0_RBCT",
        "This register contains control data related to the receive data buffer"
        ".",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_quadspi0_rbct
    },
    {
        "QuadSPI0_TBSR",
        "This register contains information related to the transmit data buffer"
        ".",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_quadspi_quadspi0_tbsr
    },
    {
        "QuadSPI0_TBDR",
        "The QSPI_TBDR register provides access to the circular TX Buffer of de"
        "pth 64 bytes.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_tbdr
    },
    {
        "QuadSPI0_TBCT",
        "This register contains control information for transmit data buffer.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_tbct
    },
    {
        "QuadSPI0_SR",
        "The QSPI_SR register provides all available status information about S"
        "FM command execution and arbitration, the RX Buffer, TX Buffer, and th"
        "e AHB Buffer.",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        false, // Writable
        21, // Number of bitfields
        hw_quadspi_quadspi0_sr
    },
    {
        "QuadSPI0_FR",
        "The QSPI_FR register provides all available flags about SFM command ex"
        "ecution and arbitration which may serve as source for the generation o"
        "f interrupt service requests.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_quadspi_quadspi0_fr
    },
    {
        "QuadSPI0_RSER",
        "The QuadSPI_RSER register provides enables and selectors for the inter"
        "rupts in the QuadSPI module.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_quadspi_quadspi0_rser
    },
    {
        "QuadSPI0_SPNDST",
        "The sequence suspend status register provides information specific to "
        "any suspended sequence.",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_quadspi_quadspi0_spndst
    },
    {
        "QuadSPI0_SPTRCLR",
        "The sequence pointer clear register provides bits to reset the IP and "
        "Buffer sequence pointers.",
        4, // Width in bytes
        0x0000016c, // Base address offset
        false, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_quadspi0_sptrclr
    },
    {
        "QuadSPI0_SFA1AD",
        "The QSPI_SFA1AD register provides the address mapping for the serial f"
        "lash A1.The difference between QSPI_SFA1AD[TPADA1] and QSPI_AMBA_BASE "
        "defines the size of the memory map for serial flash A1.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_sfa1ad
    },
    {
        "QuadSPI0_SFA2AD",
        "The QSPI_SFA2AD register provides the address mapping for the serial f"
        "lash A2.The difference between QSPI_SFA2AD[TPADA2] and QSPI_SFA1AD[TPA"
        "DA1] defines the size of the memory map for serial flash A2.",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_sfa2ad
    },
    {
        "QuadSPI0_DLPR",
        "The QSPI_DLPR register contains the information of the data to be used"
        " for Data Learning.",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_dlpr
    },
    {
        "QuadSPI0_RBDR0",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_rbdr0
    },
    {
        "QuadSPI0_RBDR1",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_rbdr1
    },
    {
        "QuadSPI0_RBDR2",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_rbdr2
    },
    {
        "QuadSPI0_RBDR3",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_rbdr3
    },
    {
        "QuadSPI0_RBDR4",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_rbdr4
    },
    {
        "QuadSPI0_RBDR5",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_rbdr5
    },
    {
        "QuadSPI0_RBDR6",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_rbdr6
    },
    {
        "QuadSPI0_RBDR7",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_rbdr7
    },
    {
        "QuadSPI0_RBDR8",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_rbdr8
    },
    {
        "QuadSPI0_RBDR9",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_rbdr9
    },
    {
        "QuadSPI0_RBDR10",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_rbdr10
    },
    {
        "QuadSPI0_RBDR11",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_rbdr11
    },
    {
        "QuadSPI0_RBDR12",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_rbdr12
    },
    {
        "QuadSPI0_RBDR13",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_rbdr13
    },
    {
        "QuadSPI0_RBDR14",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_rbdr14
    },
    {
        "QuadSPI0_RBDR15",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_rbdr15
    },
    {
        "QuadSPI0_LUTKEY",
        "The LUT Key register contains the key to lock and unlock the Look-up-t"
        "able.",
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_quadspi0_lutkey
    },
    {
        "QuadSPI0_LCKCR",
        "The LUT lock configuration register is used along with QSPI_LUTKEY reg"
        "ister to lock or unlock the LUT.",
        4, // Width in bytes
        0x00000304, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_quadspi0_lckcr
    },
    {
        "QuadSPI0_LUT0",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000310, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut0
    },
    {
        "QuadSPI0_LUT1",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000314, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut1
    },
    {
        "QuadSPI0_LUT2",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000318, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut2
    },
    {
        "QuadSPI0_LUT3",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x0000031c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut3
    },
    {
        "QuadSPI0_LUT4",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut4
    },
    {
        "QuadSPI0_LUT5",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000324, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut5
    },
    {
        "QuadSPI0_LUT6",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000328, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut6
    },
    {
        "QuadSPI0_LUT7",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x0000032c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut7
    },
    {
        "QuadSPI0_LUT8",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000330, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut8
    },
    {
        "QuadSPI0_LUT9",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000334, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut9
    },
    {
        "QuadSPI0_LUT10",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000338, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut10
    },
    {
        "QuadSPI0_LUT11",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x0000033c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut11
    },
    {
        "QuadSPI0_LUT12",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000340, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut12
    },
    {
        "QuadSPI0_LUT13",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000344, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut13
    },
    {
        "QuadSPI0_LUT14",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000348, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut14
    },
    {
        "QuadSPI0_LUT15",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x0000034c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut15
    },
    {
        "QuadSPI0_LUT16",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000350, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut16
    },
    {
        "QuadSPI0_LUT17",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000354, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut17
    },
    {
        "QuadSPI0_LUT18",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000358, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut18
    },
    {
        "QuadSPI0_LUT19",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x0000035c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut19
    },
    {
        "QuadSPI0_LUT20",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000360, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut20
    },
    {
        "QuadSPI0_LUT21",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000364, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut21
    },
    {
        "QuadSPI0_LUT22",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000368, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut22
    },
    {
        "QuadSPI0_LUT23",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x0000036c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut23
    },
    {
        "QuadSPI0_LUT24",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000370, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut24
    },
    {
        "QuadSPI0_LUT25",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000374, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut25
    },
    {
        "QuadSPI0_LUT26",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000378, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut26
    },
    {
        "QuadSPI0_LUT27",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x0000037c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut27
    },
    {
        "QuadSPI0_LUT28",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000380, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut28
    },
    {
        "QuadSPI0_LUT29",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000384, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut29
    },
    {
        "QuadSPI0_LUT30",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000388, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut30
    },
    {
        "QuadSPI0_LUT31",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x0000038c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut31
    },
    {
        "QuadSPI0_LUT32",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000390, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut32
    },
    {
        "QuadSPI0_LUT33",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000394, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut33
    },
    {
        "QuadSPI0_LUT34",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000398, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut34
    },
    {
        "QuadSPI0_LUT35",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x0000039c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut35
    },
    {
        "QuadSPI0_LUT36",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003a0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut36
    },
    {
        "QuadSPI0_LUT37",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003a4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut37
    },
    {
        "QuadSPI0_LUT38",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003a8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut38
    },
    {
        "QuadSPI0_LUT39",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003ac, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut39
    },
    {
        "QuadSPI0_LUT40",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003b0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut40
    },
    {
        "QuadSPI0_LUT41",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003b4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut41
    },
    {
        "QuadSPI0_LUT42",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003b8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut42
    },
    {
        "QuadSPI0_LUT43",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003bc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut43
    },
    {
        "QuadSPI0_LUT44",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003c0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut44
    },
    {
        "QuadSPI0_LUT45",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003c4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut45
    },
    {
        "QuadSPI0_LUT46",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003c8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut46
    },
    {
        "QuadSPI0_LUT47",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003cc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut47
    },
    {
        "QuadSPI0_LUT48",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003d0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut48
    },
    {
        "QuadSPI0_LUT49",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003d4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut49
    },
    {
        "QuadSPI0_LUT50",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003d8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut50
    },
    {
        "QuadSPI0_LUT51",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003dc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut51
    },
    {
        "QuadSPI0_LUT52",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003e0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut52
    },
    {
        "QuadSPI0_LUT53",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003e4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut53
    },
    {
        "QuadSPI0_LUT54",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003e8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut54
    },
    {
        "QuadSPI0_LUT55",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003ec, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut55
    },
    {
        "QuadSPI0_LUT56",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003f0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut56
    },
    {
        "QuadSPI0_LUT57",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003f4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut57
    },
    {
        "QuadSPI0_LUT58",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003f8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut58
    },
    {
        "QuadSPI0_LUT59",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x000003fc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut59
    },
    {
        "QuadSPI0_LUT60",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut60
    },
    {
        "QuadSPI0_LUT61",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut61
    },
    {
        "QuadSPI0_LUT62",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut62
    },
    {
        "QuadSPI0_LUT63",
        "A sequence of instruction-operand pairs may be pre-populated in the LU"
        "T according to the device connected on board.",
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_quadspi0_lut63
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ROMC
#endif

// Bitfields in register ROMC_ROMPATCH7D.
static const field_t hw_romc_rompatch7d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH6D.
static const field_t hw_romc_rompatch6d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH5D.
static const field_t hw_romc_rompatch5d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH4D.
static const field_t hw_romc_rompatch4d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH3D.
static const field_t hw_romc_rompatch3d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH2D.
static const field_t hw_romc_rompatch2d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH1D.
static const field_t hw_romc_rompatch1d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH0D.
static const field_t hw_romc_rompatch0d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHCNTL.
static const field_t hw_romc_rompatchcntl[] =
{
    {
        "DATAFIX",
        "Data Fix Enable - Controls the use of the first 8 address comparators "
        "for 1-word data fix or for code patch routine.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIS",
        "ROMC Disable -- This bit, when set, disables all ROMC operations.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHENH.
static const field_t hw_romc_rompatchenh[] =
{
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHENL.
static const field_t hw_romc_rompatchenl[] =
{
    {
        "ENABLE",
        "Enable Address Comparator - This bit enables the corresponding address"
        " comparator to trigger an event.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH0A.
static const field_t hw_romc_rompatch0a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH1A.
static const field_t hw_romc_rompatch1a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH2A.
static const field_t hw_romc_rompatch2a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH3A.
static const field_t hw_romc_rompatch3a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH4A.
static const field_t hw_romc_rompatch4a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH5A.
static const field_t hw_romc_rompatch5a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH6A.
static const field_t hw_romc_rompatch6a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH7A.
static const field_t hw_romc_rompatch7a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH8A.
static const field_t hw_romc_rompatch8a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH9A.
static const field_t hw_romc_rompatch9a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH10A.
static const field_t hw_romc_rompatch10a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH11A.
static const field_t hw_romc_rompatch11a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH12A.
static const field_t hw_romc_rompatch12a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH13A.
static const field_t hw_romc_rompatch13a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH14A.
static const field_t hw_romc_rompatch14a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH15A.
static const field_t hw_romc_rompatch15a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHSR.
static const field_t hw_romc_rompatchsr[] =
{
    {
        "SOURCE",
        "ROMC Source Number - Binary encoding of the number of the address comp"
        "arator which has an address match in the most recent patch event on RO"
        "MC AHB.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW",
        "ROMC AHB Multiple Address Comparator matches Indicator - Indicates tha"
        "t multiple address comparator matches occurred.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ROMC module.
static const reg_t hw_romc[] =
{
    {
        "ROMPATCH7D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch7d
    },
    {
        "ROMPATCH6D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch6d
    },
    {
        "ROMPATCH5D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch5d
    },
    {
        "ROMPATCH4D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch4d
    },
    {
        "ROMPATCH3D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch3d
    },
    {
        "ROMPATCH2D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch2d
    },
    {
        "ROMPATCH1D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch1d
    },
    {
        "ROMPATCH0D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch0d
    },
    {
        "ROMPATCHCNTL",
        "The ROMC control register (ROMC_ROMPATCHCNTL) contains the block disab"
        "le bit and the data fix enable bits.",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatchcntl
    },
    {
        "ROMPATCHENH",
        "The ROMC enable register high (ROMC_ROMPATCHENH) and ROMC enable regis"
        "ter low (ROMC_ROMPATCHENL) control whether or not the associated addre"
        "ss comparator can trigger a opcode patch or data fix event.",
        4, // Width in bytes
        0x000000f8, // Base address offset
        false, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_romc_rompatchenh
    },
    {
        "ROMPATCHENL",
        "The ROMC enable register high (ROMC_ROMPATCHENH) and ROMC enable regis"
        "ter low (ROMC_ROMPATCHENL) control whether or not the associated addre"
        "ss comparator can trigger a opcode patch or data fix event.",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatchenl
    },
    {
        "ROMPATCH0A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch0a
    },
    {
        "ROMPATCH1A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch1a
    },
    {
        "ROMPATCH2A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch2a
    },
    {
        "ROMPATCH3A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch3a
    },
    {
        "ROMPATCH4A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch4a
    },
    {
        "ROMPATCH5A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch5a
    },
    {
        "ROMPATCH6A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch6a
    },
    {
        "ROMPATCH7A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch7a
    },
    {
        "ROMPATCH8A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch8a
    },
    {
        "ROMPATCH9A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch9a
    },
    {
        "ROMPATCH10A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch10a
    },
    {
        "ROMPATCH11A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch11a
    },
    {
        "ROMPATCH12A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch12a
    },
    {
        "ROMPATCH13A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch13a
    },
    {
        "ROMPATCH14A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch14a
    },
    {
        "ROMPATCH15A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch15a
    },
    {
        "ROMPATCHSR",
        "The ROMC status register (ROMC_ROMPATCHSR) indicates the current state"
        " of the ROMC and the source number of the most recent address comparat"
        "or event.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatchsr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SCG_CM4
#endif

// Bitfields in register SCG_CM4_VERID.
static const field_t hw_scg_cm4_verid[] =
{
    {
        "VERSION",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_PARAM.
static const field_t hw_scg_cm4_param[] =
{
    {
        "CLKPRES",
        "Indicates which clock sources are present in this instance of SCG.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIVPRES",
        "Indicates which system clock dividers are present in this instance of "
        "SCG.",
        27, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_CSR.
static const field_t hw_scg_cm4_csr[] =
{
    {
        "DIVSLOW",
        "",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIVBUS",
        "",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIVPLAT",
        "",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIVCORE",
        "",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SCS",
        "Returns the currently configured clock source generating the system cl"
        "ock.",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_RCCR.
static const field_t hw_scg_cm4_rccr[] =
{
    {
        "DIVSLOW",
        "",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIVBUS",
        "",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIVPLAT",
        "Only Divide-by-1 is supported.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIVCORE",
        "",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCS",
        "Selects the clock source generating the system clock in Run mode.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_VCCR.
static const field_t hw_scg_cm4_vccr[] =
{
    {
        "DIVSLOW",
        "",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIVBUS",
        "",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIVPLAT",
        "Only Divide-by-1 is supported.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIVCORE",
        "",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCS",
        "Selects the clock source generating the system clock in VLPR mode.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_HCCR.
static const field_t hw_scg_cm4_hccr[] =
{
    {
        "DIVSLOW",
        "",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIVBUS",
        "",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIVPLAT",
        "Only Divide-by-1 is supported.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIVCORE",
        "",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCS",
        "Selects the clock source generating the system clock in HSRUN mode.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_CLKOUTCNFG.
static const field_t hw_scg_cm4_clkoutcnfg[] =
{
    {
        "CLKOUTSEL",
        "Selects the SCG system clock.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_SOSCCSR.
static const field_t hw_scg_cm4_sosccsr[] =
{
    {
        "SOSCEN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOSCSTEN",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOSCLPEN",
        "SOSCLPEN is required for low power modes.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOSCCM",
        "Enables the clock monitor when SOSCVLD is set.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOSCCMRE",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit field can be cleared/set at any time.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOSCVLD",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SOSCSEL",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SOSCERR",
        "This flag is reset on Chip POR only, software can also clear this flag"
        " by writing a logic one.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_SOSCDIV.
static const field_t hw_scg_cm4_soscdiv[] =
{
    {
        "SOSCDIV1",
        "Clock divider 1 for System OSC.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOSCDIV2",
        "Clock divider 2 for System OSC.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOSCDIV3",
        "Clock divider 3 for System OSC.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_SOSCCFG.
static const field_t hw_scg_cm4_sosccfg[] =
{
    {
        "EREFS",
        "Selects the source for the external reference clock.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HGO",
        "Controls the crystal oscillator power mode of operations.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_SIRCCSR.
static const field_t hw_scg_cm4_sirccsr[] =
{
    {
        "SIRCEN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIRCSTEN",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIRCLPEN",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPOPO",
        "Controls whether the 1khz LPO clock is enabled in LLS/VLLSx modes.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit field can be cleared/set at any time.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIRCVLD",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SIRCSEL",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_SIRCDIV.
static const field_t hw_scg_cm4_sircdiv[] =
{
    {
        "SIRCDIV1",
        "Clock divider 1 for Slow IRC.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIRCDIV2",
        "Clock divider 2 for Slow IRC.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIRCDIV3",
        "Clock divider 3 for Slow IRC.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_SIRCCFG.
static const field_t hw_scg_cm4_sirccfg[] =
{
    {
        "RANGE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_FIRCCSR.
static const field_t hw_scg_cm4_firccsr[] =
{
    {
        "FIRCEN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIRCSTEN",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIRCLPEN",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIRCREGOFF",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIRCTREN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIRCTRUP",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit field can be cleared/set at any time.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIRCVLD",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FIRCSEL",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FIRCERR",
        "This flag is reset on Chip POR only, software can also clear this flag"
        " by writing a logic one",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_FIRCDIV.
static const field_t hw_scg_cm4_fircdiv[] =
{
    {
        "FIRCDIV1",
        "Clock divider 1 for Fast IRC.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIRCDIV2",
        "Clock divider 2 for the Fast IRC.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIRCDIV3",
        "Clock divider 3 for the Fast IRC.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_FIRCCFG.
static const field_t hw_scg_cm4_firccfg[] =
{
    {
        "RANGE",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_FIRCTCFG.
static const field_t hw_scg_cm4_firctcfg[] =
{
    {
        "TRIMSRC",
        "Configures the external clock source to tune the Fast IRC.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIMDIV",
        "Divide the System OSC down for Fast IRC trimming.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_FIRCSTAT.
static const field_t hw_scg_cm4_fircstat[] =
{
    {
        "TRIMFINE",
        "Once the Fast IRC Clock is trimmed to +/-0.7% of the target frequency "
        "using the TRIMCOAR bits, the TRIMFINE bits can be used to trim the Fas"
        "t IRC Clock to within +/-0.04% of the target frequency.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIMCOAR",
        "TRIMCOAR bits are used to coarsely trim the Fast IRC Clock to within a"
        "pproximately +/-0.7% of the target frequency.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_ROSCCSR.
static const field_t hw_scg_cm4_rosccsr[] =
{
    {
        "ROSCCM",
        "Enables the clock monitor when ROSCVLD is set.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROSCCMRE",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit field can be cleared/set at any time.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROSCVLD",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ROSCSEL",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ROSCERR",
        "This flag is reset on Chip POR only, software can also clear this flag"
        " by writing a logic one",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_APLLCSR.
static const field_t hw_scg_cm4_apllcsr[] =
{
    {
        "APLLEN",
        "When configuring the APLL, APLLEN should be set/cleared first.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APLLSTEN",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit field can be cleared/set at any time.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APLLVLD",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APLLSEL",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_APLLDIV.
static const field_t hw_scg_cm4_aplldiv[] =
{
    {
        "APLLDIV1",
        "Clock divider 1 for Auxiliary PLL.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APLLDIV2",
        "Clock divider 2 for Auxiliary PLL.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APLLDIV3",
        "Clock divider 3 for Auxiliary PLL.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_APLLCFG.
static const field_t hw_scg_cm4_apllcfg[] =
{
    {
        "SOURCE",
        "Configures the input clock source for the Auxiliary PLL.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLLS",
        "Selects the PFD or APLL as the PLL output clock used to generate syste"
        "m clocks.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREDIV",
        "Selects the amount to divide down the reference clock for the Auxiliar"
        "y PLL.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFDSEL",
        "Selects which PFD output clock will be used as a SCG system reference "
        "clock or as a SCG DDR reference clock.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MULT",
        "Multiplier for the Auxiliary PLL.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLLPOSTDIV1",
        "Auxiliary PLL 1st stage post divider.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLLPOSTDIV2",
        "Auxiliary PLL 2nd stage post divider.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_APLLPFD.
static const field_t hw_scg_cm4_apllpfd[] =
{
    {
        "PFD0",
        "Controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_VALID",
        "Indicates when PFD0 clock is valid.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "PFD0 Clock Gate.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1",
        "Controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_VALID",
        "Indicates when PFD1 clock is valid.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "PFD1 Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2",
        "Controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_VALID",
        "Indicates when PFD2 clock is valid.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "PFD2 Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3",
        "Controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_VALID",
        "Indicates when PFD3 clock is valid.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "PFD3 Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_APLLNUM.
static const field_t hw_scg_cm4_apllnum[] =
{
    {
        "NUM",
        "NOTE: The value of numerator must always be configured to be less than"
        " the value of the denominator.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_APLLDENOM.
static const field_t hw_scg_cm4_aplldenom[] =
{
    {
        "DENOM",
        "NOTE: The value of numerator must always be configured to be less than"
        " the value of the denominator.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_APLLSS.
static const field_t hw_scg_cm4_apllss[] =
{
    {
        "STEP",
        "",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP",
        "",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_APLLLOCK_CNFG.
static const field_t hw_scg_cm4_aplllock_cnfg[] =
{
    {
        "LOCK_TIME",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_SPLLCSR.
static const field_t hw_scg_cm4_spllcsr[] =
{
    {
        "SPLLEN",
        "When configuring the SPLL, SPLLEN should be set/cleared first.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPLLSTEN",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit field can be cleared/set at any time.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPLLVLD",
        "Indicates when the SPLL clock is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPLLSEL",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPLLERR",
        "This flag is reset on Chip POR only, software can also clear this flag"
        " by writing a logic one",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_SPLLDIV.
static const field_t hw_scg_cm4_splldiv[] =
{
    {
        "SPLLDIV1",
        "Clock divider 1 for System PLL.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPLLDIV2",
        "Clock divider 2 for System PLL.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPLLDIV3",
        "Clock divider 3 for System PLL.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_SPLLCFG.
static const field_t hw_scg_cm4_spllcfg[] =
{
    {
        "SOURCE",
        "Configures the input clock source for the System PLL.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLLS",
        "Selects the PLL or PFD as the SPLL output used to generate system cloc"
        "ks.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREDIV",
        "Selects the amount to divide down the reference clock for the System P"
        "LL.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFDSEL",
        "Selects which PFD output clock will be used as a SCG system reference "
        "clock or as a SCG DDR reference clock.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MULT",
        "Multiplier for the System PLL.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_SPLLPFD.
static const field_t hw_scg_cm4_spllpfd[] =
{
    {
        "PFD0",
        "Controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_VALID",
        "Indicates when PFD0 clock is valid.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "PFD0 Clock Gate.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1",
        "Controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_VALID",
        "Indicates when PFD1 clock is valid.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "PFD1 Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2",
        "Controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_VALID",
        "Indicates when PFD2 clock is valid.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "PFD2 Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3",
        "Controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_VALID",
        "Indicates when PFD3 clock is valid.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "PFD3 Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CM4_SPLLLOCK_CNFG.
static const field_t hw_scg_cm4_splllock_cnfg[] =
{
    {
        "LOCK_TIME",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SCG_CM4 module.
static const reg_t hw_scg_cm4[] =
{
    {
        "VERID",
        "Note: Writing to this register will result in a transfer error.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_scg_cm4_verid
    },
    {
        "PARAM",
        "Note: Writing to this register will result in a transfer error.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_scg_cm4_param
    },
    {
        "CSR",
        "This register returns the currently configured system clock source and"
        " the system clock dividers for the core (DIVCORE) and peripheral inter"
        "face clock (DIVSLOW).",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_scg_cm4_csr
    },
    {
        "RCCR",
        "This register controls the system clock source and the system clock di"
        "viders for the core, platform, external and bus clock domains when in "
        "Run mode only.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_scg_cm4_rccr
    },
    {
        "VCCR",
        "This register controls the system clock source and the system clock di"
        "viders for the core, platform, external and bus clock domains when in "
        "VLPR mode only.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_scg_cm4_vccr
    },
    {
        "HCCR",
        "This register controls the system clock source and the system clock di"
        "viders for the core, platform, external and bus clock domains when in "
        "HSRUN mode only.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_scg_cm4_hccr
    },
    {
        "CLKOUTCNFG",
        "This register controls which SCG clock source is selected to be ported"
        " out to the CLKOUT pin.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_scg_cm4_clkoutcnfg
    },
    {
        "SOSCCSR",
        "",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_scg_cm4_sosccsr
    },
    {
        "SOSCDIV",
        "The SCG_SOSCDIV register provides the control of 3 clock trees which c"
        "an be used to provide optional peripheral functional clocks, or altern"
        "ative module clocks.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_scg_cm4_soscdiv
    },
    {
        "SOSCCFG",
        "The SOSCCFG register cannot be changed when the System OSC is enabled.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_scg_cm4_sosccfg
    },
    {
        "SIRCCSR",
        "",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_scg_cm4_sirccsr
    },
    {
        "SIRCDIV",
        "To prevent glitches to the output divided clock, change SIRDIV when th"
        "e Slow IRC is disabled.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_scg_cm4_sircdiv
    },
    {
        "SIRCCFG",
        "The SIRCCFG register cannot be changed when the slow IRC clock is enab"
        "led.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_scg_cm4_sirccfg
    },
    {
        "FIRCCSR",
        "",
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_scg_cm4_firccsr
    },
    {
        "FIRCDIV",
        "Changes to FIRCDIV should be done when FAST IRC is disabled to prevent"
        " glitches to output divided clock.",
        4, // Width in bytes
        0x00000304, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_scg_cm4_fircdiv
    },
    {
        "FIRCCFG",
        "The FIRCCFG register cannot be changed when the Fast IRC is enabled.",
        4, // Width in bytes
        0x00000308, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_scg_cm4_firccfg
    },
    {
        "FIRCTCFG",
        "The FIRCTCFG register cannot be changed when Fast IRC tuning is enable"
        "d.",
        4, // Width in bytes
        0x0000030c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_scg_cm4_firctcfg
    },
    {
        "FIRCSTAT",
        "This register is loaded from IFR during reset.",
        4, // Width in bytes
        0x00000318, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_scg_cm4_fircstat
    },
    {
        "ROSCCSR",
        "",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_scg_cm4_rosccsr
    },
    {
        "APLLCSR",
        "",
        4, // Width in bytes
        0x00000500, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_scg_cm4_apllcsr
    },
    {
        "APLLDIV",
        "Changes to APLLDIV should be done when Auxiliary PLL is disabled to pr"
        "event glitches to output divided clock.",
        4, // Width in bytes
        0x00000504, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_scg_cm4_aplldiv
    },
    {
        "APLLCFG",
        "The APLLCFG register cannot be changed when the Auxiliary PLL is enabl"
        "ed.",
        4, // Width in bytes
        0x00000508, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_scg_cm4_apllcfg
    },
    {
        "APLLPFD",
        "This register defines the control bits for the PFD3-PFD0 clocks derive"
        "d from the Auxiliary PLL.",
        4, // Width in bytes
        0x0000050c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_scg_cm4_apllpfd
    },
    {
        "APLLNUM",
        "",
        4, // Width in bytes
        0x00000510, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_scg_cm4_apllnum
    },
    {
        "APLLDENOM",
        "",
        4, // Width in bytes
        0x00000514, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_scg_cm4_aplldenom
    },
    {
        "APLLSS",
        "This register controls the APLL spread spectrum modulation.",
        4, // Width in bytes
        0x00000518, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_scg_cm4_apllss
    },
    {
        "APLLLOCK_CNFG",
        "The reset value for this register is chip-specific.",
        4, // Width in bytes
        0x000005f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_scg_cm4_aplllock_cnfg
    },
    {
        "SPLLCSR",
        "",
        4, // Width in bytes
        0x00000600, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_scg_cm4_spllcsr
    },
    {
        "SPLLDIV",
        "Changes to SPLLDIV should be done when System PLL is disabled to preve"
        "nt glitches to output divided clock.",
        4, // Width in bytes
        0x00000604, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_scg_cm4_splldiv
    },
    {
        "SPLLCFG",
        "The SPLLCFG register cannot be changed when the System PLL is enabled.",
        4, // Width in bytes
        0x00000608, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_scg_cm4_spllcfg
    },
    {
        "SPLLPFD",
        "This register defines the control bits for the PFD3-PFD0 clocks derive"
        "d from the System PLL.",
        4, // Width in bytes
        0x0000060c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_scg_cm4_spllpfd
    },
    {
        "SPLLLOCK_CNFG",
        "The reset value for this register is chip-specific.",
        4, // Width in bytes
        0x000006f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_scg_cm4_splllock_cnfg
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SCG_CA7
#endif

// Bitfields in register SCG_CA7_VERID.
static const field_t hw_scg_ca7_verid[] =
{
    {
        "VERSION",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_PARAM.
static const field_t hw_scg_ca7_param[] =
{
    {
        "CLKPRES",
        "Indicates which clock sources are present in this instance of SCG.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIVPRES",
        "Indicates which system clock dividers are present in this instance of "
        "SCG.",
        27, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_CSR.
static const field_t hw_scg_ca7_csr[] =
{
    {
        "DIVCORE",
        "",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SCS",
        "Returns the currently configured clock source generating the system cl"
        "ock.",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_RCCR.
static const field_t hw_scg_ca7_rccr[] =
{
    {
        "DIVCORE",
        "",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCS",
        "Selects the clock source generating the system clock in Run mode.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_VCCR.
static const field_t hw_scg_ca7_vccr[] =
{
    {
        "DIVCORE",
        "",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCS",
        "Selects the clock source generating the system clock in VLPR mode.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_HCCR.
static const field_t hw_scg_ca7_hccr[] =
{
    {
        "DIVCORE",
        "",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCS",
        "Selects the clock source generating the system clock in HSRUN mode.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_CLKOUTCNFG.
static const field_t hw_scg_ca7_clkoutcnfg[] =
{
    {
        "CLKOUTSEL",
        "Selects the SCG system clock.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_DDRCCR.
static const field_t hw_scg_ca7_ddrccr[] =
{
    {
        "DDRDIV",
        "DDRDIV can only be updated when the DDR clock is disabled.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDRCS",
        "Selects the clock source generating the DDR clock.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_NICCCR.
static const field_t hw_scg_ca7_nicccr[] =
{
    {
        "NIC1_DIVBUS",
        "",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NIC1_DIVEXT",
        "",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NIC1_DIV",
        "",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_DIV",
        "",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NIC0_DIV",
        "",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NICCS",
        "Selects the clock source generating the NIC clocks.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_NICCSR.
static const field_t hw_scg_ca7_niccsr[] =
{
    {
        "NIC1_DIVBUS",
        "",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NIC1_DIVEXT",
        "",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NIC1_DIV",
        "",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_DIV",
        "",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NIC0_DIV",
        "",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NICCS",
        "Selects the clock source generating the NIC clocks.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_SOSCCSR.
static const field_t hw_scg_ca7_sosccsr[] =
{
    {
        "SOSCCM",
        "Enables the clock monitor when SOSCVLD is set.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOSCCMRE",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit field can be cleared/set at any time.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOSCVLD",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SOSCSEL",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SOSCERR",
        "This flag is reset on Chip POR only, software can also clear this flag"
        " by writing a logic one.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_SOSCDIV.
static const field_t hw_scg_ca7_soscdiv[] =
{
    {
        "SOSCDIV1",
        "Clock divider 1 for System OSC.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOSCDIV2",
        "Clock divider 2 for System OSC.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOSCDIV3",
        "Clock divider 3 for System OSC.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_SIRCCSR.
static const field_t hw_scg_ca7_sirccsr[] =
{
    {
        "LK",
        "This bit field can be cleared/set at any time.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIRCVLD",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SIRCSEL",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_SIRCDIV.
static const field_t hw_scg_ca7_sircdiv[] =
{
    {
        "SIRCDIV1",
        "Clock divider 1 for Slow IRC.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIRCDIV2",
        "Clock divider 2 for Slow IRC.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIRCDIV3",
        "Clock divider 3 for Slow IRC.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_FIRCCSR.
static const field_t hw_scg_ca7_firccsr[] =
{
    {
        "FIRCLPEN",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIRCTREN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIRCTRUP",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIRCVLD",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FIRCSEL",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_FIRCDIV.
static const field_t hw_scg_ca7_fircdiv[] =
{
    {
        "FIRCDIV1",
        "Clock divider 1 for Fast IRC.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIRCDIV2",
        "Clock divider 2 for the Fast IRC.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIRCDIV3",
        "Clock divider 3 for the Fast IRC.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_ROSCCSR.
static const field_t hw_scg_ca7_rosccsr[] =
{
    {
        "ROSCCM",
        "Enables the clock monitor when ROSCVLD is set.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROSCCMRE",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit field can be cleared/set at any time.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROSCVLD",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ROSCERR",
        "This flag is reset on Chip POR only, software can also clear this flag"
        " by writing a logic one",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_APLLCSR.
static const field_t hw_scg_ca7_apllcsr[] =
{
    {
        "APLLEN",
        "When configuring the APLL, APLLEN should be set/cleared first.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APLLSTEN",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit field can be cleared/set at any time.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APLLVLD",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APLLSEL",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_APLLDIV.
static const field_t hw_scg_ca7_aplldiv[] =
{
    {
        "APLLDIV1",
        "Clock divider 1 for Auxiliary PLL.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APLLDIV2",
        "Clock divider 2 for Auxiliary PLL.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APLLDIV3",
        "Clock divider 3 for Auxiliary PLL.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_APLLCFG.
static const field_t hw_scg_ca7_apllcfg[] =
{
    {
        "SOURCE",
        "Configures the input clock source for the Auxiliary PLL.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLLS",
        "Selects the PFD or APLL as the PLL output clock used to generate syste"
        "m clocks.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREDIV",
        "Selects the amount to divide down the reference clock for the Auxiliar"
        "y PLL.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFDSEL",
        "Selects which PFD output clock will be used as a SCG system reference "
        "clock or as a SCG DDR reference clock.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MULT",
        "Multiplier for the Auxiliary PLL.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLLPOSTDIV1",
        "Auxiliary PLL 1st stage post divider.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLLPOSTDIV2",
        "Auxiliary PLL 2nd stage post divider.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_APLLPFD.
static const field_t hw_scg_ca7_apllpfd[] =
{
    {
        "PFD0",
        "Controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_VALID",
        "Indicates when PFD0 clock is valid.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "PFD0 Clock Gate.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1",
        "Controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_VALID",
        "Indicates when PFD1 clock is valid.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "PFD1 Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2",
        "Controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_VALID",
        "Indicates when PFD2 clock is valid.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "PFD2 Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3",
        "Controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_VALID",
        "Indicates when PFD3 clock is valid.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "PFD3 Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_APLLNUM.
static const field_t hw_scg_ca7_apllnum[] =
{
    {
        "NUM",
        "NOTE: The value of numerator must always be configured to be less than"
        " the value of the denominator.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_APLLDENOM.
static const field_t hw_scg_ca7_aplldenom[] =
{
    {
        "DENOM",
        "NOTE: The value of numerator must always be configured to be less than"
        " the value of the denominator.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_APLLSS.
static const field_t hw_scg_ca7_apllss[] =
{
    {
        "STEP",
        "",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP",
        "",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_APLLLOCK_CNFG.
static const field_t hw_scg_ca7_aplllock_cnfg[] =
{
    {
        "LOCK_TIME",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_SPLLCSR.
static const field_t hw_scg_ca7_spllcsr[] =
{
    {
        "SPLLEN",
        "When configuring the SPLL, SPLLEN should be set/cleared first.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPLLSTEN",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit field can be cleared/set at any time.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPLLVLD",
        "Indicates when the SPLL clock is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPLLSEL",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPLLERR",
        "This flag is reset on Chip POR only, software can also clear this flag"
        " by writing a logic one",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_SPLLDIV.
static const field_t hw_scg_ca7_splldiv[] =
{
    {
        "SPLLDIV1",
        "Clock divider 1 for System PLL.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPLLDIV2",
        "Clock divider 2 for System PLL.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPLLDIV3",
        "Clock divider 3 for System PLL.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_SPLLCFG.
static const field_t hw_scg_ca7_spllcfg[] =
{
    {
        "SOURCE",
        "Configures the input clock source for the System PLL.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLLS",
        "Selects the PLL or PFD as the SPLL output used to generate system cloc"
        "ks.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREDIV",
        "Selects the amount to divide down the reference clock for the System P"
        "LL.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFDSEL",
        "Selects which PFD output clock will be used as a SCG system reference "
        "clock or as a SCG DDR reference clock.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MULT",
        "Multiplier for the System PLL.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLLPOSTDIV1",
        "System PLL 1st stage post divider.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLLPOSTDIV2",
        "System PLL 2nd stage post divider.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_SPLLPFD.
static const field_t hw_scg_ca7_spllpfd[] =
{
    {
        "PFD0",
        "Controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_VALID",
        "Indicates when PFD0 clock is valid.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "PFD0 Clock Gate.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1",
        "Controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_VALID",
        "Indicates when PFD1 clock is valid.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "PFD1 Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2",
        "Controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_VALID",
        "Indicates when PFD2 clock is valid.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "PFD2 Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3",
        "Controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_VALID",
        "Indicates when PFD3 clock is valid.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "PFD3 Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_SPLLNUM.
static const field_t hw_scg_ca7_spllnum[] =
{
    {
        "NUM",
        "NOTE: The value of numerator must always be configured to be less than"
        " the value of the denominator.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_SPLLDENOM.
static const field_t hw_scg_ca7_splldenom[] =
{
    {
        "DENOM",
        "NOTE: The value of numerator must always be configured to be less than"
        " the value of the denominator.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_SPLLSS.
static const field_t hw_scg_ca7_spllss[] =
{
    {
        "STEP",
        "",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP",
        "",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SCG_CA7_SPLLLOCK_CNFG.
static const field_t hw_scg_ca7_splllock_cnfg[] =
{
    {
        "LOCK_TIME",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SCG_CA7 module.
static const reg_t hw_scg_ca7[] =
{
    {
        "VERID",
        "Note: Writing to this register will result in a transfer error.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_scg_ca7_verid
    },
    {
        "PARAM",
        "Note: Writing to this register will result in a transfer error.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_scg_ca7_param
    },
    {
        "CSR",
        "This register returns the currently configured system clock source and"
        " the system clock dividers for the core (DIVCORE) and peripheral inter"
        "face clock (DIVSLOW).",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_scg_ca7_csr
    },
    {
        "RCCR",
        "This register controls the system clock source and the system clock di"
        "viders for the core, platform, external and bus clock domains when in "
        "Run mode only.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_scg_ca7_rccr
    },
    {
        "VCCR",
        "This register controls the system clock source and the system clock di"
        "viders for the core, platform, external and bus clock domains when in "
        "VLPR mode only.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_scg_ca7_vccr
    },
    {
        "HCCR",
        "This register controls the system clock source and the system clock di"
        "viders for the core, platform, external and bus clock domains when in "
        "HSRUN mode only.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_scg_ca7_hccr
    },
    {
        "CLKOUTCNFG",
        "This register controls which SCG clock source is selected to be ported"
        " out to the CLKOUT pin.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_scg_ca7_clkoutcnfg
    },
    {
        "DDRCCR",
        "This register controls the DDR clock source and the DDR clock dividers"
        ".",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_scg_ca7_ddrccr
    },
    {
        "NICCCR",
        "This register controls the NIC clock source and the NIC clock dividers"
        ".",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_scg_ca7_nicccr
    },
    {
        "NICCSR",
        "This register returns the currently configured NIC clock source and th"
        "e NIC clock dividers.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_scg_ca7_niccsr
    },
    {
        "SOSCCSR",
        "",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_scg_ca7_sosccsr
    },
    {
        "SOSCDIV",
        "The SCG_SOSCDIV register provides the control of 3 clock trees which c"
        "an be used to provide optional peripheral functional clocks, or altern"
        "ative module clocks.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_scg_ca7_soscdiv
    },
    {
        "SIRCCSR",
        "",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_scg_ca7_sirccsr
    },
    {
        "SIRCDIV",
        "To prevent glitches to the output divided clock, change SIRDIV when th"
        "e Slow IRC is disabled.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_scg_ca7_sircdiv
    },
    {
        "FIRCCSR",
        "",
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_scg_ca7_firccsr
    },
    {
        "FIRCDIV",
        "Changes to FIRCDIV should be done when FAST IRC is disabled to prevent"
        " glitches to output divided clock.",
        4, // Width in bytes
        0x00000304, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_scg_ca7_fircdiv
    },
    {
        "ROSCCSR",
        "",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_scg_ca7_rosccsr
    },
    {
        "APLLCSR",
        "",
        4, // Width in bytes
        0x00000500, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_scg_ca7_apllcsr
    },
    {
        "APLLDIV",
        "Changes to APLLDIV should be done when Auxiliary PLL is disabled to pr"
        "event glitches to output divided clock.",
        4, // Width in bytes
        0x00000504, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_scg_ca7_aplldiv
    },
    {
        "APLLCFG",
        "The APLLCFG register cannot be changed when the Auxiliary PLL is enabl"
        "ed.",
        4, // Width in bytes
        0x00000508, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_scg_ca7_apllcfg
    },
    {
        "APLLPFD",
        "This register defines the control bits for the PFD3-PFD0 clocks derive"
        "d from the Auxiliary PLL.",
        4, // Width in bytes
        0x0000050c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_scg_ca7_apllpfd
    },
    {
        "APLLNUM",
        "",
        4, // Width in bytes
        0x00000510, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_scg_ca7_apllnum
    },
    {
        "APLLDENOM",
        "",
        4, // Width in bytes
        0x00000514, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_scg_ca7_aplldenom
    },
    {
        "APLLSS",
        "This register controls the APLL spread spectrum modulation.",
        4, // Width in bytes
        0x00000518, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_scg_ca7_apllss
    },
    {
        "APLLLOCK_CNFG",
        "The reset value for this register is chip-specific.",
        4, // Width in bytes
        0x000005f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_scg_ca7_aplllock_cnfg
    },
    {
        "SPLLCSR",
        "",
        4, // Width in bytes
        0x00000600, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_scg_ca7_spllcsr
    },
    {
        "SPLLDIV",
        "Changes to SPLLDIV should be done when System PLL is disabled to preve"
        "nt glitches to output divided clock.",
        4, // Width in bytes
        0x00000604, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_scg_ca7_splldiv
    },
    {
        "SPLLCFG",
        "The SPLLCFG register cannot be changed when the System PLL is enabled.",
        4, // Width in bytes
        0x00000608, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_scg_ca7_spllcfg
    },
    {
        "SPLLPFD",
        "This register defines the control bits for the PFD3-PFD0 clocks derive"
        "d from the System PLL.",
        4, // Width in bytes
        0x0000060c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_scg_ca7_spllpfd
    },
    {
        "SPLLNUM",
        "",
        4, // Width in bytes
        0x00000610, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_scg_ca7_spllnum
    },
    {
        "SPLLDENOM",
        "",
        4, // Width in bytes
        0x00000614, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_scg_ca7_splldenom
    },
    {
        "SPLLSS",
        "",
        4, // Width in bytes
        0x00000618, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_scg_ca7_spllss
    },
    {
        "SPLLLOCK_CNFG",
        "The reset value for this register is chip-specific.",
        4, // Width in bytes
        0x000006f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_scg_ca7_splllock_cnfg
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SEMA42
#endif

// Bitfields in register SEMA42_GATE0.
static const field_t hw_sema42_gate0[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_GATE1.
static const field_t hw_sema42_gate1[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_GATE2.
static const field_t hw_sema42_gate2[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_GATE3.
static const field_t hw_sema42_gate3[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_GATE4.
static const field_t hw_sema42_gate4[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_GATE5.
static const field_t hw_sema42_gate5[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_GATE6.
static const field_t hw_sema42_gate6[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_GATE7.
static const field_t hw_sema42_gate7[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_GATE8.
static const field_t hw_sema42_gate8[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_GATE9.
static const field_t hw_sema42_gate9[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_GATE10.
static const field_t hw_sema42_gate10[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_GATE11.
static const field_t hw_sema42_gate11[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_GATE12.
static const field_t hw_sema42_gate12[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_GATE13.
static const field_t hw_sema42_gate13[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_GATE14.
static const field_t hw_sema42_gate14[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_GATE15.
static const field_t hw_sema42_gate15[] =
{
    {
        "GTFSM",
        "Gate Finite State Machine.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_RSTGT_R.
static const field_t hw_sema42_rstgt_r[] =
{
    {
        "RSTGTN",
        "Reset Gate Number.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSTGMS",
        "Reset Gate Bus Master.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSTGSM",
        "Reset Gate Finite State Machine.",
        12, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ROZ",
        "This field always returns the value 0 when read.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SEMA42_RSTGT_W.
static const field_t hw_sema42_rstgt_w[] =
{
    {
        "RSTGTN",
        "Reset Gate Number.",
        0, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "RSTGDP",
        "Reset Gate Data Pattern.",
        8, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SEMA42 module.
static const reg_t hw_sema42[] =
{
    {
        "GATE0",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema42_gate0
    },
    {
        "GATE1",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000001, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema42_gate1
    },
    {
        "GATE2",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000002, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema42_gate2
    },
    {
        "GATE3",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000003, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema42_gate3
    },
    {
        "GATE4",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema42_gate4
    },
    {
        "GATE5",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000005, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema42_gate5
    },
    {
        "GATE6",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000006, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema42_gate6
    },
    {
        "GATE7",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000007, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema42_gate7
    },
    {
        "GATE8",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema42_gate8
    },
    {
        "GATE9",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x00000009, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema42_gate9
    },
    {
        "GATE10",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000a, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema42_gate10
    },
    {
        "GATE11",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000b, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema42_gate11
    },
    {
        "GATE12",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema42_gate12
    },
    {
        "GATE13",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000d, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema42_gate13
    },
    {
        "GATE14",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000e, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema42_gate14
    },
    {
        "GATE15",
        "Each semaphore gate is implemented in a 4-bit finite state machine, ri"
        "ght-justified in a byte data structure.",
        1, // Width in bytes
        0x0000000f, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sema42_gate15
    },
    {
        "RSTGT_R",
        "This section and the following section, , describe the same register.",
        2, // Width in bytes
        0x00000042, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_sema42_rstgt_r
    },
    {
        "RSTGT_W",
        "This section describes how the Reset Gate register fields appear when "
        "the register is written.",
        2, // Width in bytes
        0x00000042, // Base address offset
        false, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_sema42_rstgt_w
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SIM
#endif

// Bitfields in register SIM_SOPT1.
static const field_t hw_sim_sopt1[] =
{
    {
        "A7_SW_RESET",
        "1'b0 : Releases A7 domain 1'b1 : Resets A7 domain",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_SEC_VIO",
        "1'b0 : Security violation disabled 1'b1 : Security violation enabled",
        1, // LSB
        1, // MSB
        false, // Readable
        false // Writable
    },
    {
        "PMIC_STBY_REQ",
        "1'b0 : PMIC_STBY_REQ will negate - functional voltage 1'b1 : PMIC_STBY"
        "_REQ will assert - Voltage will be requested to change to standby volt"
        "age",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MIPI_ISO_DISABLE",
        "1'b0 - MIPI isolation enabled.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4_FPU_DISABLE",
        "1'b0 : FPU enabled 1'b1 : FPU disabled",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4_MPU_DISABLE",
        "1'b0 : MPU enabled 1'b1 : MPU disabled",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_SNVS_HARD_RST",
        "1'b0 : SNVS_HP system reset enabled 1'b1 : SNVS_HP system reset disabl"
        "ed",
        8, // LSB
        8, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_SOPT1CFG.
static const field_t hw_sim_sopt1cfg[] =
{
    {
        "MASK_DPM_PANIC_OUT",
        "",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "MASK_DPM_PANIC_IN",
        "",
        1, // LSB
        1, // MSB
        false, // Readable
        false // Writable
    },
    {
        "DSI_PLL_EN",
        "1'b1: DSI PLL enabled 1'b0: DSI PLL disabled",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSI_CM",
        "1'b0 - Normal mode (full color) (default).",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSI_SD",
        "1'b0 - Shutdown command not to be sent to the Type-4 display (default)"
        ".",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QSPI_PULL_TIM_RELAX_B",
        "1'b0 - OBE assertion is pulled by a half a cycle.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSI_RST_BYTE_N",
        "1'b0 - Byte domain is under reset state (default).",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSI_RST_ESC_N",
        "1'b0 - Escape domain is under reset state (default).",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSI_RST_DPI_N",
        "1'b0 - DPI domain is under reset state (default).",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_HSIC_CAL.
static const field_t hw_sim_hsic_cal[] =
{
    {
        "HSIC_ZQ_VOH",
        "This field determines the value of the Pull-up resistor during SW ZQ c"
        "alibration.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSIC_ZQ_CAL_EN",
        "Control the latching of the compare result.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSIC_ZQ_VOH_M1",
        "This field determines the value of the Pull-up resistor during SW ZQ c"
        "alibration.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSIC_ZQ_VOL",
        "This field determines the value of the Pull-down resistor during SW ZQ"
        " calibration.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSIC_ZQ_VOL_M1",
        "This field determines the value of the Pull-down resistor during SW ZQ"
        " calibration.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_REG_SNVS.
static const field_t hw_sim_reg_snvs[] =
{
    { 0 } // Terminator
};

// Bitfields in register SIM_SNVS_MISC_CTRL.
static const field_t hw_sim_snvs_misc_ctrl[] =
{
    {
        "OSC_CAP_TRIM",
        "",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COIN_CELL_CHARGE_EN",
        "1'b0 : Enable Isolation on Software Trims/Pull controls.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_GPR0.
static const field_t hw_sim_gpr0[] =
{
    {
        "MTR_CLK_DIS",
        "Disables MTR clocks to save power.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCOTP_CLK_DIS",
        "Disables OCOTP clocks to save power.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL1_PFD0_PRE_DIV",
        "1'b0: Divide by 2.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_MISC_CTRL0.
static const field_t hw_sim_misc_ctrl0[] =
{
    {
        "FB_DELAY_OE_EXTS",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OBS_CLK_ENABLE",
        "1'b0 : Clock observation feature disabled.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4_OBS_CLK_SRC_SEL",
        "4'b0000 - LPO1KHZ clock 4'b0001 - SIRC clock 4'b0010 - FIRC clock 4'b0"
        "011 - System OSC 4'b0100 - RTC OSC - 32KHz 4'b0101 - PLL0 VCO 4'b0110 "
        "- PLL0 PFD0 4'b0111 - PLL0 PFD1 4'b1000 - PLL0 PFD2 4'b1001 - PLL0 PFD"
        "3 4'b1010 - PLL1 VCO 4'b1011 - PLL1 PFD0 4'b1100 - PLL1 PFD1 4'b1101 -"
        " PLL1 PFD2 4'b1110 - PLL1 PFD3 4'b1111 - Reserved",
        6, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4_OBS_CLK_DIV_RATIO",
        "",
        10, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A7_OBS_CLK_SRC_SEL",
        "4'b0000 - PMC0_TST_DIG_OUT 4'b0001 - PMC1_TST_DIG_OUT 4'b0010 - Reserv"
        "ed 4'b0011 - Reserved 4'b0100 - Reserved 4'b0101 - PLL2 VCO 4'b0110 - "
        "PLL2 PFD0 4'b0111 - PLL2 PFD1 4'b1000 - PLL2 PFD2 4'b1001 - PLL2 PFD3 "
        "4'b1010 - PLL3 VCO 4'b1011 - PLL3 PFD0 4'b1100 - PLL3 PFD1 4'b1101 - P"
        "LL3 PFD2 4'b1110 - PLL3 PFD3 4'b1111 - Reserved",
        13, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "A7_OBS_CLK_DIV_RATIO",
        "",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_DDR_HW_AUTO_LP_MODE",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_DGO_CTRL0.
static const field_t hw_sim_dgo_ctrl0[] =
{
    {
        "UPDATE_DGO_GP1",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_DGO_GP2",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_DGO_GP3",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_DGO_GP4",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_DGO_GP5",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_DGO_GP6",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_ACK_DGO_GP1",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_ACK_DGO_GP2",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_ACK_DGO_GP3",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_ACK_DGO_GP4",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_ACK_DGO_GP5",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_ACK_DGO_GP6",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_EN_ACK1",
        "Enables write acknowledge on DGO GP1 as interrupt to NVIC.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_EN_ACK2",
        "Enables write acknowledge on DGO GP2 as interrupt to NVIC.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_EN_ACK3",
        "Enables write acknowledge on DGO GP3 as interrupt to NVIC.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_EN_ACK4",
        "Enables write acknowledge on DGO GP4 as interrupt to NVIC.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_EN_ACK5",
        "Enables write acknowledge on DGO GP5 as interrupt to NVIC.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_EN_ACK6",
        "Enables write acknowledge on DGO GP6 as interrupt to NVIC.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_DGO_CTRL1.
static const field_t hw_sim_dgo_ctrl1[] =
{
    {
        "UPDATE_DGO_GP7",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_DGO_GP8",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_DGO_GP9",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_DGO_GP10",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_DGO_GP11",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_ACK_DGO_GP7",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_ACK_DGO_GP8",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_ACK_DGO_GP9",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_ACK_DGO_GP10",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_ACK_DGO_GP11",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_EN_ACK7",
        "Enables write acknowledge on DGO GP7 as interrupt to NVIC.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_EN_ACK8",
        "Enables write acknowledge on DGO GP8 as interrupt to NVIC.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_EN_ACK9",
        "Enables write acknowledge on DGO GP9 as interrupt to NVIC.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_EN_ACK10",
        "Enables write acknowledge on DGO GP10 as interrupt to NVIC.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_EN_ACK11",
        "Enables write acknowledge on DGO GP11 as interrupt to NVIC.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_DGO_GP1.
static const field_t hw_sim_dgo_gp1[] =
{
    {
        "SIM_DGO_GP1",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_DGO_GP2.
static const field_t hw_sim_dgo_gp2[] =
{
    {
        "PTA_RANGE_CTRL",
        "1'b00: Continuous Mode.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTB_RANGE_CTRL",
        "1'b00: Continuous Mode.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTC_RANGE_CTRL",
        "1'b00: Continuous Mode.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTD_RANGE_CTRL",
        "1'b00: Continuous Mode.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTE_RANGE_CTRL",
        "1'b00: Continuous Mode.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_DGO_GP3.
static const field_t hw_sim_dgo_gp3[] =
{
    {
        "SIM_DGO_GP3",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_DGO_GP4.
static const field_t hw_sim_dgo_gp4[] =
{
    {
        "SIM_DGO_GP4",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_DGO_GP5.
static const field_t hw_sim_dgo_gp5[] =
{
    {
        "SIM_DGO_GP5",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_DGO_GP6.
static const field_t hw_sim_dgo_gp6[] =
{
    {
        "SIM_DGO_GP6",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_DGO_GP7.
static const field_t hw_sim_dgo_gp7[] =
{
    {
        "SIM_DGO_GP7",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_DGO_GP8.
static const field_t hw_sim_dgo_gp8[] =
{
    {
        "SIM_DGO_GP8",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_DGO_GP9.
static const field_t hw_sim_dgo_gp9[] =
{
    {
        "SIM_DGO_GP9",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_DGO_GP10.
static const field_t hw_sim_dgo_gp10[] =
{
    {
        "SIM_DGO_GP10",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_DGO_GP11.
static const field_t hw_sim_dgo_gp11[] =
{
    {
        "DBG_SPIDEN_SPNIDEN",
        "Writes in this register defines de value of SPIDEN/SPNIDEN bits.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_DBG_CTRL.
static const field_t hw_sim_dbg_ctrl[] =
{
    {
        "MODULE_DEBUG_SEL",
        "4'b0000 - MMDC/DDR 4'b0001 - MMDC/DDR 4'b0010 - GPU 2D/3D 4'b0011 - RE"
        "SERVED 4'b0100 - USBO 4'b0101 - DSI 4'b0110 - DSI 4'b0111 - DSI 4'b100"
        "0 - DSI 4'b1001 - LCDIF",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SIM_WAKE_UP_MSK.
static const field_t hw_sim_wake_up_msk[] =
{
    {
        "M4_QSPI_WAKE_UP_MASK_B",
        "1'b0 : Wakeup masked 1'b1 : Wakeup enabled",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4_SAI0_WAKE_UP_MASK_B",
        "1'b0 : Wakeup masked 1'b1 : Wakeup enabled",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4_SAI1_WAKE_UP_MASK_B",
        "1'b0 : Wakeup masked 1'b1 : Wakeup enabled",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4_PCTLA_WAKE_UP_MASK_B",
        "1'b0 : Wakeup masked 1'b1 : Wakeup enabled",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M4_PCTLB_WAKE_UP_MASK_B",
        "1'b0 : Wakeup masked 1'b1 : Wakeup enabled",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SIM module.
static const reg_t hw_sim[] =
{
    {
        "SOPT1",
        "This control register provides System Options for various functions on"
        " i.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_sim_sopt1
    },
    {
        "SOPT1CFG",
        "This register is used to configure system options on ULP1.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_sim_sopt1cfg
    },
    {
        "HSIC_CAL",
        "Calibration Settings for HSIC DDR pads.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_sim_hsic_cal
    },
    {
        "REG_SNVS",
        "This register defines the control and status bits for the 1.1V regulat"
        "or.",
        4, // Width in bytes
        0x00000014, // Base address offset
        false, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_sim_reg_snvs
    },
    {
        "SNVS_MISC_CTRL",
        "This register defines additional control for the SNVS domain.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sim_snvs_misc_ctrl
    },
    {
        "GPR0",
        "General Purpose Read/Write Register 0.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_sim_gpr0
    },
    {
        "MISC_CTRL0",
        "This register is used for miscellaneous controls.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_sim_misc_ctrl0
    },
    {
        "DGO_CTRL0",
        "Control Register for DGO GPs 1 to 6.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_sim_dgo_ctrl0
    },
    {
        "DGO_CTRL1",
        "Control Register for DGO GPs 7 to 11.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_sim_dgo_ctrl1
    },
    {
        "DGO_GP1",
        "General Purpose Read/Write DGO Register 1.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sim_dgo_gp1
    },
    {
        "DGO_GP2",
        "General Purpose Read/Write DGO Register 2.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_sim_dgo_gp2
    },
    {
        "DGO_GP3",
        "General Purpose Read/Write DGO Register 3.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sim_dgo_gp3
    },
    {
        "DGO_GP4",
        "General Purpose Read/Write DGO Register 4.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sim_dgo_gp4
    },
    {
        "DGO_GP5",
        "General Purpose Read/Write DGO Register 5.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sim_dgo_gp5
    },
    {
        "DGO_GP6",
        "General Purpose Read/Write DGO Register 6.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sim_dgo_gp6
    },
    {
        "DGO_GP7",
        "General Purpose Read/Write DGO Register 7.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sim_dgo_gp7
    },
    {
        "DGO_GP8",
        "General Purpose Read/Write DGO Register 8.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sim_dgo_gp8
    },
    {
        "DGO_GP9",
        "General Purpose Read/Write DGO Register 9.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sim_dgo_gp9
    },
    {
        "DGO_GP10",
        "General Purpose Read/Write DGO Register 10.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sim_dgo_gp10
    },
    {
        "DGO_GP11",
        "General Purpose Read/Write DGO Register 11.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sim_dgo_gp11
    },
    {
        "DBG_CTRL",
        "Allow the control of debug features.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sim_dbg_ctrl
    },
    {
        "WAKE_UP_MSK",
        "Allow masking wakeup sources.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_sim_wake_up_msk
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SNVS
#endif

// Bitfields in register SNVS_HPLR.
static const field_t hw_snvs_hplr[] =
{
    {
        "MC_SL",
        "Monotonic Counter Soft Lock When set, prevents any writes (increments)"
        " to the MC Registers and MC_ENV bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPR_SL",
        "General Purpose Register Soft Lock When set, prevents any writes to th"
        "e GPR.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPCOMR.
static const field_t hw_snvs_hpcomr[] =
{
    {
        "LP_SWR",
        "LP Software Reset When set to 1, the registers in the SNVS_LP section "
        "are reset.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LP_SWR_DIS",
        "LP Software Reset Disable When set, disables the LP software reset.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NPSWA_EN",
        "Non-Privileged Software Access Enable When set, allows non-privileged "
        "software to access all SNVS registers, including those that are privil"
        "eged software read/write access only.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPCR.
static const field_t hw_snvs_hpcr[] =
{
    {
        "RTC_EN",
        "HP Real Time Counter Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPTA_EN",
        "HP Time Alarm Enable When set, the time alarm interrupt is generated i"
        "f the value in the HP Time Alarm Registers is equal to the value of th"
        "e HP Real Time Counter.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PI_EN",
        "HP Periodic Interrupt Enable The periodic interrupt can be generated o"
        "nly if the HP Real Time Counter is enabled.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PI_FREQ",
        "Periodic Interrupt Frequency Defines frequency of the periodic interru"
        "pt.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPCALB_EN",
        "HP Real Time Counter Calibration Enabled Indicates that the time calib"
        "ration mechanism is enabled.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPCALB_VAL",
        "HP Calibration Value Defines signed calibration value for the HP Real "
        "Time Counter.",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BTN_CONFIG",
        "Button Configuration.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BTN_MASK",
        "Button interrupt mask.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPSR.
static const field_t hw_snvs_hpsr[] =
{
    {
        "HPTA",
        "HP Time Alarm Indicates that the HP Time Alarm has occurred since this"
        " bit was last cleared.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PI",
        "Periodic Interrupt Indicates that periodic interrupt has occurred sinc"
        "e this bit was last cleared.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPDIS",
        "Low Power Disable If 1, the low power section has been disabled by mea"
        "ns of an input signal to SNVS.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BTN",
        "Button Value of the BTN input.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BI",
        "Button Interrupt Signal ipi_snvs_btn_int_b was asserted.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPRTCMR.
static const field_t hw_snvs_hprtcmr[] =
{
    {
        "RTC",
        "HP Real Time Counter The most-significant 15 bits of the RTC.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPRTCLR.
static const field_t hw_snvs_hprtclr[] =
{
    {
        "RTC",
        "HP Real Time Counter least-significant 32 bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPTAMR.
static const field_t hw_snvs_hptamr[] =
{
    {
        "HPTA_MS",
        "HP Time Alarm, most-significant 15 bits.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPTALR.
static const field_t hw_snvs_hptalr[] =
{
    {
        "HPTA_LS",
        "HP Time Alarm, 32 least-significant bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPLR.
static const field_t hw_snvs_lplr[] =
{
    {
        "MC_HL",
        "Monotonic Counter Hard Lock When set, prevents any writes (increments)"
        " to the MC Registers and MC_ENV bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPR_HL",
        "General Purpose Register Hard Lock When set, prevents any writes to th"
        "e GPR.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPCR.
static const field_t hw_snvs_lpcr[] =
{
    {
        "MC_ENV",
        "Monotonic Counter Enabled and Valid When set, the MC can be incremente"
        "d (by write transaction to the LPSMCMR or LPSMCLR).",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPWUI_EN",
        "LP Wake-Up Interrupt Enable This interrupt line should be connected to"
        " the external pin and is intended to inform the external chip about an"
        " SNVS_LP event (tamper event, MC rollover, SRTC rollover, or time alar"
        "m ).",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_EN",
        "Dumb PMIC Enabled When set, software can control the system power.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOP",
        "Turn off System Power Asserting this bit causes a signal to be sent to"
        " the Power Management IC to turn off the system power.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWR_GLITCH_EN",
        "Power Glitch Enable By default the detection of a power glitch does no"
        "t cause the pmic_en_b signal to be asserted.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BTN_PRESS_TIME",
        "This field configures the button press time out values for the PMIC Lo"
        "gic.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBOUNCE",
        "This field configures the amount of debounce time for the BTN input si"
        "gnal.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ON_TIME",
        "The ON_TIME field is used to configure the period of time after BTN is"
        " asserted before pmic_en_b is asserted to turn on the SoC power.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PK_EN",
        "PMIC On Request Enable The value written to PK_EN will be asserted on "
        "output signal snvs_lp_pk_en.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PK_OVERRIDE",
        "PMIC On Request Override The value written to PK_OVERRIDE will be asse"
        "rted on output signal snvs_lp_pk_override.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPSR.
static const field_t hw_snvs_lpsr[] =
{
    {
        "MCR",
        "Monotonic Counter Rollover",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EO",
        "Emergency Off This bit is set when a power off is requested.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPO",
        "Set Power Off The SPO bit is set when the power button is pressed long"
        "er than the configured debounce time.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPSMCMR.
static const field_t hw_snvs_lpsmcmr[] =
{
    {
        "MON_COUNTER",
        "Monotonic Counter most-significant 16 Bits The MC is incremented by on"
        "e when: A write transaction to the LPSMCMR or LPSMCLR register is dete"
        "cted.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MC_ERA_BITS",
        "Monotonic Counter Era Bits These bits are inputs to the module and typ"
        "ically connect to fuses.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPSMCLR.
static const field_t hw_snvs_lpsmclr[] =
{
    {
        "MON_COUNTER",
        "Monotonic Counter bits The MC is incremented by one when: A write tran"
        "saction to the LPSMCMR or LPSMCLR Register is detected.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPGPR0_legacy_alias.
static const field_t hw_snvs_lpgpr0_legacy_alias[] =
{
    {
        "GPR",
        "General Purpose Register When GPR_SL or GPR_HL bit is set, the registe"
        "r cannot be programmed.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPGPR0_alias.
static const field_t hw_snvs_lpgpr0_alias[] =
{
    {
        "GPR",
        "General Purpose Register When GPR_SL or GPR_HL bit is set, the registe"
        "r cannot be programmed.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPGPR1_alias.
static const field_t hw_snvs_lpgpr1_alias[] =
{
    {
        "GPR",
        "General Purpose Register When GPR_SL or GPR_HL bit is set, the registe"
        "r cannot be programmed.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPGPR2_alias.
static const field_t hw_snvs_lpgpr2_alias[] =
{
    {
        "GPR",
        "General Purpose Register When GPR_SL or GPR_HL bit is set, the registe"
        "r cannot be programmed.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPGPR3_alias.
static const field_t hw_snvs_lpgpr3_alias[] =
{
    {
        "GPR",
        "General Purpose Register When GPR_SL or GPR_HL bit is set, the registe"
        "r cannot be programmed.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPGPR0.
static const field_t hw_snvs_lpgpr0[] =
{
    {
        "GPR",
        "General Purpose Register When GPR_SL or GPR_HL bit is set, the registe"
        "r cannot be programmed.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPGPR1.
static const field_t hw_snvs_lpgpr1[] =
{
    {
        "GPR",
        "General Purpose Register When GPR_SL or GPR_HL bit is set, the registe"
        "r cannot be programmed.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPGPR2.
static const field_t hw_snvs_lpgpr2[] =
{
    {
        "GPR",
        "General Purpose Register When GPR_SL or GPR_HL bit is set, the registe"
        "r cannot be programmed.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPGPR3.
static const field_t hw_snvs_lpgpr3[] =
{
    {
        "GPR",
        "General Purpose Register When GPR_SL or GPR_HL bit is set, the registe"
        "r cannot be programmed.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPGPR4.
static const field_t hw_snvs_lpgpr4[] =
{
    {
        "GPR",
        "General Purpose Register When GPR_SL or GPR_HL bit is set, the registe"
        "r cannot be programmed.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPGPR5.
static const field_t hw_snvs_lpgpr5[] =
{
    {
        "GPR",
        "General Purpose Register When GPR_SL or GPR_HL bit is set, the registe"
        "r cannot be programmed.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPGPR6.
static const field_t hw_snvs_lpgpr6[] =
{
    {
        "GPR",
        "General Purpose Register When GPR_SL or GPR_HL bit is set, the registe"
        "r cannot be programmed.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPGPR7.
static const field_t hw_snvs_lpgpr7[] =
{
    {
        "GPR",
        "General Purpose Register When GPR_SL or GPR_HL bit is set, the registe"
        "r cannot be programmed.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPVIDR1.
static const field_t hw_snvs_hpvidr1[] =
{
    {
        "MINOR_REV",
        "SNVS block minor version number",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR_REV",
        "SNVS block major version number",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IP_ID",
        "SNVS block ID",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPVIDR2.
static const field_t hw_snvs_hpvidr2[] =
{
    {
        "CONFIG_OPT",
        "SNVS Configuration Options",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ECO_REV",
        "SNVS ECO Revision",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INTG_OPT",
        "SNVS Integration Options",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IP_ERA",
        "IP Era 00h - Era 1 or 2 03h - Era 3 04h - Era 4 05h - Era 5",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SNVS module.
static const reg_t hw_snvs[] =
{
    {
        "HPLR",
        "The SNVS_HP Lock Register contains lock bits for the SNVS registers.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_snvs_hplr
    },
    {
        "HPCOMR",
        "The SNVS_HP Command Register contains the command, configuration, and "
        "control bits for the SNVS block.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_snvs_hpcomr
    },
    {
        "HPCR",
        "The SNVS_HP Control Register contains various control bits of the HP s"
        "ection of SNVS.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_snvs_hpcr
    },
    {
        "HPSR",
        "The HP Status Register reflects the internal state of the SNVS.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_snvs_hpsr
    },
    {
        "HPRTCMR",
        "The SNVS_HP Real Time Counter MSB register contains the 15 most-signif"
        "icant bits of the HP Real Time Counter.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_hprtcmr
    },
    {
        "HPRTCLR",
        "The SNVS_HP Real Time Counter LSB register contains the 32 least-signi"
        "ficant bits of the HP real time counter.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_hprtclr
    },
    {
        "HPTAMR",
        "The SNVS_HP Time Alarm MSB register contains the most-significant bits"
        " of the SNVS_HP Time Alarm value.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_hptamr
    },
    {
        "HPTALR",
        "The SNVS_HP Time Alarm LSB register contains the 32 least-significant "
        "bits of the SNVS_HP Time Alarm value.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_hptalr
    },
    {
        "LPLR",
        "The SNVS_LP Lock Register contains lock bits for the SNVS_LP registers"
        ".",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_snvs_lplr
    },
    {
        "LPCR",
        "The SNVS_LP Control Register contains various control bits of the LP s"
        "ection of SNVS.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_snvs_lpcr
    },
    {
        "LPSR",
        "The SNVS_LP Status Register reflects the internal state and behavior o"
        "f the SNVS_LP.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_snvs_lpsr
    },
    {
        "LPSMCMR",
        "The SNVS_LP Secure Monotonic Counter MSB Register contains the monoton"
        "ic counter era bits and the most-significant 16 bits of the monotonic "
        "counter.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_snvs_lpsmcmr
    },
    {
        "LPSMCLR",
        "The SNVS_LP Secure Monotonic Counter LSB Register contains the 32 leas"
        "t-significant bits of the monotonic counter.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_snvs_lpsmclr
    },
    {
        "LPGPR0_legacy_alias",
        "The SNVS_LP General Purpose Register is a 256-bit read/write register "
        "located in SNVS_LP, which can be used by any application for retaining"
        " data during an SoC power-down mode.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpgpr0_legacy_alias
    },
    {
        "LPGPR0_alias",
        "The SNVS_LP General Purpose Register is a 256-bit read/write register "
        "located in SNVS_LP, which can be used by any application for retaining"
        " data during an SoC power-down mode.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpgpr0_alias
    },
    {
        "LPGPR1_alias",
        "The SNVS_LP General Purpose Register is a 256-bit read/write register "
        "located in SNVS_LP, which can be used by any application for retaining"
        " data during an SoC power-down mode.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpgpr1_alias
    },
    {
        "LPGPR2_alias",
        "The SNVS_LP General Purpose Register is a 256-bit read/write register "
        "located in SNVS_LP, which can be used by any application for retaining"
        " data during an SoC power-down mode.",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpgpr2_alias
    },
    {
        "LPGPR3_alias",
        "The SNVS_LP General Purpose Register is a 256-bit read/write register "
        "located in SNVS_LP, which can be used by any application for retaining"
        " data during an SoC power-down mode.",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpgpr3_alias
    },
    {
        "LPGPR0",
        "The SNVS_LP General Purpose Register is a 256-bit read/write register "
        "located in SNVS_LP, which can be used by any application for retaining"
        " data during an SoC power-down mode.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpgpr0
    },
    {
        "LPGPR1",
        "The SNVS_LP General Purpose Register is a 256-bit read/write register "
        "located in SNVS_LP, which can be used by any application for retaining"
        " data during an SoC power-down mode.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpgpr1
    },
    {
        "LPGPR2",
        "The SNVS_LP General Purpose Register is a 256-bit read/write register "
        "located in SNVS_LP, which can be used by any application for retaining"
        " data during an SoC power-down mode.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpgpr2
    },
    {
        "LPGPR3",
        "The SNVS_LP General Purpose Register is a 256-bit read/write register "
        "located in SNVS_LP, which can be used by any application for retaining"
        " data during an SoC power-down mode.",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpgpr3
    },
    {
        "LPGPR4",
        "The SNVS_LP General Purpose Register is a 256-bit read/write register "
        "located in SNVS_LP, which can be used by any application for retaining"
        " data during an SoC power-down mode.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpgpr4
    },
    {
        "LPGPR5",
        "The SNVS_LP General Purpose Register is a 256-bit read/write register "
        "located in SNVS_LP, which can be used by any application for retaining"
        " data during an SoC power-down mode.",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpgpr5
    },
    {
        "LPGPR6",
        "The SNVS_LP General Purpose Register is a 256-bit read/write register "
        "located in SNVS_LP, which can be used by any application for retaining"
        " data during an SoC power-down mode.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpgpr6
    },
    {
        "LPGPR7",
        "The SNVS_LP General Purpose Register is a 256-bit read/write register "
        "located in SNVS_LP, which can be used by any application for retaining"
        " data during an SoC power-down mode.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpgpr7
    },
    {
        "HPVIDR1",
        "The SNVS_HP Version ID Register 1 is a read-only register that contain"
        "s the current version of the SNVS.",
        4, // Width in bytes
        0x00000bf8, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_snvs_hpvidr1
    },
    {
        "HPVIDR2",
        "The SNVS_HP Version ID Register 2 is a read-only register that indicat"
        "es the current version of the SNVS.",
        4, // Width in bytes
        0x00000bfc, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_snvs_hpvidr2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LPTPM_16B_6CH
#endif

// Bitfields in register LPTPM_16B_6CH_SC.
static const field_t hw_lptpm_16b_6ch_sc[] =
{
    {
        "PS",
        "Selects one of 8 division factors for the clock mode selected by CMOD.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMOD",
        "Selects the TPM counter clock modes.",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPWMS",
        "Selects CPWM mode.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOIE",
        "Enables TPM overflow interrupts.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOF",
        "Set by hardware when the TPM counter equals the value in the MOD regis"
        "ter and increments.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA",
        "Enables DMA transfers for the overflow flag.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_CNT.
static const field_t hw_lptpm_16b_6ch_cnt[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_MOD.
static const field_t hw_lptpm_16b_6ch_mod[] =
{
    {
        "MOD",
        "This field must be written with single 16-bit or 32-bit access.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_C0SC.
static const field_t hw_lptpm_16b_6ch_c0sc[] =
{
    {
        "DMA",
        "Enables DMA transfers for the channel.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELSA",
        "The functionality of ELSB and ELSA depends on the channel mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELSB",
        "The functionality of ELSB and ELSA depends on the channel mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSA",
        "Used for further selections in the channel logic.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSB",
        "Used for further selections in the channel logic.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHIE",
        "Enables channel interrupts.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHF",
        "Set by hardware when an event occurs on the channel.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_C0V.
static const field_t hw_lptpm_16b_6ch_c0v[] =
{
    {
        "VAL",
        "Captured TPM counter value of the input modes or the match value for t"
        "he output modes.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_C1SC.
static const field_t hw_lptpm_16b_6ch_c1sc[] =
{
    {
        "DMA",
        "Enables DMA transfers for the channel.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELSA",
        "The functionality of ELSB and ELSA depends on the channel mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELSB",
        "The functionality of ELSB and ELSA depends on the channel mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSA",
        "Used for further selections in the channel logic.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSB",
        "Used for further selections in the channel logic.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHIE",
        "Enables channel interrupts.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHF",
        "Set by hardware when an event occurs on the channel.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_C1V.
static const field_t hw_lptpm_16b_6ch_c1v[] =
{
    {
        "VAL",
        "Captured TPM counter value of the input modes or the match value for t"
        "he output modes.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_C2SC.
static const field_t hw_lptpm_16b_6ch_c2sc[] =
{
    {
        "DMA",
        "Enables DMA transfers for the channel.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELSA",
        "The functionality of ELSB and ELSA depends on the channel mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELSB",
        "The functionality of ELSB and ELSA depends on the channel mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSA",
        "Used for further selections in the channel logic.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSB",
        "Used for further selections in the channel logic.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHIE",
        "Enables channel interrupts.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHF",
        "Set by hardware when an event occurs on the channel.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_C2V.
static const field_t hw_lptpm_16b_6ch_c2v[] =
{
    {
        "VAL",
        "Captured TPM counter value of the input modes or the match value for t"
        "he output modes.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_C3SC.
static const field_t hw_lptpm_16b_6ch_c3sc[] =
{
    {
        "DMA",
        "Enables DMA transfers for the channel.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELSA",
        "The functionality of ELSB and ELSA depends on the channel mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELSB",
        "The functionality of ELSB and ELSA depends on the channel mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSA",
        "Used for further selections in the channel logic.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSB",
        "Used for further selections in the channel logic.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHIE",
        "Enables channel interrupts.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHF",
        "Set by hardware when an event occurs on the channel.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_C3V.
static const field_t hw_lptpm_16b_6ch_c3v[] =
{
    {
        "VAL",
        "Captured TPM counter value of the input modes or the match value for t"
        "he output modes.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_C4SC.
static const field_t hw_lptpm_16b_6ch_c4sc[] =
{
    {
        "DMA",
        "Enables DMA transfers for the channel.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELSA",
        "The functionality of ELSB and ELSA depends on the channel mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELSB",
        "The functionality of ELSB and ELSA depends on the channel mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSA",
        "Used for further selections in the channel logic.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSB",
        "Used for further selections in the channel logic.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHIE",
        "Enables channel interrupts.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHF",
        "Set by hardware when an event occurs on the channel.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_C4V.
static const field_t hw_lptpm_16b_6ch_c4v[] =
{
    {
        "VAL",
        "Captured TPM counter value of the input modes or the match value for t"
        "he output modes.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_C5SC.
static const field_t hw_lptpm_16b_6ch_c5sc[] =
{
    {
        "DMA",
        "Enables DMA transfers for the channel.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELSA",
        "The functionality of ELSB and ELSA depends on the channel mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELSB",
        "The functionality of ELSB and ELSA depends on the channel mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSA",
        "Used for further selections in the channel logic.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSB",
        "Used for further selections in the channel logic.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHIE",
        "Enables channel interrupts.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHF",
        "Set by hardware when an event occurs on the channel.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_C5V.
static const field_t hw_lptpm_16b_6ch_c5v[] =
{
    {
        "VAL",
        "Captured TPM counter value of the input modes or the match value for t"
        "he output modes.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_STATUS.
static const field_t hw_lptpm_16b_6ch_status[] =
{
    {
        "CH0F",
        "See the register description.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1F",
        "See the register description.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2F",
        "See the register description.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3F",
        "See the register description.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4F",
        "See the register description.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5F",
        "See the register description.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOF",
        "See register description",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_CONF.
static const field_t hw_lptpm_16b_6ch_conf[] =
{
    {
        "DOZEEN",
        "Configures the TPM behavior in wait mode.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGMODE",
        "Configures the TPM behavior in debug mode.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GTBSYNC",
        "When enabled, the TPM counter is synchronized to the global time base.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GTBEEN",
        "Configures the TPM to use an externally generated global time base cou"
        "nter.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSOT",
        "When set, the TPM counter will pause incrementing when it is enabled u"
        "ntil a rising edge on the selected trigger input is detected.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSOO",
        "When set, the TPM counter will pause incrementing once the counter equ"
        "als the MOD value and increments (this also sets the TOF).",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CROT",
        "When set, the TPM counter will reload with zero (and set PWM outputs t"
        "o their reload state) when a rising edge is detected on the selected t"
        "rigger input.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPOT",
        "When enabled, the counter will pause incrementing while the trigger re"
        "mains asserted (level sensitive).",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGPOL",
        "Selects the polarity of the external trigger source.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSRC",
        "Selects between internal (channel pin input capture) or external trigg"
        "er sources.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSEL",
        "Selects the input trigger to use for starting, reloading and/or pausin"
        "g the counter.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_QDCTRL.
static const field_t hw_lptpm_16b_6ch_qdctrl[] =
{
    {
        "QUADEN",
        "Enables the quadrature decoder mode.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOFDIR",
        "Indicates if the TOF bit was set on the top or the bottom of counting.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "QUADIR",
        "Indicates the counting direction.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "QUADMODE",
        "Selects the encoding mode used in the quadrature decoder mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_FILTER.
static const field_t hw_lptpm_16b_6ch_filter[] =
{
    {
        "CH0FVAL",
        "Sets the filter value for the channel 0 input when configured for inpu"
        "t capture or software compare modes.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1FVAL",
        "Sets the filter value for the channel 1 input when configured for inpu"
        "t capture or software compare modes.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2FVAL",
        "Sets the filter value for the channel 2 input when configured for inpu"
        "t capture or software compare modes.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3FVAL",
        "Sets the filter value for the channel 3 input when configured for inpu"
        "t capture or software compare modes.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4FVAL",
        "Sets the filter value for the channel 4 input when configured for inpu"
        "t capture or software compare modes.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5FVAL",
        "Sets the filter value for the channel 5 input when configured for inpu"
        "t capture or software compare modes.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_COMBINE.
static const field_t hw_lptpm_16b_6ch_combine[] =
{
    {
        "COMBINE0",
        "Enables the combine feature for channels 0 and 1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMSWAP0",
        "When set in combine mode, the even channel is used for the input captu"
        "re and 1st compare, the odd channel is used for the 2nd compare.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMBINE1",
        "Enables the combine feature for channels 2 and 3.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMSWAP1",
        "When set in combine mode, the odd channel is used for the input captur"
        "e and 1st compare, the even channel is used for the 2nd compare.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMBINE2",
        "Enables the combine feature for channels 2 and 3.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMSWAP2",
        "When set in combine mode, the even channel is used for the input captu"
        "re and 1st compare, the odd channel is used for the 2nd compare.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_POL.
static const field_t hw_lptpm_16b_6ch_pol[] =
{
    {
        "POL0",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL1",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL2",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL3",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL4",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL5",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_TRIG.
static const field_t hw_lptpm_16b_6ch_trig[] =
{
    {
        "TRIG0",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG1",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG2",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG3",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG4",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG5",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_VERID.
static const field_t hw_lptpm_16b_6ch_verid[] =
{
    {
        "FEATURE",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read only field returns the minor version number for the module s"
        "pecification.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read only field returns the major version number for the module s"
        "pecification.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_PARAM.
static const field_t hw_lptpm_16b_6ch_param[] =
{
    {
        "CHAN",
        "Number of timer channels implemented.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIG",
        "Number of trigger inputs implemented.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WIDTH",
        "Width of the counter and timer channels.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_16B_6CH_GLOBAL.
static const field_t hw_lptpm_16b_6ch_global[] =
{
    {
        "RST",
        "Reset all internal logic and registers, except the Global Register.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a LPTPM_16B_6CH module.
static const reg_t hw_lptpm_16b_6ch[] =
{
    {
        "SC",
        "SC contains the overflow status flag and control bits used to configur"
        "e the interrupt enable, module configuration and prescaler factor.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_lptpm_16b_6ch_sc
    },
    {
        "CNT",
        "The CNT register contains the TPM counter value.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lptpm_16b_6ch_cnt
    },
    {
        "MOD",
        "The Modulo register contains the modulo value for the TPM counter.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lptpm_16b_6ch_mod
    },
    {
        "C0SC",
        "CnSC contains the channel-interrupt-status flag and control bits used "
        "to configure the interrupt enable, channel configuration, and pin func"
        "tion.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_lptpm_16b_6ch_c0sc
    },
    {
        "C0V",
        "These registers contain the captured TPM counter value for the input m"
        "odes or the match value for the output modes.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lptpm_16b_6ch_c0v
    },
    {
        "C1SC",
        "CnSC contains the channel-interrupt-status flag and control bits used "
        "to configure the interrupt enable, channel configuration, and pin func"
        "tion.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_lptpm_16b_6ch_c1sc
    },
    {
        "C1V",
        "These registers contain the captured TPM counter value for the input m"
        "odes or the match value for the output modes.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lptpm_16b_6ch_c1v
    },
    {
        "C2SC",
        "CnSC contains the channel-interrupt-status flag and control bits used "
        "to configure the interrupt enable, channel configuration, and pin func"
        "tion.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_lptpm_16b_6ch_c2sc
    },
    {
        "C2V",
        "These registers contain the captured TPM counter value for the input m"
        "odes or the match value for the output modes.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lptpm_16b_6ch_c2v
    },
    {
        "C3SC",
        "CnSC contains the channel-interrupt-status flag and control bits used "
        "to configure the interrupt enable, channel configuration, and pin func"
        "tion.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_lptpm_16b_6ch_c3sc
    },
    {
        "C3V",
        "These registers contain the captured TPM counter value for the input m"
        "odes or the match value for the output modes.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lptpm_16b_6ch_c3v
    },
    {
        "C4SC",
        "CnSC contains the channel-interrupt-status flag and control bits used "
        "to configure the interrupt enable, channel configuration, and pin func"
        "tion.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_lptpm_16b_6ch_c4sc
    },
    {
        "C4V",
        "These registers contain the captured TPM counter value for the input m"
        "odes or the match value for the output modes.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lptpm_16b_6ch_c4v
    },
    {
        "C5SC",
        "CnSC contains the channel-interrupt-status flag and control bits used "
        "to configure the interrupt enable, channel configuration, and pin func"
        "tion.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_lptpm_16b_6ch_c5sc
    },
    {
        "C5V",
        "These registers contain the captured TPM counter value for the input m"
        "odes or the match value for the output modes.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lptpm_16b_6ch_c5v
    },
    {
        "STATUS",
        "The STATUS register contains a copy of the status flag, CnSC[CHnF] for"
        " each TPM channel, as well as SC[TOF], for software convenience.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_lptpm_16b_6ch_status
    },
    {
        "CONF",
        "This register selects the behavior in debug and wait modes and the use"
        " of an external global time base.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_lptpm_16b_6ch_conf
    },
    {
        "QDCTRL",
        "This register has the control and status bits for the quadrature decod"
        "er mode.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lptpm_16b_6ch_qdctrl
    },
    {
        "FILTER",
        "This register selects the filter value of the channel inputs, and an a"
        "dditional output delay value for the channel outputs.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_lptpm_16b_6ch_filter
    },
    {
        "COMBINE",
        "This register contains the control bits used to configure the combine "
        "channel modes for each pair of channels (n) and (n+1), where n is all "
        "the even numbered channels.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_lptpm_16b_6ch_combine
    },
    {
        "POL",
        "This register defines the input and output polarity of each of the cha"
        "nnels.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_lptpm_16b_6ch_pol
    },
    {
        "TRIG",
        "In input capture mode, configures the trigger input that is used by th"
        "e channel to capture the counter value.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_lptpm_16b_6ch_trig
    },
    {
        "VERID",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_lptpm_16b_6ch_verid
    },
    {
        "PARAM",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_lptpm_16b_6ch_param
    },
    {
        "GLOBAL",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lptpm_16b_6ch_global
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LPTPM_32B_2CH
#endif

// Bitfields in register LPTPM_32B_2CH_SC.
static const field_t hw_lptpm_32b_2ch_sc[] =
{
    {
        "PS",
        "Selects one of 8 division factors for the clock mode selected by CMOD.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMOD",
        "Selects the TPM counter clock modes.",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPWMS",
        "Selects CPWM mode.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOIE",
        "Enables TPM overflow interrupts.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOF",
        "Set by hardware when the TPM counter equals the value in the MOD regis"
        "ter and increments.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA",
        "Enables DMA transfers for the overflow flag.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_32B_2CH_CNT.
static const field_t hw_lptpm_32b_2ch_cnt[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_32B_2CH_MOD.
static const field_t hw_lptpm_32b_2ch_mod[] =
{
    {
        "MOD",
        "This field must be written with single 16-bit or 32-bit access.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_32B_2CH_C0SC.
static const field_t hw_lptpm_32b_2ch_c0sc[] =
{
    {
        "DMA",
        "Enables DMA transfers for the channel.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELSA",
        "The functionality of ELSB and ELSA depends on the channel mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELSB",
        "The functionality of ELSB and ELSA depends on the channel mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSA",
        "Used for further selections in the channel logic.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSB",
        "Used for further selections in the channel logic.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHIE",
        "Enables channel interrupts.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHF",
        "Set by hardware when an event occurs on the channel.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_32B_2CH_C0V.
static const field_t hw_lptpm_32b_2ch_c0v[] =
{
    {
        "VAL",
        "Captured TPM counter value of the input modes or the match value for t"
        "he output modes.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_32B_2CH_C1SC.
static const field_t hw_lptpm_32b_2ch_c1sc[] =
{
    {
        "DMA",
        "Enables DMA transfers for the channel.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELSA",
        "The functionality of ELSB and ELSA depends on the channel mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ELSB",
        "The functionality of ELSB and ELSA depends on the channel mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSA",
        "Used for further selections in the channel logic.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSB",
        "Used for further selections in the channel logic.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHIE",
        "Enables channel interrupts.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHF",
        "Set by hardware when an event occurs on the channel.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_32B_2CH_C1V.
static const field_t hw_lptpm_32b_2ch_c1v[] =
{
    {
        "VAL",
        "Captured TPM counter value of the input modes or the match value for t"
        "he output modes.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_32B_2CH_STATUS.
static const field_t hw_lptpm_32b_2ch_status[] =
{
    {
        "CH0F",
        "See the register description.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1F",
        "See the register description.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOF",
        "See register description",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_32B_2CH_CONF.
static const field_t hw_lptpm_32b_2ch_conf[] =
{
    {
        "DOZEEN",
        "Configures the TPM behavior in wait mode.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGMODE",
        "Configures the TPM behavior in debug mode.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GTBSYNC",
        "When enabled, the TPM counter is synchronized to the global time base.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GTBEEN",
        "Configures the TPM to use an externally generated global time base cou"
        "nter.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSOT",
        "When set, the TPM counter will pause incrementing when it is enabled u"
        "ntil a rising edge on the selected trigger input is detected.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSOO",
        "When set, the TPM counter will pause incrementing once the counter equ"
        "als the MOD value and increments (this also sets the TOF).",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CROT",
        "When set, the TPM counter will reload with zero (and set PWM outputs t"
        "o their reload state) when a rising edge is detected on the selected t"
        "rigger input.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPOT",
        "When enabled, the counter will pause incrementing while the trigger re"
        "mains asserted (level sensitive).",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGPOL",
        "Selects the polarity of the external trigger source.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSRC",
        "Selects between internal (channel pin input capture) or external trigg"
        "er sources.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRGSEL",
        "Selects the input trigger to use for starting, reloading and/or pausin"
        "g the counter.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_32B_2CH_QDCTRL.
static const field_t hw_lptpm_32b_2ch_qdctrl[] =
{
    {
        "QUADEN",
        "Enables the quadrature decoder mode.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOFDIR",
        "Indicates if the TOF bit was set on the top or the bottom of counting.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "QUADIR",
        "Indicates the counting direction.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "QUADMODE",
        "Selects the encoding mode used in the quadrature decoder mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_32B_2CH_FILTER.
static const field_t hw_lptpm_32b_2ch_filter[] =
{
    {
        "CH0FVAL",
        "Sets the filter value for the channel 0 input when configured for inpu"
        "t capture or software compare modes.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1FVAL",
        "Sets the filter value for the channel 1 input when configured for inpu"
        "t capture or software compare modes.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_32B_2CH_COMBINE.
static const field_t hw_lptpm_32b_2ch_combine[] =
{
    {
        "COMBINE0",
        "Enables the combine feature for channels 0 and 1.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMSWAP0",
        "When set in combine mode, the even channel is used for the input captu"
        "re and 1st compare, the odd channel is used for the 2nd compare.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_32B_2CH_POL.
static const field_t hw_lptpm_32b_2ch_pol[] =
{
    {
        "POL0",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POL1",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_32B_2CH_TRIG.
static const field_t hw_lptpm_32b_2ch_trig[] =
{
    {
        "TRIG0",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIG1",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_32B_2CH_VERID.
static const field_t hw_lptpm_32b_2ch_verid[] =
{
    {
        "FEATURE",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "This read only field returns the minor version number for the module s"
        "pecification.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "This read only field returns the major version number for the module s"
        "pecification.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_32B_2CH_PARAM.
static const field_t hw_lptpm_32b_2ch_param[] =
{
    {
        "CHAN",
        "Number of timer channels implemented.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIG",
        "Number of trigger inputs implemented.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WIDTH",
        "Width of the counter and timer channels.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LPTPM_32B_2CH_GLOBAL.
static const field_t hw_lptpm_32b_2ch_global[] =
{
    {
        "RST",
        "Reset all internal logic and registers, except the Global Register.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a LPTPM_32B_2CH module.
static const reg_t hw_lptpm_32b_2ch[] =
{
    {
        "SC",
        "SC contains the overflow status flag and control bits used to configur"
        "e the interrupt enable, module configuration and prescaler factor.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_lptpm_32b_2ch_sc
    },
    {
        "CNT",
        "The CNT register contains the TPM counter value.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lptpm_32b_2ch_cnt
    },
    {
        "MOD",
        "The Modulo register contains the modulo value for the TPM counter.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lptpm_32b_2ch_mod
    },
    {
        "C0SC",
        "CnSC contains the channel-interrupt-status flag and control bits used "
        "to configure the interrupt enable, channel configuration, and pin func"
        "tion.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_lptpm_32b_2ch_c0sc
    },
    {
        "C0V",
        "These registers contain the captured TPM counter value for the input m"
        "odes or the match value for the output modes.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lptpm_32b_2ch_c0v
    },
    {
        "C1SC",
        "CnSC contains the channel-interrupt-status flag and control bits used "
        "to configure the interrupt enable, channel configuration, and pin func"
        "tion.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_lptpm_32b_2ch_c1sc
    },
    {
        "C1V",
        "These registers contain the captured TPM counter value for the input m"
        "odes or the match value for the output modes.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lptpm_32b_2ch_c1v
    },
    {
        "STATUS",
        "The STATUS register contains a copy of the status flag, CnSC[CHnF] for"
        " each TPM channel, as well as SC[TOF], for software convenience.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_lptpm_32b_2ch_status
    },
    {
        "CONF",
        "This register selects the behavior in debug and wait modes and the use"
        " of an external global time base.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_lptpm_32b_2ch_conf
    },
    {
        "QDCTRL",
        "This register has the control and status bits for the quadrature decod"
        "er mode.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lptpm_32b_2ch_qdctrl
    },
    {
        "FILTER",
        "This register selects the filter value of the channel inputs, and an a"
        "dditional output delay value for the channel outputs.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lptpm_32b_2ch_filter
    },
    {
        "COMBINE",
        "This register contains the control bits used to configure the combine "
        "channel modes for each pair of channels (n) and (n+1), where n is all "
        "the even numbered channels.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lptpm_32b_2ch_combine
    },
    {
        "POL",
        "This register defines the input and output polarity of each of the cha"
        "nnels.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lptpm_32b_2ch_pol
    },
    {
        "TRIG",
        "In input capture mode, configures the trigger input that is used by th"
        "e channel to capture the counter value.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lptpm_32b_2ch_trig
    },
    {
        "VERID",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_lptpm_32b_2ch_verid
    },
    {
        "PARAM",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_lptpm_32b_2ch_param
    },
    {
        "GLOBAL",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lptpm_32b_2ch_global
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark TRGMUX0
#endif

// Bitfields in register TRGMUX0_DMAMUX0_A.
static const field_t hw_trgmux0_dmamux0_a[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL2",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL3",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 3.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_DMAMUX0_B.
static const field_t hw_trgmux0_dmamux0_b[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL2",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL3",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 3.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_LPIT0.
static const field_t hw_trgmux0_lpit0[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL2",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL3",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 3.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_TPM0.
static const field_t hw_trgmux0_tpm0[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL2",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_TPM1.
static const field_t hw_trgmux0_tpm1[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL2",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_TPM2.
static const field_t hw_trgmux0_tpm2[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL2",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_TPM3.
static const field_t hw_trgmux0_tpm3[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL2",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_ADC0.
static const field_t hw_trgmux0_adc0[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_ADC1.
static const field_t hw_trgmux0_adc1[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_CMP0.
static const field_t hw_trgmux0_cmp0[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_CMP1.
static const field_t hw_trgmux0_cmp1[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_DAC0.
static const field_t hw_trgmux0_dac0[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_DAC1.
static const field_t hw_trgmux0_dac1[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_LPUART0.
static const field_t hw_trgmux0_lpuart0[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_LPUART1.
static const field_t hw_trgmux0_lpuart1[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_LPUART2.
static const field_t hw_trgmux0_lpuart2[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_LPUART3.
static const field_t hw_trgmux0_lpuart3[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_LPI2C0.
static const field_t hw_trgmux0_lpi2c0[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_LPI2C1.
static const field_t hw_trgmux0_lpi2c1[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_LPI2C2.
static const field_t hw_trgmux0_lpi2c2[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_LPI2C3.
static const field_t hw_trgmux0_lpi2c3[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_LPSPI0.
static const field_t hw_trgmux0_lpspi0[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_LPSPI1.
static const field_t hw_trgmux0_lpspi1[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX0_FLEXIO0.
static const field_t hw_trgmux0_flexio0[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL2",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 2.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL3",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 3.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a TRGMUX0 module.
static const reg_t hw_trgmux0[] =
{
    {
        "DMAMUX0_A",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_trgmux0_dmamux0_a
    },
    {
        "DMAMUX0_B",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_trgmux0_dmamux0_b
    },
    {
        "LPIT0",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_trgmux0_lpit0
    },
    {
        "TPM0",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_trgmux0_tpm0
    },
    {
        "TPM1",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_trgmux0_tpm1
    },
    {
        "TPM2",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_trgmux0_tpm2
    },
    {
        "TPM3",
        "TRGMUX Register",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_trgmux0_tpm3
    },
    {
        "ADC0",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_trgmux0_adc0
    },
    {
        "ADC1",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_trgmux0_adc1
    },
    {
        "CMP0",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux0_cmp0
    },
    {
        "CMP1",
        "TRGMUX Register",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux0_cmp1
    },
    {
        "DAC0",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux0_dac0
    },
    {
        "DAC1",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux0_dac1
    },
    {
        "LPUART0",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux0_lpuart0
    },
    {
        "LPUART1",
        "TRGMUX Register",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux0_lpuart1
    },
    {
        "LPUART2",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux0_lpuart2
    },
    {
        "LPUART3",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux0_lpuart3
    },
    {
        "LPI2C0",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux0_lpi2c0
    },
    {
        "LPI2C1",
        "TRGMUX Register",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux0_lpi2c1
    },
    {
        "LPI2C2",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux0_lpi2c2
    },
    {
        "LPI2C3",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux0_lpi2c3
    },
    {
        "LPSPI0",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux0_lpspi0
    },
    {
        "LPSPI1",
        "TRGMUX Register",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux0_lpspi1
    },
    {
        "FLEXIO0",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_trgmux0_flexio0
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark TRGMUX1
#endif

// Bitfields in register TRGMUX1_DMAMUX1_A.
static const field_t hw_trgmux1_dmamux1_a[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL2",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 2.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL3",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 3.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_DMAMUX1_B.
static const field_t hw_trgmux1_dmamux1_b[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL2",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 2.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL3",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 3.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_TPM4.
static const field_t hw_trgmux1_tpm4[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL2",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 2.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_TPM5.
static const field_t hw_trgmux1_tpm5[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL2",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 2.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_TPM6.
static const field_t hw_trgmux1_tpm6[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL2",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 2.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_TPM7.
static const field_t hw_trgmux1_tpm7[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL2",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 2.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_LPUART4.
static const field_t hw_trgmux1_lpuart4[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_LPUART5.
static const field_t hw_trgmux1_lpuart5[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_LPUART6.
static const field_t hw_trgmux1_lpuart6[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_LPUART7.
static const field_t hw_trgmux1_lpuart7[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_LPI2C4.
static const field_t hw_trgmux1_lpi2c4[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_LPI2C5.
static const field_t hw_trgmux1_lpi2c5[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_LPI2C6.
static const field_t hw_trgmux1_lpi2c6[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_LPI2C7.
static const field_t hw_trgmux1_lpi2c7[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_LPSPI2.
static const field_t hw_trgmux1_lpspi2[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_LPSPI3.
static const field_t hw_trgmux1_lpspi3[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_FLEXIO1.
static const field_t hw_trgmux1_flexio1[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL2",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 2.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL3",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 3.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRGMUX1_LPIT1.
static const field_t hw_trgmux1_lpit1[] =
{
    {
        "SEL0",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 0.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL1",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 1.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL2",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 2.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL3",
        "This read/write bit field is used to configure the MUX select for peri"
        "pheral trigger input 3.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK",
        "This bit shows whether the register can be written or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a TRGMUX1 module.
static const reg_t hw_trgmux1[] =
{
    {
        "DMAMUX1_A",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_trgmux1_dmamux1_a
    },
    {
        "DMAMUX1_B",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_trgmux1_dmamux1_b
    },
    {
        "TPM4",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_trgmux1_tpm4
    },
    {
        "TPM5",
        "TRGMUX Register",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_trgmux1_tpm5
    },
    {
        "TPM6",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_trgmux1_tpm6
    },
    {
        "TPM7",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_trgmux1_tpm7
    },
    {
        "LPUART4",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux1_lpuart4
    },
    {
        "LPUART5",
        "TRGMUX Register",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux1_lpuart5
    },
    {
        "LPUART6",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux1_lpuart6
    },
    {
        "LPUART7",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux1_lpuart7
    },
    {
        "LPI2C4",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux1_lpi2c4
    },
    {
        "LPI2C5",
        "TRGMUX Register",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux1_lpi2c5
    },
    {
        "LPI2C6",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux1_lpi2c6
    },
    {
        "LPI2C7",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux1_lpi2c7
    },
    {
        "LPSPI2",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux1_lpspi2
    },
    {
        "LPSPI3",
        "TRGMUX Register",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trgmux1_lpspi3
    },
    {
        "FLEXIO1",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_trgmux1_flexio1
    },
    {
        "LPIT1",
        "TRGMUX Register",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_trgmux1_lpit1
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark TRNG
#endif

// Bitfields in register TRNG_MCTL.
static const field_t hw_trng_mctl[] =
{
    {
        "SAMP_MODE",
        "Sample Mode.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_DIV",
        "Oscillator Divide.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNUSED4",
        "This bit is unused.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRNG_ACC",
        "TRNG Access Mode.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST_DEF",
        "Reset Defaults.",
        6, // LSB
        6, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FOR_SCLK",
        "Force System Clock.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCT_FAIL",
        "Read only: Frequency Count Fail.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FCT_VAL",
        "Read only: Frequency Count Valid.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENT_VAL",
        "Read only: Entropy Valid.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TST_OUT",
        "Read only: Test point inside ring oscillator.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR",
        "Read: Error status.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTOP_OK",
        "TRNG_OK_TO_STOP.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRGM",
        "Programming Mode Select.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_INT_STATUS.
static const field_t hw_trng_int_status[] =
{
    {
        "HW_ERR",
        "Read: Error status.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENT_VAL",
        "Read only: Entropy Valid.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FRQ_CT_FAIL",
        "Read only: Frequency Count Fail.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_INT_CTRL.
static const field_t hw_trng_int_ctrl[] =
{
    {
        "HW_ERR",
        "Bit position that can be cleared if corresponding bit of INT_STATUS ha"
        "s been asserted.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENT_VAL",
        "Same behavior as bit 0 above.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRQ_CT_FAIL",
        "Same behavior as bit 0 above.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNUSED",
        "Reserved but writeable.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_INT_MASK.
static const field_t hw_trng_int_mask[] =
{
    {
        "HW_ERR",
        "Bit position that can be cleared if corresponding bit of INT_STATUS ha"
        "s been asserted.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENT_VAL",
        "Same behavior as bit 0 above.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRQ_CT_FAIL",
        "Same behavior as bit 0 above.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_VID1.
static const field_t hw_trng_vid1[] =
{
    {
        "MIN_REV",
        "Shows the IP's Minor revision of the TRNG.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJ_REV",
        "Shows the IP's Major revision of the TRNG.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IP_ID",
        "Shows the IP ID.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_VID2.
static const field_t hw_trng_vid2[] =
{
    {
        "CONFIG_OPT",
        "Shows the IP's Configuaration options for the TRNG.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ECO_REV",
        "Shows the IP's ECO revision of the TRNG.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INTG_OPT",
        "Shows the integration options for the TRNG.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERA",
        "Shows the compile options for the TRNG.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SEC_CFG.
static const field_t hw_trng_sec_cfg[] =
{
    {
        "SH0",
        "Reserved.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NO_PRGM",
        "If set, the TRNG registers cannot be programmed.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SK_VAL",
        "Reserved.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SCMISC.
static const field_t hw_trng_scmisc[] =
{
    {
        "LRUN_MAX",
        "LONG RUN MAX LIMIT.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTY_CT",
        "RETRY COUNT.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_PKRRNG.
static const field_t hw_trng_pkrrng[] =
{
    {
        "PKR_RNG",
        "Poker Range.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_PKRMAX.
static const field_t hw_trng_pkrmax[] =
{
    {
        "PKR_MAX",
        "During the TRNG Statistical Checks, a \"Poker Test\" is run which requ"
        "ires a maximum and minimum limit.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_PKRSQ.
static const field_t hw_trng_pkrsq[] =
{
    {
        "PKR_SQ",
        "During the TRNG Statistical Checks, a \"Poker Test\" is run which star"
        "ts with the value PKRMAX[PKR_MAX].",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SDCTL.
static const field_t hw_trng_sdctl[] =
{
    {
        "SAMP_SIZE",
        "Sample Size.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENT_DLY",
        "Entropy Delay.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SBLIM.
static const field_t hw_trng_sblim[] =
{
    {
        "SB_LIM",
        "Sparse Bit Limit.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_TOTSAM.
static const field_t hw_trng_totsam[] =
{
    {
        "TOT_SAM",
        "Total Samples.",
        0, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_FRQMIN.
static const field_t hw_trng_frqmin[] =
{
    {
        "FRQ_MIN",
        "Frequency Count Minimum Limit.",
        0, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_FRQMAX.
static const field_t hw_trng_frqmax[] =
{
    {
        "FRQ_MAX",
        "Frequency Counter Maximum Limit.",
        0, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_FRQCNT.
static const field_t hw_trng_frqcnt[] =
{
    {
        "FRQ_CT",
        "Frequency Count.",
        0, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SCML.
static const field_t hw_trng_scml[] =
{
    {
        "MONO_MAX",
        "Monobit Maximum Limit.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MONO_RNG",
        "Monobit Range.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SCMC.
static const field_t hw_trng_scmc[] =
{
    {
        "MONO_CT",
        "Monobit Count.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SCR1L.
static const field_t hw_trng_scr1l[] =
{
    {
        "RUN1_MAX",
        "Run Length 1 Maximum Limit.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUN1_RNG",
        "Run Length 1 Range.",
        16, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SCR1C.
static const field_t hw_trng_scr1c[] =
{
    {
        "R1_0_CT",
        "Runs of Zero, Length 1 Count.",
        0, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "R1_1_CT",
        "Runs of One, Length 1 Count.",
        16, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SCR2L.
static const field_t hw_trng_scr2l[] =
{
    {
        "RUN2_MAX",
        "Run Length 2 Maximum Limit.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUN2_RNG",
        "Run Length 2 Range.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SCR2C.
static const field_t hw_trng_scr2c[] =
{
    {
        "R2_0_CT",
        "Runs of Zero, Length 2 Count.",
        0, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "R2_1_CT",
        "Runs of One, Length 2 Count.",
        16, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SCR3L.
static const field_t hw_trng_scr3l[] =
{
    {
        "RUN3_MAX",
        "Run Length 3 Maximum Limit.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUN3_RNG",
        "Run Length 3 Range.",
        16, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SCR3C.
static const field_t hw_trng_scr3c[] =
{
    {
        "R3_0_CT",
        "Runs of Zeroes, Length 3 Count.",
        0, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "R3_1_CT",
        "Runs of Ones, Length 3 Count.",
        16, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SCR4L.
static const field_t hw_trng_scr4l[] =
{
    {
        "RUN4_MAX",
        "Run Length 4 Maximum Limit.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUN4_RNG",
        "Run Length 4 Range.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SCR4C.
static const field_t hw_trng_scr4c[] =
{
    {
        "R4_0_CT",
        "Runs of Zero, Length 4 Count.",
        0, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "R4_1_CT",
        "Runs of One, Length 4 Count.",
        16, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SCR5L.
static const field_t hw_trng_scr5l[] =
{
    {
        "RUN5_MAX",
        "Run Length 5 Maximum Limit.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUN5_RNG",
        "Run Length 5 Range.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SCR5C.
static const field_t hw_trng_scr5c[] =
{
    {
        "R5_0_CT",
        "Runs of Zero, Length 5 Count.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "R5_1_CT",
        "Runs of One, Length 5 Count.",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SCR6PL.
static const field_t hw_trng_scr6pl[] =
{
    {
        "RUN6P_MAX",
        "Run Length 6+ Maximum Limit.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUN6P_RNG",
        "Run Length 6+ Range.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_SCR6PC.
static const field_t hw_trng_scr6pc[] =
{
    {
        "R6P_0_CT",
        "Runs of Zero, Length 6+ Count.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "R6P_1_CT",
        "Runs of One, Length 6+ Count.",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_STATUS.
static const field_t hw_trng_status[] =
{
    {
        "TF1BR0",
        "Test Fail, 1-Bit Run, Sampling 0s.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TF1BR1",
        "Test Fail, 1-Bit Run, Sampling 1s.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TF2BR0",
        "Test Fail, 2-Bit Run, Sampling 0s.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TF2BR1",
        "Test Fail, 2-Bit Run, Sampling 1s.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TF3BR0",
        "Test Fail, 3-Bit Run, Sampling 0s.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TF3BR1",
        "Test Fail, 3-Bit Run, Sampling 1s.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TF4BR0",
        "Test Fail, 4-Bit Run, Sampling 0s.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TF4BR1",
        "Test Fail, 4-Bit Run, Sampling 1s.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TF5BR0",
        "Test Fail, 5-Bit Run, Sampling 0s.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TF5BR1",
        "Test Fail, 5-Bit Run, Sampling 1s.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TF6PBR0",
        "Test Fail, 6 Plus Bit Run, Sampling 0s.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TF6PBR1",
        "Test Fail, 6 Plus Bit Run, Sampling 1s.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFSB",
        "Test Fail, Sparse Bit.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFLR",
        "Test Fail, Long Run.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFP",
        "Test Fail, Poker.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TFMB",
        "Test Fail, Mono Bit.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RETRY_CT",
        "RETRY COUNT.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_ENT0.
static const field_t hw_trng_ent0[] =
{
    {
        "ENT",
        "Entropy Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_ENT1.
static const field_t hw_trng_ent1[] =
{
    {
        "ENT",
        "Entropy Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_ENT2.
static const field_t hw_trng_ent2[] =
{
    {
        "ENT",
        "Entropy Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_ENT3.
static const field_t hw_trng_ent3[] =
{
    {
        "ENT",
        "Entropy Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_ENT4.
static const field_t hw_trng_ent4[] =
{
    {
        "ENT",
        "Entropy Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_ENT5.
static const field_t hw_trng_ent5[] =
{
    {
        "ENT",
        "Entropy Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_ENT6.
static const field_t hw_trng_ent6[] =
{
    {
        "ENT",
        "Entropy Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_ENT7.
static const field_t hw_trng_ent7[] =
{
    {
        "ENT",
        "Entropy Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_ENT8.
static const field_t hw_trng_ent8[] =
{
    {
        "ENT",
        "Entropy Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_ENT9.
static const field_t hw_trng_ent9[] =
{
    {
        "ENT",
        "Entropy Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_ENT10.
static const field_t hw_trng_ent10[] =
{
    {
        "ENT",
        "Entropy Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_ENT11.
static const field_t hw_trng_ent11[] =
{
    {
        "ENT",
        "Entropy Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_ENT12.
static const field_t hw_trng_ent12[] =
{
    {
        "ENT",
        "Entropy Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_ENT13.
static const field_t hw_trng_ent13[] =
{
    {
        "ENT",
        "Entropy Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_ENT14.
static const field_t hw_trng_ent14[] =
{
    {
        "ENT",
        "Entropy Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_ENT15.
static const field_t hw_trng_ent15[] =
{
    {
        "ENT",
        "Entropy Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_PKRCNT10.
static const field_t hw_trng_pkrcnt10[] =
{
    {
        "PKR_0_CT",
        "Poker 0h Count.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKR_1_CT",
        "Poker 1h Count.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_PKRCNT32.
static const field_t hw_trng_pkrcnt32[] =
{
    {
        "PKR_2_CT",
        "Poker 2h Count.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKR_3_CT",
        "Poker 3h Count.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_PKRCNT54.
static const field_t hw_trng_pkrcnt54[] =
{
    {
        "PKR_4_CT",
        "Poker 4h Count.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKR_5_CT",
        "Poker 5h Count.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_PKRCNT76.
static const field_t hw_trng_pkrcnt76[] =
{
    {
        "PKR_6_CT",
        "Poker 6h Count.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKR_7_CT",
        "Poker 7h Count.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_PKRCNT98.
static const field_t hw_trng_pkrcnt98[] =
{
    {
        "PKR_8_CT",
        "Poker 8h Count.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKR_9_CT",
        "Poker 9h Count.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_PKRCNTBA.
static const field_t hw_trng_pkrcntba[] =
{
    {
        "PKR_A_CT",
        "Poker Ah Count.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKR_B_CT",
        "Poker Bh Count.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_PKRCNTDC.
static const field_t hw_trng_pkrcntdc[] =
{
    {
        "PKR_C_CT",
        "Poker Ch Count.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKR_D_CT",
        "Poker Dh Count.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TRNG_PKRCNTFE.
static const field_t hw_trng_pkrcntfe[] =
{
    {
        "PKR_E_CT",
        "Poker Eh Count.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKR_F_CT",
        "Poker Fh Count.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a TRNG module.
static const reg_t hw_trng[] =
{
    {
        "MCTL",
        "This register is intended to be used for programming, configuring and "
        "testing the RNG.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_trng_mctl
    },
    {
        "INT_STATUS",
        "The Interrupt Status Register is a read register used to control and p"
        "rovide status for the (currently) three important interrupts that are "
        "generated by the TRNG.",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_trng_int_status
    },
    {
        "INT_CTRL",
        "The Interrupt Control Register is a read/write register used to contro"
        "l the status for the (currently) three important interrupts that are g"
        "enerated by the TRNG.",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_trng_int_ctrl
    },
    {
        "INT_MASK",
        "The Interrupt Mask Register is a read/write register used to disable/m"
        "ask the status reporting of the (currently) three important interrupts"
        " that are generated by the TRNG.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_trng_int_mask
    },
    {
        "VID1",
        "The Version ID Register is a read only register used to identify the v"
        "ersion of the TRNG in use.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_trng_vid1
    },
    {
        "VID2",
        "The Version ID Register LSB is a read only register used to identify t"
        "he architecture of the TRNG in use.",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_trng_vid2
    },
    {
        "SEC_CFG",
        "The Security Configuration Register is a read/write register used to c"
        "ontrol the test mode, programmability and state modes of the TRNG0.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_trng_sec_cfg
    },
    {
        "SCMISC",
        "The Statistical Check Miscellaneous Register contains the Long Run Max"
        "imum Limit value and the Retry Count value.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trng_scmisc
    },
    {
        "PKRRNG",
        "The Poker Range Register defines the difference between the TRNG Poker"
        " Maximum Limit and the minimum limit.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_trng_pkrrng
    },
    {
        "PKRMAX",
        "The Poker Maximum Limit Register defines Maximum Limit allowable durin"
        "g the TRNG Statistical Check Poker Test.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_trng_pkrmax
    },
    {
        "PKRSQ",
        "The Poker Square Calculation Result Register is a read-only register u"
        "sed to read the result of the TRNG Statistical Check Poker Test's Squa"
        "re Calculation.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_pkrsq
    },
    {
        "SDCTL",
        "The Seed Control Register contains two fields.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trng_sdctl
    },
    {
        "SBLIM",
        "The Sparse Bit Limit Register is used when Von Neumann sampling is sel"
        "ected during Entropy Generation.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_trng_sblim
    },
    {
        "TOTSAM",
        "The Total Samples Register is a read-only register used to read the to"
        "tal number of samples taken during Entropy generation.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_totsam
    },
    {
        "FRQMIN",
        "The Frequency Count Minimum Limit Register defines the minimum allowab"
        "le count taken by the Entropy sample counter during each Entropy sampl"
        "e.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_trng_frqmin
    },
    {
        "FRQMAX",
        "The Frequency Count Maximum Limit Register defines the maximum allowab"
        "le count taken by the Entropy sample counter during each Entropy sampl"
        "e.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_trng_frqmax
    },
    {
        "FRQCNT",
        "The Frequency Count Register is a read-only register used to read the "
        "frequency counter within the TRNG entropy generator.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_frqcnt
    },
    {
        "SCML",
        "The Statistical Check Monobit Limit Register defines the allowable max"
        "imum and minimum number of ones/zero detected during entropy generatio"
        "n.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trng_scml
    },
    {
        "SCMC",
        "The Statistical Check Monobit Count Register is a read-only register u"
        "sed to read the final monobit count after entropy generation.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_scmc
    },
    {
        "SCR1L",
        "The Statistical Check Run Length 1 Limit Register defines the allowabl"
        "e maximum and minimum number of runs of length 1 detected during entro"
        "py generation.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trng_scr1l
    },
    {
        "SCR1C",
        "The Statistical Check Run Length 1 Counters Register is a read-only re"
        "gister used to read the final Run Length 1 counts after entropy genera"
        "tion.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_trng_scr1c
    },
    {
        "SCR2L",
        "The Statistical Check Run Length 2 Limit Register defines the allowabl"
        "e maximum and minimum number of runs of length 2 detected during entro"
        "py generation.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trng_scr2l
    },
    {
        "SCR2C",
        "The Statistical Check Run Length 2 Counters Register is a read-only re"
        "gister used to read the final Run Length 2 counts after entropy genera"
        "tion.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_trng_scr2c
    },
    {
        "SCR3L",
        "The Statistical Check Run Length 3 Limit Register defines the allowabl"
        "e maximum and minimum number of runs of length 3 detected during entro"
        "py generation.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trng_scr3l
    },
    {
        "SCR3C",
        "The Statistical Check Run Length 3 Counters Register is a read-only re"
        "gister used to read the final Run Length 3 counts after entropy genera"
        "tion.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_trng_scr3c
    },
    {
        "SCR4L",
        "The Statistical Check Run Length 4 Limit Register defines the allowabl"
        "e maximum and minimum number of runs of length 4 detected during entro"
        "py generation.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trng_scr4l
    },
    {
        "SCR4C",
        "The Statistical Check Run Length 4 Counters Register is a read-only re"
        "gister used to read the final Run Length 4 counts after entropy genera"
        "tion.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_trng_scr4c
    },
    {
        "SCR5L",
        "The Statistical Check Run Length 5 Limit Register defines the allowabl"
        "e maximum and minimum number of runs of length 5 detected during entro"
        "py generation.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trng_scr5l
    },
    {
        "SCR5C",
        "The Statistical Check Run Length 5 Counters Register is a read-only re"
        "gister used to read the final Run Length 5 counts after entropy genera"
        "tion.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_trng_scr5c
    },
    {
        "SCR6PL",
        "The Statistical Check Run Length 6+ Limit Register defines the allowab"
        "le maximum and minimum number of runs of length 6 or more detected dur"
        "ing entropy generation.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_trng_scr6pl
    },
    {
        "SCR6PC",
        "The Statistical Check Run Length 6+ Counters Register is a read-only r"
        "egister used to read the final Run Length 6+ counts after entropy gene"
        "ration.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_trng_scr6pc
    },
    {
        "STATUS",
        "Various statistical tests are run as a normal part of the TRNG's entro"
        "py generation process.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        false, // Writable
        17, // Number of bitfields
        hw_trng_status
    },
    {
        "ENT0",
        "The RNG TRNG can be programmed to generate an entropy value that is re"
        "adable via the SkyBlue bus.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_ent0
    },
    {
        "ENT1",
        "The RNG TRNG can be programmed to generate an entropy value that is re"
        "adable via the SkyBlue bus.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_ent1
    },
    {
        "ENT2",
        "The RNG TRNG can be programmed to generate an entropy value that is re"
        "adable via the SkyBlue bus.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_ent2
    },
    {
        "ENT3",
        "The RNG TRNG can be programmed to generate an entropy value that is re"
        "adable via the SkyBlue bus.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_ent3
    },
    {
        "ENT4",
        "The RNG TRNG can be programmed to generate an entropy value that is re"
        "adable via the SkyBlue bus.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_ent4
    },
    {
        "ENT5",
        "The RNG TRNG can be programmed to generate an entropy value that is re"
        "adable via the SkyBlue bus.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_ent5
    },
    {
        "ENT6",
        "The RNG TRNG can be programmed to generate an entropy value that is re"
        "adable via the SkyBlue bus.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_ent6
    },
    {
        "ENT7",
        "The RNG TRNG can be programmed to generate an entropy value that is re"
        "adable via the SkyBlue bus.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_ent7
    },
    {
        "ENT8",
        "The RNG TRNG can be programmed to generate an entropy value that is re"
        "adable via the SkyBlue bus.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_ent8
    },
    {
        "ENT9",
        "The RNG TRNG can be programmed to generate an entropy value that is re"
        "adable via the SkyBlue bus.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_ent9
    },
    {
        "ENT10",
        "The RNG TRNG can be programmed to generate an entropy value that is re"
        "adable via the SkyBlue bus.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_ent10
    },
    {
        "ENT11",
        "The RNG TRNG can be programmed to generate an entropy value that is re"
        "adable via the SkyBlue bus.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_ent11
    },
    {
        "ENT12",
        "The RNG TRNG can be programmed to generate an entropy value that is re"
        "adable via the SkyBlue bus.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_ent12
    },
    {
        "ENT13",
        "The RNG TRNG can be programmed to generate an entropy value that is re"
        "adable via the SkyBlue bus.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_ent13
    },
    {
        "ENT14",
        "The RNG TRNG can be programmed to generate an entropy value that is re"
        "adable via the SkyBlue bus.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_ent14
    },
    {
        "ENT15",
        "The RNG TRNG can be programmed to generate an entropy value that is re"
        "adable via the SkyBlue bus.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_trng_ent15
    },
    {
        "PKRCNT10",
        "The Statistical Check Poker Count 1 and 0 Register is a read-only regi"
        "ster used to read the final Poker test counts of 1h and 0h patterns.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_trng_pkrcnt10
    },
    {
        "PKRCNT32",
        "The Statistical Check Poker Count 3 and 2 Register is a read-only regi"
        "ster used to read the final Poker test counts of 3h and 2h patterns.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_trng_pkrcnt32
    },
    {
        "PKRCNT54",
        "The Statistical Check Poker Count 5 and 4 Register is a read-only regi"
        "ster used to read the final Poker test counts of 5h and 4h patterns.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_trng_pkrcnt54
    },
    {
        "PKRCNT76",
        "The Statistical Check Poker Count 7 and 6 Register is a read-only regi"
        "ster used to read the final Poker test counts of 7h and 6h patterns.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_trng_pkrcnt76
    },
    {
        "PKRCNT98",
        "The Statistical Check Poker Count 9 and 8 Register is a read-only regi"
        "ster used to read the final Poker test counts of 9h and 8h patterns.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_trng_pkrcnt98
    },
    {
        "PKRCNTBA",
        "The Statistical Check Poker Count B and A Register is a read-only regi"
        "ster used to read the final Poker test counts of Bh and Ah patterns.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_trng_pkrcntba
    },
    {
        "PKRCNTDC",
        "The Statistical Check Poker Count D and C Register is a read-only regi"
        "ster used to read the final Poker test counts of Dh and Ch patterns.",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_trng_pkrcntdc
    },
    {
        "PKRCNTFE",
        "The Statistical Check Poker Count F and E Register is a read-only regi"
        "ster used to read the final Poker test counts of Fh and Eh patterns.",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_trng_pkrcntfe
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark TSTMR
#endif

// Bitfields in register TSTMR_LOW.
static const field_t hw_tstmr_low[] =
{
    {
        "VALUE",
        "Lower 32 bits of the 64-bit time stamp value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TSTMR_HIGH.
static const field_t hw_tstmr_high[] =
{
    {
        "VALUE",
        "Upper 32 bits of the 64-bit time stamp value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a TSTMR module.
static const reg_t hw_tstmr[] =
{
    {
        "LOW",
        "The Time Stamp Timer is a 64-bit clock cycle counter, reset by system "
        "reset.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_tstmr_low
    },
    {
        "HIGH",
        "The Time Stamp Timer is a 64-bit counters clock cycle counter, reset b"
        "y system reset.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_tstmr_high
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USB
#endif

// Bitfields in register USB_ID.
static const field_t hw_usb_id[] =
{
    {
        "ID",
        "Configuration number.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NID",
        "Complement version of ID",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REVISION",
        "Revision number of the controller core.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_HWGENERAL.
static const field_t hw_usb_hwgeneral[] =
{
    {
        "PHYW",
        "Data width of the transciever connected to the controller core.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHYM",
        "Transciever type PHYM bit reset value: '0000b' for OTG controller core"
        ", '0100b' for Host-only controller core.",
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SM",
        "Serial interface mode capability SM bit reset value is '00b'",
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_HWHOST.
static const field_t hw_usb_hwhost[] =
{
    {
        "HC",
        "Host Capable.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NPORT",
        "The Nmber of downstream ports supported by the host controller is (NPO"
        "RT+1).",
        1, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_HWDEVICE.
static const field_t hw_usb_hwdevice[] =
{
    {
        "DC",
        "Device Capable.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEVEP",
        "Device Endpoint Number",
        1, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_HWTXBUF.
static const field_t hw_usb_hwtxbuf[] =
{
    {
        "TXBURST",
        "Default burst size for memory to TX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXCHANADD",
        "TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_HWRXBUF.
static const field_t hw_usb_hwrxbuf[] =
{
    {
        "RXBURST",
        "Default burst size for memory to RX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXADD",
        "Buffer total size for all receive endpoints is (2^RXADD).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_GPTIMER0LD.
static const field_t hw_usb_gptimer0ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value These bit fields are loaded to GPTCNT"
        " bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_GPTIMER0CTRL.
static const field_t hw_usb_gptimer0ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode In one shot mode, the timer will count down"
        " to zero, generate an interrupt, and stop until the counter is reset b"
        "y software; In repeat mode, the timer will count down to zero, generat"
        "e an interrupt and automatically reload the counter value from GPTLD b"
        "its to start again.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run GPTCNT bits are not effected when setting or"
        " clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_GPTIMER1LD.
static const field_t hw_usb_gptimer1ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value These bit fields are loaded to GPTCNT"
        " bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_GPTIMER1CTRL.
static const field_t hw_usb_gptimer1ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode In one shot mode, the timer will count down"
        " to zero, generate an interrupt, and stop until the counter is reset b"
        "y software.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run GPTCNT bits are not effected when setting or"
        " clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_SBUSCFG.
static const field_t hw_usb_sbuscfg[] =
{
    {
        "AHBBRST",
        "AHB master interface Burst configuration These bits control AHB master"
        " transfer type sequence (or priority).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_CAPLENGTH.
static const field_t hw_usb_caplength[] =
{
    {
        "CAPLENGTH",
        "These bits are used as an offset to add to register base to find the b"
        "eginning of the Operational Register.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_HCIVERSION.
static const field_t hw_usb_hciversion[] =
{
    {
        "HCIVERSION",
        "Host Controller Interface Version Number Default value is '10h', which"
        " means EHCI rev1.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_HCSPARAMS.
static const field_t hw_usb_hcsparams[] =
{
    {
        "N_PORTS",
        "Number of downstream ports.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PPC",
        "Port Power Control This field indicates whether the host controller im"
        "plementation includes port power control.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PCC",
        "Number of Ports per Companion Controller This field indicates the numb"
        "er of ports supported per internal Companion Controller.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_CC",
        "Number of Companion Controller (N_CC).",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PI",
        "Port Indicators (P INDICATOR) This bit indicates whether the ports sup"
        "port port indicator control.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PTT",
        "Number of Ports per Transaction Translator (N_PTT).",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_TT",
        "Number of Transaction Translators (N_TT).",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_HCCPARAMS.
static const field_t hw_usb_hccparams[] =
{
    {
        "ADC",
        "64-bit Addressing Capability This bit is set '0b' in all controller co"
        "re, no 64-bit addressing capability is supported.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFL",
        "Programmable Frame List Flag If this bit is set to zero, then the syst"
        "em software must use a frame list length of 1024 elements with this ho"
        "st controller.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Capability If this bit is set to a one, the"
        "n the host controller supports the park feature for high-speed queue h"
        "eads in the Asynchronous Schedule.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IST",
        "Isochronous Scheduling Threshold.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EECP",
        "EHCI Extended Capabilities Pointer.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_DCIVERSION.
static const field_t hw_usb_dciversion[] =
{
    {
        "DCIVERSION",
        "Device Controller Interface Version Number Default value is '01h', whi"
        "ch means rev0.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_DCCPARAMS.
static const field_t hw_usb_dccparams[] =
{
    {
        "DEN",
        "Device Endpoint Number This field indicates the number of endpoints bu"
        "ilt into the device controller.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC",
        "Device Capable When this bit is 1, this controller is capable of opera"
        "ting as a USB 2.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HC",
        "Host Capable When this bit is 1, this controller is capable of operati"
        "ng as an EHCI compatible USB 2.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_USBCMD.
static const field_t hw_usb_usbcmd[] =
{
    {
        "RS",
        "Run/Stop (RS) - Read/Write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        "Controller Reset (RESET) - Read/Write.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS_1",
        "See description at bit 15",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSE",
        "Periodic Schedule Enable- Read/Write.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASE",
        "Asynchronous Schedule Enable - Read/Write.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IAA",
        "Interrupt on Async Advance Doorbell - Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Mode Count - Read/Write.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASPE",
        "Asynchronous Schedule Park Mode Enable - Read/Write.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDTW",
        "Add dTD TripWire - Read/Write.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUTW",
        "Setup TripWire - Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS_2",
        "See also bits 3-2 Frame List Size - (Read/Write or Read Only).",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ITC",
        "Interrupt Threshold Control -Read/Write.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_USBSTS.
static const field_t hw_usb_usbsts[] =
{
    {
        "UI",
        "USB Interrupt (USBINT) - R/WC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEI",
        "USB Error Interrupt (USBERRINT) - R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCI",
        "Port Change Detect - R/WC.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRI",
        "Frame List Rollover - R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEI",
        "System Error- R/WC.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAI",
        "Interrupt on Async Advance - R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URI",
        "USB Reset Received - R/WC.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRI",
        "SOF Received - R/WC.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLI",
        "DCSuspend - R/WC.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPII",
        "ULPI Interrupt - R/WC.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCH",
        "HCHaIted - Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCL",
        "Reclamation - Read Only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        "Periodic Schedule Status - Read Only.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AS",
        "Asynchronous Schedule Status - Read Only.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKI",
        "NAK Interrupt Bit--RO.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TI0",
        "General Purpose Timer Interrupt 0(GPTINT0)--R/WC.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TI1",
        "General Purpose Timer Interrupt 1(GPTINT1)--R/WC.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_USBINTR.
static const field_t hw_usb_usbintr[] =
{
    {
        "UE",
        "USB Interrupt Enable When this bit is one and the UI bit in n_USBSTS r"
        "egister is a one the controller will issue an interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEE",
        "USB Error Interrupt Enable When this bit is one and the UEI bit in n_U"
        "SBSTS register is a one the controller will issue an interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCE",
        "Port Change Detect Interrupt Enable When this bit is one and the PCI b"
        "it in n_USBSTS register is a one the controller will issue an interrup"
        "t.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRE",
        "Frame List Rollover Interrupt Enable When this bit is one and the FRI "
        "bit in n_USBSTS register is a one the controller will issue an interru"
        "pt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEE",
        "System Error Interrupt Enable When this bit is one and the SEI bit in "
        "n_USBSTS register is a one the controller will issue an interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAE",
        "Async Advance Interrupt Enable When this bit is one and the AAI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URE",
        "USB Reset Interrupt Enable When this bit is one and the URI bit in n_U"
        "SBSTS register is a one the controller will issue an interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "SOF Received Interrupt Enable When this bit is one and the SRI bit in "
        "n_USBSTS register is a one the controller will issue an interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLE",
        "Sleep Interrupt Enable When this bit is one and the SLI bit in n_n_USB"
        "STS register is a one the controller will issue an interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPIE",
        "ULPI Interrupt Enable When this bit is one and the UPLII bit in n_USBS"
        "TS register is a one the controller will issue an interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKE",
        "NAK Interrupt Enable When this bit is one and the NAKI bit in n_USBSTS"
        " register is a one the controller will issue an interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UAIE",
        "USB Host Asynchronous Interrupt Enable When this bit is one, and the U"
        "AI bit in the n_USBSTS register is one, host controller will issue an "
        "interrupt at the next interrupt threshold.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPIE",
        "USB Host Periodic Interrupt Enable When this bit is one, and the UPI b"
        "it in the n_USBSTS register is one, host controller will issue an inte"
        "rrupt at the next interrupt threshold.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE0",
        "General Purpose Timer #0 Interrupt Enable When this bit is one and the"
        " TI0 bit in n_USBSTS register is a one the controller will issue an in"
        "terrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE1",
        "General Purpose Timer #1 Interrupt Enable When this bit is one and the"
        " TI1 bit in n_USBSTS register is a one the controller will issue an in"
        "terrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_FRINDEX.
static const field_t hw_usb_frindex[] =
{
    {
        "FRINDEX",
        "Frame Index.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_DEVICEADDR.
static const field_t hw_usb_deviceaddr[] =
{
    {
        "USBADRA",
        "Device Address Advance.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USBADR",
        "Device Address.",
        25, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_PERIODICLISTBASE.
static const field_t hw_usb_periodiclistbase[] =
{
    {
        "BASEADR",
        "Base Address (Low).",
        12, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ASYNCLISTADDR.
static const field_t hw_usb_asynclistaddr[] =
{
    {
        "ASYBASE",
        "Link Pointer Low (LPL).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ENDPTLISTADDR.
static const field_t hw_usb_endptlistaddr[] =
{
    {
        "EPBASE",
        "Endpoint List Pointer(Low).",
        11, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_BURSTSIZE.
static const field_t hw_usb_burstsize[] =
{
    {
        "RXPBURST",
        "Programmable RX Burst Size.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPBURST",
        "Programmable TX Burst Size.",
        8, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_TXFILLTUNING.
static const field_t hw_usb_txfilltuning[] =
{
    {
        "TXSCHOH",
        "Scheduler Overhead.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSCHHEALTH",
        "Scheduler Health Counter.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOTHRES",
        "FIFO Burst Threshold.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ENDPTNAK.
static const field_t hw_usb_endptnak[] =
{
    {
        "EPRN",
        "RX Endpoint NAK - R/WC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPTN",
        "TX Endpoint NAK - R/WC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ENDPTNAKEN.
static const field_t hw_usb_endptnaken[] =
{
    {
        "EPRNE",
        "RX Endpoint NAK Enable - R/W.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPTNE",
        "TX Endpoint NAK Enable - R/W.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_CONFIGFLAG.
static const field_t hw_usb_configflag[] =
{
    {
        "CF",
        "Configure Flag Host software sets this bit as the last action in its p"
        "rocess of configuring the Host Controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_PORTSC1.
static const field_t hw_usb_portsc1[] =
{
    {
        "CCS",
        "Current Connect Status-Read Only.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSC",
        "Connect Status Change-R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Port Enabled/Disabled-Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEC",
        "Port Enable/Disable Change-R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCA",
        "Over-current Active-Read Only.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCC",
        "Over-current Change-R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPR",
        "Force Port Resume -Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSP",
        "Suspend - Read/Write or Read Only.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "Port Reset - Read/Write or Read Only.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSP",
        "High-Speed Port - Read Only.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LS",
        "Line Status-Read Only.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP",
        "Port Power (PP)-Read/Write or Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PO",
        "Port Owner-Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIC",
        "Port Indicator Control - Read/Write.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTC",
        "Port Test Control - Read/Write.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKCN",
        "Wake on Connect Enable (WKCNNT_E) - Read/Write.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKDC",
        "Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKOC",
        "Wake on Over-current Enable (WKOC_E) - Read/Write.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHCD",
        "PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFSC",
        "Port Force Full Speed Connect - Read/Write.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS_2",
        "See description at bits 31-30",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSPD",
        "Port Speed - Read Only.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTW",
        "Parallel Transceiver Width This bit has no effect if serial interface "
        "engine is used.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "Serial Transceiver Select - Read Only Serial Transceiver Select 1 Seri"
        "al Interface Engine is selected 0 Parallel Interface signals is select"
        "ed Serial Interface Engine can be used in combination with UTMI+/ULPI "
        "physical interface to provide FS/LS signaling instead of the parallel "
        "interface signals.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS_1",
        "Bit field {bit25, bit31, bit30}: \"000b\" UTMI/UTMI+ \"001b\" Reserved"
        " \"010b\" ULPI \"011b\" Serial/USB 1.1 PHY/IC-USB (FS Only) \"100b\" H"
        "SIC All USB port interface modes are listed in this field description,"
        " but not all are supported.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_OTGSC.
static const field_t hw_usb_otgsc[] =
{
    {
        "VD",
        "VBUS_Discharge - Read/Write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VC",
        "VBUS Charge - Read/Write.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OT",
        "OTG Termination - Read/Write.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP",
        "Data Pulsing - Read/Write.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDPU",
        "ID Pullup - Read/Write This bit provide control over the ID pull-up re"
        "sistor; 0 = off, 1 = on [default].",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ID",
        "USB ID - Read Only.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AVV",
        "A VBus Valid - Read Only.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASV",
        "A Session Valid - Read Only.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BSV",
        "B Session Valid - Read Only.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BSE",
        "B Session End - Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TOG_1MS",
        "1 millisecond timer toggle - Read Only.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPS",
        "Data Bus Pulsing Status - Read Only.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDIS",
        "USB ID Interrupt Status - Read/Write.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVVIS",
        "A VBus Valid Interrupt Status - Read/Write to Clear.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASVIS",
        "A Session Valid Interrupt Status - Read/Write to Clear.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSVIS",
        "B Session Valid Interrupt Status - Read/Write to Clear.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSEIS",
        "B Session End Interrupt Status - Read/Write to Clear.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATUS_1MS",
        "1 millisecond timer Interrupt Status - Read/Write to Clear.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPIS",
        "Data Pulse Interrupt Status - Read/Write to Clear.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDIE",
        "USB ID Interrupt Enable - Read/Write.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVVIE",
        "A VBus Valid Interrupt Enable - Read/Write.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASVIE",
        "A Session Valid Interrupt Enable - Read/Write.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSVIE",
        "B Session Valid Interrupt Enable - Read/Write.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSEIE",
        "B Session End Interrupt Enable - Read/Write.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_1MS",
        "1 millisecond timer Interrupt Enable - Read/Write",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPIE",
        "Data Pulse Interrupt Enable",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_USBMODE.
static const field_t hw_usb_usbmode[] =
{
    {
        "CM",
        "Controller Mode - R/WO.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ES",
        "Endian Select - Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOM",
        "Setup Lockout Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDIS",
        "Stream Disable Mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ENDPTSETUPSTAT.
static const field_t hw_usb_endptsetupstat[] =
{
    {
        "ENDPTSETUPSTAT",
        "Setup Endpoint Status.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ENDPTPRIME.
static const field_t hw_usb_endptprime[] =
{
    {
        "PERB",
        "Prime Endpoint Receive Buffer - R/WS.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PETB",
        "Prime Endpoint Transmit Buffer - R/WS.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ENDPTFLUSH.
static const field_t hw_usb_endptflush[] =
{
    {
        "FERB",
        "Flush Endpoint Receive Buffer - R/WS.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FETB",
        "Flush Endpoint Transmit Buffer - R/WS.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ENDPTSTAT.
static const field_t hw_usb_endptstat[] =
{
    {
        "ERBR",
        "Endpoint Receive Buffer Ready -- Read Only.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ETBR",
        "Endpoint Transmit Buffer Ready -- Read Only.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ENDPTCOMPLETE.
static const field_t hw_usb_endptcomplete[] =
{
    {
        "ERCE",
        "Endpoint Receive Complete Event - RW/C.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETCE",
        "Endpoint Transmit Complete Event - R/WC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ENDPTCTRL0.
static const field_t hw_usb_endptctrl0[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control Endpoint0 is fixed as a Contr"
        "ol End Point.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 1 Enabled Endpoint0 is always enabled.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK [Default] 1 End Point St"
        "alled Software can write a one to this bit to force the endpoint to re"
        "turn a STALL handshake to the Host.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 - Control Endpoint0 is fixed as a Con"
        "trol End Point.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 1 Enabled Endpoint0 is always enabled.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ENDPTCTRL1.
static const field_t hw_usb_endptctrl1[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write 0 Dual Port Memory Buffer/DMA Engin"
        "e [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ENDPTCTRL2.
static const field_t hw_usb_endptctrl2[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write 0 Dual Port Memory Buffer/DMA Engin"
        "e [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ENDPTCTRL3.
static const field_t hw_usb_endptctrl3[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write 0 Dual Port Memory Buffer/DMA Engin"
        "e [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ENDPTCTRL4.
static const field_t hw_usb_endptctrl4[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write 0 Dual Port Memory Buffer/DMA Engin"
        "e [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ENDPTCTRL5.
static const field_t hw_usb_endptctrl5[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write 0 Dual Port Memory Buffer/DMA Engin"
        "e [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ENDPTCTRL6.
static const field_t hw_usb_endptctrl6[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write 0 Dual Port Memory Buffer/DMA Engin"
        "e [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_ENDPTCTRL7.
static const field_t hw_usb_endptctrl7[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write 0 Dual Port Memory Buffer/DMA Engin"
        "e [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Res"
        "erved",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a USB module.
static const reg_t hw_usb[] =
{
    {
        "ID",
        "The ID register identifies the USB 2.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usb_id
    },
    {
        "HWGENERAL",
        "General hardware parameters as defined in System Level Issues and Core"
        " Configuration.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usb_hwgeneral
    },
    {
        "HWHOST",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_hwhost
    },
    {
        "HWDEVICE",
        "This register is only available in OTG core.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_hwdevice
    },
    {
        "HWTXBUF",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_hwtxbuf
    },
    {
        "HWRXBUF",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_hwrxbuf
    },
    {
        "GPTIMER0LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER0CTRL.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_gptimer0ld
    },
    {
        "GPTIMER0CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_gptimer0ctrl
    },
    {
        "GPTIMER1LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER1CTRL.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_gptimer1ld
    },
    {
        "GPTIMER1CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_gptimer1ctrl
    },
    {
        "SBUSCFG",
        "",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_sbuscfg
    },
    {
        "CAPLENGTH",
        "The Capability Registers Length register contains the address offset t"
        "o the Operational registers relative to the CAPLENGTH register.",
        1, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usb_caplength
    },
    {
        "HCIVERSION",
        "This is a 2-byte register containing a BCD encoding of the EHCI revisi"
        "on number supported by this host controller.",
        2, // Width in bytes
        0x00000102, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usb_hciversion
    },
    {
        "HCSPARAMS",
        "The following figure shows the port steering logic capabilities of Hos"
        "t Control Structural Parameters (n_HCSPARAMS).",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_usb_hcsparams
    },
    {
        "HCCPARAMS",
        "This register identifies multiple mode control (time-base bit function"
        "ality), addressing capability.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_usb_hccparams
    },
    {
        "DCIVERSION",
        "This register indicates the two-byte BCD encoding of the device contro"
        "ller interface version number.",
        2, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usb_dciversion
    },
    {
        "DCCPARAMS",
        "These fields describe the overall device capability of the controller.",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usb_dccparams
    },
    {
        "USBCMD",
        "The Command Register indicates the command to be executed by the seria"
        "l bus host/device controller.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_usbcmd
    },
    {
        "USBSTS",
        "This register indicates various states of the Host/Device Controller a"
        "nd any pending interrupts.",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usb_usbsts
    },
    {
        "USBINTR",
        "The interrupts to software are enabled with this register.",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usb_usbintr
    },
    {
        "FRINDEX",
        "This register is used by the host controller to index the periodic fra"
        "me list.",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_frindex
    },
    {
        "DEVICEADDR",
        "Device Controller only The upper seven bits of this register represent"
        " the device address.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_deviceaddr
    },
    {
        "PERIODICLISTBASE",
        "Host Controller only This 32-bit register contains the beginning addre"
        "ss of the Periodic Frame List in the system memory.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_periodiclistbase
    },
    {
        "ASYNCLISTADDR",
        "Host Controller only This 32-bit register contains the address of the "
        "next asynchronous queue head to be executed by the host.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_asynclistaddr
    },
    {
        "ENDPTLISTADDR",
        "Device Controller only In device mode, this register contains the addr"
        "ess of the top of the endpoint list in system memory.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_endptlistaddr
    },
    {
        "BURSTSIZE",
        "This register is used to control the burst size used during data movem"
        "ent on the AHB master interface.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_burstsize
    },
    {
        "TXFILLTUNING",
        "The fields in this register control performance tuning associated with"
        " how the host controller posts data to the TX latency FIFO before movi"
        "ng the data onto the USB bus.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_txfilltuning
    },
    {
        "ENDPTNAK",
        "",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_endptnak
    },
    {
        "ENDPTNAKEN",
        "",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_endptnaken
    },
    {
        "CONFIGFLAG",
        "",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usb_configflag
    },
    {
        "PORTSC1",
        "Host Controller A host controller could implement one to eight port st"
        "atus and control registers.",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_usb_portsc1
    },
    {
        "OTGSC",
        "This register is availabe only in OTG controller core.",
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_usb_otgsc
    },
    {
        "USBMODE",
        "",
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_usbmode
    },
    {
        "ENDPTSETUPSTAT",
        "",
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_endptsetupstat
    },
    {
        "ENDPTPRIME",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_endptprime
    },
    {
        "ENDPTFLUSH",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000001b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_endptflush
    },
    {
        "ENDPTSTAT",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000001b8, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_endptstat
    },
    {
        "ENDPTCOMPLETE",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000001bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_endptcomplete
    },
    {
        "ENDPTCTRL0",
        "Every Device implements Endpoint 0 as a control endpoint.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usb_endptctrl0
    },
    {
        "ENDPTCTRL1",
        "This is endpoint control register for endpoint 1 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001c4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_endptctrl1
    },
    {
        "ENDPTCTRL2",
        "This is endpoint control register for endpoint 2 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001c8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_endptctrl2
    },
    {
        "ENDPTCTRL3",
        "This is endpoint control register for endpoint 3 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001cc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_endptctrl3
    },
    {
        "ENDPTCTRL4",
        "This is endpoint control register for endpoint 4 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_endptctrl4
    },
    {
        "ENDPTCTRL5",
        "This is endpoint control register for endpoint 5 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001d4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_endptctrl5
    },
    {
        "ENDPTCTRL6",
        "This is endpoint control register for endpoint 6 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001d8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_endptctrl6
    },
    {
        "ENDPTCTRL7",
        "This is endpoint control register for endpoint 7 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001dc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_endptctrl7
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USBNC
#endif

// Bitfields in register USBNC_OTGn_CTRL1.
static const field_t hw_usbnc_otgn_ctrl1[] =
{
    {
        "OVER_CUR_DIS",
        "Disable Overcurrent Detection",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVER_CUR_POL",
        "Polarity of Overcurrent The polarity of OTGn/OTG2 port overcurrent eve"
        "nt",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWR_POL",
        "Power Polarity This bit should be set according to PMIC Power Pin pola"
        "rity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIE",
        "Wake-up Interrupt Enable This bit enables or disables the OTGn wake-up"
        " interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW_EN",
        "Software Wake-up Enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW",
        "Software Wake-up",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_ID_EN",
        "Wake-up on ID change enable",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_VBUS_EN",
        "Wake-up on VBUS change enable",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPI_PHY_CLK_EN",
        "This bit is for ULPI interface only.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_DPDM_EN",
        "",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIR",
        "Wake-up Interrupt Request This bit indicates that a wake-up interrupt "
        "request is received on the OTGn port.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_OTGn_CTRL2.
static const field_t hw_usbnc_otgn_ctrl2[] =
{
    {
        "VBUS_SOURCE_SEL",
        "VBUS source select when detect VBUS wakeup event, it is for UTMI PHY o"
        "nly (UH core has no such feature).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTURESUME_EN",
        "It is for UTMI PHY host mode only (UH core has no this feature since H"
        "SIC PHY does not support auto resume).",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOWSPEED_EN",
        "Set if AUTURESUME_EN is set and works on low speed.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_CLK_VLD",
        "Indicate whether the UTMI clock to the USB PHY is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_OTGn_HSIC_CTRL.
static const field_t hw_usbnc_otgn_hsic_ctrl[] =
{
    {
        "HSIC_CLK_ON",
        "Force Host HSIC module 480M clock on, even when in Host is in suspend "
        "mode.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSIC_EN",
        "Host HSIC enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_VLD",
        "Indicating whether Host HSIC clock is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a USBNC module.
static const reg_t hw_usbnc[] =
{
    {
        "OTGn_CTRL1",
        "The USB Control 1 register controls the integration specific features "
        "of the USB OTGn and OTG2 module.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_usbnc_otgn_ctrl1
    },
    {
        "OTGn_CTRL2",
        "The USB Control 2 register controls the integration specific features "
        "of the USB module.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbnc_otgn_ctrl2
    },
    {
        "OTGn_HSIC_CTRL",
        "The USB Host HSIC control register controls Host high speed IC configu"
        "ration.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbnc_otgn_hsic_ctrl
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USBPHY
#endif

// Bitfields in register USBPHY_PWD.
static const field_t hw_usbphy_pwd[] =
{
    {
        "TXPWDFS",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDIBIAS",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDV2I",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDENV",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWD1PT1",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDDIFF",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDRX",
        "This bit will be auto cleared if there is USB wakeup event while ENAUT"
        "OCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_PWD_SET.
static const field_t hw_usbphy_pwd_set[] =
{
    {
        "TXPWDFS",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDIBIAS",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDV2I",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDENV",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWD1PT1",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDDIFF",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDRX",
        "This bit will be auto cleared if there is USB wakeup event while ENAUT"
        "OCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_PWD_CLR.
static const field_t hw_usbphy_pwd_clr[] =
{
    {
        "TXPWDFS",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDIBIAS",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDV2I",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDENV",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWD1PT1",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDDIFF",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDRX",
        "This bit will be auto cleared if there is USB wakeup event while ENAUT"
        "OCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_PWD_TOG.
static const field_t hw_usbphy_pwd_tog[] =
{
    {
        "TXPWDFS",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDIBIAS",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDV2I",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDENV",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWD1PT1",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDDIFF",
        "Note that this bit will be auto cleared if there is USB wakeup event w"
        "hile ENAUTOCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDRX",
        "This bit will be auto cleared if there is USB wakeup event while ENAUT"
        "OCLR_PHY_PWD bit of USBPHY_CTRL is enabled.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TX.
static const field_t hw_usbphy_tx[] =
{
    {
        "D_CAL",
        "Decode to trim the nominal 17.78mA current source for the High Speed T"
        "X drivers on USB_DP and USB_DM.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DM",
        "Decode to trim the nominal 45ohm series termination resistance to the "
        "USB_DM output pin.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXENCAL45DN",
        "Enable resistance calibration on DN.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DP",
        "Decode to trim the nominal 45ohm series termination resistance to the "
        "USB_DP output pin.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXENCAL45DP",
        "Enable resistance calibration on DP.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TX_SET.
static const field_t hw_usbphy_tx_set[] =
{
    {
        "D_CAL",
        "Decode to trim the nominal 17.78mA current source for the High Speed T"
        "X drivers on USB_DP and USB_DM.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DM",
        "Decode to trim the nominal 45ohm series termination resistance to the "
        "USB_DM output pin.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXENCAL45DN",
        "Enable resistance calibration on DN.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DP",
        "Decode to trim the nominal 45ohm series termination resistance to the "
        "USB_DP output pin.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXENCAL45DP",
        "Enable resistance calibration on DP.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TX_CLR.
static const field_t hw_usbphy_tx_clr[] =
{
    {
        "D_CAL",
        "Decode to trim the nominal 17.78mA current source for the High Speed T"
        "X drivers on USB_DP and USB_DM.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DM",
        "Decode to trim the nominal 45ohm series termination resistance to the "
        "USB_DM output pin.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXENCAL45DN",
        "Enable resistance calibration on DN.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DP",
        "Decode to trim the nominal 45ohm series termination resistance to the "
        "USB_DP output pin.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXENCAL45DP",
        "Enable resistance calibration on DP.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TX_TOG.
static const field_t hw_usbphy_tx_tog[] =
{
    {
        "D_CAL",
        "Decode to trim the nominal 17.78mA current source for the High Speed T"
        "X drivers on USB_DP and USB_DM.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DM",
        "Decode to trim the nominal 45ohm series termination resistance to the "
        "USB_DM output pin.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXENCAL45DN",
        "Enable resistance calibration on DN.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DP",
        "Decode to trim the nominal 45ohm series termination resistance to the "
        "USB_DP output pin.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXENCAL45DP",
        "Enable resistance calibration on DP.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_RX.
static const field_t hw_usbphy_rx[] =
{
    {
        "ENVADJ",
        "The ENVADJ field adjusts the trip point for the envelope detector.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCONADJ",
        "The DISCONADJ field adjusts the trip point for the disconnect detector"
        ".",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDBYPASS",
        "This test mode is intended for lab use only, replace FS differential r"
        "eceiver with DP single ended receiver.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_RX_SET.
static const field_t hw_usbphy_rx_set[] =
{
    {
        "ENVADJ",
        "The ENVADJ field adjusts the trip point for the envelope detector.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCONADJ",
        "The DISCONADJ field adjusts the trip point for the disconnect detector"
        ".",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDBYPASS",
        "This test mode is intended for lab use only, replace FS differential r"
        "eceiver with DP single ended receiver.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_RX_CLR.
static const field_t hw_usbphy_rx_clr[] =
{
    {
        "ENVADJ",
        "The ENVADJ field adjusts the trip point for the envelope detector.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCONADJ",
        "The DISCONADJ field adjusts the trip point for the disconnect detector"
        ".",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDBYPASS",
        "This test mode is intended for lab use only, replace FS differential r"
        "eceiver with DP single ended receiver.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_RX_TOG.
static const field_t hw_usbphy_rx_tog[] =
{
    {
        "ENVADJ",
        "The ENVADJ field adjusts the trip point for the envelope detector.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCONADJ",
        "The DISCONADJ field adjusts the trip point for the disconnect detector"
        ".",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDBYPASS",
        "This test mode is intended for lab use only, replace FS differential r"
        "eceiver with DP single ended receiver.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_CTRL.
static const field_t hw_usbphy_ctrl[] =
{
    {
        "ENHOSTDISCONDETECT",
        "For host mode, enables high-speed disconnect detector.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOSTDISCONDETECT_IRQ",
        "Indicates that the device has disconnected in High-Speed mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDEVPLUGINDET",
        "This bit field controls connection of nominal 200kohm resistors to bot"
        "h the USB_DP and USB_DM pins as one method of detecting when a USB cab"
        "le is attached in device mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_IRQ",
        "Indicates that the device is connected.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL2",
        "Enables UTMI+ Level 2 operation for the USB HS PHY.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL3",
        "Enables UTMI+ Level 3 operation for the USB HS PHY.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTORESUME_EN",
        "Enable the auto resume feature, when set, HW will use 32KHz clock to s"
        "end Resume to respond to the device remote wakeup(for host mode only).",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_CLKGATE",
        "Enables the feature to auto-clear the CLKGATE bit if there is wakeup e"
        "vent while USB is suspended.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_PHY_PWD",
        "Enables the feature to auto-clear the PWD register bits in USBPHY_PWD "
        "if there is wakeup event while USB is suspended.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLL_RST_EN",
        "Enables the feature to reset the FSDLL lock detection logic at the end"
        " of each TX packet.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTG_ID_VALUE",
        "Indicates the results of USB_ID pin while monitoring the cable plugged"
        " into the Micro- or Mini-AB receptacle.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOST_FORCE_LS_SE0",
        "Forces the next FS packet that is transmitted to have a EOP with low-s"
        "peed timing.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_SUSPENDM",
        "Used by the PHY to indicate a powered-down state.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "Gate UTMI Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Writing a 1 to this bit will soft-reset the USBPHY_PWD, USBPHY_TX, USB"
        "PHY_RX, and USBPHY_CTRL registers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_CTRL_SET.
static const field_t hw_usbphy_ctrl_set[] =
{
    {
        "ENHOSTDISCONDETECT",
        "For host mode, enables high-speed disconnect detector.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOSTDISCONDETECT_IRQ",
        "Indicates that the device has disconnected in High-Speed mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDEVPLUGINDET",
        "This bit field controls connection of nominal 200kohm resistors to bot"
        "h the USB_DP and USB_DM pins as one method of detecting when a USB cab"
        "le is attached in device mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_IRQ",
        "Indicates that the device is connected.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL2",
        "Enables UTMI+ Level 2 operation for the USB HS PHY.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL3",
        "Enables UTMI+ Level 3 operation for the USB HS PHY.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTORESUME_EN",
        "Enable the auto resume feature, when set, HW will use 32KHz clock to s"
        "end Resume to respond to the device remote wakeup(for host mode only).",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_CLKGATE",
        "Enables the feature to auto-clear the CLKGATE bit if there is wakeup e"
        "vent while USB is suspended.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_PHY_PWD",
        "Enables the feature to auto-clear the PWD register bits in USBPHY_PWD "
        "if there is wakeup event while USB is suspended.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLL_RST_EN",
        "Enables the feature to reset the FSDLL lock detection logic at the end"
        " of each TX packet.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTG_ID_VALUE",
        "Indicates the results of USB_ID pin while monitoring the cable plugged"
        " into the Micro- or Mini-AB receptacle.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOST_FORCE_LS_SE0",
        "Forces the next FS packet that is transmitted to have a EOP with low-s"
        "peed timing.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_SUSPENDM",
        "Used by the PHY to indicate a powered-down state.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "Gate UTMI Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Writing a 1 to this bit will soft-reset the USBPHY_PWD, USBPHY_TX, USB"
        "PHY_RX, and USBPHY_CTRL registers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_CTRL_CLR.
static const field_t hw_usbphy_ctrl_clr[] =
{
    {
        "ENHOSTDISCONDETECT",
        "For host mode, enables high-speed disconnect detector.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOSTDISCONDETECT_IRQ",
        "Indicates that the device has disconnected in High-Speed mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDEVPLUGINDET",
        "This bit field controls connection of nominal 200kohm resistors to bot"
        "h the USB_DP and USB_DM pins as one method of detecting when a USB cab"
        "le is attached in device mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_IRQ",
        "Indicates that the device is connected.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL2",
        "Enables UTMI+ Level 2 operation for the USB HS PHY.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL3",
        "Enables UTMI+ Level 3 operation for the USB HS PHY.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTORESUME_EN",
        "Enable the auto resume feature, when set, HW will use 32KHz clock to s"
        "end Resume to respond to the device remote wakeup(for host mode only).",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_CLKGATE",
        "Enables the feature to auto-clear the CLKGATE bit if there is wakeup e"
        "vent while USB is suspended.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_PHY_PWD",
        "Enables the feature to auto-clear the PWD register bits in USBPHY_PWD "
        "if there is wakeup event while USB is suspended.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLL_RST_EN",
        "Enables the feature to reset the FSDLL lock detection logic at the end"
        " of each TX packet.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTG_ID_VALUE",
        "Indicates the results of USB_ID pin while monitoring the cable plugged"
        " into the Micro- or Mini-AB receptacle.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOST_FORCE_LS_SE0",
        "Forces the next FS packet that is transmitted to have a EOP with low-s"
        "peed timing.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_SUSPENDM",
        "Used by the PHY to indicate a powered-down state.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "Gate UTMI Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Writing a 1 to this bit will soft-reset the USBPHY_PWD, USBPHY_TX, USB"
        "PHY_RX, and USBPHY_CTRL registers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_CTRL_TOG.
static const field_t hw_usbphy_ctrl_tog[] =
{
    {
        "ENHOSTDISCONDETECT",
        "For host mode, enables high-speed disconnect detector.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOSTDISCONDETECT_IRQ",
        "Indicates that the device has disconnected in High-Speed mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDEVPLUGINDET",
        "This bit field controls connection of nominal 200kohm resistors to bot"
        "h the USB_DP and USB_DM pins as one method of detecting when a USB cab"
        "le is attached in device mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_IRQ",
        "Indicates that the device is connected.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL2",
        "Enables UTMI+ Level 2 operation for the USB HS PHY.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL3",
        "Enables UTMI+ Level 3 operation for the USB HS PHY.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTORESUME_EN",
        "Enable the auto resume feature, when set, HW will use 32KHz clock to s"
        "end Resume to respond to the device remote wakeup(for host mode only).",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_CLKGATE",
        "Enables the feature to auto-clear the CLKGATE bit if there is wakeup e"
        "vent while USB is suspended.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_PHY_PWD",
        "Enables the feature to auto-clear the PWD register bits in USBPHY_PWD "
        "if there is wakeup event while USB is suspended.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLL_RST_EN",
        "Enables the feature to reset the FSDLL lock detection logic at the end"
        " of each TX packet.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTG_ID_VALUE",
        "Indicates the results of USB_ID pin while monitoring the cable plugged"
        " into the Micro- or Mini-AB receptacle.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOST_FORCE_LS_SE0",
        "Forces the next FS packet that is transmitted to have a EOP with low-s"
        "peed timing.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_SUSPENDM",
        "Used by the PHY to indicate a powered-down state.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "Gate UTMI Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Writing a 1 to this bit will soft-reset the USBPHY_PWD, USBPHY_TX, USB"
        "PHY_RX, and USBPHY_CTRL registers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_STATUS.
static const field_t hw_usbphy_status[] =
{
    {
        "HOSTDISCONDETECT_STATUS",
        "Indicates at the local host (downstream) port that the remote device h"
        "as disconnected while in High-Speed mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEVPLUGIN_STATUS",
        "Indicates that the device has been connected on the USB_DP and USB_DM "
        "lines using the non-standard resistive plugged-in detection method con"
        "trolled by USBPHY_CTRL[4].",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTGID_STATUS",
        "Indicates the results of USB_ID pin on the USB cable plugged into the "
        "local Micro- or Mini-AB receptacle.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUME_STATUS",
        "Indicates that the host is sending a wake-up after Suspend and has tri"
        "ggered an interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG0.
static const field_t hw_usbphy_debug0[] =
{
    {
        "OTGIDPIOLOCK",
        "Once OTG ID from USBPHY_STATUS_OTGID_STATUS is sampled, use this to ho"
        "ld the value.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_INTERFACE_HOLD",
        "Use holding registers to assist in timing for external UTMI interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSTPULLDOWN",
        "This bit field selects whether to connect pulldown resistors on the US"
        "B_DP/USB_DM pins if the corresponding pulldown overdrive mode is enabl"
        "ed through USBPHY_DEBUG[5:4} Set bit 3 to value 1'b1 to connect the 15"
        "ohm pulldown on USB_DP line.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHSTPULLDOWN",
        "This bit field selects host pulldown overdrive mode.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX2RXCOUNT",
        "Delay in between the end of transmit to the beginning of receive.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTX2RXCOUNT",
        "Set this bit to allow a countdown to transition in between TX and RX.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETCOUNT",
        "Delay in between the detection of squelch to the reset of high-speed R"
        "X.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENSQUELCHRESET",
        "Set bit to allow squelch to reset high-speed receive.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETLENGTH",
        "Duration of RESET in terms of the number of 480-MHz cycles.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOST_RESUME_DEBUG",
        "Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UT"
        "MI_SUSPEND = 1.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Gate Test Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG0_SET.
static const field_t hw_usbphy_debug0_set[] =
{
    {
        "OTGIDPIOLOCK",
        "Once OTG ID from USBPHY_STATUS_OTGID_STATUS is sampled, use this to ho"
        "ld the value.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_INTERFACE_HOLD",
        "Use holding registers to assist in timing for external UTMI interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSTPULLDOWN",
        "This bit field selects whether to connect pulldown resistors on the US"
        "B_DP/USB_DM pins if the corresponding pulldown overdrive mode is enabl"
        "ed through USBPHY_DEBUG[5:4} Set bit 3 to value 1'b1 to connect the 15"
        "ohm pulldown on USB_DP line.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHSTPULLDOWN",
        "This bit field selects host pulldown overdrive mode.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX2RXCOUNT",
        "Delay in between the end of transmit to the beginning of receive.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTX2RXCOUNT",
        "Set this bit to allow a countdown to transition in between TX and RX.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETCOUNT",
        "Delay in between the detection of squelch to the reset of high-speed R"
        "X.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENSQUELCHRESET",
        "Set bit to allow squelch to reset high-speed receive.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETLENGTH",
        "Duration of RESET in terms of the number of 480-MHz cycles.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOST_RESUME_DEBUG",
        "Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UT"
        "MI_SUSPEND = 1.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Gate Test Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG0_CLR.
static const field_t hw_usbphy_debug0_clr[] =
{
    {
        "OTGIDPIOLOCK",
        "Once OTG ID from USBPHY_STATUS_OTGID_STATUS is sampled, use this to ho"
        "ld the value.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_INTERFACE_HOLD",
        "Use holding registers to assist in timing for external UTMI interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSTPULLDOWN",
        "This bit field selects whether to connect pulldown resistors on the US"
        "B_DP/USB_DM pins if the corresponding pulldown overdrive mode is enabl"
        "ed through USBPHY_DEBUG[5:4} Set bit 3 to value 1'b1 to connect the 15"
        "ohm pulldown on USB_DP line.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHSTPULLDOWN",
        "This bit field selects host pulldown overdrive mode.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX2RXCOUNT",
        "Delay in between the end of transmit to the beginning of receive.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTX2RXCOUNT",
        "Set this bit to allow a countdown to transition in between TX and RX.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETCOUNT",
        "Delay in between the detection of squelch to the reset of high-speed R"
        "X.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENSQUELCHRESET",
        "Set bit to allow squelch to reset high-speed receive.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETLENGTH",
        "Duration of RESET in terms of the number of 480-MHz cycles.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOST_RESUME_DEBUG",
        "Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UT"
        "MI_SUSPEND = 1.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Gate Test Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG0_TOG.
static const field_t hw_usbphy_debug0_tog[] =
{
    {
        "OTGIDPIOLOCK",
        "Once OTG ID from USBPHY_STATUS_OTGID_STATUS is sampled, use this to ho"
        "ld the value.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_INTERFACE_HOLD",
        "Use holding registers to assist in timing for external UTMI interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSTPULLDOWN",
        "This bit field selects whether to connect pulldown resistors on the US"
        "B_DP/USB_DM pins if the corresponding pulldown overdrive mode is enabl"
        "ed through USBPHY_DEBUG[5:4} Set bit 3 to value 1'b1 to connect the 15"
        "ohm pulldown on USB_DP line.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHSTPULLDOWN",
        "This bit field selects host pulldown overdrive mode.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX2RXCOUNT",
        "Delay in between the end of transmit to the beginning of receive.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTX2RXCOUNT",
        "Set this bit to allow a countdown to transition in between TX and RX.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETCOUNT",
        "Delay in between the detection of squelch to the reset of high-speed R"
        "X.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENSQUELCHRESET",
        "Set bit to allow squelch to reset high-speed receive.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETLENGTH",
        "Duration of RESET in terms of the number of 480-MHz cycles.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOST_RESUME_DEBUG",
        "Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UT"
        "MI_SUSPEND = 1.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Gate Test Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG1.
static const field_t hw_usbphy_debug1[] =
{
    {
        "ENTAILADJVD",
        "Delay increment of the rise of squelch:",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USB2_REFBIAS_VBGADJ",
        "",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USB2_REFBIAS_TST",
        "",
        21, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG1_SET.
static const field_t hw_usbphy_debug1_set[] =
{
    {
        "ENTAILADJVD",
        "Delay increment of the rise of squelch:",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USB2_REFBIAS_VBGADJ",
        "",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USB2_REFBIAS_TST",
        "",
        21, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG1_CLR.
static const field_t hw_usbphy_debug1_clr[] =
{
    {
        "ENTAILADJVD",
        "Delay increment of the rise of squelch:",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USB2_REFBIAS_VBGADJ",
        "",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USB2_REFBIAS_TST",
        "",
        21, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG1_TOG.
static const field_t hw_usbphy_debug1_tog[] =
{
    {
        "ENTAILADJVD",
        "Delay increment of the rise of squelch:",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USB2_REFBIAS_VBGADJ",
        "",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USB2_REFBIAS_TST",
        "",
        21, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_VERSION.
static const field_t hw_usbphy_version[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_PLL_SIC.
static const field_t hw_usbphy_pll_sic[] =
{
    {
        "PLL_EN_USB_CLKS",
        "Enables the USB clock from PLL to USB PHY",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_POWER",
        "Power up the USB PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_ENABLE",
        "Enables the clock output from the USB PLL.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_BYPASS",
        "Bypass the USB PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFBIAS_PWD_SEL",
        "Reference bias power down select.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFBIAS_PWD",
        "This bit is only used when REFBIAS_PWD_SEL is set to 1.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_REG_ENABLE",
        "This field controls the USB PLL regulator, set to enable the regulator"
        ".",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_DIV_SEL",
        "This field controls the USB PLL feedback loop divider.",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_LOCK",
        "USB PLL lock status indicator",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_PLL_SIC_SET.
static const field_t hw_usbphy_pll_sic_set[] =
{
    {
        "PLL_EN_USB_CLKS",
        "Enables the USB clock from PLL to USB PHY",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_POWER",
        "Power up the USB PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_ENABLE",
        "Enables the clock output from the USB PLL.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_BYPASS",
        "Bypass the USB PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFBIAS_PWD_SEL",
        "Reference bias power down select.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFBIAS_PWD",
        "This bit is only used when REFBIAS_PWD_SEL is set to 1.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_REG_ENABLE",
        "This field controls the USB PLL regulator, set to enable the regulator"
        ".",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_DIV_SEL",
        "This field controls the USB PLL feedback loop divider.",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_LOCK",
        "USB PLL lock status indicator",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_PLL_SIC_CLR.
static const field_t hw_usbphy_pll_sic_clr[] =
{
    {
        "PLL_EN_USB_CLKS",
        "Enables the USB clock from PLL to USB PHY",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_POWER",
        "Power up the USB PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_ENABLE",
        "Enables the clock output from the USB PLL.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_BYPASS",
        "Bypass the USB PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFBIAS_PWD_SEL",
        "Reference bias power down select.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFBIAS_PWD",
        "This bit is only used when REFBIAS_PWD_SEL is set to 1.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_REG_ENABLE",
        "This field controls the USB PLL regulator, set to enable the regulator"
        ".",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_DIV_SEL",
        "This field controls the USB PLL feedback loop divider.",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_LOCK",
        "USB PLL lock status indicator",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_PLL_SIC_TOG.
static const field_t hw_usbphy_pll_sic_tog[] =
{
    {
        "PLL_EN_USB_CLKS",
        "Enables the USB clock from PLL to USB PHY",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_POWER",
        "Power up the USB PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_ENABLE",
        "Enables the clock output from the USB PLL.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_BYPASS",
        "Bypass the USB PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFBIAS_PWD_SEL",
        "Reference bias power down select.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFBIAS_PWD",
        "This bit is only used when REFBIAS_PWD_SEL is set to 1.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_REG_ENABLE",
        "This field controls the USB PLL regulator, set to enable the regulator"
        ".",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_DIV_SEL",
        "This field controls the USB PLL feedback loop divider.",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_LOCK",
        "USB PLL lock status indicator",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_VBUS_DETECT.
static const field_t hw_usbphy_usb1_vbus_detect[] =
{
    {
        "VBUSVALID_THRESH",
        "Sets the threshold for the VBUSVALID comparator.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUS_OVERRIDE_EN",
        "This bit field allows SW to override the results from the VBUS_VALID a"
        "nd Session Valid comparators using the values in USBPHY_USB1_VBUS_DETE"
        "CT[7:4].",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SESSEND_OVERRIDE",
        "The bit field provides the value for USBPHY_USB1_VBUS_DET_STAT[0] if U"
        "SBPHY_USB_VBUS_DETECT[3] is set to value 1'b1.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BVALID_OVERRIDE",
        "The bit field provides the value for USBPHY_USB1_VBUS_DET_STAT[1] if U"
        "SBPHY_USB_VBUS_DETECT[3] is set to value 1'b1.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVALID_OVERRIDE",
        "The bit field provides the value for USBPHY_USB1_VBUS_DET_STAT[2] if U"
        "SBPHY_USB_VBUS_DETECT[3] is set to value 1'b1.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_OVERRIDE",
        "The bit field provides the value for VBUS_VALID reported to the USB co"
        "ntroller if the value of USBPHY_USB1_VBUS_DETECT[3] is set to 1'b1.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_SEL",
        "This is one of the bit fields that selects the source of the VBUS_VALI"
        "D signal reported to the USB controller.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUS_SOURCE_SEL",
        "This is one of the bit fields that selects the source of the VBUS_VALI"
        "D signal reported to the USB controller.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_TO_SESSVALID",
        "This bit field controls the comparator used to report the VBUS_VALID r"
        "esults in USBPHY_USB1_VBUS_DETECT[3] between the VBUS_VALID comparator"
        " and the Session Valid comparator.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWRUP_CMPS",
        "Powers up the comparator used for the VBUS_VALID detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCHARGE_VBUS",
        "This bit field controls a nominal 22kohm resistor between the USB1_VBU"
        "S pin and ground.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CHARGER_RESISTOR",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_VBUS_DETECT_SET.
static const field_t hw_usbphy_usb1_vbus_detect_set[] =
{
    {
        "VBUSVALID_THRESH",
        "Sets the threshold for the VBUSVALID comparator.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUS_OVERRIDE_EN",
        "This bit field allows SW to override the results from the VBUS_VALID a"
        "nd Session Valid comparators using the values in USBPHY_USB1_VBUS_DETE"
        "CT[7:4].",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SESSEND_OVERRIDE",
        "The bit field provides the value for USBPHY_USB1_VBUS_DET_STAT[0] if U"
        "SBPHY_USB_VBUS_DETECT[3] is set to value 1'b1.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BVALID_OVERRIDE",
        "The bit field provides the value for USBPHY_USB1_VBUS_DET_STAT[1] if U"
        "SBPHY_USB_VBUS_DETECT[3] is set to value 1'b1.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVALID_OVERRIDE",
        "The bit field provides the value for USBPHY_USB1_VBUS_DET_STAT[2] if U"
        "SBPHY_USB_VBUS_DETECT[3] is set to value 1'b1.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_OVERRIDE",
        "The bit field provides the value for VBUS_VALID reported to the USB co"
        "ntroller if the value of USBPHY_USB1_VBUS_DETECT[3] is set to 1'b1.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_SEL",
        "This is one of the bit fields that selects the source of the VBUS_VALI"
        "D signal reported to the USB controller.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUS_SOURCE_SEL",
        "This is one of the bit fields that selects the source of the VBUS_VALI"
        "D signal reported to the USB controller.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_TO_SESSVALID",
        "This bit field controls the comparator used to report the VBUS_VALID r"
        "esults in USBPHY_USB1_VBUS_DETECT[3] between the VBUS_VALID comparator"
        " and the Session Valid comparator.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWRUP_CMPS",
        "Powers up the comparator used for the VBUS_VALID detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCHARGE_VBUS",
        "This bit field controls a nominal 22kohm resistor between the USB1_VBU"
        "S pin and ground.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CHARGER_RESISTOR",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_VBUS_DETECT_CLR.
static const field_t hw_usbphy_usb1_vbus_detect_clr[] =
{
    {
        "VBUSVALID_THRESH",
        "Sets the threshold for the VBUSVALID comparator.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUS_OVERRIDE_EN",
        "This bit field allows SW to override the results from the VBUS_VALID a"
        "nd Session Valid comparators using the values in USBPHY_USB1_VBUS_DETE"
        "CT[7:4].",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SESSEND_OVERRIDE",
        "The bit field provides the value for USBPHY_USB1_VBUS_DET_STAT[0] if U"
        "SBPHY_USB_VBUS_DETECT[3] is set to value 1'b1.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BVALID_OVERRIDE",
        "The bit field provides the value for USBPHY_USB1_VBUS_DET_STAT[1] if U"
        "SBPHY_USB_VBUS_DETECT[3] is set to value 1'b1.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVALID_OVERRIDE",
        "The bit field provides the value for USBPHY_USB1_VBUS_DET_STAT[2] if U"
        "SBPHY_USB_VBUS_DETECT[3] is set to value 1'b1.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_OVERRIDE",
        "The bit field provides the value for VBUS_VALID reported to the USB co"
        "ntroller if the value of USBPHY_USB1_VBUS_DETECT[3] is set to 1'b1.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_SEL",
        "This is one of the bit fields that selects the source of the VBUS_VALI"
        "D signal reported to the USB controller.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUS_SOURCE_SEL",
        "This is one of the bit fields that selects the source of the VBUS_VALI"
        "D signal reported to the USB controller.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_TO_SESSVALID",
        "This bit field controls the comparator used to report the VBUS_VALID r"
        "esults in USBPHY_USB1_VBUS_DETECT[3] between the VBUS_VALID comparator"
        " and the Session Valid comparator.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWRUP_CMPS",
        "Powers up the comparator used for the VBUS_VALID detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCHARGE_VBUS",
        "This bit field controls a nominal 22kohm resistor between the USB1_VBU"
        "S pin and ground.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CHARGER_RESISTOR",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_VBUS_DETECT_TOG.
static const field_t hw_usbphy_usb1_vbus_detect_tog[] =
{
    {
        "VBUSVALID_THRESH",
        "Sets the threshold for the VBUSVALID comparator.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUS_OVERRIDE_EN",
        "This bit field allows SW to override the results from the VBUS_VALID a"
        "nd Session Valid comparators using the values in USBPHY_USB1_VBUS_DETE"
        "CT[7:4].",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SESSEND_OVERRIDE",
        "The bit field provides the value for USBPHY_USB1_VBUS_DET_STAT[0] if U"
        "SBPHY_USB_VBUS_DETECT[3] is set to value 1'b1.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BVALID_OVERRIDE",
        "The bit field provides the value for USBPHY_USB1_VBUS_DET_STAT[1] if U"
        "SBPHY_USB_VBUS_DETECT[3] is set to value 1'b1.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVALID_OVERRIDE",
        "The bit field provides the value for USBPHY_USB1_VBUS_DET_STAT[2] if U"
        "SBPHY_USB_VBUS_DETECT[3] is set to value 1'b1.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_OVERRIDE",
        "The bit field provides the value for VBUS_VALID reported to the USB co"
        "ntroller if the value of USBPHY_USB1_VBUS_DETECT[3] is set to 1'b1.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_SEL",
        "This is one of the bit fields that selects the source of the VBUS_VALI"
        "D signal reported to the USB controller.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUS_SOURCE_SEL",
        "This is one of the bit fields that selects the source of the VBUS_VALI"
        "D signal reported to the USB controller.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUSVALID_TO_SESSVALID",
        "This bit field controls the comparator used to report the VBUS_VALID r"
        "esults in USBPHY_USB1_VBUS_DETECT[3] between the VBUS_VALID comparator"
        " and the Session Valid comparator.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWRUP_CMPS",
        "Powers up the comparator used for the VBUS_VALID detector.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCHARGE_VBUS",
        "This bit field controls a nominal 22kohm resistor between the USB1_VBU"
        "S pin and ground.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_CHARGER_RESISTOR",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_VBUS_DET_STAT.
static const field_t hw_usbphy_usb1_vbus_det_stat[] =
{
    {
        "SESSEND",
        "Session End status, value inverted from Session Valid comparator.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BVALID",
        "B-Device Session Valid status, determined by the Session Valid compara"
        "tor.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AVALID",
        "A-Device Session Valid status, determined by the Session Valid compara"
        "tor.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VBUS_VALID",
        "This bit field shows the result of VBUS_VALID detection for the USB1_V"
        "BUS pin.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VBUS_VALID_3V",
        "The VBUS_VALID_3V detector has a lower threshold for the voltage on th"
        "e USB1_VBUS pin than either the Session Valid or VBUS_VALID comparator"
        "s.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_CHRG_DETECT.
static const field_t hw_usbphy_usb1_chrg_detect[] =
{
    {
        "PULLUP_DP",
        "This bit is used to pull up DP, for digital charge detect.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_CHRG_DETECT_SET.
static const field_t hw_usbphy_usb1_chrg_detect_set[] =
{
    {
        "PULLUP_DP",
        "This bit is used to pull up DP, for digital charge detect.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_CHRG_DETECT_CLR.
static const field_t hw_usbphy_usb1_chrg_detect_clr[] =
{
    {
        "PULLUP_DP",
        "This bit is used to pull up DP, for digital charge detect.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_CHRG_DETECT_TOG.
static const field_t hw_usbphy_usb1_chrg_detect_tog[] =
{
    {
        "PULLUP_DP",
        "This bit is used to pull up DP, for digital charge detect.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_CHRG_DET_STAT.
static const field_t hw_usbphy_usb1_chrg_det_stat[] =
{
    {
        "PLUG_CONTACT",
        "During the Data Contact Detection phase per the USB Battery Charging S"
        "pecification Revision 1.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHRG_DETECTED",
        "During the USB Battery Charging Primary Detection phase using the USBH"
        "SDCD module, this bit field indicates whether a Standard Downstream Po"
        "rt or Charging Port was detected.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DM_STATE",
        "Single ended receiver output for the USB_DM pin, from charger detectio"
        "n circuits.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DP_STATE",
        "Single ended receiver output for the USB_DP pin, from charger detectio"
        "n circuits.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SECDET_DCP",
        "During the USB Battery Charging Secondary Detection phase using the US"
        "BHSDCD module, this bit field indicates which kind of Charging Port wa"
        "s detected.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_ANACTRL.
static const field_t hw_usbphy_anactrl[] =
{
    {
        "DEV_PULLDOWN",
        "Setting this field to 1'b1 will enable the 15kohm pulldown resistors o"
        "n both USB_DP and USB_DM pins.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_ANACTRL_SET.
static const field_t hw_usbphy_anactrl_set[] =
{
    {
        "DEV_PULLDOWN",
        "Setting this field to 1'b1 will enable the 15kohm pulldown resistors o"
        "n both USB_DP and USB_DM pins.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_ANACTRL_CLR.
static const field_t hw_usbphy_anactrl_clr[] =
{
    {
        "DEV_PULLDOWN",
        "Setting this field to 1'b1 will enable the 15kohm pulldown resistors o"
        "n both USB_DP and USB_DM pins.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_ANACTRL_TOG.
static const field_t hw_usbphy_anactrl_tog[] =
{
    {
        "DEV_PULLDOWN",
        "Setting this field to 1'b1 will enable the 15kohm pulldown resistors o"
        "n both USB_DP and USB_DM pins.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_LOOPBACK.
static const field_t hw_usbphy_usb1_loopback[] =
{
    {
        "UTMI_TESTSTART",
        "This bit enables the USB loopback test.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_DIG_TST0",
        "Mode control for USB loopback test.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_DIG_TST1",
        "Mode control for USB loopback test.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_TX_HS_MODE",
        "Select HS or FS mode for USB loopback testing.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_TX_LS_MODE",
        "Set to value 1'b1 to choose LS for USB loopback testing, set to value "
        "1'b0 to choose HS or FS mode which is defined by TSTI1_TX_HS.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_TX_EN",
        "Enable TX for USB loopback test.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_TX_HIZ",
        "Sets TX Hi-Z for USB loopback test.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMO_DIG_TST0",
        "This read-only bit is a status bit for USB loopback test results.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UTMO_DIG_TST1",
        "This read-only bit is a status bit for USB loopback test.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSTI_HSFS_MODE_EN",
        "Setting this bit field to value 1'b1 will enable the loopback test to "
        "dynamically change the packet speed.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTPKT",
        "Selects the packet data byte used for USB loopback testing in Pulse mo"
        "de.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_LOOPBACK_SET.
static const field_t hw_usbphy_usb1_loopback_set[] =
{
    {
        "UTMI_TESTSTART",
        "This bit enables the USB loopback test.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_DIG_TST0",
        "Mode control for USB loopback test.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_DIG_TST1",
        "Mode control for USB loopback test.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_TX_HS_MODE",
        "Select HS or FS mode for USB loopback testing.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_TX_LS_MODE",
        "Set to value 1'b1 to choose LS for USB loopback testing, set to value "
        "1'b0 to choose HS or FS mode which is defined by TSTI1_TX_HS.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_TX_EN",
        "Enable TX for USB loopback test.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_TX_HIZ",
        "Sets TX Hi-Z for USB loopback test.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMO_DIG_TST0",
        "This read-only bit is a status bit for USB loopback test results.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UTMO_DIG_TST1",
        "This read-only bit is a status bit for USB loopback test.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSTI_HSFS_MODE_EN",
        "Setting this bit field to value 1'b1 will enable the loopback test to "
        "dynamically change the packet speed.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTPKT",
        "Selects the packet data byte used for USB loopback testing in Pulse mo"
        "de.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_LOOPBACK_CLR.
static const field_t hw_usbphy_usb1_loopback_clr[] =
{
    {
        "UTMI_TESTSTART",
        "This bit enables the USB loopback test.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_DIG_TST0",
        "Mode control for USB loopback test.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_DIG_TST1",
        "Mode control for USB loopback test.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_TX_HS_MODE",
        "Select HS or FS mode for USB loopback testing.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_TX_LS_MODE",
        "Set to value 1'b1 to choose LS for USB loopback testing, set to value "
        "1'b0 to choose HS or FS mode which is defined by TSTI1_TX_HS.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_TX_EN",
        "Enable TX for USB loopback test.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_TX_HIZ",
        "Sets TX Hi-Z for USB loopback test.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMO_DIG_TST0",
        "This read-only bit is a status bit for USB loopback test results.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UTMO_DIG_TST1",
        "This read-only bit is a status bit for USB loopback test.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSTI_HSFS_MODE_EN",
        "Setting this bit field to value 1'b1 will enable the loopback test to "
        "dynamically change the packet speed.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTPKT",
        "Selects the packet data byte used for USB loopback testing in Pulse mo"
        "de.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_LOOPBACK_TOG.
static const field_t hw_usbphy_usb1_loopback_tog[] =
{
    {
        "UTMI_TESTSTART",
        "This bit enables the USB loopback test.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_DIG_TST0",
        "Mode control for USB loopback test.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_DIG_TST1",
        "Mode control for USB loopback test.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_TX_HS_MODE",
        "Select HS or FS mode for USB loopback testing.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_TX_LS_MODE",
        "Set to value 1'b1 to choose LS for USB loopback testing, set to value "
        "1'b0 to choose HS or FS mode which is defined by TSTI1_TX_HS.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_TX_EN",
        "Enable TX for USB loopback test.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_TX_HIZ",
        "Sets TX Hi-Z for USB loopback test.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMO_DIG_TST0",
        "This read-only bit is a status bit for USB loopback test results.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UTMO_DIG_TST1",
        "This read-only bit is a status bit for USB loopback test.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSTI_HSFS_MODE_EN",
        "Setting this bit field to value 1'b1 will enable the loopback test to "
        "dynamically change the packet speed.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTPKT",
        "Selects the packet data byte used for USB loopback testing in Pulse mo"
        "de.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_LOOPBACK_HSFSCNT.
static const field_t hw_usbphy_usb1_loopback_hsfscnt[] =
{
    {
        "TSTI_HS_NUMBER",
        "High speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MOD"
        "E_EN] is set to value 1'b1.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_FS_NUMBER",
        "Full speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MOD"
        "E_EN] is set to value 1'b1.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_LOOPBACK_HSFSCNT_SET.
static const field_t hw_usbphy_usb1_loopback_hsfscnt_set[] =
{
    {
        "TSTI_HS_NUMBER",
        "High speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MOD"
        "E_EN] is set to value 1'b1.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_FS_NUMBER",
        "Full speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MOD"
        "E_EN] is set to value 1'b1.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_LOOPBACK_HSFSCNT_CLR.
static const field_t hw_usbphy_usb1_loopback_hsfscnt_clr[] =
{
    {
        "TSTI_HS_NUMBER",
        "High speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MOD"
        "E_EN] is set to value 1'b1.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_FS_NUMBER",
        "Full speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MOD"
        "E_EN] is set to value 1'b1.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_USB1_LOOPBACK_HSFSCNT_TOG.
static const field_t hw_usbphy_usb1_loopback_hsfscnt_tog[] =
{
    {
        "TSTI_HS_NUMBER",
        "High speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MOD"
        "E_EN] is set to value 1'b1.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSTI_FS_NUMBER",
        "Full speed packet number, used when USBPHY_USB1_LOOPBACK[TSTI_HSFS_MOD"
        "E_EN] is set to value 1'b1.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TRIM_OVERRIDE_EN.
static const field_t hw_usbphy_trim_override_en[] =
{
    {
        "TRIM_DIV_SEL_OVERRIDE",
        "Override enable for PLL_DIV_SEL, when set, the register value in USBPH"
        "Y_PLL_SIC[1:0] will be used.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_ENV_TAIL_ADJ_VD_OVERRIDE",
        "Override enable for ENV_TAIL_ADJ, when set, the register value in USBP"
        "HY_DEBUG1[14:13] will be used.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_TX_D_CAL_OVERRIDE",
        "Override enable for TX_D_CAL, when set, the register value in USBPHY_T"
        "X[3:0] will be used.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_TX_CAL45DP_OVERRIDE",
        "Override enable for TX_CAL45DP, when set, the register value in USBPHY"
        "_TX[19:16] will be used.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_TX_CAL45DM_OVERRIDE",
        "Override enable for TX_CAL45DM, when set, the register value in USBPHY"
        "_TX[11:8] will be used.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_REFBIAS_VBGADJ_OVERRIDE",
        "When this field is set, the register value in USBPHY_DEBUG1[20:18] wil"
        "l be used.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_REFBIAS_TST_OVERRIDE",
        "When this field is set, the register value in USBPHY_DEBUG1[22:21] wil"
        "l be used.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_USB2_REFBIAS_VBGADJ",
        "Adjustment bits for bandgap",
        10, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USB2_REFBIAS_TST",
        "Bias current control for usb2_phy",
        13, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_PLL_CTRL0_DIV_SEL",
        "IFR value of PLL_DIV_SEL.",
        15, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USB_REG_ENV_TAIL_ADJ_VD",
        "IFR value of ENV_TAIL_ADJ.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USBPHY_TX_D_CAL",
        "IFR value of TX_D_CAL.",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USBPHY_TX_CAL45DP",
        "IFR value of TX_CAL45DP.",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USBPHY_TX_CAL45DM",
        "IFR value of TX_CAL45DM.",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TRIM_OVERRIDE_EN_SET.
static const field_t hw_usbphy_trim_override_en_set[] =
{
    {
        "TRIM_DIV_SEL_OVERRIDE",
        "Override enable for PLL_DIV_SEL, when set, the register value in USBPH"
        "Y_PLL_SIC[1:0] will be used.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_ENV_TAIL_ADJ_VD_OVERRIDE",
        "Override enable for ENV_TAIL_ADJ, when set, the register value in USBP"
        "HY_DEBUG1[14:13] will be used.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_TX_D_CAL_OVERRIDE",
        "Override enable for TX_D_CAL, when set, the register value in USBPHY_T"
        "X[3:0] will be used.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_TX_CAL45DP_OVERRIDE",
        "Override enable for TX_CAL45DP, when set, the register value in USBPHY"
        "_TX[19:16] will be used.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_TX_CAL45DM_OVERRIDE",
        "Override enable for TX_CAL45DM, when set, the register value in USBPHY"
        "_TX[11:8] will be used.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_REFBIAS_VBGADJ_OVERRIDE",
        "When this field is set, the register value in USBPHY_DEBUG1[20:18] wil"
        "l be used.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_REFBIAS_TST_OVERRIDE",
        "When this field is set, the register value in USBPHY_DEBUG1[22:21] wil"
        "l be used.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_USB2_REFBIAS_VBGADJ",
        "Adjustment bits for bandgap",
        10, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USB2_REFBIAS_TST",
        "Bias current control for usb2_phy",
        13, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_PLL_CTRL0_DIV_SEL",
        "IFR value of PLL_DIV_SEL.",
        15, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USB_REG_ENV_TAIL_ADJ_VD",
        "IFR value of ENV_TAIL_ADJ.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USBPHY_TX_D_CAL",
        "IFR value of TX_D_CAL.",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USBPHY_TX_CAL45DP",
        "IFR value of TX_CAL45DP.",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USBPHY_TX_CAL45DM",
        "IFR value of TX_CAL45DM.",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TRIM_OVERRIDE_EN_CLR.
static const field_t hw_usbphy_trim_override_en_clr[] =
{
    {
        "TRIM_DIV_SEL_OVERRIDE",
        "Override enable for PLL_DIV_SEL, when set, the register value in USBPH"
        "Y_PLL_SIC[1:0] will be used.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_ENV_TAIL_ADJ_VD_OVERRIDE",
        "Override enable for ENV_TAIL_ADJ, when set, the register value in USBP"
        "HY_DEBUG1[14:13] will be used.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_TX_D_CAL_OVERRIDE",
        "Override enable for TX_D_CAL, when set, the register value in USBPHY_T"
        "X[3:0] will be used.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_TX_CAL45DP_OVERRIDE",
        "Override enable for TX_CAL45DP, when set, the register value in USBPHY"
        "_TX[19:16] will be used.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_TX_CAL45DM_OVERRIDE",
        "Override enable for TX_CAL45DM, when set, the register value in USBPHY"
        "_TX[11:8] will be used.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_REFBIAS_VBGADJ_OVERRIDE",
        "When this field is set, the register value in USBPHY_DEBUG1[20:18] wil"
        "l be used.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_REFBIAS_TST_OVERRIDE",
        "When this field is set, the register value in USBPHY_DEBUG1[22:21] wil"
        "l be used.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_USB2_REFBIAS_VBGADJ",
        "Adjustment bits for bandgap",
        10, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USB2_REFBIAS_TST",
        "Bias current control for usb2_phy",
        13, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_PLL_CTRL0_DIV_SEL",
        "IFR value of PLL_DIV_SEL.",
        15, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USB_REG_ENV_TAIL_ADJ_VD",
        "IFR value of ENV_TAIL_ADJ.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USBPHY_TX_D_CAL",
        "IFR value of TX_D_CAL.",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USBPHY_TX_CAL45DP",
        "IFR value of TX_CAL45DP.",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USBPHY_TX_CAL45DM",
        "IFR value of TX_CAL45DM.",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TRIM_OVERRIDE_EN_TOG.
static const field_t hw_usbphy_trim_override_en_tog[] =
{
    {
        "TRIM_DIV_SEL_OVERRIDE",
        "Override enable for PLL_DIV_SEL, when set, the register value in USBPH"
        "Y_PLL_SIC[1:0] will be used.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_ENV_TAIL_ADJ_VD_OVERRIDE",
        "Override enable for ENV_TAIL_ADJ, when set, the register value in USBP"
        "HY_DEBUG1[14:13] will be used.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_TX_D_CAL_OVERRIDE",
        "Override enable for TX_D_CAL, when set, the register value in USBPHY_T"
        "X[3:0] will be used.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_TX_CAL45DP_OVERRIDE",
        "Override enable for TX_CAL45DP, when set, the register value in USBPHY"
        "_TX[19:16] will be used.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_TX_CAL45DM_OVERRIDE",
        "Override enable for TX_CAL45DM, when set, the register value in USBPHY"
        "_TX[11:8] will be used.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_REFBIAS_VBGADJ_OVERRIDE",
        "When this field is set, the register value in USBPHY_DEBUG1[20:18] wil"
        "l be used.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_REFBIAS_TST_OVERRIDE",
        "When this field is set, the register value in USBPHY_DEBUG1[22:21] wil"
        "l be used.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIM_USB2_REFBIAS_VBGADJ",
        "Adjustment bits for bandgap",
        10, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USB2_REFBIAS_TST",
        "Bias current control for usb2_phy",
        13, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_PLL_CTRL0_DIV_SEL",
        "IFR value of PLL_DIV_SEL.",
        15, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USB_REG_ENV_TAIL_ADJ_VD",
        "IFR value of ENV_TAIL_ADJ.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USBPHY_TX_D_CAL",
        "IFR value of TX_D_CAL.",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USBPHY_TX_CAL45DP",
        "IFR value of TX_CAL45DP.",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRIM_USBPHY_TX_CAL45DM",
        "IFR value of TX_CAL45DM.",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a USBPHY module.
static const reg_t hw_usbphy[] =
{
    {
        "PWD",
        "The USB PHY Power-Down Register provides overall control of the PHY po"
        "wer state.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_usbphy_pwd
    },
    {
        "PWD_SET",
        "The USB PHY Power-Down Register provides overall control of the PHY po"
        "wer state.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_usbphy_pwd_set
    },
    {
        "PWD_CLR",
        "The USB PHY Power-Down Register provides overall control of the PHY po"
        "wer state.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_usbphy_pwd_clr
    },
    {
        "PWD_TOG",
        "The USB PHY Power-Down Register provides overall control of the PHY po"
        "wer state.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_usbphy_pwd_tog
    },
    {
        "TX",
        "The USB PHY Transmitter Control Register handles the transmit controls"
        ".",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_usbphy_tx
    },
    {
        "TX_SET",
        "The USB PHY Transmitter Control Register handles the transmit controls"
        ".",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_usbphy_tx_set
    },
    {
        "TX_CLR",
        "The USB PHY Transmitter Control Register handles the transmit controls"
        ".",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_usbphy_tx_clr
    },
    {
        "TX_TOG",
        "The USB PHY Transmitter Control Register handles the transmit controls"
        ".",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_usbphy_tx_tog
    },
    {
        "RX",
        "The USB PHY Receiver Control Register handles receive path controls.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_rx
    },
    {
        "RX_SET",
        "The USB PHY Receiver Control Register handles receive path controls.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_rx_set
    },
    {
        "RX_CLR",
        "The USB PHY Receiver Control Register handles receive path controls.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_rx_clr
    },
    {
        "RX_TOG",
        "The USB PHY Receiver Control Register handles receive path controls.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_rx_tog
    },
    {
        "CTRL",
        "The USB PHY General Control Register handles OTG and Host controls.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbphy_ctrl
    },
    {
        "CTRL_SET",
        "The USB PHY General Control Register handles OTG and Host controls.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbphy_ctrl_set
    },
    {
        "CTRL_CLR",
        "The USB PHY General Control Register handles OTG and Host controls.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbphy_ctrl_clr
    },
    {
        "CTRL_TOG",
        "The USB PHY General Control Register handles OTG and Host controls.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbphy_ctrl_tog
    },
    {
        "STATUS",
        "The USB PHY Status Register holds results of IRQ and other detects.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usbphy_status
    },
    {
        "DEBUG0",
        "This register is used to debug the USB PHY.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_usbphy_debug0
    },
    {
        "DEBUG0_SET",
        "This register is used to debug the USB PHY.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_usbphy_debug0_set
    },
    {
        "DEBUG0_CLR",
        "This register is used to debug the USB PHY.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_usbphy_debug0_clr
    },
    {
        "DEBUG0_TOG",
        "This register is used to debug the USB PHY.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_usbphy_debug0_tog
    },
    {
        "DEBUG1",
        "Chooses the muxing of the debug register to be shown in USBPHYx_DEBUG0"
        "_STATUS.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_debug1
    },
    {
        "DEBUG1_SET",
        "Chooses the muxing of the debug register to be shown in USBPHYx_DEBUG0"
        "_STATUS.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_debug1_set
    },
    {
        "DEBUG1_CLR",
        "Chooses the muxing of the debug register to be shown in USBPHYx_DEBUG0"
        "_STATUS.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_debug1_clr
    },
    {
        "DEBUG1_TOG",
        "Chooses the muxing of the debug register to be shown in USBPHYx_DEBUG0"
        "_STATUS.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_debug1_tog
    },
    {
        "VERSION",
        "Fields for RTL Version.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbphy_version
    },
    {
        "PLL_SIC",
        "This register configures the 480 MHz USB PHY PLL.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usbphy_pll_sic
    },
    {
        "PLL_SIC_SET",
        "This register configures the 480 MHz USB PHY PLL.",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usbphy_pll_sic_set
    },
    {
        "PLL_SIC_CLR",
        "This register configures the 480 MHz USB PHY PLL.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usbphy_pll_sic_clr
    },
    {
        "PLL_SIC_TOG",
        "This register configures the 480 MHz USB PHY PLL.",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usbphy_pll_sic_tog
    },
    {
        "USB1_VBUS_DETECT",
        "This register defines controls for USB VBUS detect and some additional"
        " out of band signaling functions.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbphy_usb1_vbus_detect
    },
    {
        "USB1_VBUS_DETECT_SET",
        "This register defines controls for USB VBUS detect and some additional"
        " out of band signaling functions.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbphy_usb1_vbus_detect_set
    },
    {
        "USB1_VBUS_DETECT_CLR",
        "This register defines controls for USB VBUS detect and some additional"
        " out of band signaling functions.",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbphy_usb1_vbus_detect_clr
    },
    {
        "USB1_VBUS_DETECT_TOG",
        "This register defines controls for USB VBUS detect and some additional"
        " out of band signaling functions.",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usbphy_usb1_vbus_detect_tog
    },
    {
        "USB1_VBUS_DET_STAT",
        "This register allows observation of status for USB VBUS detect functio"
        "ns.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_usbphy_usb1_vbus_det_stat
    },
    {
        "USB1_CHRG_DETECT",
        "This register defines controls for USB Battery Charging detection func"
        "tions.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbphy_usb1_chrg_detect
    },
    {
        "USB1_CHRG_DETECT_SET",
        "This register defines controls for USB Battery Charging detection func"
        "tions.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbphy_usb1_chrg_detect_set
    },
    {
        "USB1_CHRG_DETECT_CLR",
        "This register defines controls for USB Battery Charging detection func"
        "tions.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbphy_usb1_chrg_detect_clr
    },
    {
        "USB1_CHRG_DETECT_TOG",
        "This register defines controls for USB Battery Charging detection func"
        "tions.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbphy_usb1_chrg_detect_tog
    },
    {
        "USB1_CHRG_DET_STAT",
        "The control of the USB Battery Charging detection functions has been m"
        "oved to the USBHSDCD instantiation of the USBDCD module for this produ"
        "ct.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_usbphy_usb1_chrg_det_stat
    },
    {
        "ANACTRL",
        "The USBPHY_ANACTRL register a bit field to allow an additional type of"
        " control of 15 kohm pulldown resistors on both USB_DP and USB_DM pins.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbphy_anactrl
    },
    {
        "ANACTRL_SET",
        "The USBPHY_ANACTRL register a bit field to allow an additional type of"
        " control of 15 kohm pulldown resistors on both USB_DP and USB_DM pins.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbphy_anactrl_set
    },
    {
        "ANACTRL_CLR",
        "The USBPHY_ANACTRL register a bit field to allow an additional type of"
        " control of 15 kohm pulldown resistors on both USB_DP and USB_DM pins.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbphy_anactrl_clr
    },
    {
        "ANACTRL_TOG",
        "The USBPHY_ANACTRL register a bit field to allow an additional type of"
        " control of 15 kohm pulldown resistors on both USB_DP and USB_DM pins.",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbphy_anactrl_tog
    },
    {
        "USB1_LOOPBACK",
        "This register controls loopback testing of the USB PHY.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_usbphy_usb1_loopback
    },
    {
        "USB1_LOOPBACK_SET",
        "This register controls loopback testing of the USB PHY.",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_usbphy_usb1_loopback_set
    },
    {
        "USB1_LOOPBACK_CLR",
        "This register controls loopback testing of the USB PHY.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_usbphy_usb1_loopback_clr
    },
    {
        "USB1_LOOPBACK_TOG",
        "This register controls loopback testing of the USB PHY.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_usbphy_usb1_loopback_tog
    },
    {
        "USB1_LOOPBACK_HSFSCNT",
        "",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbphy_usb1_loopback_hsfscnt
    },
    {
        "USB1_LOOPBACK_HSFSCNT_SET",
        "",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbphy_usb1_loopback_hsfscnt_set
    },
    {
        "USB1_LOOPBACK_HSFSCNT_CLR",
        "",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbphy_usb1_loopback_hsfscnt_clr
    },
    {
        "USB1_LOOPBACK_HSFSCNT_TOG",
        "",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usbphy_usb1_loopback_hsfscnt_tog
    },
    {
        "TRIM_OVERRIDE_EN",
        "The bit fields in this register allow observation of the default IFR s"
        "ettings of Phy parameters for TX_CAL45DM, TX_CAL45DP, TX_D_CAL, ENV_TA"
        "IL_ADJ, and PLL_DIV_SEL.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_usbphy_trim_override_en
    },
    {
        "TRIM_OVERRIDE_EN_SET",
        "The bit fields in this register allow observation of the default IFR s"
        "ettings of Phy parameters for TX_CAL45DM, TX_CAL45DP, TX_D_CAL, ENV_TA"
        "IL_ADJ, and PLL_DIV_SEL.",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_usbphy_trim_override_en_set
    },
    {
        "TRIM_OVERRIDE_EN_CLR",
        "The bit fields in this register allow observation of the default IFR s"
        "ettings of Phy parameters for TX_CAL45DM, TX_CAL45DP, TX_D_CAL, ENV_TA"
        "IL_ADJ, and PLL_DIV_SEL.",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_usbphy_trim_override_en_clr
    },
    {
        "TRIM_OVERRIDE_EN_TOG",
        "The bit fields in this register allow observation of the default IFR s"
        "ettings of Phy parameters for TX_CAL45DM, TX_CAL45DP, TX_D_CAL, ENV_TA"
        "IL_ADJ, and PLL_DIV_SEL.",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_usbphy_trim_override_en_tog
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USDHC
#endif

// Bitfields in register USDHC_DS_ADDR.
static const field_t hw_usdhc_ds_addr[] =
{
    {
        "DS_ADDR",
        "DMA System Address: This register contains the 32-bit system memory ad"
        "dress for a DMA transfer.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_BLK_ATT.
static const field_t hw_usdhc_blk_att[] =
{
    {
        "BLKSIZE",
        "Transfer Block Size: This register specifies the block size for block "
        "data transfers.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BLKCNT",
        "Blocks Count For Current Transfer: This register is enabled when the B"
        "lock Count Enable bit in the Transfer Mode register is set to 1 and is"
        " valid only for multiple block transfers.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_ARG.
static const field_t hw_usdhc_cmd_arg[] =
{
    {
        "CMDARG",
        "The SD / MMC Command Argument is specified as bits 39-8 of the Command"
        " Format in the SD or MMC Specification.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_XFR_TYP.
static const field_t hw_usdhc_cmd_xfr_typ[] =
{
    {
        "RSPTYP",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCCEN",
        "If this bit is set to 1, the uSDHC shall check the CRC field in the re"
        "sponse.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CICEN",
        "If this bit is set to 1, the uSDHC will check the Index field in the r"
        "esponse to see if it has the same value as the command index.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPSEL",
        "This bit is set to 1 to indicate that data is present and shall be tra"
        "nsferred using the DATA line.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMDTYP",
        "There are three types of special commands: Suspend, Resume and Abort.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMDINX",
        "These bits shall be set to the command number that is specified in bit"
        "s 45-40 of the Command-Format in the SD Memory Card Physical Layer Spe"
        "cification and SDIO Card Specification.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_RSP0.
static const field_t hw_usdhc_cmd_rsp0[] =
{
    {
        "CMDRSP0",
        "Refer to for the mapping of command responses from the SD Bus to this "
        "register for each response type.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_RSP1.
static const field_t hw_usdhc_cmd_rsp1[] =
{
    {
        "CMDRSP1",
        "Refer to for the mapping of command responses from the SD Bus to this "
        "register for each response type.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_RSP2.
static const field_t hw_usdhc_cmd_rsp2[] =
{
    {
        "CMDRSP2",
        "Refer to for the mapping of command responses from the SD Bus to this "
        "register for each response type.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CMD_RSP3.
static const field_t hw_usdhc_cmd_rsp3[] =
{
    {
        "CMDRSP3",
        "Refer to for the mapping of command responses from the SD Bus to this "
        "register for each response type.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_DATA_BUFF_ACC_PORT.
static const field_t hw_usdhc_data_buff_acc_port[] =
{
    {
        "DATCONT",
        "The Buffer Data Port register is for 32-bit data access by the ARM pla"
        "tform.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_PRES_STATE.
static const field_t hw_usdhc_pres_state[] =
{
    {
        "CIHB",
        "If this status bit is 0, it indicates that the CMD line is not in use "
        "and the uSDHC can issue a SD / MMC Command using the CMD line.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CDIHB",
        "This status bit is generated if either the DAT Line Active or the Read"
        " Transfer Active is set to 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLA",
        "This status bit indicates whether one of the DATA lines on the SD Bus "
        "is in use.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDSTB",
        "This status bit indicates that the internal card clock is stable.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IPGOFF",
        "This status bit indicates that the ipg_clk is internally gated off.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HCKOFF",
        "This status bit indicates that the HCLK is internally gated off.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PEROFF",
        "This status bit indicates that the IPG_PERCLK is internally gated off.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDOFF",
        "This status bit indicates that the SD Clock is internally gated off, b"
        "ecause of buffer over / under-run or read pause without read wait asse"
        "rtion, or the driver set FRC_SDCLK_ON bit is 0 to stop the SD clock in"
        " idle status.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WTA",
        "This status bit indicates a write transfer is active.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTA",
        "This status bit is used for detecting completion of a read transfer.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BWEN",
        "This status bit is used for non-DMA write transfers.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BREN",
        "This status bit is used for non-DMA read transfers.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTR",
        "Host Controller may request Host Driver to execute re-tuning sequence "
        "by setting this bit when the data window is shifted by temperature dri"
        "ft and a tuned sampling point does not have a good margin to receive c"
        "orrect data.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSCD",
        "This bit indicates the dealy setting is effective after write CLK_TUNE"
        "_CTRL_STATUS register.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CINST",
        "This bit indicates whether a card has been inserted.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CDPL",
        "This bit reflects the inverse value of the CD_B pin for the card socke"
        "t.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WPSPL",
        "The Write Protect Switch is supported for memory and combo cards.This "
        "bit reflects the inverted value of the WP pin of the card socket.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLSL",
        "This status is used to check the CMD line level to recover from errors"
        ", and for debugging.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLSL",
        "This status is used to check the DATA line level to recover from error"
        "s, and for debugging.This is especially useful in detecting the busy s"
        "ignal level from DATA0.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_PROT_CTRL.
static const field_t hw_usdhc_prot_ctrl[] =
{
    {
        "LCTL",
        "This bit, fully controlled by the Host Driver, is used to caution the "
        "user not to remove the card while the card is being accessed.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTW",
        "This bit selects the data width of the SD bus for a data transfer.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3CD",
        "If this bit is set, DATA3 should be pulled down to act as a card detec"
        "tion pin.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EMODE",
        "The uSDHC supports all three endian modes in data transfer.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CDTL",
        "This is bit is enabled while the Card Detection Signal Selection is se"
        "t to 1 and it indicates card insertion.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CDSS",
        "This bit selects the source for the card detection.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMASEL",
        "This field is valid while DMA (SDMA or ADMA) is enabled and selects th"
        "e DMA operation.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SABGREQ",
        "This bit is used to stop executing a transaction at the next block gap"
        " for both DMA and non-DMA transfers.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREQ",
        "This bit is used to restart a transaction which was stopped using the "
        "Stop At Block Gap Request.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWCTL",
        "The read wait function is optional for SDIO cards.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IABG",
        "This bit is valid only in 4-bit mode, of the SDIO card, and selects a "
        "sample point in the interrupt cycle.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DONE_NO_8CLK",
        "Read done no 8 clock: According to the SD/MMC spec, for read data tran"
        "saction, 8 clocks are needed after the end bit of the last data block.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WECINT",
        "This bit enables a wakeup event, via a Card Interrupt, in the Interrup"
        "t Status register.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WECINS",
        "This bit enables a wakeup event, via a Card Insertion, in the Interrup"
        "t Status register.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WECRM",
        "This bit enables a wakeup event, via a Card Removal, in the Interrupt "
        "Status register.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_LEN_EN",
        "This is used to enable / disable the burst length for the external AHB"
        "2AXI bridge.",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NON_EXACT_BLK_RD",
        "Current block read is non-exact block read.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_SYS_CTRL.
static const field_t hw_usdhc_sys_ctrl[] =
{
    {
        "DVS",
        "This register is used to provide a more exact divisor to generate the "
        "desired SD clock frequency.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDCLKFS",
        "This register is used to select the frequency of the SDCLK pin.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOCV",
        "This value determines the interval by which DAT line timeouts are dete"
        "cted.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPP_RST_N",
        "This register's value will be output to CARD from pad directly for har"
        "dware reset of the card if the card supports this feature.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTA",
        "This reset effects the entire Host Controller except for the card dete"
        "ction circuit.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTC",
        "Only part of the command circuit is reset.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTD",
        "Only part of the data circuit is reset.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INITA",
        "When this bit is set, 80 SD-Clocks are sent to the card.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTT",
        "When set this bit to 1, it will reset tuning circuit.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_INT_STATUS.
static const field_t hw_usdhc_int_status[] =
{
    {
        "CC",
        "This bit is set when you receive the end bit of the command response ("
        "except Auto CMD12).",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TC",
        "This bit is set when a read or write transfer is completed.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGE",
        "If the Stop At Block Gap Request bit in the Protocol Control register "
        "is set, this bit is set when a read or write transaction is stopped at"
        " a block gap.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DINT",
        "Occurs only when the internal DMA finishes the data transfer successfu"
        "lly.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWR",
        "This status bit is set if the Buffer Write Enable bit, in the Present "
        "State register, changes from 0 to 1.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRR",
        "This status bit is set if the Buffer Read Enable bit, in the Present S"
        "tate register, changes from 0 to 1.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINS",
        "This status bit is set if the Card Inserted bit in the Present State r"
        "egister changes from 0 to 1.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRM",
        "This status bit is set if the Card Inserted bit in the Present State r"
        "egister changes from 1 to 0.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINT",
        "This status bit is set when an interrupt signal is detected from the e"
        "xternal card.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTE",
        "This status is set if Re-Tuning Request in the Present State register "
        "changes from 0 to 1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TP",
        "Current CMD19 transfer is done successfully.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTOE",
        "Occurs only if no response is returned within 64 SDCLK cycles from the"
        " end bit of the command.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCE",
        "Command CRC Error is generated in two cases.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEBE",
        "Occurs when detecting that the end bit of a command response is 0.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIE",
        "Occurs if a Command Index error occurs in the command response.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOE",
        "Occurs when detecting one of following time-out conditions.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCE",
        "Occurs when detecting a CRC error when transferring read data, which u"
        "ses the DATA line, or when detecting the Write CRC status having a val"
        "ue other than 010.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBE",
        "Occurs either when detecting 0 at the end bit position of read data, w"
        "hich uses the DATA line, or at the end bit position of the CRC.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12E",
        "Occurs when detecting that one of the bits in the Auto CMD12 Error Sta"
        "tus register has changed from 0 to 1.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNE",
        "This bit is set when an unrecoverable error is detected in a tuning ci"
        "rcuit.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAE",
        "Occurs when an Internal DMA transfer has failed.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_INT_STATUS_EN.
static const field_t hw_usdhc_int_status_en[] =
{
    {
        "CCSEN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEN",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGESEN",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DINTSEN",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWRSEN",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRRSEN",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINSSEN",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRMSEN",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINTSEN",
        "If this bit is set to 0, the uSDHC will clear the interrupt request to"
        " the system.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTESEN",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPSEN",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTOESEN",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCESEN",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEBESEN",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIESEN",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOESEN",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCESEN",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBESEN",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12ESEN",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNESEN",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAESEN",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_INT_SIGNAL_EN.
static const field_t hw_usdhc_int_signal_en[] =
{
    {
        "CCIEN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCIEN",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGEIEN",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DINTIEN",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWRIEN",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRRIEN",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINSIEN",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRMIEN",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINTIEN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTEIEN",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPIEN",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTOEIEN",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCEIEN",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEBEIEN",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIEIEN",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOEIEN",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCEIEN",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBEIEN",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12EIEN",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNEIEN",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAEIEN",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_AUTOCMD12_ERR_STATUS.
static const field_t hw_usdhc_autocmd12_err_status[] =
{
    {
        "AC12NE",
        "If memory multiple block data transfer is not started, due to a comman"
        "d error, this bit is not set because it is not necessary to issue an A"
        "uto CMD12.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12TOE",
        "Occurs if no response is returned within 64 SDCLK cycles from the end "
        "bit of the command.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12EBE",
        "Occurs when detecting that the end bit of command response is 0 which "
        "should be 1.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12CE",
        "Occurs when detecting a CRC error in the command response.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12IE",
        "Occurs if the Command Index error occurs in response to a command.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CNIBAC12E",
        "Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto "
        "CMD12 Error (D04-D01) in this register.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EXECUTE_TUNING",
        "When std_tuning_en bit is set, this bit is used to start tuning proced"
        "ure.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMP_CLK_SEL",
        "When std_tuning_en bit is set, this bit is used to select sampling clo"
        "ck to receive CMD and DATA.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_HOST_CTRL_CAP.
static const field_t hw_usdhc_host_ctrl_cap[] =
{
    {
        "SDR50_SUPPORT",
        "This bit indicates support of SDR50 mode.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDR104_SUPPORT",
        "This bit indicates support of SDR104 mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR50_SUPPORT",
        "This bit indicates support of DDR50 mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TIME_COUNT_RETUNING",
        "This bit indicates an initial value of the Retuning Timer for Re-Tunin"
        "g Mode1 and 3.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USE_TUNING_SDR50",
        "This bit is set to 1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RETUNING_MODE",
        "This bit selects retuning method.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MBL",
        "This value indicates the maximum block size that the Host Driver can r"
        "ead and write to the buffer in the uSDHC.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADMAS",
        "This bit indicates whether the uSDHC supports the ADMA feature.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HSS",
        "This bit indicates whether the uSDHC supports High Speed mode and the "
        "Host System can supply a SD Clock frequency from 25 MHz to 50 MHz.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMAS",
        "This bit indicates whether the uSDHC is capable of using the internal "
        "DMA to transfer data between system memory and the data buffer directl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SRS",
        "This bit indicates whether the uSDHC supports Suspend / Resume functio"
        "nality.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VS33",
        "This bit shall depend on the Host System ability.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VS30",
        "This bit shall depend on the Host System ability.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VS18",
        "This bit shall depend on the Host System ability.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_WTMK_LVL.
static const field_t hw_usdhc_wtmk_lvl[] =
{
    {
        "RD_WML",
        "The number of words used as the watermark level (FIFO threshold) in a "
        "DMA read operation.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_BRST_LEN",
        "The number of words the uSDHC reads in a single burst.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_WML",
        "The number of words used as the watermark level (FIFO threshold) in a "
        "DMA write operation.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_BRST_LEN",
        "The number of words the uSDHC writes in a single burst.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_MIX_CTRL.
static const field_t hw_usdhc_mix_ctrl[] =
{
    {
        "DMAEN",
        "This bit enables DMA functionality.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCEN",
        "This bit is used to enable the Block Count register, which is only rel"
        "evant for multiple block transfers.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12EN",
        "Multiple block transfers for memory require a CMD12 to stop the transa"
        "ction.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_EN",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTDSEL",
        "This bit defines the direction of DATA line data transfers.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSBSEL",
        "This bit enables multiple block DATA line data transfers.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NIBBLE_POS",
        "In DDR 4-bit mode nibble position indictation.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC23EN",
        "When this bit is set to 1, the Host Controller issues a CMD23 automati"
        "cally before issuing a command specified in the Command Register.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXE_TUNE",
        "When STD_TUNING_EN is 0, this bit is set to 1 to indicate the Host Dri"
        "ver is starting tuning procedure.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMP_CLK_SEL",
        "When STD_TUNING_EN is 0, this bit is used to select Tuned clock or Fix"
        "ed clock to sample data / cmd (Only used for SD3.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTO_TUNE_EN",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FBCLK_SEL",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HS400_MODE",
        "HS400 Enable",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_FORCE_EVENT.
static const field_t hw_usdhc_force_event[] =
{
    {
        "FEVTAC12NE",
        "Forces the AC12NE bit in the Auto Command12 Error Status Register to b"
        "e set.",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTAC12TOE",
        "Forces the AC12TOE bit in the Auto Command12 Error Status Register to "
        "be set.",
        1, // LSB
        1, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTAC12CE",
        "Forces the AC12CE bit in the Auto Command12 Error Status Register to b"
        "e set.",
        2, // LSB
        2, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTAC12EBE",
        "Forces the AC12EBE bit in the Auto Command12 Error Status Register to "
        "be set.",
        3, // LSB
        3, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTAC12IE",
        "Forces the AC12IE bit in the Auto Command12 Error Status Register to b"
        "e set.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCNIBAC12E",
        "Forces the CNIBAC12E bit in the Auto Command12 Error Status Register t"
        "o be set.",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCTOE",
        "Forces the CTOE bit of Interrupt Status Register to be set.",
        16, // LSB
        16, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCCE",
        "Forces the CCE bit of Interrupt Status Register to be set.",
        17, // LSB
        17, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCEBE",
        "Forces the CEBE bit of Interrupt Status Register to be set.",
        18, // LSB
        18, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCIE",
        "Forces the CCE bit of Interrupt Status Register to be set.",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTDTOE",
        "Force the DTOE bit of Interrupt Status Register to be set.",
        20, // LSB
        20, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTDCE",
        "Forces the DCE bit of Interrupt Status Register to be set.",
        21, // LSB
        21, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTDEBE",
        "Forces the DEBE bit of Interrupt Status Register to be set.",
        22, // LSB
        22, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTAC12E",
        "Forces the AC12E bit of Interrupt Status Register to be set.",
        24, // LSB
        24, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTTNE",
        "Forces the TNE bit of Interrupt Status Register to be set.",
        26, // LSB
        26, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTDMAE",
        "Forces the DMAE bit of Interrupt Status Register to be set.",
        28, // LSB
        28, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCINT",
        "Writing 1 to this bit generates a short low-level pulse on the interna"
        "l DATA1 line, as if a self clearing interrupt was received from the ex"
        "ternal card.",
        31, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_ADMA_ERR_STATUS.
static const field_t hw_usdhc_adma_err_status[] =
{
    {
        "ADMAES",
        "This field indicates the state of the ADMA when an error has occurred "
        "during an ADMA data transfer.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADMALME",
        "This error occurs in the following 2 cases: While the Block Count Enab"
        "le is being set, the total data length specified by the Descriptor tab"
        "le is different from that specified by the Block Count and Block Lengt"
        "h.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADMADCE",
        "This error occurs when invalid descriptor fetched by ADMA.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_ADMA_SYS_ADDR.
static const field_t hw_usdhc_adma_sys_addr[] =
{
    {
        "ADS_ADDR",
        "This register holds the word address of the executing command in the D"
        "escriptor table.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_DLL_CTRL.
static const field_t hw_usdhc_dll_ctrl[] =
{
    {
        "DLL_CTRL_ENABLE",
        "Set this bit to 1 to enable the DLL and delay chain; otherwise; set to"
        " 0 to bypasses DLL.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_RESET",
        "Setting this bit to 1 force a reset on DLL.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_FORCE_UPD",
        "Setting this bit to 1, forces the slave delay line to update to the DL"
        "L calibrated value immediately.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_DLY_TARGET0",
        "The delay target for the uSDHC loopback read clock can be programmed i"
        "n 1/16th increments of an ref_clock half-period.",
        3, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_GATE_UPDATE",
        "Set this bit to 1 to prevent the DLL from updating (since when clock_i"
        "n exists, glitches may appear during DLL updates).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OVERRIDE",
        "Set this bit to 1 to Enable manual override for slave delay chain usin"
        "g SLV_OVERRIDE_VAL; to set 0 to disable manual override.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OVERRIDE_VAL",
        "When SLV_OVERRIDE = 1 This field is used to select 1 of 128 physical t"
        "aps manually.",
        9, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_DLY_TARGET1",
        "Refer to DLL_CTRL_SLV_DLY_TARGET0 below.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_UPDATE_INT",
        "Slave delay line update interval.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_REF_UPDATE_INT",
        "DLL control loop update interval.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_DLL_STATUS.
static const field_t hw_usdhc_dll_status[] =
{
    {
        "DLL_STS_SLV_LOCK",
        "Slave delay-line lock status.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLL_STS_REF_LOCK",
        "Reference DLL lock status.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLL_STS_SLV_SEL",
        "Slave delay line select status.",
        2, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLL_STS_REF_SEL",
        "Reference delay line select taps.",
        9, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_CLK_TUNE_CTRL_STATUS.
static const field_t hw_usdhc_clk_tune_ctrl_status[] =
{
    {
        "DLY_CELL_SET_POST",
        "Set the number of delay cells on the feedback clock between CLK_OUT an"
        "d CLK_POST.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLY_CELL_SET_OUT",
        "Set the number of delay cells on the feedback clock between CLK_PRE an"
        "d CLK_OUT.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLY_CELL_SET_PRE",
        "Set the number of delay cells on the feedback clock between the feedba"
        "ck clock and CLK_PRE.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NXT_ERR",
        "NXT error which means the number of delay cells added on the feedback "
        "clock is too large.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAP_SEL_POST",
        "Reflect the number of delay cells added on the feedback clock between "
        "CLK_OUT and CLK_POST.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAP_SEL_OUT",
        "Reflect the number of delay cells added on the feedback clock between "
        "CLK_PRE and CLK_OUT.",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAP_SEL_PRE",
        "Reflects the number of delay cells added on the feedback clock between"
        " the feedback clock and CLK_PRE.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRE_ERR",
        "PRE error which means the number of delay cells added on the feedback "
        "clock is too small.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_STROBE_DLL_CTRL.
static const field_t hw_usdhc_strobe_dll_ctrl[] =
{
    {
        "STROBE_DLL_CTRL_ENABLE",
        "Set this bit to 1 to enable the DLL and delay chain; otherwise, set to"
        " 0 to bypasses DLL.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STROBE_DLL_CTRL_RESET",
        "Setting this bit to 1 to force a reset on DLL.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STROBE_DLL_CTRL_SLV_FORCE_UPD",
        "Setting this bit to 1, forces the slave delay line to update to the DL"
        "L calibrated value immediately.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STROBE_DLL_CTRL_SLV_DLY_TARGET",
        "The delay target for the uSDHC loopback read clock can be programmed i"
        "n 1/16th increments of an STROBE_REF_CLOCK half-period.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STROBE_DLL_CTRL_GATE_UPDATE_0",
        "Set this bit to 1 to prevent the DLL from updating (since when STROBE_"
        "CLOCK_IN exists, glitches may appear during DLL updates).",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STROBE_DLL_CTRL_GATE_UPDATE_1",
        "Set this bit to 1 to prevent the DLL from updating (since when STROBE_"
        "CLOCK_IN exists, glitches may appear during DLL updates).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STROBE_DLL_CTRL_SLV_OVERRIDE",
        "Set this bit to 1 to Enable manual override for slave delay chain usin"
        "g STROBE_SLV_OVERRIDE_VAL; set this bit to 0 to disable manual overrid"
        "e.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STROBE_DLL_CTRL_SLV_OVERRIDE_VAL",
        "When STROBE_SLV_OVERRIDE = 1, this field is used to manually select on"
        "e of 128 physical taps.",
        9, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STROBE_DLL_CTRL_SLV_UPDATE_INT",
        "Slave delay line update interval.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STROBE_DLL_CTRL_REF_UPDATE_INT",
        "The interval cycle is (2 + STROBE_REF_UPDATE_INT) * STROBE_REF_CLOCK.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_STROBE_DLL_STATUS.
static const field_t hw_usdhc_strobe_dll_status[] =
{
    {
        "STROBE_DLL_STS_SLV_LOCK",
        "Slave delay-line lock status.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STROBE_DLL_STS_REF_LOCK",
        "This signifies that the DLL has detected and locked to a half-phase RE"
        "F_CLOCK shift, it allows the slave delay-line to perform programmed cl"
        "ock delays.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STROBE_DLL_STS_SLV_SEL",
        "Slave delay line select status.",
        2, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STROBE_DLL_STS_REF_SEL",
        "Reference delay line select taps.",
        9, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_VEND_SPEC.
static const field_t hw_usdhc_vend_spec[] =
{
    {
        "VSELECT",
        "Change the value of output signal VSELECT, to control the voltage on p"
        "ads for external card.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CONFLICT_CHK_EN",
        "It is not implemented in uSDHC IP.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12_WR_CHKBUSY_EN",
        "Check busy enable after auto CMD12 for write data packet",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAT3_CD_POL",
        "Only for debug.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CD_POL",
        "Only for debug.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP_POL",
        "Only for debug.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKONJ_IN_ABORT",
        "Only for debug.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRC_SDCLK_ON",
        "Force CLK output active",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_CHK_DIS",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_BYTE_EN",
        "Byte access",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_MMC_BOOT.
static const field_t hw_usdhc_mmc_boot[] =
{
    {
        "DTOCV_ACK",
        "Boot ACK time out counter value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_ACK",
        "Boot ACK mode select",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_MODE",
        "Boot mode select",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_EN",
        "Boot mode enable",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTO_SABG_EN",
        "During boot, enable auto stop at block gap function.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_TIME_OUT",
        "When this bit is set, there is no timeout check no matter whether BOOT"
        "_EN is set or not.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_BLK_CNT",
        "The value defines the Stop At Block Gap value of automatic mode.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_VEND_SPEC2.
static const field_t hw_usdhc_vend_spec2[] =
{
    {
        "SDR104_TIMING_DIS",
        "Timeout counter test.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDR104_OE_DIS",
        "CMD_OE / DATA_OE logic generation test.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDR104_NSD_DIS",
        "Interrupt window after abort command is sent.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CARD_INT_D3_TEST",
        "This bit only uses for debugging.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_8BIT_EN",
        "Enable the auto tuning circuit to check the DATA[7:0].",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_1BIT_EN",
        "Enable the auto tuning circuit to check the DATA0 only.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_CMD_EN",
        "Enable the auto tuning circuit to check the CMD line.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CARD_INT_AUTO_CLR_DIS",
        "Disable the feature to clear the Card interrupt status bit when Card I"
        "nterrupt status enable bit is cleared.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HS400_WR_CLK_STOP_EN",
        "Only stop clock at write block gap.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HS400_RD_CLK_STOP_EN",
        "Only stop clock at read block gap.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHB_RST",
        "Reset internal AHB bus logic before RST_ALL or RST_DATA to avoid AHB b"
        "us hang.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_32K_CLK",
        "use 32khz clock for card detection",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FBCLK_TAP_SEL",
        "",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USDHC_TUNING_CTRL.
static const field_t hw_usdhc_tuning_ctrl[] =
{
    {
        "TUNING_START_TAP",
        "The start dealy cell point when send first CMD19 in tuning procedure.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_COUNTER",
        "The MAX repeat CMD19 times in tuning procedure.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_STEP",
        "The increasing delay cell steps in tuning procedure.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_WINDOW",
        "Select data window value for auto tuning",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STD_TUNING_EN",
        "Standard tuning circuit and procedure enable: This bit is used to enab"
        "le standard tuning circuit and procedure.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a USDHC module.
static const reg_t hw_usdhc[] =
{
    {
        "DS_ADDR",
        "This register contains the physical system memory address used for DMA"
        " transfers.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_ds_addr
    },
    {
        "BLK_ATT",
        "This register is used to configure the number of data blocks and the n"
        "umber of bytes in each block.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usdhc_blk_att
    },
    {
        "CMD_ARG",
        "This register contains the SD / MMC Command Argument.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_arg
    },
    {
        "CMD_XFR_TYP",
        "This register is used to control the operation of data transfers.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usdhc_cmd_xfr_typ
    },
    {
        "CMD_RSP0",
        "This register is used to store part 0 of the response bits from the ca"
        "rd.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp0
    },
    {
        "CMD_RSP1",
        "This register is used to store part 1 of the response bits from the ca"
        "rd.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp1
    },
    {
        "CMD_RSP2",
        "This register is used to store part 2 of the response bits from the ca"
        "rd.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp2
    },
    {
        "CMD_RSP3",
        "This register is used to store part 3 of the response bits from the ca"
        "rd.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp3
    },
    {
        "DATA_BUFF_ACC_PORT",
        "This is a 32-bit data port register used to access the internal buffer"
        ".",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_data_buff_acc_port
    },
    {
        "PRES_STATE",
        "The Host Driver can get status of the uSDHC from this 32-bit read only"
        " register.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        19, // Number of bitfields
        hw_usdhc_pres_state
    },
    {
        "PROT_CTRL",
        "There are three cases to restart the transfer after stop at the block "
        "gap.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usdhc_prot_ctrl
    },
    {
        "SYS_CTRL",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usdhc_sys_ctrl
    },
    {
        "INT_STATUS",
        "An interrupt is generated when the Normal Interrupt Signal Enable is e"
        "nabled and at least one of the status bits is set to 1.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_usdhc_int_status
    },
    {
        "INT_STATUS_EN",
        "Setting the bits in this register to 1 enables the corresponding Inter"
        "rupt Status to be set by the specified event.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_usdhc_int_status_en
    },
    {
        "INT_SIGNAL_EN",
        "This register is used to select which interrupt status is indicated to"
        " the Host System as the interrupt.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_usdhc_int_signal_en
    },
    {
        "AUTOCMD12_ERR_STATUS",
        "When the Auto CMD12 Error Status bit in the Status register is set, th"
        "e Host Driver shall check this register to identify what kind of error"
        " the Auto CMD12 / CMD 23 indicated.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usdhc_autocmd12_err_status
    },
    {
        "HOST_CTRL_CAP",
        "This register provides the Host Driver with information specific to th"
        "e uSDHC implementation.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_usdhc_host_ctrl_cap
    },
    {
        "WTMK_LVL",
        "Both write and read watermark levels (FIFO threshold) are configurable"
        ".",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usdhc_wtmk_lvl
    },
    {
        "MIX_CTRL",
        "This register is used to DMA and data transfer.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_usdhc_mix_ctrl
    },
    {
        "FORCE_EVENT",
        "The Force Event Register is not a physically implemented register.",
        4, // Width in bytes
        0x00000050, // Base address offset
        false, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usdhc_force_event
    },
    {
        "ADMA_ERR_STATUS",
        "When an ADMA Error Interrupt has occurred, the ADMA Error States field"
        " in this register holds the ADMA state and the ADMA System Address reg"
        "ister holds the address around the error descriptor.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usdhc_adma_err_status
    },
    {
        "ADMA_SYS_ADDR",
        "This register contains the physical system memory address used for ADM"
        "A transfers.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_adma_sys_addr
    },
    {
        "DLL_CTRL",
        "This register contains control bits for DLL.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_usdhc_dll_ctrl
    },
    {
        "DLL_STATUS",
        "This register contains the DLL status information.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usdhc_dll_status
    },
    {
        "CLK_TUNE_CTRL_STATUS",
        "This register contains the Clock Tuning Control status information.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usdhc_clk_tune_ctrl_status
    },
    {
        "STROBE_DLL_CTRL",
        "This register contains the strobe DLL Control information.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_usdhc_strobe_dll_ctrl
    },
    {
        "STROBE_DLL_STATUS",
        "This register contains the strobe DLL status information.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usdhc_strobe_dll_status
    },
    {
        "VEND_SPEC",
        "This register contains the vendor specific control / status register.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_usdhc_vend_spec
    },
    {
        "MMC_BOOT",
        "This register contains the MMC Fast Boot control register.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_usdhc_mmc_boot
    },
    {
        "VEND_SPEC2",
        "This register contains the vendor specific control 2 register.",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_usdhc_vend_spec2
    },
    {
        "TUNING_CTRL",
        "The register contains configuration of tuning circuit.",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_usdhc_tuning_ctrl
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark VIU
#endif

// Bitfields in register VIU_SCR.
static const field_t hw_viu_scr[] =
{
    {
        "SOFT_RESET",
        "Writing 1 to this bit generates an internal reset to all components ex"
        "cept registers in the VIU block.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FORMAT_CTRL",
        "Output pixel data format control.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_CODE",
        "Error code.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FIELD_EN",
        "Interrupt enable bit for FIELD_IRQ.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_EN",
        "Interrupt enable bit for VSYNC_IRQ.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_EN",
        "Interrupt enable bit for HSYNC_IRQ.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSTART_EN",
        "Interrupt enable bit for VSTART_IRQ.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_END_EN",
        "Interrupt enable bit for DMA_END_IRQ.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_EN",
        "Interrupt enable bit for ERROR_IRQ.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_EN",
        "When this bit is set ECC errors generate ERROR_IRQ and the nature of E"
        "CC error gets reflected on the ERROR_CODE bit field.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIELD_IRQ",
        "Interrupt status bit.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_IRQ",
        "Interrupt status bit.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_IRQ",
        "Interrupt status bit.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSTART_IRQ",
        "Interrupt status bit.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_END_IRQ",
        "Interrupt status bit.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERROR_IRQ",
        "Interrupt status bit.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE444",
        "YUV 4:4:4 mode enable bit.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BC_EN",
        "Bright/Contrast adjust enable.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YUV2RGB_EN",
        "YUV to RGB conversion enable.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCALER_EN",
        "Scaling enable.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_ACT",
        "DMA transfer of current field/frame is busy (write by software, cleare"
        "d at end of transfer).",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIELD_NO",
        "Field number, extracted from ITU-656 stream.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DITHER_ON",
        "Dithering is on.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROUND_ON",
        "Round is on.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE32BIT",
        "Select 32-bit or 16-bit output from the output formatter (block 6 in )"
        " For RGB666 parallel input, when MODE32BIT is cleared, the output is {"
        "R[5:1], G[5:0], B[5:1]}; when MODE32BIT is set, the output is {R[5:0],"
        " 2'b00, G[5:0], 2'b00, B[5:0], 2'b00} This bit only acts when MODE_8BI"
        "T of EXT_CONFIG is 1'b0.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VIU_DINVSZ.
static const field_t hw_viu_dinvsz[] =
{
    {
        "DETECTED_PIXELC",
        "(DETECTED_PIXELC[15:0]) Detected number of active pixels in each input"
        " video line.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DETECTED_LINEC",
        "(DETECTED_LINEC[15:0]) Detected number of active lines in each input v"
        "ideo field/frame.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VIU_DINVFL.
static const field_t hw_viu_dinvfl[] =
{
    {
        "DETECTED_FRAME_WIDTH",
        "(DETECTED_FRAME_WIDTH[15:0]) Detected number of clock cycles of each i"
        "nput video line.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DETECTED_FRAME_HEIGHT",
        "(DETECTED_FRAME_HEIGHT[15:0]) Detected number of total lines of each i"
        "nput video field/frame.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VIU_DMA_ADDR.
static const field_t hw_viu_dma_addr[] =
{
    {
        "ADDR",
        "(ADDR[31:3]) Base address of every field of picture in memory used by "
        "DMA.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VIU_DMA_INC.
static const field_t hw_viu_dma_inc[] =
{
    {
        "INC",
        "(INC[15:3]) Value of this field should be zero or memory size that one"
        " active line occupies in memory.",
        3, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VIU_INVSZ.
static const field_t hw_viu_invsz[] =
{
    {
        "PIXELC",
        "(PIXELC[15:0]) Expected number of active pixels in each input video li"
        "ne, it shall be an integer multiple of 4.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINEC",
        "(LINEC[15:0]) Expected number of active lines in each input video fiel"
        "d/frame.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VIU_HPRALRM.
static const field_t hw_viu_hpralrm[] =
{
    {
        "ALARM",
        "(ALARM[15:0]) High priority alarm threshold.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VIU_ALPHA.
static const field_t hw_viu_alpha[] =
{
    {
        "ALPHA",
        "(ALPHA[7:0]) Alpha value used for picture blending.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VIU_HFACTOR.
static const field_t hw_viu_hfactor[] =
{
    {
        "FACTOR",
        "Scaling factor at horizontal direction.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VIU_VFACTOR.
static const field_t hw_viu_vfactor[] =
{
    {
        "FACTOR",
        "Down scaling factor at vertical direction.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VIU_VID_SIZE.
static const field_t hw_viu_vid_size[] =
{
    {
        "PIXELC",
        "(PIXELC[15:0]) Expected number of pixels in each output video line aft"
        "er scaling.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINEC",
        "(LINEC[15:0]) Expected number of lines in each output video frame afte"
        "r scaling.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VIU_LUT_ADDR.
static const field_t hw_viu_lut_addr[] =
{
    {
        "ADDR",
        "(ADDR[9:2]) Current address pointer of the B/C adjust look-up-table.",
        2, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VIU_LUT_DATA.
static const field_t hw_viu_lut_data[] =
{
    {
        "DATA",
        "(DATA[31:0]) B/C adjust look-up-table data entry.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VIU_EXT_CONFIG.
static const field_t hw_viu_ext_config[] =
{
    {
        "HMIRROR_EN",
        "Horizontal mirror enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DE_POL",
        "Data enable polarity control bit.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "Hsync polarity control bit.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_POL",
        "Vsync polarity control bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCLK_POL",
        "Pixel clock polarity control bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INP_FORMAT",
        "Input video format select bits.",
        5, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DE_VALID",
        "External data enable indicator is valid at parallel input modes.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RGB2YUV_EN",
        "RGB to YUV conversion enable",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LENDIAN",
        "Data endian control bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS_EN",
        "Chroma swap enable bit.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE_8BIT",
        "This mode select bit has higher priority than MODE32BIT of SCR registe"
        "r.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MONO_LSB",
        "This bit decides the 8bit MONO input data is on 8 MSB or LSB.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VIU_ACT_ORG.
static const field_t hw_viu_act_org[] =
{
    {
        "ACT_ORG_X",
        "X-coordinate of active image origin.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACT_ORG_Y",
        "Y-coordinate of active image origin.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register VIU_ACT_SIZE.
static const field_t hw_viu_act_size[] =
{
    {
        "ACT_IMG_WIDTH",
        "Width of image captured.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACT_IMG_HEIGHT",
        "Height of image captured.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a VIU module.
static const reg_t hw_viu[] =
{
    {
        "SCR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_viu_scr
    },
    {
        "DINVSZ",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_viu_dinvsz
    },
    {
        "DINVFL",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_viu_dinvfl
    },
    {
        "DMA_ADDR",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_viu_dma_addr
    },
    {
        "DMA_INC",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_viu_dma_inc
    },
    {
        "INVSZ",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_viu_invsz
    },
    {
        "HPRALRM",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_viu_hpralrm
    },
    {
        "ALPHA",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_viu_alpha
    },
    {
        "HFACTOR",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_viu_hfactor
    },
    {
        "VFACTOR",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_viu_vfactor
    },
    {
        "VID_SIZE",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_viu_vid_size
    },
    {
        "LUT_ADDR",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_viu_lut_addr
    },
    {
        "LUT_DATA",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_viu_lut_data
    },
    {
        "EXT_CONFIG",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_viu_ext_config
    },
    {
        "ACT_ORG",
        "",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_viu_act_org
    },
    {
        "ACT_SIZE",
        "",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_viu_act_size
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark WDOG
#endif

// Bitfields in register WDOG_CS.
static const field_t hw_wdog_cs[] =
{
    {
        "STOP",
        "This write-once bit enables the watchdog to operate when the chip is i"
        "n stop mode.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT",
        "This write-once bit enables the watchdog to operate when the chip is i"
        "n wait mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBG",
        "This write-once bit enables the watchdog to operate when the chip is i"
        "n debug mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TST",
        "Enables the fast test mode.",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE",
        "This write-once bit allows software to reconfigure the watchdog withou"
        "t a reset.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT",
        "This write-once bit configures the watchdog to immediately generate an"
        " interrupt request upon a reset-triggering event (timeout or illegal w"
        "rite to the watchdog), before forcing a reset.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN",
        "This write-once bit enables the watchdog counter to start counting.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK",
        "This write-once field indicates the clock source that feeds the watchd"
        "og counter.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCS",
        "This read-only bit indicates whether the reconfiguration is successful"
        " or not.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ULK",
        "This read-only bit indicates whether WDOG is unlocked or not.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRES",
        "This write-once bit enables a fixed 256 pre-scaling of watchdog counte"
        "r reference clock.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD32EN",
        "This is write-once field, and the user needs to unlock WDOG after writ"
        "ing this field for reconfiguration.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FLG",
        "This bit is an interrupt indicator when INT is set in control and stat"
        "us register 1.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIN",
        "This write-once bit enables window mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_CNT.
static const field_t hw_wdog_cnt[] =
{
    {
        "CNTLOW",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNTHIGH",
        "",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_TOVAL.
static const field_t hw_wdog_toval[] =
{
    {
        "TOVALLOW",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOVALHIGH",
        "",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WIN.
static const field_t hw_wdog_win[] =
{
    {
        "WINLOW",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WINHIGH",
        "",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a WDOG module.
static const reg_t hw_wdog[] =
{
    {
        "CS",
        "This section describes the function of Watchdog Control and Status Reg"
        "ister.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_wdog_cs
    },
    {
        "CNT",
        "This section describes the watchdog counter register.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_wdog_cnt
    },
    {
        "TOVAL",
        "This section describes the watchdog timeout value register.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_wdog_toval
    },
    {
        "WIN",
        "This section describes the watchdog window register.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_wdog_win
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark WKPU
#endif

// Bitfields in register WKPU_NSR.
static const field_t hw_wkpu_nsr[] =
{
    {
        "NOVF0",
        "NMI Overrun Status Flag 0.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NIF0",
        "NMI Status Flag 0.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WKPU_NCR.
static const field_t hw_wkpu_ncr[] =
{
    {
        "NFE0",
        "NMI Filter Enable 0.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NFEE0",
        "NMI Falling-edge Events Enable 0.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NREE0",
        "NMI Rising-edge Events Enable 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NWRE0",
        "NMI Wakeup Request Enable 0 If wakeup requests are disabled, the corre"
        "sponding NDSS field must be set to 11 to disable wakeups from an NMI, "
        "critical interrupt, or machine check.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NDSS0",
        "NMI Destination Source Select 0.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NLOCK0",
        "NMI Configuration Lock Register 0.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WKPU_WISR.
static const field_t hw_wkpu_wisr[] =
{
    {
        "EIF",
        "External Wakeup/Interrupt Status Flag x.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WKPU_IRER.
static const field_t hw_wkpu_irer[] =
{
    {
        "EIRE",
        "External Interrupt Request Enable x.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WKPU_WRER.
static const field_t hw_wkpu_wrer[] =
{
    {
        "WRE",
        "External Wakeup Request Enable x.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WKPU_WIREER.
static const field_t hw_wkpu_wireer[] =
{
    {
        "IREE",
        "External Interrupt Rising-edge Events Enable x.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WKPU_WIFEER.
static const field_t hw_wkpu_wifeer[] =
{
    {
        "IFEEX",
        "External Interrupt Falling-edge Events Enable x.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WKPU_WIFER.
static const field_t hw_wkpu_wifer[] =
{
    {
        "IFE",
        "External Interrupt Filter Enable x.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WKPU_WIPUER.
static const field_t hw_wkpu_wipuer[] =
{
    {
        "IPUE",
        "External Interrupt Pullup Enable x.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a WKPU module.
static const reg_t hw_wkpu[] =
{
    {
        "NSR",
        "This register holds the non-maskable interrupt status flags.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_wkpu_nsr
    },
    {
        "NCR",
        "This register holds the configuration bits for the non-maskable interr"
        "upt settings.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_wkpu_ncr
    },
    {
        "WISR",
        "This register holds the wakeup/interrupt flags.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_wkpu_wisr
    },
    {
        "IRER",
        "This register is used to enable the interrupt messaging from the wakeu"
        "p/interrupt pads to the interrupt controller.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_wkpu_irer
    },
    {
        "WRER",
        "This register is used to enable the system wakeup messaging from the w"
        "akeup/interrupt pads to the mode entry and power control modules.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_wkpu_wrer
    },
    {
        "WIREER",
        "This register is used to enable rising-edge triggered events on the co"
        "rresponding wakeup/interrupt pads.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_wkpu_wireer
    },
    {
        "WIFEER",
        "This register is used to enable falling-edge triggered events on the c"
        "orresponding wakeup/interrupt pads.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_wkpu_wifeer
    },
    {
        "WIFER",
        "This register is used to enable an analog filter on the corresponding "
        "interrupt pads to filter out glitches on the inputs.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_wkpu_wifer
    },
    {
        "WIPUER",
        "This register is used to enable a pullup on the corresponding interrup"
        "t pads to pull an unconnected wakeup/interrupt input to a high voltage"
        " level (See the Chip-specific WKPU information for the exact level of "
        "voltage) .",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_wkpu_wipuer
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark XRDC
#endif

// Bitfields in register XRDC_CR.
static const field_t hw_xrdc_cr[] =
{
    {
        "GVLD",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HRL",
        "This read-only field specifies the XRDC's hardware and definition revi"
        "sion level.",
        1, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MRF",
        "This read-only bit signals the format of the memory region descriptors"
        " and is defined by SoC requirements.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VAW",
        "This field signals that the domain assignments support the optional in"
        "clusion of a logical partition identifier (also known as an operating "
        "system number).",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_HWCFG0.
static const field_t hw_xrdc_hwcfg0[] =
{
    {
        "NDID",
        "This read-only field defines the number of domains minus 1 in the devi"
        "ce.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NMSTR",
        "This read-only field defines the number of bus masters minus 1 in the "
        "device.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NMRC",
        "This field defines the number of MRCs minus 1 in the device.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NPAC",
        "This field defines the number of PACs minus 1 in the device.",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MID",
        "",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_HWCFG1.
static const field_t hw_xrdc_hwcfg1[] =
{
    {
        "DID",
        "This field provides the domain number [0-15] of the requesting bus mas"
        "ter.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_HWCFG2.
static const field_t hw_xrdc_hwcfg2[] =
{
    {
        "PIDP0",
        "Process identifier present from bus master 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP1",
        "Process identifier present from bus master 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP2",
        "Process identifier present from bus master 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP3",
        "Process identifier present from bus master 3.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP4",
        "Process identifier present from bus master 4.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP5",
        "Process identifier present from bus master 5.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP6",
        "Process identifier present from bus master 6.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP7",
        "Process identifier present from bus master 7.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP8",
        "Process identifier present from bus master 8.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP9",
        "Process identifier present from bus master 9.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP10",
        "Process identifier present from bus master 10.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP11",
        "Process identifier present from bus master 11.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP12",
        "Process identifier present from bus master 12.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP13",
        "Process identifier present from bus master 13.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP14",
        "Process identifier present from bus master 14.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP15",
        "Process identifier present from bus master 15.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP16",
        "Process identifier present from bus master 16.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP17",
        "Process identifier present from bus master 17.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP18",
        "Process identifier present from bus master 18.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP19",
        "Process identifier present from bus master 19.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP20",
        "Process identifier present from bus master 20.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP21",
        "Process identifier present from bus master 21.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP22",
        "Process identifier present from bus master 22.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP23",
        "Process identifier present from bus master 23.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP24",
        "Process identifier present from bus master 24.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP25",
        "Process identifier present from bus master 25.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP26",
        "Process identifier present from bus master 26.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP27",
        "Process identifier present from bus master 27.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP28",
        "Process identifier present from bus master 28.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP29",
        "Process identifier present from bus master 29.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP30",
        "Process identifier present from bus master 30.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIDP31",
        "Process identifier present from bus master 31.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDACFG0.
static const field_t hw_xrdc_mdacfg0[] =
{
    {
        "NMDAR",
        "This read-only field specifies the number of registers associated with"
        " the master domain assignment register for a given bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCM",
        "This read-only field signals that bus master m is a non-CPU master.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDACFG1.
static const field_t hw_xrdc_mdacfg1[] =
{
    {
        "NMDAR",
        "This read-only field specifies the number of registers associated with"
        " the master domain assignment register for a given bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCM",
        "This read-only field signals that bus master m is a non-CPU master.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDACFG2.
static const field_t hw_xrdc_mdacfg2[] =
{
    {
        "NMDAR",
        "This read-only field specifies the number of registers associated with"
        " the master domain assignment register for a given bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCM",
        "This read-only field signals that bus master m is a non-CPU master.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDACFG3.
static const field_t hw_xrdc_mdacfg3[] =
{
    {
        "NMDAR",
        "This read-only field specifies the number of registers associated with"
        " the master domain assignment register for a given bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCM",
        "This read-only field signals that bus master m is a non-CPU master.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDACFG4.
static const field_t hw_xrdc_mdacfg4[] =
{
    {
        "NMDAR",
        "This read-only field specifies the number of registers associated with"
        " the master domain assignment register for a given bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCM",
        "This read-only field signals that bus master m is a non-CPU master.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDACFG5.
static const field_t hw_xrdc_mdacfg5[] =
{
    {
        "NMDAR",
        "This read-only field specifies the number of registers associated with"
        " the master domain assignment register for a given bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCM",
        "This read-only field signals that bus master m is a non-CPU master.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDACFG6.
static const field_t hw_xrdc_mdacfg6[] =
{
    {
        "NMDAR",
        "This read-only field specifies the number of registers associated with"
        " the master domain assignment register for a given bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCM",
        "This read-only field signals that bus master m is a non-CPU master.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDACFG7.
static const field_t hw_xrdc_mdacfg7[] =
{
    {
        "NMDAR",
        "This read-only field specifies the number of registers associated with"
        " the master domain assignment register for a given bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCM",
        "This read-only field signals that bus master m is a non-CPU master.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDACFG8.
static const field_t hw_xrdc_mdacfg8[] =
{
    {
        "NMDAR",
        "This read-only field specifies the number of registers associated with"
        " the master domain assignment register for a given bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCM",
        "This read-only field signals that bus master m is a non-CPU master.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDACFG9.
static const field_t hw_xrdc_mdacfg9[] =
{
    {
        "NMDAR",
        "This read-only field specifies the number of registers associated with"
        " the master domain assignment register for a given bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCM",
        "This read-only field signals that bus master m is a non-CPU master.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDACFG10.
static const field_t hw_xrdc_mdacfg10[] =
{
    {
        "NMDAR",
        "This read-only field specifies the number of registers associated with"
        " the master domain assignment register for a given bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCM",
        "This read-only field signals that bus master m is a non-CPU master.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDACFG11.
static const field_t hw_xrdc_mdacfg11[] =
{
    {
        "NMDAR",
        "This read-only field specifies the number of registers associated with"
        " the master domain assignment register for a given bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCM",
        "This read-only field signals that bus master m is a non-CPU master.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDACFG12.
static const field_t hw_xrdc_mdacfg12[] =
{
    {
        "NMDAR",
        "This read-only field specifies the number of registers associated with"
        " the master domain assignment register for a given bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCM",
        "This read-only field signals that bus master m is a non-CPU master.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDACFG13.
static const field_t hw_xrdc_mdacfg13[] =
{
    {
        "NMDAR",
        "This read-only field specifies the number of registers associated with"
        " the master domain assignment register for a given bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCM",
        "This read-only field signals that bus master m is a non-CPU master.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRCFG0.
static const field_t hw_xrdc_mrcfg0[] =
{
    {
        "NMRGD",
        "Number of memory region descriptors for MRCr.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRCFG1.
static const field_t hw_xrdc_mrcfg1[] =
{
    {
        "NMRGD",
        "Number of memory region descriptors for MRCr.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRCFG2.
static const field_t hw_xrdc_mrcfg2[] =
{
    {
        "NMRGD",
        "Number of memory region descriptors for MRCr.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRCFG3.
static const field_t hw_xrdc_mrcfg3[] =
{
    {
        "NMRGD",
        "Number of memory region descriptors for MRCr.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRCFG4.
static const field_t hw_xrdc_mrcfg4[] =
{
    {
        "NMRGD",
        "Number of memory region descriptors for MRCr.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRCFG5.
static const field_t hw_xrdc_mrcfg5[] =
{
    {
        "NMRGD",
        "Number of memory region descriptors for MRCr.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRCFG6.
static const field_t hw_xrdc_mrcfg6[] =
{
    {
        "NMRGD",
        "Number of memory region descriptors for MRCr.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERRLOC0.
static const field_t hw_xrdc_derrloc0[] =
{
    {
        "MRCINST",
        "This field is a bitmap indicating the presence of a detected access vi"
        "olation for domain d in the implemented instances of the MRC.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PACINST",
        "This field is a bitmap indicating the presence of a detected access vi"
        "olation for domain d in the implemented instances of the PAC.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERRLOC1.
static const field_t hw_xrdc_derrloc1[] =
{
    {
        "MRCINST",
        "This field is a bitmap indicating the presence of a detected access vi"
        "olation for domain d in the implemented instances of the MRC.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PACINST",
        "This field is a bitmap indicating the presence of a detected access vi"
        "olation for domain d in the implemented instances of the PAC.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERRLOC2.
static const field_t hw_xrdc_derrloc2[] =
{
    {
        "MRCINST",
        "This field is a bitmap indicating the presence of a detected access vi"
        "olation for domain d in the implemented instances of the MRC.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PACINST",
        "This field is a bitmap indicating the presence of a detected access vi"
        "olation for domain d in the implemented instances of the PAC.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERRLOC3.
static const field_t hw_xrdc_derrloc3[] =
{
    {
        "MRCINST",
        "This field is a bitmap indicating the presence of a detected access vi"
        "olation for domain d in the implemented instances of the MRC.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PACINST",
        "This field is a bitmap indicating the presence of a detected access vi"
        "olation for domain d in the implemented instances of the PAC.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERRLOC4.
static const field_t hw_xrdc_derrloc4[] =
{
    {
        "MRCINST",
        "This field is a bitmap indicating the presence of a detected access vi"
        "olation for domain d in the implemented instances of the MRC.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PACINST",
        "This field is a bitmap indicating the presence of a detected access vi"
        "olation for domain d in the implemented instances of the PAC.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERRLOC5.
static const field_t hw_xrdc_derrloc5[] =
{
    {
        "MRCINST",
        "This field is a bitmap indicating the presence of a detected access vi"
        "olation for domain d in the implemented instances of the MRC.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PACINST",
        "This field is a bitmap indicating the presence of a detected access vi"
        "olation for domain d in the implemented instances of the PAC.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERRLOC6.
static const field_t hw_xrdc_derrloc6[] =
{
    {
        "MRCINST",
        "This field is a bitmap indicating the presence of a detected access vi"
        "olation for domain d in the implemented instances of the MRC.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PACINST",
        "This field is a bitmap indicating the presence of a detected access vi"
        "olation for domain d in the implemented instances of the PAC.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERRLOC7.
static const field_t hw_xrdc_derrloc7[] =
{
    {
        "MRCINST",
        "This field is a bitmap indicating the presence of a detected access vi"
        "olation for domain d in the implemented instances of the MRC.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PACINST",
        "This field is a bitmap indicating the presence of a detected access vi"
        "olation for domain d in the implemented instances of the PAC.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W0_0.
static const field_t hw_xrdc_derr_w0_0[] =
{
    {
        "EADDR",
        "This is the access address that generated an access violation.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W1_0.
static const field_t hw_xrdc_derr_w1_0[] =
{
    {
        "EDID",
        "This field captures the domain identifier of the access violation.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EATR",
        "This field captures certain attributes of the access violation.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERW",
        "This field signals whether the captured access violation occurred on a"
        " read or write reference.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EPORT",
        "This field identifies the encoded port number of the MRC that detected"
        " the access violation.",
        24, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EST",
        "This field signals the state of access violations for this domain in t"
        "his instance of the memory region controller or peripheral access cont"
        "roller.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W3_0.
static const field_t hw_xrdc_derr_w3_0[] =
{
    {
        "RECR",
        "This 2-bit, write-only field controls the rearming of the domain error"
        " capture registers.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W0_1.
static const field_t hw_xrdc_derr_w0_1[] =
{
    {
        "EADDR",
        "This is the access address that generated an access violation.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W1_1.
static const field_t hw_xrdc_derr_w1_1[] =
{
    {
        "EDID",
        "This field captures the domain identifier of the access violation.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EATR",
        "This field captures certain attributes of the access violation.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERW",
        "This field signals whether the captured access violation occurred on a"
        " read or write reference.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EPORT",
        "This field identifies the encoded port number of the MRC that detected"
        " the access violation.",
        24, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EST",
        "This field signals the state of access violations for this domain in t"
        "his instance of the memory region controller or peripheral access cont"
        "roller.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W3_1.
static const field_t hw_xrdc_derr_w3_1[] =
{
    {
        "RECR",
        "This 2-bit, write-only field controls the rearming of the domain error"
        " capture registers.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W0_2.
static const field_t hw_xrdc_derr_w0_2[] =
{
    {
        "EADDR",
        "This is the access address that generated an access violation.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W1_2.
static const field_t hw_xrdc_derr_w1_2[] =
{
    {
        "EDID",
        "This field captures the domain identifier of the access violation.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EATR",
        "This field captures certain attributes of the access violation.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERW",
        "This field signals whether the captured access violation occurred on a"
        " read or write reference.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EPORT",
        "This field identifies the encoded port number of the MRC that detected"
        " the access violation.",
        24, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EST",
        "This field signals the state of access violations for this domain in t"
        "his instance of the memory region controller or peripheral access cont"
        "roller.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W3_2.
static const field_t hw_xrdc_derr_w3_2[] =
{
    {
        "RECR",
        "This 2-bit, write-only field controls the rearming of the domain error"
        " capture registers.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W0_3.
static const field_t hw_xrdc_derr_w0_3[] =
{
    {
        "EADDR",
        "This is the access address that generated an access violation.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W1_3.
static const field_t hw_xrdc_derr_w1_3[] =
{
    {
        "EDID",
        "This field captures the domain identifier of the access violation.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EATR",
        "This field captures certain attributes of the access violation.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERW",
        "This field signals whether the captured access violation occurred on a"
        " read or write reference.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EPORT",
        "This field identifies the encoded port number of the MRC that detected"
        " the access violation.",
        24, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EST",
        "This field signals the state of access violations for this domain in t"
        "his instance of the memory region controller or peripheral access cont"
        "roller.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W3_3.
static const field_t hw_xrdc_derr_w3_3[] =
{
    {
        "RECR",
        "This 2-bit, write-only field controls the rearming of the domain error"
        " capture registers.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W0_4.
static const field_t hw_xrdc_derr_w0_4[] =
{
    {
        "EADDR",
        "This is the access address that generated an access violation.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W1_4.
static const field_t hw_xrdc_derr_w1_4[] =
{
    {
        "EDID",
        "This field captures the domain identifier of the access violation.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EATR",
        "This field captures certain attributes of the access violation.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERW",
        "This field signals whether the captured access violation occurred on a"
        " read or write reference.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EPORT",
        "This field identifies the encoded port number of the MRC that detected"
        " the access violation.",
        24, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EST",
        "This field signals the state of access violations for this domain in t"
        "his instance of the memory region controller or peripheral access cont"
        "roller.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W3_4.
static const field_t hw_xrdc_derr_w3_4[] =
{
    {
        "RECR",
        "This 2-bit, write-only field controls the rearming of the domain error"
        " capture registers.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W0_5.
static const field_t hw_xrdc_derr_w0_5[] =
{
    {
        "EADDR",
        "This is the access address that generated an access violation.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W1_5.
static const field_t hw_xrdc_derr_w1_5[] =
{
    {
        "EDID",
        "This field captures the domain identifier of the access violation.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EATR",
        "This field captures certain attributes of the access violation.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERW",
        "This field signals whether the captured access violation occurred on a"
        " read or write reference.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EPORT",
        "This field identifies the encoded port number of the MRC that detected"
        " the access violation.",
        24, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EST",
        "This field signals the state of access violations for this domain in t"
        "his instance of the memory region controller or peripheral access cont"
        "roller.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W3_5.
static const field_t hw_xrdc_derr_w3_5[] =
{
    {
        "RECR",
        "This 2-bit, write-only field controls the rearming of the domain error"
        " capture registers.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W0_6.
static const field_t hw_xrdc_derr_w0_6[] =
{
    {
        "EADDR",
        "This is the access address that generated an access violation.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W1_6.
static const field_t hw_xrdc_derr_w1_6[] =
{
    {
        "EDID",
        "This field captures the domain identifier of the access violation.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EATR",
        "This field captures certain attributes of the access violation.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERW",
        "This field signals whether the captured access violation occurred on a"
        " read or write reference.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EPORT",
        "This field identifies the encoded port number of the MRC that detected"
        " the access violation.",
        24, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EST",
        "This field signals the state of access violations for this domain in t"
        "his instance of the memory region controller or peripheral access cont"
        "roller.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W3_6.
static const field_t hw_xrdc_derr_w3_6[] =
{
    {
        "RECR",
        "This 2-bit, write-only field controls the rearming of the domain error"
        " capture registers.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W0_16.
static const field_t hw_xrdc_derr_w0_16[] =
{
    {
        "EADDR",
        "This is the access address that generated an access violation.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W1_16.
static const field_t hw_xrdc_derr_w1_16[] =
{
    {
        "EDID",
        "This field captures the domain identifier of the access violation.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EATR",
        "This field captures certain attributes of the access violation.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERW",
        "This field signals whether the captured access violation occurred on a"
        " read or write reference.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EPORT",
        "This field identifies the encoded port number of the MRC that detected"
        " the access violation.",
        24, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EST",
        "This field signals the state of access violations for this domain in t"
        "his instance of the memory region controller or peripheral access cont"
        "roller.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W3_16.
static const field_t hw_xrdc_derr_w3_16[] =
{
    {
        "RECR",
        "This 2-bit, write-only field controls the rearming of the domain error"
        " capture registers.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W0_17.
static const field_t hw_xrdc_derr_w0_17[] =
{
    {
        "EADDR",
        "This is the access address that generated an access violation.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W1_17.
static const field_t hw_xrdc_derr_w1_17[] =
{
    {
        "EDID",
        "This field captures the domain identifier of the access violation.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EATR",
        "This field captures certain attributes of the access violation.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERW",
        "This field signals whether the captured access violation occurred on a"
        " read or write reference.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EPORT",
        "This field identifies the encoded port number of the MRC that detected"
        " the access violation.",
        24, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EST",
        "This field signals the state of access violations for this domain in t"
        "his instance of the memory region controller or peripheral access cont"
        "roller.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W3_17.
static const field_t hw_xrdc_derr_w3_17[] =
{
    {
        "RECR",
        "This 2-bit, write-only field controls the rearming of the domain error"
        " capture registers.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W0_18.
static const field_t hw_xrdc_derr_w0_18[] =
{
    {
        "EADDR",
        "This is the access address that generated an access violation.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W1_18.
static const field_t hw_xrdc_derr_w1_18[] =
{
    {
        "EDID",
        "This field captures the domain identifier of the access violation.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EATR",
        "This field captures certain attributes of the access violation.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERW",
        "This field signals whether the captured access violation occurred on a"
        " read or write reference.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EPORT",
        "This field identifies the encoded port number of the MRC that detected"
        " the access violation.",
        24, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EST",
        "This field signals the state of access violations for this domain in t"
        "his instance of the memory region controller or peripheral access cont"
        "roller.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W3_18.
static const field_t hw_xrdc_derr_w3_18[] =
{
    {
        "RECR",
        "This 2-bit, write-only field controls the rearming of the domain error"
        " capture registers.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W0_19.
static const field_t hw_xrdc_derr_w0_19[] =
{
    {
        "EADDR",
        "This is the access address that generated an access violation.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W1_19.
static const field_t hw_xrdc_derr_w1_19[] =
{
    {
        "EDID",
        "This field captures the domain identifier of the access violation.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EATR",
        "This field captures certain attributes of the access violation.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERW",
        "This field signals whether the captured access violation occurred on a"
        " read or write reference.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EPORT",
        "This field identifies the encoded port number of the MRC that detected"
        " the access violation.",
        24, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EST",
        "This field signals the state of access violations for this domain in t"
        "his instance of the memory region controller or peripheral access cont"
        "roller.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_DERR_W3_19.
static const field_t hw_xrdc_derr_w3_19[] =
{
    {
        "RECR",
        "This 2-bit, write-only field controls the rearming of the domain error"
        " capture registers.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PID0.
static const field_t hw_xrdc_pid0[] =
{
    {
        "PID",
        "The PIDm[5] bit determines the secure (0) or nonsecure (1) attribute f"
        "or transactions associated with the corresponding processor.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LMNUM",
        "This read-only field is only enabled when ELK22K = 1.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ELK22H",
        "LK2 is in its standard form and LMNUM will be reserved and always read"
        " as 0.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSM",
        "If asserted, this bit indicates the associated processor core only sup"
        "ports the 3-state access control model.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK2",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PID1.
static const field_t hw_xrdc_pid1[] =
{
    {
        "PID",
        "The PIDm[5] bit determines the secure (0) or nonsecure (1) attribute f"
        "or transactions associated with the corresponding processor.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LMNUM",
        "This read-only field is only enabled when ELK22K = 1.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ELK22H",
        "LK2 is in its standard form and LMNUM will be reserved and always read"
        " as 0.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSM",
        "If asserted, this bit indicates the associated processor core only sup"
        "ports the 3-state access control model.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK2",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PID2.
static const field_t hw_xrdc_pid2[] =
{
    {
        "PID",
        "The PIDm[5] bit determines the secure (0) or nonsecure (1) attribute f"
        "or transactions associated with the corresponding processor.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LMNUM",
        "This read-only field is only enabled when ELK22K = 1.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ELK22H",
        "LK2 is in its standard form and LMNUM will be reserved and always read"
        " as 0.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSM",
        "If asserted, this bit indicates the associated processor core only sup"
        "ports the 3-state access control model.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK2",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PID3.
static const field_t hw_xrdc_pid3[] =
{
    {
        "PID",
        "The PIDm[5] bit determines the secure (0) or nonsecure (1) attribute f"
        "or transactions associated with the corresponding processor.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LMNUM",
        "This read-only field is only enabled when ELK22K = 1.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ELK22H",
        "LK2 is in its standard form and LMNUM will be reserved and always read"
        " as 0.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSM",
        "If asserted, this bit indicates the associated processor core only sup"
        "ports the 3-state access control model.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK2",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PID4.
static const field_t hw_xrdc_pid4[] =
{
    {
        "PID",
        "The PIDm[5] bit determines the secure (0) or nonsecure (1) attribute f"
        "or transactions associated with the corresponding processor.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LMNUM",
        "This read-only field is only enabled when ELK22K = 1.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ELK22H",
        "LK2 is in its standard form and LMNUM will be reserved and always read"
        " as 0.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSM",
        "If asserted, this bit indicates the associated processor core only sup"
        "ports the 3-state access control model.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK2",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PID5.
static const field_t hw_xrdc_pid5[] =
{
    {
        "PID",
        "The PIDm[5] bit determines the secure (0) or nonsecure (1) attribute f"
        "or transactions associated with the corresponding processor.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LMNUM",
        "This read-only field is only enabled when ELK22K = 1.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ELK22H",
        "LK2 is in its standard form and LMNUM will be reserved and always read"
        " as 0.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSM",
        "If asserted, this bit indicates the associated processor core only sup"
        "ports the 3-state access control model.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK2",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PID6.
static const field_t hw_xrdc_pid6[] =
{
    {
        "PID",
        "The PIDm[5] bit determines the secure (0) or nonsecure (1) attribute f"
        "or transactions associated with the corresponding processor.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LMNUM",
        "This read-only field is only enabled when ELK22K = 1.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ELK22H",
        "LK2 is in its standard form and LMNUM will be reserved and always read"
        " as 0.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSM",
        "If asserted, this bit indicates the associated processor core only sup"
        "ports the 3-state access control model.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK2",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PID7.
static const field_t hw_xrdc_pid7[] =
{
    {
        "PID",
        "The PIDm[5] bit determines the secure (0) or nonsecure (1) attribute f"
        "or transactions associated with the corresponding processor.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LMNUM",
        "This read-only field is only enabled when ELK22K = 1.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ELK22H",
        "LK2 is in its standard form and LMNUM will be reserved and always read"
        " as 0.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSM",
        "If asserted, this bit indicates the associated processor core only sup"
        "ports the 3-state access control model.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK2",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PID8.
static const field_t hw_xrdc_pid8[] =
{
    {
        "PID",
        "The PIDm[5] bit determines the secure (0) or nonsecure (1) attribute f"
        "or transactions associated with the corresponding processor.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LMNUM",
        "This read-only field is only enabled when ELK22K = 1.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ELK22H",
        "LK2 is in its standard form and LMNUM will be reserved and always read"
        " as 0.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSM",
        "If asserted, this bit indicates the associated processor core only sup"
        "ports the 3-state access control model.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK2",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PID9.
static const field_t hw_xrdc_pid9[] =
{
    {
        "PID",
        "The PIDm[5] bit determines the secure (0) or nonsecure (1) attribute f"
        "or transactions associated with the corresponding processor.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LMNUM",
        "This read-only field is only enabled when ELK22K = 1.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ELK22H",
        "LK2 is in its standard form and LMNUM will be reserved and always read"
        " as 0.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSM",
        "If asserted, this bit indicates the associated processor core only sup"
        "ports the 3-state access control model.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK2",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PID10.
static const field_t hw_xrdc_pid10[] =
{
    {
        "PID",
        "The PIDm[5] bit determines the secure (0) or nonsecure (1) attribute f"
        "or transactions associated with the corresponding processor.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LMNUM",
        "This read-only field is only enabled when ELK22K = 1.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ELK22H",
        "LK2 is in its standard form and LMNUM will be reserved and always read"
        " as 0.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSM",
        "If asserted, this bit indicates the associated processor core only sup"
        "ports the 3-state access control model.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK2",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PID11.
static const field_t hw_xrdc_pid11[] =
{
    {
        "PID",
        "The PIDm[5] bit determines the secure (0) or nonsecure (1) attribute f"
        "or transactions associated with the corresponding processor.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LMNUM",
        "This read-only field is only enabled when ELK22K = 1.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ELK22H",
        "LK2 is in its standard form and LMNUM will be reserved and always read"
        " as 0.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSM",
        "If asserted, this bit indicates the associated processor core only sup"
        "ports the 3-state access control model.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK2",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PID12.
static const field_t hw_xrdc_pid12[] =
{
    {
        "PID",
        "The PIDm[5] bit determines the secure (0) or nonsecure (1) attribute f"
        "or transactions associated with the corresponding processor.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LMNUM",
        "This read-only field is only enabled when ELK22K = 1.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ELK22H",
        "LK2 is in its standard form and LMNUM will be reserved and always read"
        " as 0.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSM",
        "If asserted, this bit indicates the associated processor core only sup"
        "ports the 3-state access control model.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK2",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PID13.
static const field_t hw_xrdc_pid13[] =
{
    {
        "PID",
        "The PIDm[5] bit determines the secure (0) or nonsecure (1) attribute f"
        "or transactions associated with the corresponding processor.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LMNUM",
        "This read-only field is only enabled when ELK22K = 1.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ELK22H",
        "LK2 is in its standard form and LMNUM will be reserved and always read"
        " as 0.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSM",
        "If asserted, this bit indicates the associated processor core only sup"
        "ports the 3-state access control model.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LK2",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W0_0_DFMT0.
static const field_t hw_xrdc_mda_w0_0_dfmt0[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDS",
        "This field selects the source of the domain identifier.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "This field controls the optional inclusion of the PID, qualified by PI"
        "DM, into the domain hit evaluation.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIDM",
        "This field provides a masking capability so that multiple process iden"
        "tifiers can be included as part of the domain hit determination.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PID",
        "This field specifies that the process identifier is to be combined wit"
        "h the PIDM field and included in the domain hit determination.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W1_0_DFMT0.
static const field_t hw_xrdc_mda_w1_0_dfmt0[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDS",
        "This field selects the source of the domain identifier.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "This field controls the optional inclusion of the PID, qualified by PI"
        "DM, into the domain hit evaluation.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIDM",
        "This field provides a masking capability so that multiple process iden"
        "tifiers can be included as part of the domain hit determination.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PID",
        "This field specifies that the process identifier is to be combined wit"
        "h the PIDM field and included in the domain hit determination.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W0_1_DFMT0.
static const field_t hw_xrdc_mda_w0_1_dfmt0[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDS",
        "This field selects the source of the domain identifier.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "This field controls the optional inclusion of the PID, qualified by PI"
        "DM, into the domain hit evaluation.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIDM",
        "This field provides a masking capability so that multiple process iden"
        "tifiers can be included as part of the domain hit determination.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PID",
        "This field specifies that the process identifier is to be combined wit"
        "h the PIDM field and included in the domain hit determination.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W1_1_DFMT0.
static const field_t hw_xrdc_mda_w1_1_dfmt0[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDS",
        "This field selects the source of the domain identifier.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "This field controls the optional inclusion of the PID, qualified by PI"
        "DM, into the domain hit evaluation.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIDM",
        "This field provides a masking capability so that multiple process iden"
        "tifiers can be included as part of the domain hit determination.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PID",
        "This field specifies that the process identifier is to be combined wit"
        "h the PIDM field and included in the domain hit determination.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W0_3_DFMT0.
static const field_t hw_xrdc_mda_w0_3_dfmt0[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDS",
        "This field selects the source of the domain identifier.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "This field controls the optional inclusion of the PID, qualified by PI"
        "DM, into the domain hit evaluation.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIDM",
        "This field provides a masking capability so that multiple process iden"
        "tifiers can be included as part of the domain hit determination.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PID",
        "This field specifies that the process identifier is to be combined wit"
        "h the PIDM field and included in the domain hit determination.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W1_3_DFMT0.
static const field_t hw_xrdc_mda_w1_3_dfmt0[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDS",
        "This field selects the source of the domain identifier.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "This field controls the optional inclusion of the PID, qualified by PI"
        "DM, into the domain hit evaluation.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIDM",
        "This field provides a masking capability so that multiple process iden"
        "tifiers can be included as part of the domain hit determination.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PID",
        "This field specifies that the process identifier is to be combined wit"
        "h the PIDM field and included in the domain hit determination.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W0_2_DFMT1.
static const field_t hw_xrdc_mda_w0_2_dfmt1[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PA",
        "This field defines the privileged/user attribute for non-processor cor"
        "es.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SA",
        "This field defines the secure/nonsecure attribute for non-processor co"
        "res.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDB",
        "If asserted, this bit enables the bypassing of an input DID value as t"
        "he domain identifier for this non-processor bus master.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W0_4_DFMT1.
static const field_t hw_xrdc_mda_w0_4_dfmt1[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PA",
        "This field defines the privileged/user attribute for non-processor cor"
        "es.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SA",
        "This field defines the secure/nonsecure attribute for non-processor co"
        "res.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDB",
        "If asserted, this bit enables the bypassing of an input DID value as t"
        "he domain identifier for this non-processor bus master.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W0_5_DFMT1.
static const field_t hw_xrdc_mda_w0_5_dfmt1[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PA",
        "This field defines the privileged/user attribute for non-processor cor"
        "es.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SA",
        "This field defines the secure/nonsecure attribute for non-processor co"
        "res.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDB",
        "If asserted, this bit enables the bypassing of an input DID value as t"
        "he domain identifier for this non-processor bus master.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W0_6_DFMT1.
static const field_t hw_xrdc_mda_w0_6_dfmt1[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PA",
        "This field defines the privileged/user attribute for non-processor cor"
        "es.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SA",
        "This field defines the secure/nonsecure attribute for non-processor co"
        "res.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDB",
        "If asserted, this bit enables the bypassing of an input DID value as t"
        "he domain identifier for this non-processor bus master.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W0_7_DFMT1.
static const field_t hw_xrdc_mda_w0_7_dfmt1[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PA",
        "This field defines the privileged/user attribute for non-processor cor"
        "es.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SA",
        "This field defines the secure/nonsecure attribute for non-processor co"
        "res.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDB",
        "If asserted, this bit enables the bypassing of an input DID value as t"
        "he domain identifier for this non-processor bus master.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W0_8_DFMT1.
static const field_t hw_xrdc_mda_w0_8_dfmt1[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PA",
        "This field defines the privileged/user attribute for non-processor cor"
        "es.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SA",
        "This field defines the secure/nonsecure attribute for non-processor co"
        "res.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDB",
        "If asserted, this bit enables the bypassing of an input DID value as t"
        "he domain identifier for this non-processor bus master.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W0_9_DFMT1.
static const field_t hw_xrdc_mda_w0_9_dfmt1[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PA",
        "This field defines the privileged/user attribute for non-processor cor"
        "es.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SA",
        "This field defines the secure/nonsecure attribute for non-processor co"
        "res.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDB",
        "If asserted, this bit enables the bypassing of an input DID value as t"
        "he domain identifier for this non-processor bus master.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W0_10_DFMT1.
static const field_t hw_xrdc_mda_w0_10_dfmt1[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PA",
        "This field defines the privileged/user attribute for non-processor cor"
        "es.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SA",
        "This field defines the secure/nonsecure attribute for non-processor co"
        "res.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDB",
        "If asserted, this bit enables the bypassing of an input DID value as t"
        "he domain identifier for this non-processor bus master.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W0_11_DFMT1.
static const field_t hw_xrdc_mda_w0_11_dfmt1[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PA",
        "This field defines the privileged/user attribute for non-processor cor"
        "es.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SA",
        "This field defines the secure/nonsecure attribute for non-processor co"
        "res.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDB",
        "If asserted, this bit enables the bypassing of an input DID value as t"
        "he domain identifier for this non-processor bus master.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W0_12_DFMT1.
static const field_t hw_xrdc_mda_w0_12_dfmt1[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PA",
        "This field defines the privileged/user attribute for non-processor cor"
        "es.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SA",
        "This field defines the secure/nonsecure attribute for non-processor co"
        "res.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDB",
        "If asserted, this bit enables the bypassing of an input DID value as t"
        "he domain identifier for this non-processor bus master.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MDA_W0_13_DFMT1.
static const field_t hw_xrdc_mda_w0_13_dfmt1[] =
{
    {
        "DID",
        "",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PA",
        "This field defines the privileged/user attribute for non-processor cor"
        "es.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SA",
        "This field defines the secure/nonsecure attribute for non-processor co"
        "res.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIDB",
        "If asserted, this bit enables the bypassing of an input DID value as t"
        "he domain identifier for this non-processor bus master.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPID",
        "This field defines an optional logical partition identifier (as known "
        "as an operating system number) to be included in the domain hit evalua"
        "tion.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DFMT",
        "Identifies this register's domain assignment.",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LK1",
        "This field provides a locking mechanism that can be used to limit the "
        "ability to write the register.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the domain assignment is valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_8.
static const field_t hw_xrdc_pdac_w0_8[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_9.
static const field_t hw_xrdc_pdac_w0_9[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_15.
static const field_t hw_xrdc_pdac_w0_15[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_20.
static const field_t hw_xrdc_pdac_w0_20[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_21.
static const field_t hw_xrdc_pdac_w0_21[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_22.
static const field_t hw_xrdc_pdac_w0_22[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_23.
static const field_t hw_xrdc_pdac_w0_23[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_27.
static const field_t hw_xrdc_pdac_w0_27[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_32.
static const field_t hw_xrdc_pdac_w0_32[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_33.
static const field_t hw_xrdc_pdac_w0_33[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_34.
static const field_t hw_xrdc_pdac_w0_34[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_36.
static const field_t hw_xrdc_pdac_w0_36[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_37.
static const field_t hw_xrdc_pdac_w0_37[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_38.
static const field_t hw_xrdc_pdac_w0_38[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_39.
static const field_t hw_xrdc_pdac_w0_39[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_41.
static const field_t hw_xrdc_pdac_w0_41[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_42.
static const field_t hw_xrdc_pdac_w0_42[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_44.
static const field_t hw_xrdc_pdac_w0_44[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_45.
static const field_t hw_xrdc_pdac_w0_45[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_46.
static const field_t hw_xrdc_pdac_w0_46[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_47.
static const field_t hw_xrdc_pdac_w0_47[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_48.
static const field_t hw_xrdc_pdac_w0_48[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_49.
static const field_t hw_xrdc_pdac_w0_49[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_50.
static const field_t hw_xrdc_pdac_w0_50[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_51.
static const field_t hw_xrdc_pdac_w0_51[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_52.
static const field_t hw_xrdc_pdac_w0_52[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_53.
static const field_t hw_xrdc_pdac_w0_53[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_54.
static const field_t hw_xrdc_pdac_w0_54[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_55.
static const field_t hw_xrdc_pdac_w0_55[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_56.
static const field_t hw_xrdc_pdac_w0_56[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_57.
static const field_t hw_xrdc_pdac_w0_57[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_58.
static const field_t hw_xrdc_pdac_w0_58[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_59.
static const field_t hw_xrdc_pdac_w0_59[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_61.
static const field_t hw_xrdc_pdac_w0_61[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_63.
static const field_t hw_xrdc_pdac_w0_63[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_64.
static const field_t hw_xrdc_pdac_w0_64[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_65.
static const field_t hw_xrdc_pdac_w0_65[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_66.
static const field_t hw_xrdc_pdac_w0_66[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_67.
static const field_t hw_xrdc_pdac_w0_67[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_68.
static const field_t hw_xrdc_pdac_w0_68[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_69.
static const field_t hw_xrdc_pdac_w0_69[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_71.
static const field_t hw_xrdc_pdac_w0_71[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_72.
static const field_t hw_xrdc_pdac_w0_72[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_73.
static const field_t hw_xrdc_pdac_w0_73[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_74.
static const field_t hw_xrdc_pdac_w0_74[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_75.
static const field_t hw_xrdc_pdac_w0_75[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_144.
static const field_t hw_xrdc_pdac_w0_144[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_145.
static const field_t hw_xrdc_pdac_w0_145[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_146.
static const field_t hw_xrdc_pdac_w0_146[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_147.
static const field_t hw_xrdc_pdac_w0_147[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_148.
static const field_t hw_xrdc_pdac_w0_148[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_149.
static const field_t hw_xrdc_pdac_w0_149[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_150.
static const field_t hw_xrdc_pdac_w0_150[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_151.
static const field_t hw_xrdc_pdac_w0_151[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_152.
static const field_t hw_xrdc_pdac_w0_152[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_154.
static const field_t hw_xrdc_pdac_w0_154[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_155.
static const field_t hw_xrdc_pdac_w0_155[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_156.
static const field_t hw_xrdc_pdac_w0_156[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_157.
static const field_t hw_xrdc_pdac_w0_157[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_158.
static const field_t hw_xrdc_pdac_w0_158[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_160.
static const field_t hw_xrdc_pdac_w0_160[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_161.
static const field_t hw_xrdc_pdac_w0_161[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_163.
static const field_t hw_xrdc_pdac_w0_163[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_164.
static const field_t hw_xrdc_pdac_w0_164[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_165.
static const field_t hw_xrdc_pdac_w0_165[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_166.
static const field_t hw_xrdc_pdac_w0_166[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_167.
static const field_t hw_xrdc_pdac_w0_167[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_168.
static const field_t hw_xrdc_pdac_w0_168[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_169.
static const field_t hw_xrdc_pdac_w0_169[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_170.
static const field_t hw_xrdc_pdac_w0_170[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_171.
static const field_t hw_xrdc_pdac_w0_171[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_172.
static const field_t hw_xrdc_pdac_w0_172[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_173.
static const field_t hw_xrdc_pdac_w0_173[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_178.
static const field_t hw_xrdc_pdac_w0_178[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_264.
static const field_t hw_xrdc_pdac_w0_264[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_265.
static const field_t hw_xrdc_pdac_w0_265[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_271.
static const field_t hw_xrdc_pdac_w0_271[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_272.
static const field_t hw_xrdc_pdac_w0_272[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_283.
static const field_t hw_xrdc_pdac_w0_283[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_289.
static const field_t hw_xrdc_pdac_w0_289[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_290.
static const field_t hw_xrdc_pdac_w0_290[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_291.
static const field_t hw_xrdc_pdac_w0_291[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_292.
static const field_t hw_xrdc_pdac_w0_292[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_293.
static const field_t hw_xrdc_pdac_w0_293[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_294.
static const field_t hw_xrdc_pdac_w0_294[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_295.
static const field_t hw_xrdc_pdac_w0_295[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_297.
static const field_t hw_xrdc_pdac_w0_297[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_298.
static const field_t hw_xrdc_pdac_w0_298[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_299.
static const field_t hw_xrdc_pdac_w0_299[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_300.
static const field_t hw_xrdc_pdac_w0_300[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_301.
static const field_t hw_xrdc_pdac_w0_301[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_302.
static const field_t hw_xrdc_pdac_w0_302[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_305.
static const field_t hw_xrdc_pdac_w0_305[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_307.
static const field_t hw_xrdc_pdac_w0_307[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_308.
static const field_t hw_xrdc_pdac_w0_308[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_309.
static const field_t hw_xrdc_pdac_w0_309[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_310.
static const field_t hw_xrdc_pdac_w0_310[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_311.
static const field_t hw_xrdc_pdac_w0_311[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_312.
static const field_t hw_xrdc_pdac_w0_312[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_314.
static const field_t hw_xrdc_pdac_w0_314[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_317.
static const field_t hw_xrdc_pdac_w0_317[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_318.
static const field_t hw_xrdc_pdac_w0_318[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_319.
static const field_t hw_xrdc_pdac_w0_319[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_320.
static const field_t hw_xrdc_pdac_w0_320[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_321.
static const field_t hw_xrdc_pdac_w0_321[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_323.
static const field_t hw_xrdc_pdac_w0_323[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_400.
static const field_t hw_xrdc_pdac_w0_400[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_417.
static const field_t hw_xrdc_pdac_w0_417[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_418.
static const field_t hw_xrdc_pdac_w0_418[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_420.
static const field_t hw_xrdc_pdac_w0_420[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_421.
static const field_t hw_xrdc_pdac_w0_421[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_422.
static const field_t hw_xrdc_pdac_w0_422[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_423.
static const field_t hw_xrdc_pdac_w0_423[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_424.
static const field_t hw_xrdc_pdac_w0_424[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_425.
static const field_t hw_xrdc_pdac_w0_425[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_426.
static const field_t hw_xrdc_pdac_w0_426[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_427.
static const field_t hw_xrdc_pdac_w0_427[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_428.
static const field_t hw_xrdc_pdac_w0_428[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_429.
static const field_t hw_xrdc_pdac_w0_429[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_430.
static const field_t hw_xrdc_pdac_w0_430[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_431.
static const field_t hw_xrdc_pdac_w0_431[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_432.
static const field_t hw_xrdc_pdac_w0_432[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_433.
static const field_t hw_xrdc_pdac_w0_433[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_435.
static const field_t hw_xrdc_pdac_w0_435[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W0_437.
static const field_t hw_xrdc_pdac_w0_437[] =
{
    {
        "D0ACP",
        "See D7ACP above.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See D7ACP above.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See D7ACP above.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See D7ACP above.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See D7ACP above.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See D7ACP above.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See D7ACP above.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_8.
static const field_t hw_xrdc_pdac_w1_8[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_9.
static const field_t hw_xrdc_pdac_w1_9[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_15.
static const field_t hw_xrdc_pdac_w1_15[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_20.
static const field_t hw_xrdc_pdac_w1_20[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_21.
static const field_t hw_xrdc_pdac_w1_21[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_22.
static const field_t hw_xrdc_pdac_w1_22[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_23.
static const field_t hw_xrdc_pdac_w1_23[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_27.
static const field_t hw_xrdc_pdac_w1_27[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_32.
static const field_t hw_xrdc_pdac_w1_32[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_33.
static const field_t hw_xrdc_pdac_w1_33[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_34.
static const field_t hw_xrdc_pdac_w1_34[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_36.
static const field_t hw_xrdc_pdac_w1_36[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_37.
static const field_t hw_xrdc_pdac_w1_37[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_38.
static const field_t hw_xrdc_pdac_w1_38[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_39.
static const field_t hw_xrdc_pdac_w1_39[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_41.
static const field_t hw_xrdc_pdac_w1_41[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_42.
static const field_t hw_xrdc_pdac_w1_42[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_44.
static const field_t hw_xrdc_pdac_w1_44[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_45.
static const field_t hw_xrdc_pdac_w1_45[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_46.
static const field_t hw_xrdc_pdac_w1_46[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_47.
static const field_t hw_xrdc_pdac_w1_47[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_48.
static const field_t hw_xrdc_pdac_w1_48[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_49.
static const field_t hw_xrdc_pdac_w1_49[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_50.
static const field_t hw_xrdc_pdac_w1_50[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_51.
static const field_t hw_xrdc_pdac_w1_51[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_52.
static const field_t hw_xrdc_pdac_w1_52[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_53.
static const field_t hw_xrdc_pdac_w1_53[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_54.
static const field_t hw_xrdc_pdac_w1_54[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_55.
static const field_t hw_xrdc_pdac_w1_55[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_56.
static const field_t hw_xrdc_pdac_w1_56[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_57.
static const field_t hw_xrdc_pdac_w1_57[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_58.
static const field_t hw_xrdc_pdac_w1_58[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_59.
static const field_t hw_xrdc_pdac_w1_59[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_61.
static const field_t hw_xrdc_pdac_w1_61[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_63.
static const field_t hw_xrdc_pdac_w1_63[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_64.
static const field_t hw_xrdc_pdac_w1_64[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_65.
static const field_t hw_xrdc_pdac_w1_65[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_66.
static const field_t hw_xrdc_pdac_w1_66[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_67.
static const field_t hw_xrdc_pdac_w1_67[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_68.
static const field_t hw_xrdc_pdac_w1_68[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_69.
static const field_t hw_xrdc_pdac_w1_69[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_71.
static const field_t hw_xrdc_pdac_w1_71[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_72.
static const field_t hw_xrdc_pdac_w1_72[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_73.
static const field_t hw_xrdc_pdac_w1_73[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_74.
static const field_t hw_xrdc_pdac_w1_74[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_75.
static const field_t hw_xrdc_pdac_w1_75[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_144.
static const field_t hw_xrdc_pdac_w1_144[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_145.
static const field_t hw_xrdc_pdac_w1_145[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_146.
static const field_t hw_xrdc_pdac_w1_146[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_147.
static const field_t hw_xrdc_pdac_w1_147[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_148.
static const field_t hw_xrdc_pdac_w1_148[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_149.
static const field_t hw_xrdc_pdac_w1_149[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_150.
static const field_t hw_xrdc_pdac_w1_150[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_151.
static const field_t hw_xrdc_pdac_w1_151[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_152.
static const field_t hw_xrdc_pdac_w1_152[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_154.
static const field_t hw_xrdc_pdac_w1_154[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_155.
static const field_t hw_xrdc_pdac_w1_155[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_156.
static const field_t hw_xrdc_pdac_w1_156[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_157.
static const field_t hw_xrdc_pdac_w1_157[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_158.
static const field_t hw_xrdc_pdac_w1_158[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_160.
static const field_t hw_xrdc_pdac_w1_160[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_161.
static const field_t hw_xrdc_pdac_w1_161[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_163.
static const field_t hw_xrdc_pdac_w1_163[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_164.
static const field_t hw_xrdc_pdac_w1_164[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_165.
static const field_t hw_xrdc_pdac_w1_165[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_166.
static const field_t hw_xrdc_pdac_w1_166[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_167.
static const field_t hw_xrdc_pdac_w1_167[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_168.
static const field_t hw_xrdc_pdac_w1_168[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_169.
static const field_t hw_xrdc_pdac_w1_169[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_170.
static const field_t hw_xrdc_pdac_w1_170[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_171.
static const field_t hw_xrdc_pdac_w1_171[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_172.
static const field_t hw_xrdc_pdac_w1_172[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_173.
static const field_t hw_xrdc_pdac_w1_173[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_178.
static const field_t hw_xrdc_pdac_w1_178[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_264.
static const field_t hw_xrdc_pdac_w1_264[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_265.
static const field_t hw_xrdc_pdac_w1_265[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_271.
static const field_t hw_xrdc_pdac_w1_271[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_272.
static const field_t hw_xrdc_pdac_w1_272[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_283.
static const field_t hw_xrdc_pdac_w1_283[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_289.
static const field_t hw_xrdc_pdac_w1_289[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_290.
static const field_t hw_xrdc_pdac_w1_290[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_291.
static const field_t hw_xrdc_pdac_w1_291[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_292.
static const field_t hw_xrdc_pdac_w1_292[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_293.
static const field_t hw_xrdc_pdac_w1_293[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_294.
static const field_t hw_xrdc_pdac_w1_294[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_295.
static const field_t hw_xrdc_pdac_w1_295[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_297.
static const field_t hw_xrdc_pdac_w1_297[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_298.
static const field_t hw_xrdc_pdac_w1_298[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_299.
static const field_t hw_xrdc_pdac_w1_299[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_300.
static const field_t hw_xrdc_pdac_w1_300[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_301.
static const field_t hw_xrdc_pdac_w1_301[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_302.
static const field_t hw_xrdc_pdac_w1_302[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_305.
static const field_t hw_xrdc_pdac_w1_305[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_307.
static const field_t hw_xrdc_pdac_w1_307[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_308.
static const field_t hw_xrdc_pdac_w1_308[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_309.
static const field_t hw_xrdc_pdac_w1_309[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_310.
static const field_t hw_xrdc_pdac_w1_310[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_311.
static const field_t hw_xrdc_pdac_w1_311[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_312.
static const field_t hw_xrdc_pdac_w1_312[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_314.
static const field_t hw_xrdc_pdac_w1_314[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_317.
static const field_t hw_xrdc_pdac_w1_317[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_318.
static const field_t hw_xrdc_pdac_w1_318[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_319.
static const field_t hw_xrdc_pdac_w1_319[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_320.
static const field_t hw_xrdc_pdac_w1_320[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_321.
static const field_t hw_xrdc_pdac_w1_321[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_323.
static const field_t hw_xrdc_pdac_w1_323[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_400.
static const field_t hw_xrdc_pdac_w1_400[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_417.
static const field_t hw_xrdc_pdac_w1_417[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_418.
static const field_t hw_xrdc_pdac_w1_418[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_420.
static const field_t hw_xrdc_pdac_w1_420[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_421.
static const field_t hw_xrdc_pdac_w1_421[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_422.
static const field_t hw_xrdc_pdac_w1_422[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_423.
static const field_t hw_xrdc_pdac_w1_423[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_424.
static const field_t hw_xrdc_pdac_w1_424[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_425.
static const field_t hw_xrdc_pdac_w1_425[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_426.
static const field_t hw_xrdc_pdac_w1_426[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_427.
static const field_t hw_xrdc_pdac_w1_427[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_428.
static const field_t hw_xrdc_pdac_w1_428[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_429.
static const field_t hw_xrdc_pdac_w1_429[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_430.
static const field_t hw_xrdc_pdac_w1_430[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_431.
static const field_t hw_xrdc_pdac_w1_431[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_432.
static const field_t hw_xrdc_pdac_w1_432[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_433.
static const field_t hw_xrdc_pdac_w1_433[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_435.
static const field_t hw_xrdc_pdac_w1_435[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_PDAC_W1_437.
static const field_t hw_xrdc_pdac_w1_437[] =
{
    {
        "LK2",
        "Lock.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "Valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_0.
static const field_t hw_xrdc_mrgd_w0_0[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_1.
static const field_t hw_xrdc_mrgd_w0_1[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_2.
static const field_t hw_xrdc_mrgd_w0_2[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_3.
static const field_t hw_xrdc_mrgd_w0_3[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_32.
static const field_t hw_xrdc_mrgd_w0_32[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_33.
static const field_t hw_xrdc_mrgd_w0_33[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_34.
static const field_t hw_xrdc_mrgd_w0_34[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_35.
static const field_t hw_xrdc_mrgd_w0_35[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_48.
static const field_t hw_xrdc_mrgd_w0_48[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_49.
static const field_t hw_xrdc_mrgd_w0_49[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_50.
static const field_t hw_xrdc_mrgd_w0_50[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_51.
static const field_t hw_xrdc_mrgd_w0_51[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_64.
static const field_t hw_xrdc_mrgd_w0_64[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_65.
static const field_t hw_xrdc_mrgd_w0_65[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_66.
static const field_t hw_xrdc_mrgd_w0_66[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_67.
static const field_t hw_xrdc_mrgd_w0_67[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_80.
static const field_t hw_xrdc_mrgd_w0_80[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_81.
static const field_t hw_xrdc_mrgd_w0_81[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_82.
static const field_t hw_xrdc_mrgd_w0_82[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_83.
static const field_t hw_xrdc_mrgd_w0_83[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_96.
static const field_t hw_xrdc_mrgd_w0_96[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_97.
static const field_t hw_xrdc_mrgd_w0_97[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_98.
static const field_t hw_xrdc_mrgd_w0_98[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_99.
static const field_t hw_xrdc_mrgd_w0_99[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_100.
static const field_t hw_xrdc_mrgd_w0_100[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_101.
static const field_t hw_xrdc_mrgd_w0_101[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_102.
static const field_t hw_xrdc_mrgd_w0_102[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W0_103.
static const field_t hw_xrdc_mrgd_w0_103[] =
{
    {
        "BASEADDR",
        "This field defines the most significant bits of the base address of th"
        "e memory region (minimum size = 32 bytes).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_0.
static const field_t hw_xrdc_mrgd_w1_0[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_1.
static const field_t hw_xrdc_mrgd_w1_1[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_2.
static const field_t hw_xrdc_mrgd_w1_2[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_3.
static const field_t hw_xrdc_mrgd_w1_3[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_32.
static const field_t hw_xrdc_mrgd_w1_32[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_33.
static const field_t hw_xrdc_mrgd_w1_33[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_34.
static const field_t hw_xrdc_mrgd_w1_34[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_35.
static const field_t hw_xrdc_mrgd_w1_35[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_48.
static const field_t hw_xrdc_mrgd_w1_48[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_49.
static const field_t hw_xrdc_mrgd_w1_49[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_50.
static const field_t hw_xrdc_mrgd_w1_50[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_51.
static const field_t hw_xrdc_mrgd_w1_51[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_64.
static const field_t hw_xrdc_mrgd_w1_64[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_65.
static const field_t hw_xrdc_mrgd_w1_65[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_66.
static const field_t hw_xrdc_mrgd_w1_66[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_67.
static const field_t hw_xrdc_mrgd_w1_67[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_80.
static const field_t hw_xrdc_mrgd_w1_80[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_81.
static const field_t hw_xrdc_mrgd_w1_81[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_82.
static const field_t hw_xrdc_mrgd_w1_82[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_83.
static const field_t hw_xrdc_mrgd_w1_83[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_96.
static const field_t hw_xrdc_mrgd_w1_96[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_97.
static const field_t hw_xrdc_mrgd_w1_97[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_98.
static const field_t hw_xrdc_mrgd_w1_98[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_99.
static const field_t hw_xrdc_mrgd_w1_99[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_100.
static const field_t hw_xrdc_mrgd_w1_100[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_101.
static const field_t hw_xrdc_mrgd_w1_101[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_102.
static const field_t hw_xrdc_mrgd_w1_102[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W1_103.
static const field_t hw_xrdc_mrgd_w1_103[] =
{
    {
        "SRD",
        "For regions of 256 bytes or larger, this field is a bitmap enabling or"
        " disabling each of the eight equal-size subregions.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SZ",
        "The region size is defined as 2(SZ+1) bytes.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_0.
static const field_t hw_xrdc_mrgd_w2_0[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_1.
static const field_t hw_xrdc_mrgd_w2_1[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_2.
static const field_t hw_xrdc_mrgd_w2_2[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_3.
static const field_t hw_xrdc_mrgd_w2_3[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_32.
static const field_t hw_xrdc_mrgd_w2_32[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_33.
static const field_t hw_xrdc_mrgd_w2_33[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_34.
static const field_t hw_xrdc_mrgd_w2_34[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_35.
static const field_t hw_xrdc_mrgd_w2_35[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_48.
static const field_t hw_xrdc_mrgd_w2_48[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_49.
static const field_t hw_xrdc_mrgd_w2_49[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_50.
static const field_t hw_xrdc_mrgd_w2_50[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_51.
static const field_t hw_xrdc_mrgd_w2_51[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_64.
static const field_t hw_xrdc_mrgd_w2_64[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_65.
static const field_t hw_xrdc_mrgd_w2_65[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_66.
static const field_t hw_xrdc_mrgd_w2_66[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_67.
static const field_t hw_xrdc_mrgd_w2_67[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_80.
static const field_t hw_xrdc_mrgd_w2_80[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_81.
static const field_t hw_xrdc_mrgd_w2_81[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_82.
static const field_t hw_xrdc_mrgd_w2_82[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_83.
static const field_t hw_xrdc_mrgd_w2_83[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_96.
static const field_t hw_xrdc_mrgd_w2_96[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_97.
static const field_t hw_xrdc_mrgd_w2_97[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_98.
static const field_t hw_xrdc_mrgd_w2_98[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_99.
static const field_t hw_xrdc_mrgd_w2_99[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_100.
static const field_t hw_xrdc_mrgd_w2_100[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_101.
static const field_t hw_xrdc_mrgd_w2_101[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_102.
static const field_t hw_xrdc_mrgd_w2_102[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W2_103.
static const field_t hw_xrdc_mrgd_w2_103[] =
{
    {
        "D0ACP",
        "See Domain 7 access control policy.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D1ACP",
        "See Domain 7 access control policy.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D2ACP",
        "See Domain 7 access control policy.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3ACP",
        "See Domain 7 access control policy.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D4ACP",
        "See Domain 7 access control policy.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D5ACP",
        "See Domain 7 access control policy.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D6ACP",
        "See Domain 7 access control policy.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D7ACP",
        "This field defines the access control rights for the selected domain.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNUM",
        "Include this hardware semaphore in the DxACP access evaluation.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SE",
        "This field indicates if a semaphore, SNUM, is to be included in the Dx"
        "ACP access evaluation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_0.
static const field_t hw_xrdc_mrgd_w3_0[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_1.
static const field_t hw_xrdc_mrgd_w3_1[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_2.
static const field_t hw_xrdc_mrgd_w3_2[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_3.
static const field_t hw_xrdc_mrgd_w3_3[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_32.
static const field_t hw_xrdc_mrgd_w3_32[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_33.
static const field_t hw_xrdc_mrgd_w3_33[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_34.
static const field_t hw_xrdc_mrgd_w3_34[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_35.
static const field_t hw_xrdc_mrgd_w3_35[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_48.
static const field_t hw_xrdc_mrgd_w3_48[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_49.
static const field_t hw_xrdc_mrgd_w3_49[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_50.
static const field_t hw_xrdc_mrgd_w3_50[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_51.
static const field_t hw_xrdc_mrgd_w3_51[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_64.
static const field_t hw_xrdc_mrgd_w3_64[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_65.
static const field_t hw_xrdc_mrgd_w3_65[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_66.
static const field_t hw_xrdc_mrgd_w3_66[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_67.
static const field_t hw_xrdc_mrgd_w3_67[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_80.
static const field_t hw_xrdc_mrgd_w3_80[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_81.
static const field_t hw_xrdc_mrgd_w3_81[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_82.
static const field_t hw_xrdc_mrgd_w3_82[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_83.
static const field_t hw_xrdc_mrgd_w3_83[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_96.
static const field_t hw_xrdc_mrgd_w3_96[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_97.
static const field_t hw_xrdc_mrgd_w3_97[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_98.
static const field_t hw_xrdc_mrgd_w3_98[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_99.
static const field_t hw_xrdc_mrgd_w3_99[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_100.
static const field_t hw_xrdc_mrgd_w3_100[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_101.
static const field_t hw_xrdc_mrgd_w3_101[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_102.
static const field_t hw_xrdc_mrgd_w3_102[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XRDC_MRGD_W3_103.
static const field_t hw_xrdc_mrgd_w3_103[] =
{
    {
        "LK2",
        "This 2-bit field provides a mechanism to limit writes to the MRGDn reg"
        "ister to protect its contents.",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VLD",
        "This field indicates the peripheral domain access control definition i"
        "s valid.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a XRDC module.
static const reg_t hw_xrdc[] =
{
    {
        "CR",
        "This register provides read-only status about the XRDC and a global en"
        "able bit for the entire module's operation.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_xrdc_cr
    },
    {
        "HWCFG0",
        "This read-only register contains information on the XRDC's hardware co"
        "nfiguration.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_xrdc_hwcfg0
    },
    {
        "HWCFG1",
        "This register contains information on the XRDC's hardware configuratio"
        "n.",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_hwcfg1
    },
    {
        "HWCFG2",
        "This register contains information on the XRDC's hardware configuratio"
        "n.",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        false, // Writable
        32, // Number of bitfields
        hw_xrdc_hwcfg2
    },
    {
        "MDACFG0",
        "MDACFGm register reset values Register Reset value MDACGF0 02h MDACGF1"
        " 02h MDACGF2 81h MDACGF3 02h MDACGF4 81h MDACGF5 81h MDACGF6 81h MDACG"
        "F7 81h MDACGF8 81h MDACGF9 81h MDACGF10 81h MDACGF11 81h MDACGF12 81h "
        "MDACGF13 81h This register defines the number of implemented domain as"
        "signment registers for bus master m, where m+1 can specify from 1 to 6"
        "4 bus masters.",
        1, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_mdacfg0
    },
    {
        "MDACFG1",
        "MDACFGm register reset values Register Reset value MDACGF0 02h MDACGF1"
        " 02h MDACGF2 81h MDACGF3 02h MDACGF4 81h MDACGF5 81h MDACGF6 81h MDACG"
        "F7 81h MDACGF8 81h MDACGF9 81h MDACGF10 81h MDACGF11 81h MDACGF12 81h "
        "MDACGF13 81h This register defines the number of implemented domain as"
        "signment registers for bus master m, where m+1 can specify from 1 to 6"
        "4 bus masters.",
        1, // Width in bytes
        0x00000101, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_mdacfg1
    },
    {
        "MDACFG2",
        "MDACFGm register reset values Register Reset value MDACGF0 02h MDACGF1"
        " 02h MDACGF2 81h MDACGF3 02h MDACGF4 81h MDACGF5 81h MDACGF6 81h MDACG"
        "F7 81h MDACGF8 81h MDACGF9 81h MDACGF10 81h MDACGF11 81h MDACGF12 81h "
        "MDACGF13 81h This register defines the number of implemented domain as"
        "signment registers for bus master m, where m+1 can specify from 1 to 6"
        "4 bus masters.",
        1, // Width in bytes
        0x00000102, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_mdacfg2
    },
    {
        "MDACFG3",
        "MDACFGm register reset values Register Reset value MDACGF0 02h MDACGF1"
        " 02h MDACGF2 81h MDACGF3 02h MDACGF4 81h MDACGF5 81h MDACGF6 81h MDACG"
        "F7 81h MDACGF8 81h MDACGF9 81h MDACGF10 81h MDACGF11 81h MDACGF12 81h "
        "MDACGF13 81h This register defines the number of implemented domain as"
        "signment registers for bus master m, where m+1 can specify from 1 to 6"
        "4 bus masters.",
        1, // Width in bytes
        0x00000103, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_mdacfg3
    },
    {
        "MDACFG4",
        "MDACFGm register reset values Register Reset value MDACGF0 02h MDACGF1"
        " 02h MDACGF2 81h MDACGF3 02h MDACGF4 81h MDACGF5 81h MDACGF6 81h MDACG"
        "F7 81h MDACGF8 81h MDACGF9 81h MDACGF10 81h MDACGF11 81h MDACGF12 81h "
        "MDACGF13 81h This register defines the number of implemented domain as"
        "signment registers for bus master m, where m+1 can specify from 1 to 6"
        "4 bus masters.",
        1, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_mdacfg4
    },
    {
        "MDACFG5",
        "MDACFGm register reset values Register Reset value MDACGF0 02h MDACGF1"
        " 02h MDACGF2 81h MDACGF3 02h MDACGF4 81h MDACGF5 81h MDACGF6 81h MDACG"
        "F7 81h MDACGF8 81h MDACGF9 81h MDACGF10 81h MDACGF11 81h MDACGF12 81h "
        "MDACGF13 81h This register defines the number of implemented domain as"
        "signment registers for bus master m, where m+1 can specify from 1 to 6"
        "4 bus masters.",
        1, // Width in bytes
        0x00000105, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_mdacfg5
    },
    {
        "MDACFG6",
        "MDACFGm register reset values Register Reset value MDACGF0 02h MDACGF1"
        " 02h MDACGF2 81h MDACGF3 02h MDACGF4 81h MDACGF5 81h MDACGF6 81h MDACG"
        "F7 81h MDACGF8 81h MDACGF9 81h MDACGF10 81h MDACGF11 81h MDACGF12 81h "
        "MDACGF13 81h This register defines the number of implemented domain as"
        "signment registers for bus master m, where m+1 can specify from 1 to 6"
        "4 bus masters.",
        1, // Width in bytes
        0x00000106, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_mdacfg6
    },
    {
        "MDACFG7",
        "MDACFGm register reset values Register Reset value MDACGF0 02h MDACGF1"
        " 02h MDACGF2 81h MDACGF3 02h MDACGF4 81h MDACGF5 81h MDACGF6 81h MDACG"
        "F7 81h MDACGF8 81h MDACGF9 81h MDACGF10 81h MDACGF11 81h MDACGF12 81h "
        "MDACGF13 81h This register defines the number of implemented domain as"
        "signment registers for bus master m, where m+1 can specify from 1 to 6"
        "4 bus masters.",
        1, // Width in bytes
        0x00000107, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_mdacfg7
    },
    {
        "MDACFG8",
        "MDACFGm register reset values Register Reset value MDACGF0 02h MDACGF1"
        " 02h MDACGF2 81h MDACGF3 02h MDACGF4 81h MDACGF5 81h MDACGF6 81h MDACG"
        "F7 81h MDACGF8 81h MDACGF9 81h MDACGF10 81h MDACGF11 81h MDACGF12 81h "
        "MDACGF13 81h This register defines the number of implemented domain as"
        "signment registers for bus master m, where m+1 can specify from 1 to 6"
        "4 bus masters.",
        1, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_mdacfg8
    },
    {
        "MDACFG9",
        "MDACFGm register reset values Register Reset value MDACGF0 02h MDACGF1"
        " 02h MDACGF2 81h MDACGF3 02h MDACGF4 81h MDACGF5 81h MDACGF6 81h MDACG"
        "F7 81h MDACGF8 81h MDACGF9 81h MDACGF10 81h MDACGF11 81h MDACGF12 81h "
        "MDACGF13 81h This register defines the number of implemented domain as"
        "signment registers for bus master m, where m+1 can specify from 1 to 6"
        "4 bus masters.",
        1, // Width in bytes
        0x00000109, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_mdacfg9
    },
    {
        "MDACFG10",
        "MDACFGm register reset values Register Reset value MDACGF0 02h MDACGF1"
        " 02h MDACGF2 81h MDACGF3 02h MDACGF4 81h MDACGF5 81h MDACGF6 81h MDACG"
        "F7 81h MDACGF8 81h MDACGF9 81h MDACGF10 81h MDACGF11 81h MDACGF12 81h "
        "MDACGF13 81h This register defines the number of implemented domain as"
        "signment registers for bus master m, where m+1 can specify from 1 to 6"
        "4 bus masters.",
        1, // Width in bytes
        0x0000010a, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_mdacfg10
    },
    {
        "MDACFG11",
        "MDACFGm register reset values Register Reset value MDACGF0 02h MDACGF1"
        " 02h MDACGF2 81h MDACGF3 02h MDACGF4 81h MDACGF5 81h MDACGF6 81h MDACG"
        "F7 81h MDACGF8 81h MDACGF9 81h MDACGF10 81h MDACGF11 81h MDACGF12 81h "
        "MDACGF13 81h This register defines the number of implemented domain as"
        "signment registers for bus master m, where m+1 can specify from 1 to 6"
        "4 bus masters.",
        1, // Width in bytes
        0x0000010b, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_mdacfg11
    },
    {
        "MDACFG12",
        "MDACFGm register reset values Register Reset value MDACGF0 02h MDACGF1"
        " 02h MDACGF2 81h MDACGF3 02h MDACGF4 81h MDACGF5 81h MDACGF6 81h MDACG"
        "F7 81h MDACGF8 81h MDACGF9 81h MDACGF10 81h MDACGF11 81h MDACGF12 81h "
        "MDACGF13 81h This register defines the number of implemented domain as"
        "signment registers for bus master m, where m+1 can specify from 1 to 6"
        "4 bus masters.",
        1, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_mdacfg12
    },
    {
        "MDACFG13",
        "MDACFGm register reset values Register Reset value MDACGF0 02h MDACGF1"
        " 02h MDACGF2 81h MDACGF3 02h MDACGF4 81h MDACGF5 81h MDACGF6 81h MDACG"
        "F7 81h MDACGF8 81h MDACGF9 81h MDACGF10 81h MDACGF11 81h MDACGF12 81h "
        "MDACGF13 81h This register defines the number of implemented domain as"
        "signment registers for bus master m, where m+1 can specify from 1 to 6"
        "4 bus masters.",
        1, // Width in bytes
        0x0000010d, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_mdacfg13
    },
    {
        "MRCFG0",
        "MRCFGr register reset values Register Reset value MRCFG0 04h MRCFG1 08"
        "h MRCFG2 04h MRCFG3 04h MRCFG4 04h MRCFG5 04h MRCFG6 08h This read-onl"
        "y register defines the number of implemented memory region descriptors"
        " for each MRCr, where r+1 can specify up to 16 instances.",
        1, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_mrcfg0
    },
    {
        "MRCFG1",
        "MRCFGr register reset values Register Reset value MRCFG0 04h MRCFG1 08"
        "h MRCFG2 04h MRCFG3 04h MRCFG4 04h MRCFG5 04h MRCFG6 08h This read-onl"
        "y register defines the number of implemented memory region descriptors"
        " for each MRCr, where r+1 can specify up to 16 instances.",
        1, // Width in bytes
        0x00000141, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_mrcfg1
    },
    {
        "MRCFG2",
        "MRCFGr register reset values Register Reset value MRCFG0 04h MRCFG1 08"
        "h MRCFG2 04h MRCFG3 04h MRCFG4 04h MRCFG5 04h MRCFG6 08h This read-onl"
        "y register defines the number of implemented memory region descriptors"
        " for each MRCr, where r+1 can specify up to 16 instances.",
        1, // Width in bytes
        0x00000142, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_mrcfg2
    },
    {
        "MRCFG3",
        "MRCFGr register reset values Register Reset value MRCFG0 04h MRCFG1 08"
        "h MRCFG2 04h MRCFG3 04h MRCFG4 04h MRCFG5 04h MRCFG6 08h This read-onl"
        "y register defines the number of implemented memory region descriptors"
        " for each MRCr, where r+1 can specify up to 16 instances.",
        1, // Width in bytes
        0x00000143, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_mrcfg3
    },
    {
        "MRCFG4",
        "MRCFGr register reset values Register Reset value MRCFG0 04h MRCFG1 08"
        "h MRCFG2 04h MRCFG3 04h MRCFG4 04h MRCFG5 04h MRCFG6 08h This read-onl"
        "y register defines the number of implemented memory region descriptors"
        " for each MRCr, where r+1 can specify up to 16 instances.",
        1, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_mrcfg4
    },
    {
        "MRCFG5",
        "MRCFGr register reset values Register Reset value MRCFG0 04h MRCFG1 08"
        "h MRCFG2 04h MRCFG3 04h MRCFG4 04h MRCFG5 04h MRCFG6 08h This read-onl"
        "y register defines the number of implemented memory region descriptors"
        " for each MRCr, where r+1 can specify up to 16 instances.",
        1, // Width in bytes
        0x00000145, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_mrcfg5
    },
    {
        "MRCFG6",
        "MRCFGr register reset values Register Reset value MRCFG0 04h MRCFG1 08"
        "h MRCFG2 04h MRCFG3 04h MRCFG4 04h MRCFG5 04h MRCFG6 08h This read-onl"
        "y register defines the number of implemented memory region descriptors"
        " for each MRCr, where r+1 can specify up to 16 instances.",
        1, // Width in bytes
        0x00000146, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_mrcfg6
    },
    {
        "DERRLOC0",
        "This array of read-only registers provide the instance number of the s"
        "ubmodule where (an) access violation(s) occurred.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_derrloc0
    },
    {
        "DERRLOC1",
        "This array of read-only registers provide the instance number of the s"
        "ubmodule where (an) access violation(s) occurred.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_derrloc1
    },
    {
        "DERRLOC2",
        "This array of read-only registers provide the instance number of the s"
        "ubmodule where (an) access violation(s) occurred.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_derrloc2
    },
    {
        "DERRLOC3",
        "This array of read-only registers provide the instance number of the s"
        "ubmodule where (an) access violation(s) occurred.",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_derrloc3
    },
    {
        "DERRLOC4",
        "This array of read-only registers provide the instance number of the s"
        "ubmodule where (an) access violation(s) occurred.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_derrloc4
    },
    {
        "DERRLOC5",
        "This array of read-only registers provide the instance number of the s"
        "ubmodule where (an) access violation(s) occurred.",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_derrloc5
    },
    {
        "DERRLOC6",
        "This array of read-only registers provide the instance number of the s"
        "ubmodule where (an) access violation(s) occurred.",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_derrloc6
    },
    {
        "DERRLOC7",
        "This array of read-only registers provide the instance number of the s"
        "ubmodule where (an) access violation(s) occurred.",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_xrdc_derrloc7
    },
    {
        "DERR_W0_0",
        "This read-only register array provides the address of an access violat"
        "ion detected by either a memory region controller (MRC) or a periphera"
        "l access controller (PAC).",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w0_0
    },
    {
        "DERR_W1_0",
        "This read-only register array provides the attributes of an access vio"
        "lation detected by either a memory region controller (MRC) or a periph"
        "eral access controller (PAC).",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_xrdc_derr_w1_0
    },
    {
        "DERR_W3_0",
        "This register is used to rearm the error capture logic and clear the D"
        "ERR_W0_i and DERR_W1_i registers.",
        4, // Width in bytes
        0x0000040c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w3_0
    },
    {
        "DERR_W0_1",
        "This read-only register array provides the address of an access violat"
        "ion detected by either a memory region controller (MRC) or a periphera"
        "l access controller (PAC).",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w0_1
    },
    {
        "DERR_W1_1",
        "This read-only register array provides the attributes of an access vio"
        "lation detected by either a memory region controller (MRC) or a periph"
        "eral access controller (PAC).",
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_xrdc_derr_w1_1
    },
    {
        "DERR_W3_1",
        "This register is used to rearm the error capture logic and clear the D"
        "ERR_W0_i and DERR_W1_i registers.",
        4, // Width in bytes
        0x0000041c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w3_1
    },
    {
        "DERR_W0_2",
        "This read-only register array provides the address of an access violat"
        "ion detected by either a memory region controller (MRC) or a periphera"
        "l access controller (PAC).",
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w0_2
    },
    {
        "DERR_W1_2",
        "This read-only register array provides the attributes of an access vio"
        "lation detected by either a memory region controller (MRC) or a periph"
        "eral access controller (PAC).",
        4, // Width in bytes
        0x00000424, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_xrdc_derr_w1_2
    },
    {
        "DERR_W3_2",
        "This register is used to rearm the error capture logic and clear the D"
        "ERR_W0_i and DERR_W1_i registers.",
        4, // Width in bytes
        0x0000042c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w3_2
    },
    {
        "DERR_W0_3",
        "This read-only register array provides the address of an access violat"
        "ion detected by either a memory region controller (MRC) or a periphera"
        "l access controller (PAC).",
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w0_3
    },
    {
        "DERR_W1_3",
        "This read-only register array provides the attributes of an access vio"
        "lation detected by either a memory region controller (MRC) or a periph"
        "eral access controller (PAC).",
        4, // Width in bytes
        0x00000434, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_xrdc_derr_w1_3
    },
    {
        "DERR_W3_3",
        "This register is used to rearm the error capture logic and clear the D"
        "ERR_W0_i and DERR_W1_i registers.",
        4, // Width in bytes
        0x0000043c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w3_3
    },
    {
        "DERR_W0_4",
        "This read-only register array provides the address of an access violat"
        "ion detected by either a memory region controller (MRC) or a periphera"
        "l access controller (PAC).",
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w0_4
    },
    {
        "DERR_W1_4",
        "This read-only register array provides the attributes of an access vio"
        "lation detected by either a memory region controller (MRC) or a periph"
        "eral access controller (PAC).",
        4, // Width in bytes
        0x00000444, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_xrdc_derr_w1_4
    },
    {
        "DERR_W3_4",
        "This register is used to rearm the error capture logic and clear the D"
        "ERR_W0_i and DERR_W1_i registers.",
        4, // Width in bytes
        0x0000044c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w3_4
    },
    {
        "DERR_W0_5",
        "This read-only register array provides the address of an access violat"
        "ion detected by either a memory region controller (MRC) or a periphera"
        "l access controller (PAC).",
        4, // Width in bytes
        0x00000450, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w0_5
    },
    {
        "DERR_W1_5",
        "This read-only register array provides the attributes of an access vio"
        "lation detected by either a memory region controller (MRC) or a periph"
        "eral access controller (PAC).",
        4, // Width in bytes
        0x00000454, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_xrdc_derr_w1_5
    },
    {
        "DERR_W3_5",
        "This register is used to rearm the error capture logic and clear the D"
        "ERR_W0_i and DERR_W1_i registers.",
        4, // Width in bytes
        0x0000045c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w3_5
    },
    {
        "DERR_W0_6",
        "This read-only register array provides the address of an access violat"
        "ion detected by either a memory region controller (MRC) or a periphera"
        "l access controller (PAC).",
        4, // Width in bytes
        0x00000460, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w0_6
    },
    {
        "DERR_W1_6",
        "This read-only register array provides the attributes of an access vio"
        "lation detected by either a memory region controller (MRC) or a periph"
        "eral access controller (PAC).",
        4, // Width in bytes
        0x00000464, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_xrdc_derr_w1_6
    },
    {
        "DERR_W3_6",
        "This register is used to rearm the error capture logic and clear the D"
        "ERR_W0_i and DERR_W1_i registers.",
        4, // Width in bytes
        0x0000046c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w3_6
    },
    {
        "DERR_W0_16",
        "This read-only register array provides the address of an access violat"
        "ion detected by either a memory region controller (MRC) or a periphera"
        "l access controller (PAC).",
        4, // Width in bytes
        0x00000500, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w0_16
    },
    {
        "DERR_W1_16",
        "This read-only register array provides the attributes of an access vio"
        "lation detected by either a memory region controller (MRC) or a periph"
        "eral access controller (PAC).",
        4, // Width in bytes
        0x00000504, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_xrdc_derr_w1_16
    },
    {
        "DERR_W3_16",
        "This register is used to rearm the error capture logic and clear the D"
        "ERR_W0_i and DERR_W1_i registers.",
        4, // Width in bytes
        0x0000050c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w3_16
    },
    {
        "DERR_W0_17",
        "This read-only register array provides the address of an access violat"
        "ion detected by either a memory region controller (MRC) or a periphera"
        "l access controller (PAC).",
        4, // Width in bytes
        0x00000510, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w0_17
    },
    {
        "DERR_W1_17",
        "This read-only register array provides the attributes of an access vio"
        "lation detected by either a memory region controller (MRC) or a periph"
        "eral access controller (PAC).",
        4, // Width in bytes
        0x00000514, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_xrdc_derr_w1_17
    },
    {
        "DERR_W3_17",
        "This register is used to rearm the error capture logic and clear the D"
        "ERR_W0_i and DERR_W1_i registers.",
        4, // Width in bytes
        0x0000051c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w3_17
    },
    {
        "DERR_W0_18",
        "This read-only register array provides the address of an access violat"
        "ion detected by either a memory region controller (MRC) or a periphera"
        "l access controller (PAC).",
        4, // Width in bytes
        0x00000520, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w0_18
    },
    {
        "DERR_W1_18",
        "This read-only register array provides the attributes of an access vio"
        "lation detected by either a memory region controller (MRC) or a periph"
        "eral access controller (PAC).",
        4, // Width in bytes
        0x00000524, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_xrdc_derr_w1_18
    },
    {
        "DERR_W3_18",
        "This register is used to rearm the error capture logic and clear the D"
        "ERR_W0_i and DERR_W1_i registers.",
        4, // Width in bytes
        0x0000052c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w3_18
    },
    {
        "DERR_W0_19",
        "This read-only register array provides the address of an access violat"
        "ion detected by either a memory region controller (MRC) or a periphera"
        "l access controller (PAC).",
        4, // Width in bytes
        0x00000530, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w0_19
    },
    {
        "DERR_W1_19",
        "This read-only register array provides the attributes of an access vio"
        "lation detected by either a memory region controller (MRC) or a periph"
        "eral access controller (PAC).",
        4, // Width in bytes
        0x00000534, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_xrdc_derr_w1_19
    },
    {
        "DERR_W3_19",
        "This register is used to rearm the error capture logic and clear the D"
        "ERR_W0_i and DERR_W1_i registers.",
        4, // Width in bytes
        0x0000053c, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_derr_w3_19
    },
    {
        "PID0",
        "In the XRDC's access control definition, each processor has a correspo"
        "nding process identifier (PID) which performs two important functions:"
        " the PID[5] bit defines the secure/nonsecure attribute associated with"
        " an executing task, and the entire value can be used to group tasks in"
        "to different domains.",
        4, // Width in bytes
        0x00000700, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_xrdc_pid0
    },
    {
        "PID1",
        "In the XRDC's access control definition, each processor has a correspo"
        "nding process identifier (PID) which performs two important functions:"
        " the PID[5] bit defines the secure/nonsecure attribute associated with"
        " an executing task, and the entire value can be used to group tasks in"
        "to different domains.",
        4, // Width in bytes
        0x00000704, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_xrdc_pid1
    },
    {
        "PID2",
        "In the XRDC's access control definition, each processor has a correspo"
        "nding process identifier (PID) which performs two important functions:"
        " the PID[5] bit defines the secure/nonsecure attribute associated with"
        " an executing task, and the entire value can be used to group tasks in"
        "to different domains.",
        4, // Width in bytes
        0x00000708, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_xrdc_pid2
    },
    {
        "PID3",
        "In the XRDC's access control definition, each processor has a correspo"
        "nding process identifier (PID) which performs two important functions:"
        " the PID[5] bit defines the secure/nonsecure attribute associated with"
        " an executing task, and the entire value can be used to group tasks in"
        "to different domains.",
        4, // Width in bytes
        0x0000070c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_xrdc_pid3
    },
    {
        "PID4",
        "In the XRDC's access control definition, each processor has a correspo"
        "nding process identifier (PID) which performs two important functions:"
        " the PID[5] bit defines the secure/nonsecure attribute associated with"
        " an executing task, and the entire value can be used to group tasks in"
        "to different domains.",
        4, // Width in bytes
        0x00000710, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_xrdc_pid4
    },
    {
        "PID5",
        "In the XRDC's access control definition, each processor has a correspo"
        "nding process identifier (PID) which performs two important functions:"
        " the PID[5] bit defines the secure/nonsecure attribute associated with"
        " an executing task, and the entire value can be used to group tasks in"
        "to different domains.",
        4, // Width in bytes
        0x00000714, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_xrdc_pid5
    },
    {
        "PID6",
        "In the XRDC's access control definition, each processor has a correspo"
        "nding process identifier (PID) which performs two important functions:"
        " the PID[5] bit defines the secure/nonsecure attribute associated with"
        " an executing task, and the entire value can be used to group tasks in"
        "to different domains.",
        4, // Width in bytes
        0x00000718, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_xrdc_pid6
    },
    {
        "PID7",
        "In the XRDC's access control definition, each processor has a correspo"
        "nding process identifier (PID) which performs two important functions:"
        " the PID[5] bit defines the secure/nonsecure attribute associated with"
        " an executing task, and the entire value can be used to group tasks in"
        "to different domains.",
        4, // Width in bytes
        0x0000071c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_xrdc_pid7
    },
    {
        "PID8",
        "In the XRDC's access control definition, each processor has a correspo"
        "nding process identifier (PID) which performs two important functions:"
        " the PID[5] bit defines the secure/nonsecure attribute associated with"
        " an executing task, and the entire value can be used to group tasks in"
        "to different domains.",
        4, // Width in bytes
        0x00000720, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_xrdc_pid8
    },
    {
        "PID9",
        "In the XRDC's access control definition, each processor has a correspo"
        "nding process identifier (PID) which performs two important functions:"
        " the PID[5] bit defines the secure/nonsecure attribute associated with"
        " an executing task, and the entire value can be used to group tasks in"
        "to different domains.",
        4, // Width in bytes
        0x00000724, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_xrdc_pid9
    },
    {
        "PID10",
        "In the XRDC's access control definition, each processor has a correspo"
        "nding process identifier (PID) which performs two important functions:"
        " the PID[5] bit defines the secure/nonsecure attribute associated with"
        " an executing task, and the entire value can be used to group tasks in"
        "to different domains.",
        4, // Width in bytes
        0x00000728, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_xrdc_pid10
    },
    {
        "PID11",
        "In the XRDC's access control definition, each processor has a correspo"
        "nding process identifier (PID) which performs two important functions:"
        " the PID[5] bit defines the secure/nonsecure attribute associated with"
        " an executing task, and the entire value can be used to group tasks in"
        "to different domains.",
        4, // Width in bytes
        0x0000072c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_xrdc_pid11
    },
    {
        "PID12",
        "In the XRDC's access control definition, each processor has a correspo"
        "nding process identifier (PID) which performs two important functions:"
        " the PID[5] bit defines the secure/nonsecure attribute associated with"
        " an executing task, and the entire value can be used to group tasks in"
        "to different domains.",
        4, // Width in bytes
        0x00000730, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_xrdc_pid12
    },
    {
        "PID13",
        "In the XRDC's access control definition, each processor has a correspo"
        "nding process identifier (PID) which performs two important functions:"
        " the PID[5] bit defines the secure/nonsecure attribute associated with"
        " an executing task, and the entire value can be used to group tasks in"
        "to different domains.",
        4, // Width in bytes
        0x00000734, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_xrdc_pid13
    },
    {
        "MDA_W0_0_DFMT0",
        "The MDA_Wr_m registers provide a 2-dimensional data structure for assi"
        "gning bus masters to domains.",
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_xrdc_mda_w0_0_dfmt0
    },
    {
        "MDA_W1_0_DFMT0",
        "The MDA_Wr_m registers provide a 2-dimensional data structure for assi"
        "gning bus masters to domains.",
        4, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_xrdc_mda_w1_0_dfmt0
    },
    {
        "MDA_W0_1_DFMT0",
        "The MDA_Wr_m registers provide a 2-dimensional data structure for assi"
        "gning bus masters to domains.",
        4, // Width in bytes
        0x00000820, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_xrdc_mda_w0_1_dfmt0
    },
    {
        "MDA_W1_1_DFMT0",
        "The MDA_Wr_m registers provide a 2-dimensional data structure for assi"
        "gning bus masters to domains.",
        4, // Width in bytes
        0x00000824, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_xrdc_mda_w1_1_dfmt0
    },
    {
        "MDA_W0_3_DFMT0",
        "The MDA_Wr_m registers provide a 2-dimensional data structure for assi"
        "gning bus masters to domains.",
        4, // Width in bytes
        0x00000860, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_xrdc_mda_w0_3_dfmt0
    },
    {
        "MDA_W1_3_DFMT0",
        "The MDA_Wr_m registers provide a 2-dimensional data structure for assi"
        "gning bus masters to domains.",
        4, // Width in bytes
        0x00000864, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_xrdc_mda_w1_3_dfmt0
    },
    {
        "MDA_W0_2_DFMT1",
        "This register is identical to Master Domain Assignment (MDA_Wr_m_DFMT0"
        ") except that the domain format field, DFMT, is 1.",
        4, // Width in bytes
        0x00000840, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xrdc_mda_w0_2_dfmt1
    },
    {
        "MDA_W0_4_DFMT1",
        "This register is identical to Master Domain Assignment (MDA_Wr_m_DFMT0"
        ") except that the domain format field, DFMT, is 1.",
        4, // Width in bytes
        0x00000880, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xrdc_mda_w0_4_dfmt1
    },
    {
        "MDA_W0_5_DFMT1",
        "This register is identical to Master Domain Assignment (MDA_Wr_m_DFMT0"
        ") except that the domain format field, DFMT, is 1.",
        4, // Width in bytes
        0x000008a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xrdc_mda_w0_5_dfmt1
    },
    {
        "MDA_W0_6_DFMT1",
        "This register is identical to Master Domain Assignment (MDA_Wr_m_DFMT0"
        ") except that the domain format field, DFMT, is 1.",
        4, // Width in bytes
        0x000008c0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xrdc_mda_w0_6_dfmt1
    },
    {
        "MDA_W0_7_DFMT1",
        "This register is identical to Master Domain Assignment (MDA_Wr_m_DFMT0"
        ") except that the domain format field, DFMT, is 1.",
        4, // Width in bytes
        0x000008e0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xrdc_mda_w0_7_dfmt1
    },
    {
        "MDA_W0_8_DFMT1",
        "This register is identical to Master Domain Assignment (MDA_Wr_m_DFMT0"
        ") except that the domain format field, DFMT, is 1.",
        4, // Width in bytes
        0x00000900, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xrdc_mda_w0_8_dfmt1
    },
    {
        "MDA_W0_9_DFMT1",
        "This register is identical to Master Domain Assignment (MDA_Wr_m_DFMT0"
        ") except that the domain format field, DFMT, is 1.",
        4, // Width in bytes
        0x00000920, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xrdc_mda_w0_9_dfmt1
    },
    {
        "MDA_W0_10_DFMT1",
        "This register is identical to Master Domain Assignment (MDA_Wr_m_DFMT0"
        ") except that the domain format field, DFMT, is 1.",
        4, // Width in bytes
        0x00000940, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xrdc_mda_w0_10_dfmt1
    },
    {
        "MDA_W0_11_DFMT1",
        "This register is identical to Master Domain Assignment (MDA_Wr_m_DFMT0"
        ") except that the domain format field, DFMT, is 1.",
        4, // Width in bytes
        0x00000960, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xrdc_mda_w0_11_dfmt1
    },
    {
        "MDA_W0_12_DFMT1",
        "This register is identical to Master Domain Assignment (MDA_Wr_m_DFMT0"
        ") except that the domain format field, DFMT, is 1.",
        4, // Width in bytes
        0x00000980, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xrdc_mda_w0_12_dfmt1
    },
    {
        "MDA_W0_13_DFMT1",
        "This register is identical to Master Domain Assignment (MDA_Wr_m_DFMT0"
        ") except that the domain format field, DFMT, is 1.",
        4, // Width in bytes
        0x000009a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xrdc_mda_w0_13_dfmt1
    },
    {
        "PDAC_W0_8",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001040, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_8
    },
    {
        "PDAC_W0_9",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001048, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_9
    },
    {
        "PDAC_W0_15",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001078, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_15
    },
    {
        "PDAC_W0_20",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000010a0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_20
    },
    {
        "PDAC_W0_21",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000010a8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_21
    },
    {
        "PDAC_W0_22",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000010b0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_22
    },
    {
        "PDAC_W0_23",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000010b8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_23
    },
    {
        "PDAC_W0_27",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000010d8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_27
    },
    {
        "PDAC_W0_32",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001100, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_32
    },
    {
        "PDAC_W0_33",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001108, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_33
    },
    {
        "PDAC_W0_34",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001110, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_34
    },
    {
        "PDAC_W0_36",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001120, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_36
    },
    {
        "PDAC_W0_37",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001128, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_37
    },
    {
        "PDAC_W0_38",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001130, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_38
    },
    {
        "PDAC_W0_39",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001138, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_39
    },
    {
        "PDAC_W0_41",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001148, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_41
    },
    {
        "PDAC_W0_42",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001150, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_42
    },
    {
        "PDAC_W0_44",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001160, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_44
    },
    {
        "PDAC_W0_45",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001168, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_45
    },
    {
        "PDAC_W0_46",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001170, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_46
    },
    {
        "PDAC_W0_47",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001178, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_47
    },
    {
        "PDAC_W0_48",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001180, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_48
    },
    {
        "PDAC_W0_49",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001188, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_49
    },
    {
        "PDAC_W0_50",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001190, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_50
    },
    {
        "PDAC_W0_51",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001198, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_51
    },
    {
        "PDAC_W0_52",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000011a0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_52
    },
    {
        "PDAC_W0_53",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000011a8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_53
    },
    {
        "PDAC_W0_54",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000011b0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_54
    },
    {
        "PDAC_W0_55",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000011b8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_55
    },
    {
        "PDAC_W0_56",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000011c0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_56
    },
    {
        "PDAC_W0_57",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000011c8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_57
    },
    {
        "PDAC_W0_58",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000011d0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_58
    },
    {
        "PDAC_W0_59",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000011d8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_59
    },
    {
        "PDAC_W0_61",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000011e8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_61
    },
    {
        "PDAC_W0_63",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000011f8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_63
    },
    {
        "PDAC_W0_64",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001200, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_64
    },
    {
        "PDAC_W0_65",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001208, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_65
    },
    {
        "PDAC_W0_66",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001210, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_66
    },
    {
        "PDAC_W0_67",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001218, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_67
    },
    {
        "PDAC_W0_68",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001220, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_68
    },
    {
        "PDAC_W0_69",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001228, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_69
    },
    {
        "PDAC_W0_71",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001238, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_71
    },
    {
        "PDAC_W0_72",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001240, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_72
    },
    {
        "PDAC_W0_73",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001248, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_73
    },
    {
        "PDAC_W0_74",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001250, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_74
    },
    {
        "PDAC_W0_75",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001258, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_75
    },
    {
        "PDAC_W0_144",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001480, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_144
    },
    {
        "PDAC_W0_145",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001488, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_145
    },
    {
        "PDAC_W0_146",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001490, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_146
    },
    {
        "PDAC_W0_147",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001498, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_147
    },
    {
        "PDAC_W0_148",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000014a0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_148
    },
    {
        "PDAC_W0_149",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000014a8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_149
    },
    {
        "PDAC_W0_150",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000014b0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_150
    },
    {
        "PDAC_W0_151",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000014b8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_151
    },
    {
        "PDAC_W0_152",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000014c0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_152
    },
    {
        "PDAC_W0_154",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000014d0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_154
    },
    {
        "PDAC_W0_155",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000014d8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_155
    },
    {
        "PDAC_W0_156",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000014e0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_156
    },
    {
        "PDAC_W0_157",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000014e8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_157
    },
    {
        "PDAC_W0_158",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000014f0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_158
    },
    {
        "PDAC_W0_160",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001500, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_160
    },
    {
        "PDAC_W0_161",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001508, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_161
    },
    {
        "PDAC_W0_163",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001518, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_163
    },
    {
        "PDAC_W0_164",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001520, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_164
    },
    {
        "PDAC_W0_165",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001528, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_165
    },
    {
        "PDAC_W0_166",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001530, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_166
    },
    {
        "PDAC_W0_167",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001538, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_167
    },
    {
        "PDAC_W0_168",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001540, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_168
    },
    {
        "PDAC_W0_169",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001548, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_169
    },
    {
        "PDAC_W0_170",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001550, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_170
    },
    {
        "PDAC_W0_171",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001558, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_171
    },
    {
        "PDAC_W0_172",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001560, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_172
    },
    {
        "PDAC_W0_173",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001568, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_173
    },
    {
        "PDAC_W0_178",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001590, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_178
    },
    {
        "PDAC_W0_264",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001840, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_264
    },
    {
        "PDAC_W0_265",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001848, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_265
    },
    {
        "PDAC_W0_271",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001878, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_271
    },
    {
        "PDAC_W0_272",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001880, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_272
    },
    {
        "PDAC_W0_283",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000018d8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_283
    },
    {
        "PDAC_W0_289",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001908, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_289
    },
    {
        "PDAC_W0_290",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001910, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_290
    },
    {
        "PDAC_W0_291",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001918, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_291
    },
    {
        "PDAC_W0_292",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001920, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_292
    },
    {
        "PDAC_W0_293",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001928, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_293
    },
    {
        "PDAC_W0_294",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001930, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_294
    },
    {
        "PDAC_W0_295",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001938, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_295
    },
    {
        "PDAC_W0_297",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001948, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_297
    },
    {
        "PDAC_W0_298",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001950, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_298
    },
    {
        "PDAC_W0_299",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001958, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_299
    },
    {
        "PDAC_W0_300",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001960, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_300
    },
    {
        "PDAC_W0_301",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001968, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_301
    },
    {
        "PDAC_W0_302",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001970, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_302
    },
    {
        "PDAC_W0_305",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001988, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_305
    },
    {
        "PDAC_W0_307",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001998, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_307
    },
    {
        "PDAC_W0_308",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000019a0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_308
    },
    {
        "PDAC_W0_309",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000019a8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_309
    },
    {
        "PDAC_W0_310",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000019b0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_310
    },
    {
        "PDAC_W0_311",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000019b8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_311
    },
    {
        "PDAC_W0_312",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000019c0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_312
    },
    {
        "PDAC_W0_314",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000019d0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_314
    },
    {
        "PDAC_W0_317",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000019e8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_317
    },
    {
        "PDAC_W0_318",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000019f0, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_318
    },
    {
        "PDAC_W0_319",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x000019f8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_319
    },
    {
        "PDAC_W0_320",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001a00, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_320
    },
    {
        "PDAC_W0_321",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001a08, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_321
    },
    {
        "PDAC_W0_323",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001a18, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_323
    },
    {
        "PDAC_W0_400",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001c80, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_400
    },
    {
        "PDAC_W0_417",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d08, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_417
    },
    {
        "PDAC_W0_418",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d10, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_418
    },
    {
        "PDAC_W0_420",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d20, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_420
    },
    {
        "PDAC_W0_421",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d28, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_421
    },
    {
        "PDAC_W0_422",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d30, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_422
    },
    {
        "PDAC_W0_423",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d38, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_423
    },
    {
        "PDAC_W0_424",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d40, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_424
    },
    {
        "PDAC_W0_425",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d48, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_425
    },
    {
        "PDAC_W0_426",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d50, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_426
    },
    {
        "PDAC_W0_427",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d58, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_427
    },
    {
        "PDAC_W0_428",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d60, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_428
    },
    {
        "PDAC_W0_429",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d68, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_429
    },
    {
        "PDAC_W0_430",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d70, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_430
    },
    {
        "PDAC_W0_431",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d78, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_431
    },
    {
        "PDAC_W0_432",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d80, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_432
    },
    {
        "PDAC_W0_433",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d88, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_433
    },
    {
        "PDAC_W0_435",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001d98, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_435
    },
    {
        "PDAC_W0_437",
        "The PDAC_Wr_s registers provide a 2-dimensional data structure for def"
        "ining access control policies per domain for each implemented slave pe"
        "ripheral.",
        4, // Width in bytes
        0x00001da8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_pdac_w0_437
    },
    {
        "PDAC_W1_8",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001044, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_8
    },
    {
        "PDAC_W1_9",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000104c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_9
    },
    {
        "PDAC_W1_15",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000107c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_15
    },
    {
        "PDAC_W1_20",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000010a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_20
    },
    {
        "PDAC_W1_21",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000010ac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_21
    },
    {
        "PDAC_W1_22",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000010b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_22
    },
    {
        "PDAC_W1_23",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000010bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_23
    },
    {
        "PDAC_W1_27",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000010dc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_27
    },
    {
        "PDAC_W1_32",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001104, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_32
    },
    {
        "PDAC_W1_33",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000110c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_33
    },
    {
        "PDAC_W1_34",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001114, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_34
    },
    {
        "PDAC_W1_36",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001124, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_36
    },
    {
        "PDAC_W1_37",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000112c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_37
    },
    {
        "PDAC_W1_38",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001134, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_38
    },
    {
        "PDAC_W1_39",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000113c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_39
    },
    {
        "PDAC_W1_41",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000114c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_41
    },
    {
        "PDAC_W1_42",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001154, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_42
    },
    {
        "PDAC_W1_44",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001164, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_44
    },
    {
        "PDAC_W1_45",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000116c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_45
    },
    {
        "PDAC_W1_46",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001174, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_46
    },
    {
        "PDAC_W1_47",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000117c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_47
    },
    {
        "PDAC_W1_48",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001184, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_48
    },
    {
        "PDAC_W1_49",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000118c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_49
    },
    {
        "PDAC_W1_50",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001194, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_50
    },
    {
        "PDAC_W1_51",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000119c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_51
    },
    {
        "PDAC_W1_52",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000011a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_52
    },
    {
        "PDAC_W1_53",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000011ac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_53
    },
    {
        "PDAC_W1_54",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000011b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_54
    },
    {
        "PDAC_W1_55",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000011bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_55
    },
    {
        "PDAC_W1_56",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000011c4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_56
    },
    {
        "PDAC_W1_57",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000011cc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_57
    },
    {
        "PDAC_W1_58",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000011d4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_58
    },
    {
        "PDAC_W1_59",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000011dc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_59
    },
    {
        "PDAC_W1_61",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000011ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_61
    },
    {
        "PDAC_W1_63",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000011fc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_63
    },
    {
        "PDAC_W1_64",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001204, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_64
    },
    {
        "PDAC_W1_65",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000120c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_65
    },
    {
        "PDAC_W1_66",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001214, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_66
    },
    {
        "PDAC_W1_67",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000121c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_67
    },
    {
        "PDAC_W1_68",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001224, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_68
    },
    {
        "PDAC_W1_69",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000122c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_69
    },
    {
        "PDAC_W1_71",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000123c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_71
    },
    {
        "PDAC_W1_72",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001244, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_72
    },
    {
        "PDAC_W1_73",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000124c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_73
    },
    {
        "PDAC_W1_74",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001254, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_74
    },
    {
        "PDAC_W1_75",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000125c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_75
    },
    {
        "PDAC_W1_144",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001484, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_144
    },
    {
        "PDAC_W1_145",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000148c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_145
    },
    {
        "PDAC_W1_146",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001494, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_146
    },
    {
        "PDAC_W1_147",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000149c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_147
    },
    {
        "PDAC_W1_148",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000014a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_148
    },
    {
        "PDAC_W1_149",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000014ac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_149
    },
    {
        "PDAC_W1_150",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000014b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_150
    },
    {
        "PDAC_W1_151",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000014bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_151
    },
    {
        "PDAC_W1_152",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000014c4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_152
    },
    {
        "PDAC_W1_154",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000014d4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_154
    },
    {
        "PDAC_W1_155",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000014dc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_155
    },
    {
        "PDAC_W1_156",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000014e4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_156
    },
    {
        "PDAC_W1_157",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000014ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_157
    },
    {
        "PDAC_W1_158",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000014f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_158
    },
    {
        "PDAC_W1_160",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001504, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_160
    },
    {
        "PDAC_W1_161",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000150c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_161
    },
    {
        "PDAC_W1_163",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000151c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_163
    },
    {
        "PDAC_W1_164",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001524, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_164
    },
    {
        "PDAC_W1_165",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000152c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_165
    },
    {
        "PDAC_W1_166",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001534, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_166
    },
    {
        "PDAC_W1_167",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000153c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_167
    },
    {
        "PDAC_W1_168",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001544, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_168
    },
    {
        "PDAC_W1_169",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000154c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_169
    },
    {
        "PDAC_W1_170",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001554, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_170
    },
    {
        "PDAC_W1_171",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000155c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_171
    },
    {
        "PDAC_W1_172",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001564, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_172
    },
    {
        "PDAC_W1_173",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000156c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_173
    },
    {
        "PDAC_W1_178",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001594, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_178
    },
    {
        "PDAC_W1_264",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001844, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_264
    },
    {
        "PDAC_W1_265",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000184c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_265
    },
    {
        "PDAC_W1_271",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000187c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_271
    },
    {
        "PDAC_W1_272",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001884, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_272
    },
    {
        "PDAC_W1_283",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000018dc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_283
    },
    {
        "PDAC_W1_289",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000190c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_289
    },
    {
        "PDAC_W1_290",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001914, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_290
    },
    {
        "PDAC_W1_291",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000191c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_291
    },
    {
        "PDAC_W1_292",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001924, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_292
    },
    {
        "PDAC_W1_293",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000192c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_293
    },
    {
        "PDAC_W1_294",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001934, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_294
    },
    {
        "PDAC_W1_295",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000193c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_295
    },
    {
        "PDAC_W1_297",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000194c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_297
    },
    {
        "PDAC_W1_298",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001954, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_298
    },
    {
        "PDAC_W1_299",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000195c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_299
    },
    {
        "PDAC_W1_300",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001964, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_300
    },
    {
        "PDAC_W1_301",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000196c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_301
    },
    {
        "PDAC_W1_302",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001974, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_302
    },
    {
        "PDAC_W1_305",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000198c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_305
    },
    {
        "PDAC_W1_307",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x0000199c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_307
    },
    {
        "PDAC_W1_308",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000019a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_308
    },
    {
        "PDAC_W1_309",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000019ac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_309
    },
    {
        "PDAC_W1_310",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000019b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_310
    },
    {
        "PDAC_W1_311",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000019bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_311
    },
    {
        "PDAC_W1_312",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000019c4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_312
    },
    {
        "PDAC_W1_314",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000019d4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_314
    },
    {
        "PDAC_W1_317",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000019ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_317
    },
    {
        "PDAC_W1_318",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000019f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_318
    },
    {
        "PDAC_W1_319",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x000019fc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_319
    },
    {
        "PDAC_W1_320",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001a04, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_320
    },
    {
        "PDAC_W1_321",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001a0c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_321
    },
    {
        "PDAC_W1_323",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001a1c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_323
    },
    {
        "PDAC_W1_400",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001c84, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_400
    },
    {
        "PDAC_W1_417",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d0c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_417
    },
    {
        "PDAC_W1_418",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d14, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_418
    },
    {
        "PDAC_W1_420",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d24, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_420
    },
    {
        "PDAC_W1_421",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d2c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_421
    },
    {
        "PDAC_W1_422",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d34, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_422
    },
    {
        "PDAC_W1_423",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d3c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_423
    },
    {
        "PDAC_W1_424",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d44, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_424
    },
    {
        "PDAC_W1_425",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d4c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_425
    },
    {
        "PDAC_W1_426",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d54, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_426
    },
    {
        "PDAC_W1_427",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d5c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_427
    },
    {
        "PDAC_W1_428",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d64, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_428
    },
    {
        "PDAC_W1_429",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d6c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_429
    },
    {
        "PDAC_W1_430",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d74, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_430
    },
    {
        "PDAC_W1_431",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d7c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_431
    },
    {
        "PDAC_W1_432",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d84, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_432
    },
    {
        "PDAC_W1_433",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d8c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_433
    },
    {
        "PDAC_W1_435",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001d9c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_435
    },
    {
        "PDAC_W1_437",
        "See the \"Peripheral Domain Access Control (PDAC_W0_c_s)\" section for"
        " the description.",
        4, // Width in bytes
        0x00001dac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_pdac_w1_437
    },
    {
        "MRGD_W0_0",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_0
    },
    {
        "MRGD_W0_1",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_1
    },
    {
        "MRGD_W0_2",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_2
    },
    {
        "MRGD_W0_3",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002060, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_3
    },
    {
        "MRGD_W0_32",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002400, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_32
    },
    {
        "MRGD_W0_33",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002420, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_33
    },
    {
        "MRGD_W0_34",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002440, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_34
    },
    {
        "MRGD_W0_35",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002460, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_35
    },
    {
        "MRGD_W0_48",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002600, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_48
    },
    {
        "MRGD_W0_49",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002620, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_49
    },
    {
        "MRGD_W0_50",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002640, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_50
    },
    {
        "MRGD_W0_51",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002660, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_51
    },
    {
        "MRGD_W0_64",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002800, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_64
    },
    {
        "MRGD_W0_65",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002820, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_65
    },
    {
        "MRGD_W0_66",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002840, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_66
    },
    {
        "MRGD_W0_67",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002860, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_67
    },
    {
        "MRGD_W0_80",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002a00, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_80
    },
    {
        "MRGD_W0_81",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002a20, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_81
    },
    {
        "MRGD_W0_82",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002a40, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_82
    },
    {
        "MRGD_W0_83",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002a60, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_83
    },
    {
        "MRGD_W0_96",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002c00, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_96
    },
    {
        "MRGD_W0_97",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002c20, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_97
    },
    {
        "MRGD_W0_98",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002c40, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_98
    },
    {
        "MRGD_W0_99",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002c60, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_99
    },
    {
        "MRGD_W0_100",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002c80, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_100
    },
    {
        "MRGD_W0_101",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002ca0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_101
    },
    {
        "MRGD_W0_102",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002cc0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_102
    },
    {
        "MRGD_W0_103",
        "The MRGD_Wo_n_m registers provide a 2-dimensional data structure for d"
        "efining access control policies () per domain for each supported memor"
        "y region.",
        4, // Width in bytes
        0x00002ce0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_xrdc_mrgd_w0_103
    },
    {
        "MRGD_W1_0",
        "See for description.",
        4, // Width in bytes
        0x00002004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_0
    },
    {
        "MRGD_W1_1",
        "See for description.",
        4, // Width in bytes
        0x00002024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_1
    },
    {
        "MRGD_W1_2",
        "See for description.",
        4, // Width in bytes
        0x00002044, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_2
    },
    {
        "MRGD_W1_3",
        "See for description.",
        4, // Width in bytes
        0x00002064, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_3
    },
    {
        "MRGD_W1_32",
        "See for description.",
        4, // Width in bytes
        0x00002404, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_32
    },
    {
        "MRGD_W1_33",
        "See for description.",
        4, // Width in bytes
        0x00002424, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_33
    },
    {
        "MRGD_W1_34",
        "See for description.",
        4, // Width in bytes
        0x00002444, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_34
    },
    {
        "MRGD_W1_35",
        "See for description.",
        4, // Width in bytes
        0x00002464, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_35
    },
    {
        "MRGD_W1_48",
        "See for description.",
        4, // Width in bytes
        0x00002604, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_48
    },
    {
        "MRGD_W1_49",
        "See for description.",
        4, // Width in bytes
        0x00002624, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_49
    },
    {
        "MRGD_W1_50",
        "See for description.",
        4, // Width in bytes
        0x00002644, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_50
    },
    {
        "MRGD_W1_51",
        "See for description.",
        4, // Width in bytes
        0x00002664, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_51
    },
    {
        "MRGD_W1_64",
        "See for description.",
        4, // Width in bytes
        0x00002804, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_64
    },
    {
        "MRGD_W1_65",
        "See for description.",
        4, // Width in bytes
        0x00002824, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_65
    },
    {
        "MRGD_W1_66",
        "See for description.",
        4, // Width in bytes
        0x00002844, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_66
    },
    {
        "MRGD_W1_67",
        "See for description.",
        4, // Width in bytes
        0x00002864, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_67
    },
    {
        "MRGD_W1_80",
        "See for description.",
        4, // Width in bytes
        0x00002a04, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_80
    },
    {
        "MRGD_W1_81",
        "See for description.",
        4, // Width in bytes
        0x00002a24, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_81
    },
    {
        "MRGD_W1_82",
        "See for description.",
        4, // Width in bytes
        0x00002a44, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_82
    },
    {
        "MRGD_W1_83",
        "See for description.",
        4, // Width in bytes
        0x00002a64, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_83
    },
    {
        "MRGD_W1_96",
        "See for description.",
        4, // Width in bytes
        0x00002c04, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_96
    },
    {
        "MRGD_W1_97",
        "See for description.",
        4, // Width in bytes
        0x00002c24, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_97
    },
    {
        "MRGD_W1_98",
        "See for description.",
        4, // Width in bytes
        0x00002c44, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_98
    },
    {
        "MRGD_W1_99",
        "See for description.",
        4, // Width in bytes
        0x00002c64, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_99
    },
    {
        "MRGD_W1_100",
        "See for description.",
        4, // Width in bytes
        0x00002c84, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_100
    },
    {
        "MRGD_W1_101",
        "See for description.",
        4, // Width in bytes
        0x00002ca4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_101
    },
    {
        "MRGD_W1_102",
        "See for description.",
        4, // Width in bytes
        0x00002cc4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_102
    },
    {
        "MRGD_W1_103",
        "See for description.",
        4, // Width in bytes
        0x00002ce4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w1_103
    },
    {
        "MRGD_W2_0",
        "See for description.",
        4, // Width in bytes
        0x00002008, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_0
    },
    {
        "MRGD_W2_1",
        "See for description.",
        4, // Width in bytes
        0x00002028, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_1
    },
    {
        "MRGD_W2_2",
        "See for description.",
        4, // Width in bytes
        0x00002048, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_2
    },
    {
        "MRGD_W2_3",
        "See for description.",
        4, // Width in bytes
        0x00002068, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_3
    },
    {
        "MRGD_W2_32",
        "See for description.",
        4, // Width in bytes
        0x00002408, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_32
    },
    {
        "MRGD_W2_33",
        "See for description.",
        4, // Width in bytes
        0x00002428, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_33
    },
    {
        "MRGD_W2_34",
        "See for description.",
        4, // Width in bytes
        0x00002448, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_34
    },
    {
        "MRGD_W2_35",
        "See for description.",
        4, // Width in bytes
        0x00002468, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_35
    },
    {
        "MRGD_W2_48",
        "See for description.",
        4, // Width in bytes
        0x00002608, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_48
    },
    {
        "MRGD_W2_49",
        "See for description.",
        4, // Width in bytes
        0x00002628, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_49
    },
    {
        "MRGD_W2_50",
        "See for description.",
        4, // Width in bytes
        0x00002648, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_50
    },
    {
        "MRGD_W2_51",
        "See for description.",
        4, // Width in bytes
        0x00002668, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_51
    },
    {
        "MRGD_W2_64",
        "See for description.",
        4, // Width in bytes
        0x00002808, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_64
    },
    {
        "MRGD_W2_65",
        "See for description.",
        4, // Width in bytes
        0x00002828, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_65
    },
    {
        "MRGD_W2_66",
        "See for description.",
        4, // Width in bytes
        0x00002848, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_66
    },
    {
        "MRGD_W2_67",
        "See for description.",
        4, // Width in bytes
        0x00002868, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_67
    },
    {
        "MRGD_W2_80",
        "See for description.",
        4, // Width in bytes
        0x00002a08, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_80
    },
    {
        "MRGD_W2_81",
        "See for description.",
        4, // Width in bytes
        0x00002a28, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_81
    },
    {
        "MRGD_W2_82",
        "See for description.",
        4, // Width in bytes
        0x00002a48, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_82
    },
    {
        "MRGD_W2_83",
        "See for description.",
        4, // Width in bytes
        0x00002a68, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_83
    },
    {
        "MRGD_W2_96",
        "See for description.",
        4, // Width in bytes
        0x00002c08, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_96
    },
    {
        "MRGD_W2_97",
        "See for description.",
        4, // Width in bytes
        0x00002c28, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_97
    },
    {
        "MRGD_W2_98",
        "See for description.",
        4, // Width in bytes
        0x00002c48, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_98
    },
    {
        "MRGD_W2_99",
        "See for description.",
        4, // Width in bytes
        0x00002c68, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_99
    },
    {
        "MRGD_W2_100",
        "See for description.",
        4, // Width in bytes
        0x00002c88, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_100
    },
    {
        "MRGD_W2_101",
        "See for description.",
        4, // Width in bytes
        0x00002ca8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_101
    },
    {
        "MRGD_W2_102",
        "See for description.",
        4, // Width in bytes
        0x00002cc8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_102
    },
    {
        "MRGD_W2_103",
        "See for description.",
        4, // Width in bytes
        0x00002ce8, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_xrdc_mrgd_w2_103
    },
    {
        "MRGD_W3_0",
        "See for description.",
        4, // Width in bytes
        0x0000200c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_0
    },
    {
        "MRGD_W3_1",
        "See for description.",
        4, // Width in bytes
        0x0000202c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_1
    },
    {
        "MRGD_W3_2",
        "See for description.",
        4, // Width in bytes
        0x0000204c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_2
    },
    {
        "MRGD_W3_3",
        "See for description.",
        4, // Width in bytes
        0x0000206c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_3
    },
    {
        "MRGD_W3_32",
        "See for description.",
        4, // Width in bytes
        0x0000240c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_32
    },
    {
        "MRGD_W3_33",
        "See for description.",
        4, // Width in bytes
        0x0000242c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_33
    },
    {
        "MRGD_W3_34",
        "See for description.",
        4, // Width in bytes
        0x0000244c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_34
    },
    {
        "MRGD_W3_35",
        "See for description.",
        4, // Width in bytes
        0x0000246c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_35
    },
    {
        "MRGD_W3_48",
        "See for description.",
        4, // Width in bytes
        0x0000260c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_48
    },
    {
        "MRGD_W3_49",
        "See for description.",
        4, // Width in bytes
        0x0000262c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_49
    },
    {
        "MRGD_W3_50",
        "See for description.",
        4, // Width in bytes
        0x0000264c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_50
    },
    {
        "MRGD_W3_51",
        "See for description.",
        4, // Width in bytes
        0x0000266c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_51
    },
    {
        "MRGD_W3_64",
        "See for description.",
        4, // Width in bytes
        0x0000280c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_64
    },
    {
        "MRGD_W3_65",
        "See for description.",
        4, // Width in bytes
        0x0000282c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_65
    },
    {
        "MRGD_W3_66",
        "See for description.",
        4, // Width in bytes
        0x0000284c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_66
    },
    {
        "MRGD_W3_67",
        "See for description.",
        4, // Width in bytes
        0x0000286c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_67
    },
    {
        "MRGD_W3_80",
        "See for description.",
        4, // Width in bytes
        0x00002a0c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_80
    },
    {
        "MRGD_W3_81",
        "See for description.",
        4, // Width in bytes
        0x00002a2c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_81
    },
    {
        "MRGD_W3_82",
        "See for description.",
        4, // Width in bytes
        0x00002a4c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_82
    },
    {
        "MRGD_W3_83",
        "See for description.",
        4, // Width in bytes
        0x00002a6c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_83
    },
    {
        "MRGD_W3_96",
        "See for description.",
        4, // Width in bytes
        0x00002c0c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_96
    },
    {
        "MRGD_W3_97",
        "See for description.",
        4, // Width in bytes
        0x00002c2c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_97
    },
    {
        "MRGD_W3_98",
        "See for description.",
        4, // Width in bytes
        0x00002c4c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_98
    },
    {
        "MRGD_W3_99",
        "See for description.",
        4, // Width in bytes
        0x00002c6c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_99
    },
    {
        "MRGD_W3_100",
        "See for description.",
        4, // Width in bytes
        0x00002c8c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_100
    },
    {
        "MRGD_W3_101",
        "See for description.",
        4, // Width in bytes
        0x00002cac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_101
    },
    {
        "MRGD_W3_102",
        "See for description.",
        4, // Width in bytes
        0x00002ccc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_102
    },
    {
        "MRGD_W3_103",
        "See for description.",
        4, // Width in bytes
        0x00002cec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xrdc_mrgd_w3_103
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark mx6
#endif

const module_t mx7ulp[] =
{
    // Module name, instance number, base address, register count, register definitions
    { "ADC0",           1, 0x41041000, 47,   hw_adc_16fifo_15_cmd_buffer },
    { "ADC1",           2, 0x410ad000, 47,   hw_adc_16fifo_15_cmd_buffer },
    { "AXBS0",          1, 0x41000000, 0,    hw_axbs },
    { "AXBS1",          2, 0x41080000, 0,    hw_axbs },
    { "CMP0",           1, 0x41042000, 6,    hw_cmp },
    { "CMP1",           2, 0x41043000, 6,    hw_cmp },
    { "CRC0",           1, 0x41029000, 3,    hw_crc },
    { "DAC0",           1, 0x41044000, 7,    hw_dac },
    { "DAC1",           2, 0x41045000, 7,    hw_dac },
    { "DCD",            1, 0x40350800, 8,    hw_dcd },
    { "DMA0",           1, 0x41008000, 528,  hw_dma },
    { "DMA1",           2, 0x40080000, 528,  hw_dma },
    { "DMA_CH_MUX0",    1, 0x41020000, 32,   hw_dma_ch_mux },
    { "DMA_CH_MUX1",    2, 0x40210000, 32,   hw_dma_ch_mux },
    { "EWM",            1, 0x410a0000, 6,    hw_ewm },
    { "FB",             1, 0x40100000, 19,   hw_fb },
    { "FLEXIO0",        1, 0x41032000, 108,  hw_flexio_8shift_8tim_32pin },
    { "FLEXIO1",        2, 0x40310000, 108,  hw_flexio_8shift_8tim_32pin },
    { "GPIOA",          1, 0x4100f000, 7,    hw_gpio },
    { "GPIOB",          2, 0x4100f040, 7,    hw_gpio },
    { "GPIOC",          3, 0x400f0000, 7,    hw_gpio },
    { "GPIOD",          4, 0x400f0040, 7,    hw_gpio },
    { "GPIOE",          5, 0x400f0080, 7,    hw_gpio },
    { "GPIOF",          6, 0x400f00c0, 7,    hw_gpio },
    { "I2S0",           1, 0x41037000, 22,   hw_sai_2ch },
    { "I2S1",           1, 0x410aa000, 30,   hw_sai_4ch },
    { "IOMUXC0",        1, 0x4103d000, 128,  hw_iomuxc0 },
    { "IOMUXC1",        1, 0x40ac0000, 195,  hw_iomuxc1 },
    { "IOMUXC1_DDR",    1, 0x40ad0000, 75,   hw_iomuxc1_ddr },
    { "LCDIF0",         1, 0x40aa0000, 31,   hw_lcdif },
    { "LLWU",           1, 0x41021000, 9,    hw_llwu },
    { "LMEM",           1, 0xe0082000, 4,    hw_lmem },
    { "LPI2C0",         1, 0x41033000, 28,   hw_lpi2c_4fifo },
    { "LPI2C1",         2, 0x41034000, 28,   hw_lpi2c_4fifo },
    { "LPI2C2",         3, 0x41035000, 28,   hw_lpi2c_4fifo },
    { "LPI2C3",         4, 0x41036000, 28,   hw_lpi2c_4fifo },
    { "LPI2C4",         5, 0x402b0000, 28,   hw_lpi2c_4fifo },
    { "LPI2C5",         6, 0x402c0000, 28,   hw_lpi2c_4fifo },
    { "LPI2C6",         7, 0x40a40000, 28,   hw_lpi2c_4fifo },
    { "LPI2C7",         8, 0x40a50000, 28,   hw_lpi2c_4fifo },
    { "LPIT0",          1, 0x4102d000, 19,   hw_lpit_4ch_32b },
    { "LPIT1",          2, 0x40270000, 19,   hw_lpit_4ch_32b },
    { "LPSPI0",         1, 0x41038000, 17,   hw_lpspi_4fifo_30mhz_master },
    { "LPSPI1",         2, 0x41039000, 17,   hw_lpspi_4fifo_30mhz_master },
    { "LPSPI2",         1, 0x40290000, 17,   hw_lpspi_16fifo_60mhz_master },
    { "LPSPI3",         2, 0x402a0000, 17,   hw_lpspi_16fifo_60mhz_master },
    { "LPTMR0",         1, 0x4102e000, 4,    hw_lptimer_16b_1ch },
    { "LPTMR1",         2, 0x4102f000, 4,    hw_lptimer_16b_1ch },
    { "LPUART0",        1, 0x4103a000, 12,   hw_lpuart_4w_fifo },
    { "LPUART1",        2, 0x4103b000, 12,   hw_lpuart_4w_fifo },
    { "LPUART2",        1, 0x410ab000, 12,   hw_lpuart_8w_fifo },
    { "LPUART3",        2, 0x410ac000, 12,   hw_lpuart_8w_fifo },
    { "LPUART4",        3, 0x402d0000, 12,   hw_lpuart_8w_fifo },
    { "LPUART5",        4, 0x402e0000, 12,   hw_lpuart_8w_fifo },
    { "LPUART6",        5, 0x40a60000, 12,   hw_lpuart_8w_fifo },
    { "LPUART7",        6, 0x40a70000, 12,   hw_lpuart_8w_fifo },
    { "MCM",            1, 0xe0080000, 6,    hw_mcm },
    { "MIPI_DSI_HOST0", 1, 0x40a90000, 13,   hw_mipi_dsi_host },
    { "MIPI_DSI_HOST_APB_PKT_IF0", 1, 0x40a90280, 12, hw_mipi_dsi_host_apb_pkt_if },
    { "MIPI_DSI_HOST_DPI_INTFC0", 1, 0x40a90200, 17, hw_mipi_dsi_host_dpi_intfc },
    { "MIPI_DSI_HOST_FSL_IP1_DPHY_INTFC0", 1, 0x40a90300, 18, hw_mipi_dsi_host_fsl_ip1_dphy_intfc },
    { "MMCAU",          1, 0xe0081000, 11,   hw_mmcau },
    { "MMDC0",          1, 0x40ab0000, 67,   hw_mmdc },
    { "MSMC0",          1, 0x410a4000, 13,   hw_msmc1 },
    { "MSMC1",          1, 0x40410000, 13,   hw_msmc2 },
    { "MUA",            1, 0x41022000, 12,   hw_mua },
    { "OCOTP_CTRL",     1, 0x410a6000, 33,   hw_ocotp_ctrl },
    { "PCC0",           1, 0x41026000, 32,   hw_pcc_1 },
    { "PCC1",           1, 0x410b2000, 8,    hw_pcc_2 },
    { "PCC2",           1, 0x403f0000, 25,   hw_pcc_3 },
    { "PCC3",           1, 0x40b30000, 16,   hw_pcc_4 },
    { "PMC0",           1, 0x410a1000, 13,   hw_pmc0 },
    { "PMC1",           1, 0x40400000, 11,   hw_pmc1 },
    { "PORTA",          1, 0x4103f000, 37,   hw_port },
    { "PORTB",          2, 0x41040000, 25,   hw_port },
    { "PORTC",          3, 0x40ae0000, 25,   hw_port },
    { "PORTD",          4, 0x40af0000, 17,   hw_port },
    { "PORTE",          5, 0x40b00000, 21,   hw_port },
    { "PORTF",          6, 0x40b10000, 25,   hw_port },
    { "QUADSPI0",       1, 0x410a5000, 110,  hw_quadspi },
    { "ROMC0",          1, 0x41090000, 28,   hw_romc },
    { "ROMC1",          2, 0x40900000, 28,   hw_romc },
    { "SCG0",           1, 0x41027000, 32,   hw_scg_cm4 },
    { "SCG1",           1, 0x403e0000, 33,   hw_scg_ca7 },
    { "SEMA42_0",       1, 0x4101b000, 18,   hw_sema42 },
    { "SEMA42_1",       2, 0x401b0000, 18,   hw_sema42 },
    { "SIM",            1, 0x410a3000, 22,   hw_sim },
    { "SNVS",           1, 0x40230000, 28,   hw_snvs },
    { "TPM0",           1, 0x41030000, 25,   hw_lptpm_16b_6ch },
    { "TPM1",           1, 0x41031000, 17,   hw_lptpm_32b_2ch },
    { "TPM2",           2, 0x410a8000, 17,   hw_lptpm_32b_2ch },
    { "TPM3",           2, 0x410a9000, 25,   hw_lptpm_16b_6ch },
    { "TPM4",           3, 0x40250000, 25,   hw_lptpm_16b_6ch },
    { "TPM5",           3, 0x40260000, 17,   hw_lptpm_32b_2ch },
    { "TPM6",           4, 0x40a10000, 17,   hw_lptpm_32b_2ch },
    { "TPM7",           4, 0x40a20000, 25,   hw_lptpm_16b_6ch },
    { "TRGMUX0",        1, 0x41024000, 24,   hw_trgmux0 },
    { "TRGMUX1",        1, 0x403a0000, 18,   hw_trgmux1 },
    { "TRNG0",          1, 0x4102c000, 56,   hw_trng },
    { "TSTMR",          1, 0x410a3c00, 2,    hw_tstmr },
    { "USB0",           1, 0x40330000, 46,   hw_usb },
    { "USB1",           2, 0x40340000, 46,   hw_usb },
    { "USBNC0",         1, 0x40330200, 3,    hw_usbnc },
    { "USBNC1",         2, 0x40340200, 3,    hw_usbnc },
    { "USBPHY",         1, 0x40350000, 56,   hw_usbphy },
    { "USDHC0",         1, 0x40370000, 31,   hw_usdhc },
    { "USDHC1",         2, 0x40380000, 31,   hw_usdhc },
    { "VIU",            1, 0x40a80000, 16,   hw_viu },
    { "WDOG0",          1, 0x41025000, 4,    hw_wdog },
    { "WDOG1",          2, 0x403d0000, 4,    hw_wdog },
    { "WDOG2",          3, 0x40430000, 4,    hw_wdog },
    { "WKPU0",          1, 0x40b51000, 9,    hw_wkpu },
    { "XRDC",           1, 0x41014000, 459,  hw_xrdc },
    { 0 } // Terminator
};

////////////////////////////////////////////////////////////////////////////////
