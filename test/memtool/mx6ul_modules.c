#include "memtools_register_info.h"

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ADC
#endif

// Bitfields in register ADC_HC0.
static const field_t hw_adc_hc0[] =
{
    {
        "ADCH",
        "This 5-bit field selects one of the input channels.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AIEN",
        "An interrupt is generated whenever ADC_HS[COCO0]=1 (conversion ADC_HC0"
        " completed), provided the corresponding interrupt is enabled.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_HC1.
static const field_t hw_adc_hc1[] =
{
    {
        "ADCH",
        "This 5-bit field selects one of the input channels.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AIEN",
        "An interrupt is generated whenever ADC_HS[COCO0]=1(conversion ADC_HC0 "
        "completed), provided the corresponding interrupt is enabled.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_HS.
static const field_t hw_adc_hs[] =
{
    {
        "COCO0",
        "The COCOn flag is a read-only bit that is set each time a conversion i"
        "s completed when the compare function is disabled (ADC_GC[ACFE]=0) and"
        " the hardware average function is disabled (ADC_GC[AVGE]=0).",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COCO1",
        "See description for COCO0.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_R0.
static const field_t hw_adc_r0[] =
{
    {
        "CDATA",
        "",
        0, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_R1.
static const field_t hw_adc_r1[] =
{
    {
        "CDATA",
        "Data (result of an ADC conversion)",
        0, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_CFG.
static const field_t hw_adc_cfg[] =
{
    {
        "ADICLK",
        "Selects the input clock source to generate the internal clock ADCK.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE",
        "Used to set the ADC resolution mode.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADLSMP",
        "Selects between different sample times based on the ADC_CFG[ADSTS] fie"
        "ld.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADIV",
        "Selects the divide ratio used by the ADC to generate the internal cloc"
        "k ADCK.",
        5, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADLPC",
        "Puts the ADC hard block into low power mode and reduces the comparator"
        " enable period by controlling its timing in the SAR controller block t"
        "owards the anlong hard block.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADSTS",
        "Defines the sample time duration.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADHSC",
        "This bit configures the ADC for high speed operation.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFSEL",
        "Selects the voltage reference source used for conversions (see the chi"
        "p-specific SARADC information for details).",
        11, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADTRG",
        "Selects the type of trigger used for initiating a conversion.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGS",
        "Determines how many ADC conversions will be averaged to create the ADC"
        " average result.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVWREN",
        "Controls the overwriting of the next converted Data onto the existing "
        "(previous) unread data into the Data result register.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_GC.
static const field_t hw_adc_gc[] =
{
    {
        "ADACKEN",
        "Enables the ADC's asynchronous clock source and the clock source outpu"
        "t regardless of the conversion and input clock select (ADC_CFG[ADICLK]"
        ") settings of the ADC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAEN",
        "Enables the DMA logic.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACREN",
        "Configures the compare function to check the conversion result of the "
        "input being monitored is either between or outside the range formed by"
        " the compare values in register (ADC_CV) determined by the value of AC"
        "FGT.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACFGT",
        "Configures the compare function to check the conversion result relativ"
        "e to the compare value register (ADC_CV) based upon the value of ACREN"
        " (bit 2 in ADC_GC register).",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACFE",
        "Enables the compare function.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVGE",
        "Enables the hardware average function of the ADC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADCO",
        "Enables continuous conversions.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAL",
        "CAL begins the calibration sequence when set.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_GS.
static const field_t hw_adc_gs[] =
{
    {
        "ADACT",
        "Indicates that a conversion or hardware averaging is in progress.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CALF",
        "Displays the result of the calibration sequence.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AWKST",
        "Holds the status of asynchronous interrupt status that occured during "
        "stop mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_CV.
static const field_t hw_adc_cv[] =
{
    {
        "CV1",
        "Contains a compare value used to compare with the conversion result wh"
        "en the compare function ais enabled (ADC_GC[ACFE]=1).",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CV2",
        "Contains a compare value used to compare with the conversion result wh"
        "en the compare function and compare range function are enabled (ADC_GC"
        "[ACFE]=1, ADC_GC[ACREN]=1).",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_OFS.
static const field_t hw_adc_ofs[] =
{
    {
        "OFS",
        "User configurable offset value.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIGN",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ADC_CAL.
static const field_t hw_adc_cal[] =
{
    {
        "CAL_CODE",
        "This value is automatically loaded and updated at the end of calibrati"
        "on.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ADC module.
static const reg_t hw_adc[] =
{
    {
        "HC0",
        "ADC_HC0 can be used for both software and hardware trigger mode.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_adc_hc0
    },
    {
        "HC1",
        "ADC_HC1 are for use only in hardware trigger mode.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_adc_hc1
    },
    {
        "HS",
        "Bit 0 is used for both software and hardware trigger modes of operatio"
        "n.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_adc_hs
    },
    {
        "R0",
        "Contains the result of an ADC conversion of the channel selected by th"
        "e respective hardware trigger and channel control register (ADC_HC0:AD"
        "C_HCn).",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_adc_r0
    },
    {
        "R1",
        "Contains the result of an ADC conversion of the channel selected by th"
        "e respective Hardware Trigger and channel control register (ADC_HC0:AD"
        "C_HCn).",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_adc_r1
    },
    {
        "CFG",
        "Selects the mode of operation, clock source, clock divide, configure f"
        "or low power, long sample time, high speed configuration and selects t"
        "he sample time duration.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_adc_cfg
    },
    {
        "GC",
        "Controls the calibration, continuous convert, hardware averaging funct"
        "ions, conversion active, hardware/software trigger select, compare fun"
        "ction and voltage reference select of the ADC module.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_adc_gc
    },
    {
        "GS",
        "Controls the calibration, continuous convert, hardware averaging funct"
        "ions, conversion active, hardware/software trigger select, compare fun"
        "ction and voltage reference select of the ADC module.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_adc_gs
    },
    {
        "CV",
        "Contains compare values used to compare with the conversion result whe"
        "n the compare function is enabled (ADC_GC[ACFE]=1).",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_adc_cv
    },
    {
        "OFS",
        "Contains the user-defined offset error correction value.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_adc_ofs
    },
    {
        "CAL",
        "Contains calibration information that is generated by the calibration "
        "function.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_adc_cal
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark APBH
#endif

// Bitfields in register APBH_CTRL0.
static const field_t hw_apbh_ctrl0[] =
{
    {
        "CLKGATE_CHANNEL",
        "These bits must be set to zero for normal operation of each channel.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        16, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "APB_BURST_EN",
        "Set this bit to one to enable apb master do a continous transfers when"
        " a device request a burst dma.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHB_BURST8_EN",
        "Set this bit to one (default) to enable AHB 8-beat burst.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to zero to enable normal APBH DMA operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CTRL0_SET.
static const field_t hw_apbh_ctrl0_set[] =
{
    {
        "CLKGATE_CHANNEL",
        "These bits must be set to zero for normal operation of each channel.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        16, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "APB_BURST_EN",
        "Set this bit to one to enable apb master do a continous transfers when"
        " a device request a burst dma.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHB_BURST8_EN",
        "Set this bit to one (default) to enable AHB 8-beat burst.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to zero to enable normal APBH DMA operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CTRL0_CLR.
static const field_t hw_apbh_ctrl0_clr[] =
{
    {
        "CLKGATE_CHANNEL",
        "These bits must be set to zero for normal operation of each channel.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        16, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "APB_BURST_EN",
        "Set this bit to one to enable apb master do a continous transfers when"
        " a device request a burst dma.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHB_BURST8_EN",
        "Set this bit to one (default) to enable AHB 8-beat burst.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to zero to enable normal APBH DMA operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CTRL0_TOG.
static const field_t hw_apbh_ctrl0_tog[] =
{
    {
        "CLKGATE_CHANNEL",
        "These bits must be set to zero for normal operation of each channel.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        16, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "APB_BURST_EN",
        "Set this bit to one to enable apb master do a continous transfers when"
        " a device request a burst dma.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHB_BURST8_EN",
        "Set this bit to one (default) to enable AHB 8-beat burst.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to zero to enable normal APBH DMA operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CTRL1.
static const field_t hw_apbh_ctrl1[] =
{
    {
        "CH0_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 3.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 4.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 5.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 6.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 7.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH8_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 8.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 9.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 10.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 11.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 12.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 13.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 14.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 15.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH0_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 2.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 3.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 4.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 5.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 6.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 7.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH8_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 8.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 9.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 10.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 11.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 12.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 13.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 14.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 15.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CTRL1_SET.
static const field_t hw_apbh_ctrl1_set[] =
{
    {
        "CH0_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 3.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 4.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 5.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 6.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 7.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH8_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 8.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 9.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 10.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 11.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 12.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 13.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 14.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 15.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH0_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 2.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 3.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 4.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 5.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 6.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 7.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH8_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 8.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 9.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 10.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 11.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 12.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 13.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 14.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 15.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CTRL1_CLR.
static const field_t hw_apbh_ctrl1_clr[] =
{
    {
        "CH0_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 3.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 4.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 5.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 6.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 7.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH8_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 8.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 9.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 10.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 11.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 12.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 13.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 14.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 15.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH0_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 2.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 3.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 4.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 5.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 6.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 7.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH8_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 8.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 9.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 10.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 11.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 12.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 13.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 14.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 15.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CTRL1_TOG.
static const field_t hw_apbh_ctrl1_tog[] =
{
    {
        "CH0_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 3.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 4.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 5.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 6.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA channel 7.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH8_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 8.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 9.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 10.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 11.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 12.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 13.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 14.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15_CMDCMPLT_IRQ",
        "Interrupt request status bit for APBH DMA Channel 15.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH0_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 0.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 1.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 2.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 3.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 4.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 5.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 6.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 7.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH8_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 8.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 9.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 10.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 11.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 12.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 13.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 14.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15_CMDCMPLT_IRQ_EN",
        "Setting this bit enables the generation of an interrupt request for AP"
        "BH DMA channel 15.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CTRL2.
static const field_t hw_apbh_ctrl2[] =
{
    {
        "CH0_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 3.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 4.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 5.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 6.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 7.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH8_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 8.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 9.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 10.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 11.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 12.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 13.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 14.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 15.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH0_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 0.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH1_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 1.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH2_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 2.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH3_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 3.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH4_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 4.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH5_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 5.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH6_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 6.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH7_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 7.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH8_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 8.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH9_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 9.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH10_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 10.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH11_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 11.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH12_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 12.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH13_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 13.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH14_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 14.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH15_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 15.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CTRL2_SET.
static const field_t hw_apbh_ctrl2_set[] =
{
    {
        "CH0_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 3.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 4.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 5.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 6.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 7.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH8_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 8.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 9.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 10.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 11.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 12.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 13.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 14.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 15.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH0_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 0.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH1_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 1.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH2_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 2.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH3_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 3.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH4_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 4.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH5_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 5.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH6_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 6.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH7_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 7.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH8_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 8.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH9_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 9.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH10_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 10.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH11_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 11.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH12_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 12.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH13_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 13.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH14_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 14.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH15_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 15.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CTRL2_CLR.
static const field_t hw_apbh_ctrl2_clr[] =
{
    {
        "CH0_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 3.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 4.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 5.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 6.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 7.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH8_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 8.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 9.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 10.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 11.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 12.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 13.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 14.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 15.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH0_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 0.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH1_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 1.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH2_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 2.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH3_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 3.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH4_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 4.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH5_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 5.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH6_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 6.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH7_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 7.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH8_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 8.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH9_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 9.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH10_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 10.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH11_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 11.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH12_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 12.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH13_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 13.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH14_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 14.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH15_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 15.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CTRL2_TOG.
static const field_t hw_apbh_ctrl2_tog[] =
{
    {
        "CH0_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 2.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 3.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 4.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 5.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 6.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7_ERROR_IRQ",
        "Error interrupt status bit for APBX DMA Channel 7.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH8_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 8.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 9.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH10_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 10.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH11_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 11.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH12_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 12.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH13_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 13.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH14_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 14.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH15_ERROR_IRQ",
        "Error interrupt status bit for APBH DMA Channel 15.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH0_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 0.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH1_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 1.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH2_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 2.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH3_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 3.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH4_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 4.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH5_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 5.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH6_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 6.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH7_ERROR_STATUS",
        "Error status bit for APBX DMA Channel 7.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH8_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 8.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH9_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 9.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH10_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 10.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH11_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 11.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH12_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 12.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH13_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 13.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH14_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 14.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CH15_ERROR_STATUS",
        "Error status bit for APBH DMA Channel 15.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CHANNEL_CTRL.
static const field_t hw_apbh_channel_ctrl[] =
{
    {
        "FREEZE_CHANNEL",
        "Setting a bit in this field will freeze the DMA channel associated wit"
        "h it.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESET_CHANNEL",
        "Setting a bit in this field causes the DMA controller to take the corr"
        "esponding channel through its reset state.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CHANNEL_CTRL_SET.
static const field_t hw_apbh_channel_ctrl_set[] =
{
    {
        "FREEZE_CHANNEL",
        "Setting a bit in this field will freeze the DMA channel associated wit"
        "h it.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESET_CHANNEL",
        "Setting a bit in this field causes the DMA controller to take the corr"
        "esponding channel through its reset state.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CHANNEL_CTRL_CLR.
static const field_t hw_apbh_channel_ctrl_clr[] =
{
    {
        "FREEZE_CHANNEL",
        "Setting a bit in this field will freeze the DMA channel associated wit"
        "h it.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESET_CHANNEL",
        "Setting a bit in this field causes the DMA controller to take the corr"
        "esponding channel through its reset state.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CHANNEL_CTRL_TOG.
static const field_t hw_apbh_channel_ctrl_tog[] =
{
    {
        "FREEZE_CHANNEL",
        "Setting a bit in this field will freeze the DMA channel associated wit"
        "h it.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESET_CHANNEL",
        "Setting a bit in this field causes the DMA controller to take the corr"
        "esponding channel through its reset state.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_DEVSEL.
static const field_t hw_apbh_devsel[] =
{
    {
        "CH0",
        "Reserved.",
        0, // LSB
        1, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH1",
        "Reserved.",
        2, // LSB
        3, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH2",
        "Reserved.",
        4, // LSB
        5, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH3",
        "Reserved.",
        6, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH4",
        "Reserved.",
        8, // LSB
        9, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH5",
        "Reserved.",
        10, // LSB
        11, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH6",
        "Reserved.",
        12, // LSB
        13, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH7",
        "Reserved.",
        14, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH8",
        "Reserved.",
        16, // LSB
        17, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH9",
        "Reserved.",
        18, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH10",
        "Reserved.",
        20, // LSB
        21, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH11",
        "Reserved.",
        22, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH12",
        "Reserved.",
        24, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH13",
        "Reserved.",
        26, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH14",
        "Reserved.",
        28, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH15",
        "Reserved.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_DMA_BURST_SIZE.
static const field_t hw_apbh_dma_burst_size[] =
{
    {
        "CH0",
        "DMA burst size for GPMI channel 0.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH1",
        "DMA burst size for GPMI channel 1.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH2",
        "DMA burst size for GPMI channel 2.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH3",
        "DMA burst size for GPMI channel 3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH4",
        "DMA burst size for GPMI channel 4.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH5",
        "DMA burst size for GPMI channel 5.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH6",
        "DMA burst size for GPMI channel 6.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH7",
        "DMA burst size for GPMI channel 7.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH8",
        "DMA burst size for SSP.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CH9",
        "Reserved.",
        18, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH10",
        "Reserved.",
        20, // LSB
        21, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH11",
        "Reserved.",
        22, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH12",
        "Reserved.",
        24, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH13",
        "Reserved.",
        26, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH14",
        "Reserved.",
        28, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CH15",
        "Reserved.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_DEBUG.
static const field_t hw_apbh_debug[] =
{
    {
        "GPMI_ONE_FIFO",
        "Set to 0ne and the 8 GPMI channels will share the DMA FIFO, and when s"
        "et to zero, the 8 GPMI channels will use its own DMA FIFO.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH0_CURCMDAR.
static const field_t hw_apbh_ch0_curcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to command structure currently being processed for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH0_NXTCMDAR.
static const field_t hw_apbh_ch0_nxtcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to next command structure for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH0_CMD.
static const field_t hw_apbh_ch0_cmd[] =
{
    {
        "COMMAND",
        "This bitfield indicates the type of current command:",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        "A value of one indicates that another command is chained onto the end "
        "of the current command structure.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IRQONCMPLT",
        "A value of one indicates that the channel will cause the interrupt sta"
        "tus bit to be set upon completion of the current command, i.e.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDLOCK",
        "A value of one indicates that the NAND DMA channel will remain \"locke"
        "d\" in the arbiter at the expense of other NAND DMA channels.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDWAIT4READY",
        "A value of one indicates that the NAND DMA channel will will wait unti"
        "l the NAND device reports \"ready\" before executing the command.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEMAPHORE",
        "A value of one indicates that the channel will decrement its semaphore"
        " at the completion of the current command structure.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT4ENDCMD",
        "A value of one indicates that the channel will wait for the end of com"
        "mand signal to be sent from the APBH device to the DMA before starting"
        " the next DMA command.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALTONTERMINATE",
        "A value of one indicates that the channel will immeditately terminate "
        "the current descriptor and halt the DMA channel if a terminate signal "
        "is set.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDWORDS",
        "This field indicates the number of command words to send to the GPMI0,"
        " starting with the base PIO address of the GPMI0 control register and "
        "incrementing from there.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "XFER_COUNT",
        "This field indicates the number of bytes to transfer to or from the ap"
        "propriate PIO register in the GPMI0 device.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH0_BAR.
static const field_t hw_apbh_ch0_bar[] =
{
    {
        "ADDRESS",
        "Address of system memory buffer to be read or written over the AHB bus"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH0_SEMA.
static const field_t hw_apbh_ch0_sema[] =
{
    {
        "INCREMENT_SEMA",
        "The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DMA hardware subst"
        "racts happening on the same clock are protected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHORE",
        "This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH0_DEBUG1.
static const field_t hw_apbh_ch0_debug1[] =
{
    {
        "STATEMACHINE",
        "PIO Display of the DMA Channel n state machine state.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "WR_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Write FIFO Fu"
        "ll signal.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Write FIFO Em"
        "pty signal.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Read FIFO Ful"
        "l signal.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Read FIFO Emp"
        "ty signal.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXTCMDADDRVALID",
        "This bit reflects the internal bit which indicates whether the channel"
        "'s next command address is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "This bit is reserved for this Channel and always reads 0.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READY",
        "This bit is reserved for this DMA Channel and always reads 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SENSE",
        "This bit is reserved for this DMA Channel and always reads 0.",
        27, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "END",
        "This bit reflects the current state of the DMA End Command Signal sent"
        " from the APB Device",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KICK",
        "This bit reflects the current state of the DMA Kick Signal sent to the"
        " APB Device",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BURST",
        "This bit reflects the current state of the DMA Burst Signal from the A"
        "PB device",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REQ",
        "This bit reflects the current state of the DMA Request Signal from the"
        " APB device",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH0_DEBUG2.
static const field_t hw_apbh_ch0_debug2[] =
{
    {
        "AHB_BYTES",
        "This value reflects the current number of AHB bytes remaining to be tr"
        "ansfered in the current transfer.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_BYTES",
        "This value reflects the current number of APB bytes remaining to be tr"
        "ansfered in the current transfer.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH1_CURCMDAR.
static const field_t hw_apbh_ch1_curcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to command structure currently being processed for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH1_NXTCMDAR.
static const field_t hw_apbh_ch1_nxtcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to next command structure for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH1_CMD.
static const field_t hw_apbh_ch1_cmd[] =
{
    {
        "COMMAND",
        "This bitfield indicates the type of current command:",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        "A value of one indicates that another command is chained onto the end "
        "of the current command structure.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IRQONCMPLT",
        "A value of one indicates that the channel will cause the interrupt sta"
        "tus bit to be set upon completion of the current command, i.e.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDLOCK",
        "A value of one indicates that the NAND DMA channel will remain \"locke"
        "d\" in the arbiter at the expense of other NAND DMA channels.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDWAIT4READY",
        "A value of one indicates that the NAND DMA channel will will wait unti"
        "l the NAND device reports \"ready\" before executing the command.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEMAPHORE",
        "A value of one indicates that the channel will decrement its semaphore"
        " at the completion of the current command structure.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT4ENDCMD",
        "A value of one indicates that the channel will wait for the end of com"
        "mand signal to be sent from the APBH device to the DMA before starting"
        " the next DMA command.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALTONTERMINATE",
        "A value of one indicates that the channel will immeditately terminate "
        "the current descriptor and halt the DMA channel if a terminate signal "
        "is set.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDWORDS",
        "This field indicates the number of command words to send to the GPMI0,"
        " starting with the base PIO address of the GPMI0 control register and "
        "incrementing from there.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "XFER_COUNT",
        "This field indicates the number of bytes to transfer to or from the ap"
        "propriate PIO register in the GPMI0 device.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH1_BAR.
static const field_t hw_apbh_ch1_bar[] =
{
    {
        "ADDRESS",
        "Address of system memory buffer to be read or written over the AHB bus"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH1_SEMA.
static const field_t hw_apbh_ch1_sema[] =
{
    {
        "INCREMENT_SEMA",
        "The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DMA hardware subst"
        "racts happening on the same clock are protected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHORE",
        "This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH1_DEBUG1.
static const field_t hw_apbh_ch1_debug1[] =
{
    {
        "STATEMACHINE",
        "PIO Display of the DMA Channel n state machine state.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "WR_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Write FIFO Fu"
        "ll signal.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Write FIFO Em"
        "pty signal.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Read FIFO Ful"
        "l signal.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Read FIFO Emp"
        "ty signal.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXTCMDADDRVALID",
        "This bit reflects the internal bit which indicates whether the channel"
        "'s next command address is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "This bit is reserved for this Channel and always reads 0.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READY",
        "This bit is reserved for this DMA Channel and always reads 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SENSE",
        "This bit is reserved for this DMA Channel and always reads 0.",
        27, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "END",
        "This bit reflects the current state of the DMA End Command Signal sent"
        " from the APB Device",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KICK",
        "This bit reflects the current state of the DMA Kick Signal sent to the"
        " APB Device",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BURST",
        "This bit reflects the current state of the DMA Burst Signal from the A"
        "PB device",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REQ",
        "This bit reflects the current state of the DMA Request Signal from the"
        " APB device",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH1_DEBUG2.
static const field_t hw_apbh_ch1_debug2[] =
{
    {
        "AHB_BYTES",
        "This value reflects the current number of AHB bytes remaining to be tr"
        "ansfered in the current transfer.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_BYTES",
        "This value reflects the current number of APB bytes remaining to be tr"
        "ansfered in the current transfer.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH2_CURCMDAR.
static const field_t hw_apbh_ch2_curcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to command structure currently being processed for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH2_NXTCMDAR.
static const field_t hw_apbh_ch2_nxtcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to next command structure for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH2_CMD.
static const field_t hw_apbh_ch2_cmd[] =
{
    {
        "COMMAND",
        "This bitfield indicates the type of current command:",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        "A value of one indicates that another command is chained onto the end "
        "of the current command structure.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IRQONCMPLT",
        "A value of one indicates that the channel will cause the interrupt sta"
        "tus bit to be set upon completion of the current command, i.e.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDLOCK",
        "A value of one indicates that the NAND DMA channel will remain \"locke"
        "d\" in the arbiter at the expense of other NAND DMA channels.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDWAIT4READY",
        "A value of one indicates that the NAND DMA channel will will wait unti"
        "l the NAND device reports \"ready\" before executing the command.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEMAPHORE",
        "A value of one indicates that the channel will decrement its semaphore"
        " at the completion of the current command structure.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT4ENDCMD",
        "A value of one indicates that the channel will wait for the end of com"
        "mand signal to be sent from the APBH device to the DMA before starting"
        " the next DMA command.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALTONTERMINATE",
        "A value of one indicates that the channel will immeditately terminate "
        "the current descriptor and halt the DMA channel if a terminate signal "
        "is set.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDWORDS",
        "This field indicates the number of command words to send to the GPMI0,"
        " starting with the base PIO address of the GPMI0 control register and "
        "incrementing from there.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "XFER_COUNT",
        "This field indicates the number of bytes to transfer to or from the ap"
        "propriate PIO register in the GPMI0 device.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH2_BAR.
static const field_t hw_apbh_ch2_bar[] =
{
    {
        "ADDRESS",
        "Address of system memory buffer to be read or written over the AHB bus"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH2_SEMA.
static const field_t hw_apbh_ch2_sema[] =
{
    {
        "INCREMENT_SEMA",
        "The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DMA hardware subst"
        "racts happening on the same clock are protected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHORE",
        "This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH2_DEBUG1.
static const field_t hw_apbh_ch2_debug1[] =
{
    {
        "STATEMACHINE",
        "PIO Display of the DMA Channel n state machine state.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "WR_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Write FIFO Fu"
        "ll signal.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Write FIFO Em"
        "pty signal.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Read FIFO Ful"
        "l signal.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Read FIFO Emp"
        "ty signal.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXTCMDADDRVALID",
        "This bit reflects the internal bit which indicates whether the channel"
        "'s next command address is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "This bit is reserved for this Channel and always reads 0.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READY",
        "This bit is reserved for this DMA Channel and always reads 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SENSE",
        "This bit is reserved for this DMA Channel and always reads 0.",
        27, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "END",
        "This bit reflects the current state of the DMA End Command Signal sent"
        " from the APB Device",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KICK",
        "This bit reflects the current state of the DMA Kick Signal sent to the"
        " APB Device",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BURST",
        "This bit reflects the current state of the DMA Burst Signal from the A"
        "PB device",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REQ",
        "This bit reflects the current state of the DMA Request Signal from the"
        " APB device",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH2_DEBUG2.
static const field_t hw_apbh_ch2_debug2[] =
{
    {
        "AHB_BYTES",
        "This value reflects the current number of AHB bytes remaining to be tr"
        "ansfered in the current transfer.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_BYTES",
        "This value reflects the current number of APB bytes remaining to be tr"
        "ansfered in the current transfer.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH3_CURCMDAR.
static const field_t hw_apbh_ch3_curcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to command structure currently being processed for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH3_NXTCMDAR.
static const field_t hw_apbh_ch3_nxtcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to next command structure for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH3_CMD.
static const field_t hw_apbh_ch3_cmd[] =
{
    {
        "COMMAND",
        "This bitfield indicates the type of current command:",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        "A value of one indicates that another command is chained onto the end "
        "of the current command structure.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IRQONCMPLT",
        "A value of one indicates that the channel will cause the interrupt sta"
        "tus bit to be set upon completion of the current command, i.e.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDLOCK",
        "A value of one indicates that the NAND DMA channel will remain \"locke"
        "d\" in the arbiter at the expense of other NAND DMA channels.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDWAIT4READY",
        "A value of one indicates that the NAND DMA channel will will wait unti"
        "l the NAND device reports \"ready\" before executing the command.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEMAPHORE",
        "A value of one indicates that the channel will decrement its semaphore"
        " at the completion of the current command structure.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT4ENDCMD",
        "A value of one indicates that the channel will wait for the end of com"
        "mand signal to be sent from the APBH device to the DMA before starting"
        " the next DMA command.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALTONTERMINATE",
        "A value of one indicates that the channel will immeditately terminate "
        "the current descriptor and halt the DMA channel if a terminate signal "
        "is set.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDWORDS",
        "This field indicates the number of command words to send to the GPMI0,"
        " starting with the base PIO address of the GPMI0 control register and "
        "incrementing from there.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "XFER_COUNT",
        "This field indicates the number of bytes to transfer to or from the ap"
        "propriate PIO register in the GPMI0 device.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH3_BAR.
static const field_t hw_apbh_ch3_bar[] =
{
    {
        "ADDRESS",
        "Address of system memory buffer to be read or written over the AHB bus"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH3_SEMA.
static const field_t hw_apbh_ch3_sema[] =
{
    {
        "INCREMENT_SEMA",
        "The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DMA hardware subst"
        "racts happening on the same clock are protected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHORE",
        "This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH3_DEBUG1.
static const field_t hw_apbh_ch3_debug1[] =
{
    {
        "STATEMACHINE",
        "PIO Display of the DMA Channel n state machine state.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "WR_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Write FIFO Fu"
        "ll signal.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Write FIFO Em"
        "pty signal.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Read FIFO Ful"
        "l signal.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Read FIFO Emp"
        "ty signal.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXTCMDADDRVALID",
        "This bit reflects the internal bit which indicates whether the channel"
        "'s next command address is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "This bit is reserved for this Channel and always reads 0.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READY",
        "This bit is reserved for this DMA Channel and always reads 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SENSE",
        "This bit is reserved for this DMA Channel and always reads 0.",
        27, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "END",
        "This bit reflects the current state of the DMA End Command Signal sent"
        " from the APB Device",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KICK",
        "This bit reflects the current state of the DMA Kick Signal sent to the"
        " APB Device",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BURST",
        "This bit reflects the current state of the DMA Burst Signal from the A"
        "PB device",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REQ",
        "This bit reflects the current state of the DMA Request Signal from the"
        " APB device",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH3_DEBUG2.
static const field_t hw_apbh_ch3_debug2[] =
{
    {
        "AHB_BYTES",
        "This value reflects the current number of AHB bytes remaining to be tr"
        "ansfered in the current transfer.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_BYTES",
        "This value reflects the current number of APB bytes remaining to be tr"
        "ansfered in the current transfer.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH4_CURCMDAR.
static const field_t hw_apbh_ch4_curcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to command structure currently being processed for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH4_NXTCMDAR.
static const field_t hw_apbh_ch4_nxtcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to next command structure for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH4_CMD.
static const field_t hw_apbh_ch4_cmd[] =
{
    {
        "COMMAND",
        "This bitfield indicates the type of current command:",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        "A value of one indicates that another command is chained onto the end "
        "of the current command structure.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IRQONCMPLT",
        "A value of one indicates that the channel will cause the interrupt sta"
        "tus bit to be set upon completion of the current command, i.e.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDLOCK",
        "A value of one indicates that the NAND DMA channel will remain \"locke"
        "d\" in the arbiter at the expense of other NAND DMA channels.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDWAIT4READY",
        "A value of one indicates that the NAND DMA channel will will wait unti"
        "l the NAND device reports \"ready\" before executing the command.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEMAPHORE",
        "A value of one indicates that the channel will decrement its semaphore"
        " at the completion of the current command structure.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT4ENDCMD",
        "A value of one indicates that the channel will wait for the end of com"
        "mand signal to be sent from the APBH device to the DMA before starting"
        " the next DMA command.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALTONTERMINATE",
        "A value of one indicates that the channel will immeditately terminate "
        "the current descriptor and halt the DMA channel if a terminate signal "
        "is set.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDWORDS",
        "This field indicates the number of command words to send to the GPMI0,"
        " starting with the base PIO address of the GPMI0 control register and "
        "incrementing from there.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "XFER_COUNT",
        "This field indicates the number of bytes to transfer to or from the ap"
        "propriate PIO register in the GPMI0 device.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH4_BAR.
static const field_t hw_apbh_ch4_bar[] =
{
    {
        "ADDRESS",
        "Address of system memory buffer to be read or written over the AHB bus"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH4_SEMA.
static const field_t hw_apbh_ch4_sema[] =
{
    {
        "INCREMENT_SEMA",
        "The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DMA hardware subst"
        "racts happening on the same clock are protected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHORE",
        "This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH4_DEBUG1.
static const field_t hw_apbh_ch4_debug1[] =
{
    {
        "STATEMACHINE",
        "PIO Display of the DMA Channel n state machine state.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "WR_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Write FIFO Fu"
        "ll signal.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Write FIFO Em"
        "pty signal.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Read FIFO Ful"
        "l signal.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Read FIFO Emp"
        "ty signal.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXTCMDADDRVALID",
        "This bit reflects the internal bit which indicates whether the channel"
        "'s next command address is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "This bit is reserved for this Channel and always reads 0.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READY",
        "This bit is reserved for this DMA Channel and always reads 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SENSE",
        "This bit is reserved for this DMA Channel and always reads 0.",
        27, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "END",
        "This bit reflects the current state of the DMA End Command Signal sent"
        " from the APB Device",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KICK",
        "This bit reflects the current state of the DMA Kick Signal sent to the"
        " APB Device",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BURST",
        "This bit reflects the current state of the DMA Burst Signal from the A"
        "PB device",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REQ",
        "This bit reflects the current state of the DMA Request Signal from the"
        " APB device",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH4_DEBUG2.
static const field_t hw_apbh_ch4_debug2[] =
{
    {
        "AHB_BYTES",
        "This value reflects the current number of AHB bytes remaining to be tr"
        "ansfered in the current transfer.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_BYTES",
        "This value reflects the current number of APB bytes remaining to be tr"
        "ansfered in the current transfer.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH5_CURCMDAR.
static const field_t hw_apbh_ch5_curcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to command structure currently being processed for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH5_NXTCMDAR.
static const field_t hw_apbh_ch5_nxtcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to next command structure for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH5_CMD.
static const field_t hw_apbh_ch5_cmd[] =
{
    {
        "COMMAND",
        "This bitfield indicates the type of current command:",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        "A value of one indicates that another command is chained onto the end "
        "of the current command structure.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IRQONCMPLT",
        "A value of one indicates that the channel will cause the interrupt sta"
        "tus bit to be set upon completion of the current command, i.e.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDLOCK",
        "A value of one indicates that the NAND DMA channel will remain \"locke"
        "d\" in the arbiter at the expense of other NAND DMA channels.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDWAIT4READY",
        "A value of one indicates that the NAND DMA channel will will wait unti"
        "l the NAND device reports \"ready\" before executing the command.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEMAPHORE",
        "A value of one indicates that the channel will decrement its semaphore"
        " at the completion of the current command structure.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT4ENDCMD",
        "A value of one indicates that the channel will wait for the end of com"
        "mand signal to be sent from the APBH device to the DMA before starting"
        " the next DMA command.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALTONTERMINATE",
        "A value of one indicates that the channel will immeditately terminate "
        "the current descriptor and halt the DMA channel if a terminate signal "
        "is set.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDWORDS",
        "This field indicates the number of command words to send to the GPMI0,"
        " starting with the base PIO address of the GPMI0 control register and "
        "incrementing from there.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "XFER_COUNT",
        "This field indicates the number of bytes to transfer to or from the ap"
        "propriate PIO register in the GPMI0 device.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH5_BAR.
static const field_t hw_apbh_ch5_bar[] =
{
    {
        "ADDRESS",
        "Address of system memory buffer to be read or written over the AHB bus"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH5_SEMA.
static const field_t hw_apbh_ch5_sema[] =
{
    {
        "INCREMENT_SEMA",
        "The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DMA hardware subst"
        "racts happening on the same clock are protected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHORE",
        "This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH5_DEBUG1.
static const field_t hw_apbh_ch5_debug1[] =
{
    {
        "STATEMACHINE",
        "PIO Display of the DMA Channel n state machine state.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "WR_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Write FIFO Fu"
        "ll signal.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Write FIFO Em"
        "pty signal.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Read FIFO Ful"
        "l signal.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Read FIFO Emp"
        "ty signal.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXTCMDADDRVALID",
        "This bit reflects the internal bit which indicates whether the channel"
        "'s next command address is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "This bit is reserved for this Channel and always reads 0.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READY",
        "This bit is reserved for this DMA Channel and always reads 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SENSE",
        "This bit is reserved for this DMA Channel and always reads 0.",
        27, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "END",
        "This bit reflects the current state of the DMA End Command Signal sent"
        " from the APB Device",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KICK",
        "This bit reflects the current state of the DMA Kick Signal sent to the"
        " APB Device",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BURST",
        "This bit reflects the current state of the DMA Burst Signal from the A"
        "PB device",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REQ",
        "This bit reflects the current state of the DMA Request Signal from the"
        " APB device",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH5_DEBUG2.
static const field_t hw_apbh_ch5_debug2[] =
{
    {
        "AHB_BYTES",
        "This value reflects the current number of AHB bytes remaining to be tr"
        "ansfered in the current transfer.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_BYTES",
        "This value reflects the current number of APB bytes remaining to be tr"
        "ansfered in the current transfer.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH6_CURCMDAR.
static const field_t hw_apbh_ch6_curcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to command structure currently being processed for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH6_NXTCMDAR.
static const field_t hw_apbh_ch6_nxtcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to next command structure for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH6_CMD.
static const field_t hw_apbh_ch6_cmd[] =
{
    {
        "COMMAND",
        "This bitfield indicates the type of current command:",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        "A value of one indicates that another command is chained onto the end "
        "of the current command structure.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IRQONCMPLT",
        "A value of one indicates that the channel will cause the interrupt sta"
        "tus bit to be set upon completion of the current command, i.e.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDLOCK",
        "A value of one indicates that the NAND DMA channel will remain \"locke"
        "d\" in the arbiter at the expense of other NAND DMA channels.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDWAIT4READY",
        "A value of one indicates that the NAND DMA channel will will wait unti"
        "l the NAND device reports \"ready\" before executing the command.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEMAPHORE",
        "A value of one indicates that the channel will decrement its semaphore"
        " at the completion of the current command structure.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT4ENDCMD",
        "A value of one indicates that the channel will wait for the end of com"
        "mand signal to be sent from the APBH device to the DMA before starting"
        " the next DMA command.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALTONTERMINATE",
        "A value of one indicates that the channel will immeditately terminate "
        "the current descriptor and halt the DMA channel if a terminate signal "
        "is set.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDWORDS",
        "This field indicates the number of command words to send to the GPMI0,"
        " starting with the base PIO address of the GPMI0 control register and "
        "incrementing from there.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "XFER_COUNT",
        "This field indicates the number of bytes to transfer to or from the ap"
        "propriate PIO register in the GPMI0 device.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH6_BAR.
static const field_t hw_apbh_ch6_bar[] =
{
    {
        "ADDRESS",
        "Address of system memory buffer to be read or written over the AHB bus"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH6_SEMA.
static const field_t hw_apbh_ch6_sema[] =
{
    {
        "INCREMENT_SEMA",
        "The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DMA hardware subst"
        "racts happening on the same clock are protected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHORE",
        "This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH6_DEBUG1.
static const field_t hw_apbh_ch6_debug1[] =
{
    {
        "STATEMACHINE",
        "PIO Display of the DMA Channel n state machine state.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "WR_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Write FIFO Fu"
        "ll signal.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Write FIFO Em"
        "pty signal.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Read FIFO Ful"
        "l signal.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Read FIFO Emp"
        "ty signal.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXTCMDADDRVALID",
        "This bit reflects the internal bit which indicates whether the channel"
        "'s next command address is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "This bit is reserved for this Channel and always reads 0.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READY",
        "This bit is reserved for this DMA Channel and always reads 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SENSE",
        "This bit is reserved for this DMA Channel and always reads 0.",
        27, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "END",
        "This bit reflects the current state of the DMA End Command Signal sent"
        " from the APB Device",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KICK",
        "This bit reflects the current state of the DMA Kick Signal sent to the"
        " APB Device",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BURST",
        "This bit reflects the current state of the DMA Burst Signal from the A"
        "PB device",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REQ",
        "This bit reflects the current state of the DMA Request Signal from the"
        " APB device",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH6_DEBUG2.
static const field_t hw_apbh_ch6_debug2[] =
{
    {
        "AHB_BYTES",
        "This value reflects the current number of AHB bytes remaining to be tr"
        "ansfered in the current transfer.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_BYTES",
        "This value reflects the current number of APB bytes remaining to be tr"
        "ansfered in the current transfer.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH7_CURCMDAR.
static const field_t hw_apbh_ch7_curcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to command structure currently being processed for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH7_NXTCMDAR.
static const field_t hw_apbh_ch7_nxtcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to next command structure for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH7_CMD.
static const field_t hw_apbh_ch7_cmd[] =
{
    {
        "COMMAND",
        "This bitfield indicates the type of current command:",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        "A value of one indicates that another command is chained onto the end "
        "of the current command structure.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IRQONCMPLT",
        "A value of one indicates that the channel will cause the interrupt sta"
        "tus bit to be set upon completion of the current command, i.e.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDLOCK",
        "A value of one indicates that the NAND DMA channel will remain \"locke"
        "d\" in the arbiter at the expense of other NAND DMA channels.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDWAIT4READY",
        "A value of one indicates that the NAND DMA channel will will wait unti"
        "l the NAND device reports \"ready\" before executing the command.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEMAPHORE",
        "A value of one indicates that the channel will decrement its semaphore"
        " at the completion of the current command structure.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT4ENDCMD",
        "A value of one indicates that the channel will wait for the end of com"
        "mand signal to be sent from the APBH device to the DMA before starting"
        " the next DMA command.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALTONTERMINATE",
        "A value of one indicates that the channel will immeditately terminate "
        "the current descriptor and halt the DMA channel if a terminate signal "
        "is set.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDWORDS",
        "This field indicates the number of command words to send to the GPMI0,"
        " starting with the base PIO address of the GPMI0 control register and "
        "incrementing from there.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "XFER_COUNT",
        "This field indicates the number of bytes to transfer to or from the ap"
        "propriate PIO register in the GPMI0 device.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH7_BAR.
static const field_t hw_apbh_ch7_bar[] =
{
    {
        "ADDRESS",
        "Address of system memory buffer to be read or written over the AHB bus"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH7_SEMA.
static const field_t hw_apbh_ch7_sema[] =
{
    {
        "INCREMENT_SEMA",
        "The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DMA hardware subst"
        "racts happening on the same clock are protected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHORE",
        "This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH7_DEBUG1.
static const field_t hw_apbh_ch7_debug1[] =
{
    {
        "STATEMACHINE",
        "PIO Display of the DMA Channel n state machine state.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "WR_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Write FIFO Fu"
        "ll signal.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Write FIFO Em"
        "pty signal.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Read FIFO Ful"
        "l signal.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Read FIFO Emp"
        "ty signal.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXTCMDADDRVALID",
        "This bit reflects the internal bit which indicates whether the channel"
        "'s next command address is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "This bit is reserved for this Channel and always reads 0.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READY",
        "This bit is reserved for this DMA Channel and always reads 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SENSE",
        "This bit is reserved for this DMA Channel and always reads 0.",
        27, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "END",
        "This bit reflects the current state of the DMA End Command Signal sent"
        " from the APB Device",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KICK",
        "This bit reflects the current state of the DMA Kick Signal sent to the"
        " APB Device",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BURST",
        "This bit reflects the current state of the DMA Burst Signal from the A"
        "PB device",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REQ",
        "This bit reflects the current state of the DMA Request Signal from the"
        " APB device",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH7_DEBUG2.
static const field_t hw_apbh_ch7_debug2[] =
{
    {
        "AHB_BYTES",
        "This value reflects the current number of AHB bytes remaining to be tr"
        "ansfered in the current transfer.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_BYTES",
        "This value reflects the current number of APB bytes remaining to be tr"
        "ansfered in the current transfer.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH8_CURCMDAR.
static const field_t hw_apbh_ch8_curcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to command structure currently being processed for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH8_NXTCMDAR.
static const field_t hw_apbh_ch8_nxtcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to next command structure for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH8_CMD.
static const field_t hw_apbh_ch8_cmd[] =
{
    {
        "COMMAND",
        "This bitfield indicates the type of current command:",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        "A value of one indicates that another command is chained onto the end "
        "of the current command structure.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IRQONCMPLT",
        "A value of one indicates that the channel will cause the interrupt sta"
        "tus bit to be set upon completion of the current command, i.e.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDLOCK",
        "A value of one indicates that the NAND DMA channel will remain \"locke"
        "d\" in the arbiter at the expense of other NAND DMA channels.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDWAIT4READY",
        "A value of one indicates that the NAND DMA channel will will wait unti"
        "l the NAND device reports \"ready\" before executing the command.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEMAPHORE",
        "A value of one indicates that the channel will decrement its semaphore"
        " at the completion of the current command structure.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT4ENDCMD",
        "A value of one indicates that the channel will wait for the end of com"
        "mand signal to be sent from the APBH device to the DMA before starting"
        " the next DMA command.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALTONTERMINATE",
        "A value of one indicates that the channel will immeditately terminate "
        "the current descriptor and halt the DMA channel if a terminate signal "
        "is set.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDWORDS",
        "This field indicates the number of command words to send to the GPMI0,"
        " starting with the base PIO address of the GPMI0 control register and "
        "incrementing from there.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "XFER_COUNT",
        "This field indicates the number of bytes to transfer to or from the ap"
        "propriate PIO register in the GPMI0 device.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH8_BAR.
static const field_t hw_apbh_ch8_bar[] =
{
    {
        "ADDRESS",
        "Address of system memory buffer to be read or written over the AHB bus"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH8_SEMA.
static const field_t hw_apbh_ch8_sema[] =
{
    {
        "INCREMENT_SEMA",
        "The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DMA hardware subst"
        "racts happening on the same clock are protected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHORE",
        "This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH8_DEBUG1.
static const field_t hw_apbh_ch8_debug1[] =
{
    {
        "STATEMACHINE",
        "PIO Display of the DMA Channel n state machine state.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "WR_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Write FIFO Fu"
        "ll signal.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Write FIFO Em"
        "pty signal.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Read FIFO Ful"
        "l signal.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Read FIFO Emp"
        "ty signal.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXTCMDADDRVALID",
        "This bit reflects the internal bit which indicates whether the channel"
        "'s next command address is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "This bit is reserved for this Channel and always reads 0.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READY",
        "This bit is reserved for this DMA Channel and always reads 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SENSE",
        "This bit is reserved for this DMA Channel and always reads 0.",
        27, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "END",
        "This bit reflects the current state of the DMA End Command Signal sent"
        " from the APB Device",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KICK",
        "This bit reflects the current state of the DMA Kick Signal sent to the"
        " APB Device",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BURST",
        "This bit reflects the current state of the DMA Burst Signal from the A"
        "PB device",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REQ",
        "This bit reflects the current state of the DMA Request Signal from the"
        " APB device",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH8_DEBUG2.
static const field_t hw_apbh_ch8_debug2[] =
{
    {
        "AHB_BYTES",
        "This value reflects the current number of AHB bytes remaining to be tr"
        "ansfered in the current transfer.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_BYTES",
        "This value reflects the current number of APB bytes remaining to be tr"
        "ansfered in the current transfer.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH9_CURCMDAR.
static const field_t hw_apbh_ch9_curcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to command structure currently being processed for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH9_NXTCMDAR.
static const field_t hw_apbh_ch9_nxtcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to next command structure for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH9_CMD.
static const field_t hw_apbh_ch9_cmd[] =
{
    {
        "COMMAND",
        "This bitfield indicates the type of current command:",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        "A value of one indicates that another command is chained onto the end "
        "of the current command structure.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IRQONCMPLT",
        "A value of one indicates that the channel will cause the interrupt sta"
        "tus bit to be set upon completion of the current command, i.e.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDLOCK",
        "A value of one indicates that the NAND DMA channel will remain \"locke"
        "d\" in the arbiter at the expense of other NAND DMA channels.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDWAIT4READY",
        "A value of one indicates that the NAND DMA channel will will wait unti"
        "l the NAND device reports \"ready\" before executing the command.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEMAPHORE",
        "A value of one indicates that the channel will decrement its semaphore"
        " at the completion of the current command structure.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT4ENDCMD",
        "A value of one indicates that the channel will wait for the end of com"
        "mand signal to be sent from the APBH device to the DMA before starting"
        " the next DMA command.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALTONTERMINATE",
        "A value of one indicates that the channel will immeditately terminate "
        "the current descriptor and halt the DMA channel if a terminate signal "
        "is set.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDWORDS",
        "This field indicates the number of command words to send to the GPMI0,"
        " starting with the base PIO address of the GPMI0 control register and "
        "incrementing from there.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "XFER_COUNT",
        "This field indicates the number of bytes to transfer to or from the ap"
        "propriate PIO register in the GPMI0 device.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH9_BAR.
static const field_t hw_apbh_ch9_bar[] =
{
    {
        "ADDRESS",
        "Address of system memory buffer to be read or written over the AHB bus"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH9_SEMA.
static const field_t hw_apbh_ch9_sema[] =
{
    {
        "INCREMENT_SEMA",
        "The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DMA hardware subst"
        "racts happening on the same clock are protected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHORE",
        "This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH9_DEBUG1.
static const field_t hw_apbh_ch9_debug1[] =
{
    {
        "STATEMACHINE",
        "PIO Display of the DMA Channel n state machine state.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "WR_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Write FIFO Fu"
        "ll signal.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Write FIFO Em"
        "pty signal.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Read FIFO Ful"
        "l signal.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Read FIFO Emp"
        "ty signal.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXTCMDADDRVALID",
        "This bit reflects the internal bit which indicates whether the channel"
        "'s next command address is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "This bit is reserved for this Channel and always reads 0.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READY",
        "This bit is reserved for this DMA Channel and always reads 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SENSE",
        "This bit is reserved for this DMA Channel and always reads 0.",
        27, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "END",
        "This bit reflects the current state of the DMA End Command Signal sent"
        " from the APB Device",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KICK",
        "This bit reflects the current state of the DMA Kick Signal sent to the"
        " APB Device",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BURST",
        "This bit reflects the current state of the DMA Burst Signal from the A"
        "PB device",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REQ",
        "This bit reflects the current state of the DMA Request Signal from the"
        " APB device",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH9_DEBUG2.
static const field_t hw_apbh_ch9_debug2[] =
{
    {
        "AHB_BYTES",
        "This value reflects the current number of AHB bytes remaining to be tr"
        "ansfered in the current transfer.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_BYTES",
        "This value reflects the current number of APB bytes remaining to be tr"
        "ansfered in the current transfer.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH10_CURCMDAR.
static const field_t hw_apbh_ch10_curcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to command structure currently being processed for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH10_NXTCMDAR.
static const field_t hw_apbh_ch10_nxtcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to next command structure for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH10_CMD.
static const field_t hw_apbh_ch10_cmd[] =
{
    {
        "COMMAND",
        "This bitfield indicates the type of current command:",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        "A value of one indicates that another command is chained onto the end "
        "of the current command structure.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IRQONCMPLT",
        "A value of one indicates that the channel will cause the interrupt sta"
        "tus bit to be set upon completion of the current command, i.e.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDLOCK",
        "A value of one indicates that the NAND DMA channel will remain \"locke"
        "d\" in the arbiter at the expense of other NAND DMA channels.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDWAIT4READY",
        "A value of one indicates that the NAND DMA channel will will wait unti"
        "l the NAND device reports \"ready\" before executing the command.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEMAPHORE",
        "A value of one indicates that the channel will decrement its semaphore"
        " at the completion of the current command structure.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT4ENDCMD",
        "A value of one indicates that the channel will wait for the end of com"
        "mand signal to be sent from the APBH device to the DMA before starting"
        " the next DMA command.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALTONTERMINATE",
        "A value of one indicates that the channel will immeditately terminate "
        "the current descriptor and halt the DMA channel if a terminate signal "
        "is set.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDWORDS",
        "This field indicates the number of command words to send to the GPMI0,"
        " starting with the base PIO address of the GPMI0 control register and "
        "incrementing from there.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "XFER_COUNT",
        "This field indicates the number of bytes to transfer to or from the ap"
        "propriate PIO register in the GPMI0 device.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH10_BAR.
static const field_t hw_apbh_ch10_bar[] =
{
    {
        "ADDRESS",
        "Address of system memory buffer to be read or written over the AHB bus"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH10_SEMA.
static const field_t hw_apbh_ch10_sema[] =
{
    {
        "INCREMENT_SEMA",
        "The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DMA hardware subst"
        "racts happening on the same clock are protected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHORE",
        "This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH10_DEBUG1.
static const field_t hw_apbh_ch10_debug1[] =
{
    {
        "STATEMACHINE",
        "PIO Display of the DMA Channel n state machine state.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "WR_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Write FIFO Fu"
        "ll signal.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Write FIFO Em"
        "pty signal.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Read FIFO Ful"
        "l signal.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Read FIFO Emp"
        "ty signal.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXTCMDADDRVALID",
        "This bit reflects the internal bit which indicates whether the channel"
        "'s next command address is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "This bit is reserved for this Channel and always reads 0.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READY",
        "This bit is reserved for this DMA Channel and always reads 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SENSE",
        "This bit is reserved for this DMA Channel and always reads 0.",
        27, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "END",
        "This bit reflects the current state of the DMA End Command Signal sent"
        " from the APB Device",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KICK",
        "This bit reflects the current state of the DMA Kick Signal sent to the"
        " APB Device",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BURST",
        "This bit reflects the current state of the DMA Burst Signal from the A"
        "PB device",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REQ",
        "This bit reflects the current state of the DMA Request Signal from the"
        " APB device",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH10_DEBUG2.
static const field_t hw_apbh_ch10_debug2[] =
{
    {
        "AHB_BYTES",
        "This value reflects the current number of AHB bytes remaining to be tr"
        "ansfered in the current transfer.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_BYTES",
        "This value reflects the current number of APB bytes remaining to be tr"
        "ansfered in the current transfer.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH11_CURCMDAR.
static const field_t hw_apbh_ch11_curcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to command structure currently being processed for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH11_NXTCMDAR.
static const field_t hw_apbh_ch11_nxtcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to next command structure for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH11_CMD.
static const field_t hw_apbh_ch11_cmd[] =
{
    {
        "COMMAND",
        "This bitfield indicates the type of current command:",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        "A value of one indicates that another command is chained onto the end "
        "of the current command structure.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IRQONCMPLT",
        "A value of one indicates that the channel will cause the interrupt sta"
        "tus bit to be set upon completion of the current command, i.e.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDLOCK",
        "A value of one indicates that the NAND DMA channel will remain \"locke"
        "d\" in the arbiter at the expense of other NAND DMA channels.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDWAIT4READY",
        "A value of one indicates that the NAND DMA channel will will wait unti"
        "l the NAND device reports \"ready\" before executing the command.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEMAPHORE",
        "A value of one indicates that the channel will decrement its semaphore"
        " at the completion of the current command structure.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT4ENDCMD",
        "A value of one indicates that the channel will wait for the end of com"
        "mand signal to be sent from the APBH device to the DMA before starting"
        " the next DMA command.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALTONTERMINATE",
        "A value of one indicates that the channel will immeditately terminate "
        "the current descriptor and halt the DMA channel if a terminate signal "
        "is set.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDWORDS",
        "This field indicates the number of command words to send to the GPMI0,"
        " starting with the base PIO address of the GPMI0 control register and "
        "incrementing from there.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "XFER_COUNT",
        "This field indicates the number of bytes to transfer to or from the ap"
        "propriate PIO register in the GPMI0 device.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH11_BAR.
static const field_t hw_apbh_ch11_bar[] =
{
    {
        "ADDRESS",
        "Address of system memory buffer to be read or written over the AHB bus"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH11_SEMA.
static const field_t hw_apbh_ch11_sema[] =
{
    {
        "INCREMENT_SEMA",
        "The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DMA hardware subst"
        "racts happening on the same clock are protected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHORE",
        "This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH11_DEBUG1.
static const field_t hw_apbh_ch11_debug1[] =
{
    {
        "STATEMACHINE",
        "PIO Display of the DMA Channel n state machine state.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "WR_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Write FIFO Fu"
        "ll signal.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Write FIFO Em"
        "pty signal.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Read FIFO Ful"
        "l signal.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Read FIFO Emp"
        "ty signal.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXTCMDADDRVALID",
        "This bit reflects the internal bit which indicates whether the channel"
        "'s next command address is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "This bit is reserved for this Channel and always reads 0.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READY",
        "This bit is reserved for this DMA Channel and always reads 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SENSE",
        "This bit is reserved for this DMA Channel and always reads 0.",
        27, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "END",
        "This bit reflects the current state of the DMA End Command Signal sent"
        " from the APB Device",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KICK",
        "This bit reflects the current state of the DMA Kick Signal sent to the"
        " APB Device",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BURST",
        "This bit reflects the current state of the DMA Burst Signal from the A"
        "PB device",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REQ",
        "This bit reflects the current state of the DMA Request Signal from the"
        " APB device",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH11_DEBUG2.
static const field_t hw_apbh_ch11_debug2[] =
{
    {
        "AHB_BYTES",
        "This value reflects the current number of AHB bytes remaining to be tr"
        "ansfered in the current transfer.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_BYTES",
        "This value reflects the current number of APB bytes remaining to be tr"
        "ansfered in the current transfer.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH12_CURCMDAR.
static const field_t hw_apbh_ch12_curcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to command structure currently being processed for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH12_NXTCMDAR.
static const field_t hw_apbh_ch12_nxtcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to next command structure for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH12_CMD.
static const field_t hw_apbh_ch12_cmd[] =
{
    {
        "COMMAND",
        "This bitfield indicates the type of current command:",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        "A value of one indicates that another command is chained onto the end "
        "of the current command structure.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IRQONCMPLT",
        "A value of one indicates that the channel will cause the interrupt sta"
        "tus bit to be set upon completion of the current command, i.e.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDLOCK",
        "A value of one indicates that the NAND DMA channel will remain \"locke"
        "d\" in the arbiter at the expense of other NAND DMA channels.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDWAIT4READY",
        "A value of one indicates that the NAND DMA channel will will wait unti"
        "l the NAND device reports \"ready\" before executing the command.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEMAPHORE",
        "A value of one indicates that the channel will decrement its semaphore"
        " at the completion of the current command structure.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT4ENDCMD",
        "A value of one indicates that the channel will wait for the end of com"
        "mand signal to be sent from the APBH device to the DMA before starting"
        " the next DMA command.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALTONTERMINATE",
        "A value of one indicates that the channel will immeditately terminate "
        "the current descriptor and halt the DMA channel if a terminate signal "
        "is set.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDWORDS",
        "This field indicates the number of command words to send to the GPMI0,"
        " starting with the base PIO address of the GPMI0 control register and "
        "incrementing from there.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "XFER_COUNT",
        "This field indicates the number of bytes to transfer to or from the ap"
        "propriate PIO register in the GPMI0 device.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH12_BAR.
static const field_t hw_apbh_ch12_bar[] =
{
    {
        "ADDRESS",
        "Address of system memory buffer to be read or written over the AHB bus"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH12_SEMA.
static const field_t hw_apbh_ch12_sema[] =
{
    {
        "INCREMENT_SEMA",
        "The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DMA hardware subst"
        "racts happening on the same clock are protected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHORE",
        "This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH12_DEBUG1.
static const field_t hw_apbh_ch12_debug1[] =
{
    {
        "STATEMACHINE",
        "PIO Display of the DMA Channel n state machine state.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "WR_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Write FIFO Fu"
        "ll signal.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Write FIFO Em"
        "pty signal.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Read FIFO Ful"
        "l signal.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Read FIFO Emp"
        "ty signal.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXTCMDADDRVALID",
        "This bit reflects the internal bit which indicates whether the channel"
        "'s next command address is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "This bit is reserved for this Channel and always reads 0.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READY",
        "This bit is reserved for this DMA Channel and always reads 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SENSE",
        "This bit is reserved for this DMA Channel and always reads 0.",
        27, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "END",
        "This bit reflects the current state of the DMA End Command Signal sent"
        " from the APB Device",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KICK",
        "This bit reflects the current state of the DMA Kick Signal sent to the"
        " APB Device",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BURST",
        "This bit reflects the current state of the DMA Burst Signal from the A"
        "PB device",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REQ",
        "This bit reflects the current state of the DMA Request Signal from the"
        " APB device",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH12_DEBUG2.
static const field_t hw_apbh_ch12_debug2[] =
{
    {
        "AHB_BYTES",
        "This value reflects the current number of AHB bytes remaining to be tr"
        "ansfered in the current transfer.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_BYTES",
        "This value reflects the current number of APB bytes remaining to be tr"
        "ansfered in the current transfer.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH13_CURCMDAR.
static const field_t hw_apbh_ch13_curcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to command structure currently being processed for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH13_NXTCMDAR.
static const field_t hw_apbh_ch13_nxtcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to next command structure for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH13_CMD.
static const field_t hw_apbh_ch13_cmd[] =
{
    {
        "COMMAND",
        "This bitfield indicates the type of current command:",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        "A value of one indicates that another command is chained onto the end "
        "of the current command structure.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IRQONCMPLT",
        "A value of one indicates that the channel will cause the interrupt sta"
        "tus bit to be set upon completion of the current command, i.e.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDLOCK",
        "A value of one indicates that the NAND DMA channel will remain \"locke"
        "d\" in the arbiter at the expense of other NAND DMA channels.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDWAIT4READY",
        "A value of one indicates that the NAND DMA channel will will wait unti"
        "l the NAND device reports \"ready\" before executing the command.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEMAPHORE",
        "A value of one indicates that the channel will decrement its semaphore"
        " at the completion of the current command structure.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT4ENDCMD",
        "A value of one indicates that the channel will wait for the end of com"
        "mand signal to be sent from the APBH device to the DMA before starting"
        " the next DMA command.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALTONTERMINATE",
        "A value of one indicates that the channel will immeditately terminate "
        "the current descriptor and halt the DMA channel if a terminate signal "
        "is set.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDWORDS",
        "This field indicates the number of command words to send to the GPMI0,"
        " starting with the base PIO address of the GPMI0 control register and "
        "incrementing from there.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "XFER_COUNT",
        "This field indicates the number of bytes to transfer to or from the ap"
        "propriate PIO register in the GPMI0 device.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH13_BAR.
static const field_t hw_apbh_ch13_bar[] =
{
    {
        "ADDRESS",
        "Address of system memory buffer to be read or written over the AHB bus"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH13_SEMA.
static const field_t hw_apbh_ch13_sema[] =
{
    {
        "INCREMENT_SEMA",
        "The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DMA hardware subst"
        "racts happening on the same clock are protected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHORE",
        "This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH13_DEBUG1.
static const field_t hw_apbh_ch13_debug1[] =
{
    {
        "STATEMACHINE",
        "PIO Display of the DMA Channel n state machine state.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "WR_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Write FIFO Fu"
        "ll signal.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Write FIFO Em"
        "pty signal.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Read FIFO Ful"
        "l signal.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Read FIFO Emp"
        "ty signal.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXTCMDADDRVALID",
        "This bit reflects the internal bit which indicates whether the channel"
        "'s next command address is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "This bit is reserved for this Channel and always reads 0.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READY",
        "This bit is reserved for this DMA Channel and always reads 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SENSE",
        "This bit is reserved for this DMA Channel and always reads 0.",
        27, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "END",
        "This bit reflects the current state of the DMA End Command Signal sent"
        " from the APB Device",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KICK",
        "This bit reflects the current state of the DMA Kick Signal sent to the"
        " APB Device",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BURST",
        "This bit reflects the current state of the DMA Burst Signal from the A"
        "PB device",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REQ",
        "This bit reflects the current state of the DMA Request Signal from the"
        " APB device",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH13_DEBUG2.
static const field_t hw_apbh_ch13_debug2[] =
{
    {
        "AHB_BYTES",
        "This value reflects the current number of AHB bytes remaining to be tr"
        "ansfered in the current transfer.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_BYTES",
        "This value reflects the current number of APB bytes remaining to be tr"
        "ansfered in the current transfer.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH14_CURCMDAR.
static const field_t hw_apbh_ch14_curcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to command structure currently being processed for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH14_NXTCMDAR.
static const field_t hw_apbh_ch14_nxtcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to next command structure for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH14_CMD.
static const field_t hw_apbh_ch14_cmd[] =
{
    {
        "COMMAND",
        "This bitfield indicates the type of current command:",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        "A value of one indicates that another command is chained onto the end "
        "of the current command structure.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IRQONCMPLT",
        "A value of one indicates that the channel will cause the interrupt sta"
        "tus bit to be set upon completion of the current command, i.e.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDLOCK",
        "A value of one indicates that the NAND DMA channel will remain \"locke"
        "d\" in the arbiter at the expense of other NAND DMA channels.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDWAIT4READY",
        "A value of one indicates that the NAND DMA channel will will wait unti"
        "l the NAND device reports \"ready\" before executing the command.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEMAPHORE",
        "A value of one indicates that the channel will decrement its semaphore"
        " at the completion of the current command structure.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT4ENDCMD",
        "A value of one indicates that the channel will wait for the end of com"
        "mand signal to be sent from the APBH device to the DMA before starting"
        " the next DMA command.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALTONTERMINATE",
        "A value of one indicates that the channel will immeditately terminate "
        "the current descriptor and halt the DMA channel if a terminate signal "
        "is set.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDWORDS",
        "This field indicates the number of command words to send to the GPMI0,"
        " starting with the base PIO address of the GPMI0 control register and "
        "incrementing from there.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "XFER_COUNT",
        "This field indicates the number of bytes to transfer to or from the ap"
        "propriate PIO register in the GPMI0 device.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH14_BAR.
static const field_t hw_apbh_ch14_bar[] =
{
    {
        "ADDRESS",
        "Address of system memory buffer to be read or written over the AHB bus"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH14_SEMA.
static const field_t hw_apbh_ch14_sema[] =
{
    {
        "INCREMENT_SEMA",
        "The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DMA hardware subst"
        "racts happening on the same clock are protected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHORE",
        "This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH14_DEBUG1.
static const field_t hw_apbh_ch14_debug1[] =
{
    {
        "STATEMACHINE",
        "PIO Display of the DMA Channel n state machine state.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "WR_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Write FIFO Fu"
        "ll signal.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Write FIFO Em"
        "pty signal.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Read FIFO Ful"
        "l signal.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Read FIFO Emp"
        "ty signal.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXTCMDADDRVALID",
        "This bit reflects the internal bit which indicates whether the channel"
        "'s next command address is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "This bit is reserved for this Channel and always reads 0.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READY",
        "This bit is reserved for this DMA Channel and always reads 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SENSE",
        "This bit is reserved for this DMA Channel and always reads 0.",
        27, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "END",
        "This bit reflects the current state of the DMA End Command Signal sent"
        " from the APB Device",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KICK",
        "This bit reflects the current state of the DMA Kick Signal sent to the"
        " APB Device",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BURST",
        "This bit reflects the current state of the DMA Burst Signal from the A"
        "PB device",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REQ",
        "This bit reflects the current state of the DMA Request Signal from the"
        " APB device",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH14_DEBUG2.
static const field_t hw_apbh_ch14_debug2[] =
{
    {
        "AHB_BYTES",
        "This value reflects the current number of AHB bytes remaining to be tr"
        "ansfered in the current transfer.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_BYTES",
        "This value reflects the current number of APB bytes remaining to be tr"
        "ansfered in the current transfer.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH15_CURCMDAR.
static const field_t hw_apbh_ch15_curcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to command structure currently being processed for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH15_NXTCMDAR.
static const field_t hw_apbh_ch15_nxtcmdar[] =
{
    {
        "CMD_ADDR",
        "Pointer to next command structure for channel n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH15_CMD.
static const field_t hw_apbh_ch15_cmd[] =
{
    {
        "COMMAND",
        "This bitfield indicates the type of current command:",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHAIN",
        "A value of one indicates that another command is chained onto the end "
        "of the current command structure.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IRQONCMPLT",
        "A value of one indicates that the channel will cause the interrupt sta"
        "tus bit to be set upon completion of the current command, i.e.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDLOCK",
        "A value of one indicates that the NAND DMA channel will remain \"locke"
        "d\" in the arbiter at the expense of other NAND DMA channels.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NANDWAIT4READY",
        "A value of one indicates that the NAND DMA channel will will wait unti"
        "l the NAND device reports \"ready\" before executing the command.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SEMAPHORE",
        "A value of one indicates that the channel will decrement its semaphore"
        " at the completion of the current command structure.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT4ENDCMD",
        "A value of one indicates that the channel will wait for the end of com"
        "mand signal to be sent from the APBH device to the DMA before starting"
        " the next DMA command.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALTONTERMINATE",
        "A value of one indicates that the channel will immeditately terminate "
        "the current descriptor and halt the DMA channel if a terminate signal "
        "is set.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMDWORDS",
        "This field indicates the number of command words to send to the GPMI0,"
        " starting with the base PIO address of the GPMI0 control register and "
        "incrementing from there.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "XFER_COUNT",
        "This field indicates the number of bytes to transfer to or from the ap"
        "propriate PIO register in the GPMI0 device.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH15_BAR.
static const field_t hw_apbh_ch15_bar[] =
{
    {
        "ADDRESS",
        "Address of system memory buffer to be read or written over the AHB bus"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH15_SEMA.
static const field_t hw_apbh_ch15_sema[] =
{
    {
        "INCREMENT_SEMA",
        "The value written to this field is added to the semaphore count in an "
        "atomic way such that simultaneous software adds and DMA hardware subst"
        "racts happening on the same clock are protected.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHORE",
        "This read-only field shows the current (instantaneous) value of the se"
        "maphore counter.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH15_DEBUG1.
static const field_t hw_apbh_ch15_debug1[] =
{
    {
        "STATEMACHINE",
        "PIO Display of the DMA Channel n state machine state.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        5, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "WR_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Write FIFO Fu"
        "ll signal.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Write FIFO Em"
        "pty signal.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_FULL",
        "This bit reflects the current state of the DMA Channel's Read FIFO Ful"
        "l signal.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_FIFO_EMPTY",
        "This bit reflects the current state of the DMA Channel's Read FIFO Emp"
        "ty signal.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NEXTCMDADDRVALID",
        "This bit reflects the internal bit which indicates whether the channel"
        "'s next command address is valid.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "This bit is reserved for this Channel and always reads 0.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READY",
        "This bit is reserved for this DMA Channel and always reads 0.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SENSE",
        "This bit is reserved for this DMA Channel and always reads 0.",
        27, // LSB
        27, // MSB
        false, // Readable
        false // Writable
    },
    {
        "END",
        "This bit reflects the current state of the DMA End Command Signal sent"
        " from the APB Device",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KICK",
        "This bit reflects the current state of the DMA Kick Signal sent to the"
        " APB Device",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BURST",
        "This bit reflects the current state of the DMA Burst Signal from the A"
        "PB device",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REQ",
        "This bit reflects the current state of the DMA Request Signal from the"
        " APB device",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_CH15_DEBUG2.
static const field_t hw_apbh_ch15_debug2[] =
{
    {
        "AHB_BYTES",
        "This value reflects the current number of AHB bytes remaining to be tr"
        "ansfered in the current transfer.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_BYTES",
        "This value reflects the current number of APB bytes remaining to be tr"
        "ansfered in the current transfer.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register APBH_VERSION.
static const field_t hw_apbh_version[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a APBH module.
static const reg_t hw_apbh[] =
{
    {
        "CTRL0",
        "The APBH CTRL 0 provides overall control of the AHB to APBH bridge and"
        " DMA.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_apbh_ctrl0
    },
    {
        "CTRL0_SET",
        "The APBH CTRL 0 provides overall control of the AHB to APBH bridge and"
        " DMA.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_apbh_ctrl0_set
    },
    {
        "CTRL0_CLR",
        "The APBH CTRL 0 provides overall control of the AHB to APBH bridge and"
        " DMA.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_apbh_ctrl0_clr
    },
    {
        "CTRL0_TOG",
        "The APBH CTRL 0 provides overall control of the AHB to APBH bridge and"
        " DMA.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_apbh_ctrl0_tog
    },
    {
        "CTRL1",
        "The APBH CTRL one provides overall control of the interrupts generated"
        " by the AHB to APBH DMA.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_apbh_ctrl1
    },
    {
        "CTRL1_SET",
        "The APBH CTRL one provides overall control of the interrupts generated"
        " by the AHB to APBH DMA.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_apbh_ctrl1_set
    },
    {
        "CTRL1_CLR",
        "The APBH CTRL one provides overall control of the interrupts generated"
        " by the AHB to APBH DMA.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_apbh_ctrl1_clr
    },
    {
        "CTRL1_TOG",
        "The APBH CTRL one provides overall control of the interrupts generated"
        " by the AHB to APBH DMA.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_apbh_ctrl1_tog
    },
    {
        "CTRL2",
        "The APBH CTRL 2 provides channel error interrupts generated by the AHB"
        " to APBH DMA.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_apbh_ctrl2
    },
    {
        "CTRL2_SET",
        "The APBH CTRL 2 provides channel error interrupts generated by the AHB"
        " to APBH DMA.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_apbh_ctrl2_set
    },
    {
        "CTRL2_CLR",
        "The APBH CTRL 2 provides channel error interrupts generated by the AHB"
        " to APBH DMA.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_apbh_ctrl2_clr
    },
    {
        "CTRL2_TOG",
        "The APBH CTRL 2 provides channel error interrupts generated by the AHB"
        " to APBH DMA.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        32, // Number of bitfields
        hw_apbh_ctrl2_tog
    },
    {
        "CHANNEL_CTRL",
        "The APBH CHANNEL CTRL provides reset/freeze control of each DMA channe"
        "l.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_channel_ctrl
    },
    {
        "CHANNEL_CTRL_SET",
        "The APBH CHANNEL CTRL provides reset/freeze control of each DMA channe"
        "l.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_channel_ctrl_set
    },
    {
        "CHANNEL_CTRL_CLR",
        "The APBH CHANNEL CTRL provides reset/freeze control of each DMA channe"
        "l.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_channel_ctrl_clr
    },
    {
        "CHANNEL_CTRL_TOG",
        "The APBH CHANNEL CTRL provides reset/freeze control of each DMA channe"
        "l.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_channel_ctrl_tog
    },
    {
        "DEVSEL",
        "This register allows reassignment of the APBH device connected to the "
        "DMA Channels.",
        4, // Width in bytes
        0x00000040, // Base address offset
        false, // Readable
        false, // Writable
        16, // Number of bitfields
        hw_apbh_devsel
    },
    {
        "DMA_BURST_SIZE",
        "This register programs the apbh burst size of the APBH DMA devices whe"
        "n a DMA burst request is issued.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_apbh_dma_burst_size
    },
    {
        "DEBUG",
        "This register is for debug purpose.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_debug
    },
    {
        "CH0_CURCMDAR",
        "The APBH DMA channel n current command address register points to the "
        "multiword command that is currently being executed.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch0_curcmdar
    },
    {
        "CH0_NXTCMDAR",
        "The APBH DMA Channel n Next Command Address register contains the addr"
        "ess of the next multiword command to be executed.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_ch0_nxtcmdar
    },
    {
        "CH0_CMD",
        "The APBH DMA Channel n command register specifies the DMA transaction "
        "to perform for the current command chain item.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_apbh_ch0_cmd
    },
    {
        "CH0_BAR",
        "The APBH DMA Channel n buffer address register contains a pointer to t"
        "he data buffer for the transfer.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch0_bar
    },
    {
        "CH0_SEMA",
        "The APBH DMA Channel n semaphore register is used to synchronize the A"
        "RM platform instruction stream and the DMA chain processing state.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_ch0_sema
    },
    {
        "CH0_DEBUG1",
        "This register gives debug visibility into the APBH DMA Channel n state"
        " machine and controls.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_apbh_ch0_debug1
    },
    {
        "CH0_DEBUG2",
        "This register gives debug visibility for the APB and AHB byte counts f"
        "or DMA Channel n.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_apbh_ch0_debug2
    },
    {
        "CH1_CURCMDAR",
        "The APBH DMA channel n current command address register points to the "
        "multiword command that is currently being executed.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch1_curcmdar
    },
    {
        "CH1_NXTCMDAR",
        "The APBH DMA Channel n Next Command Address register contains the addr"
        "ess of the next multiword command to be executed.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_ch1_nxtcmdar
    },
    {
        "CH1_CMD",
        "The APBH DMA Channel n command register specifies the DMA transaction "
        "to perform for the current command chain item.",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_apbh_ch1_cmd
    },
    {
        "CH1_BAR",
        "The APBH DMA Channel n buffer address register contains a pointer to t"
        "he data buffer for the transfer.",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch1_bar
    },
    {
        "CH1_SEMA",
        "The APBH DMA Channel n semaphore register is used to synchronize the A"
        "RM platform instruction stream and the DMA chain processing state.",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_ch1_sema
    },
    {
        "CH1_DEBUG1",
        "This register gives debug visibility into the APBH DMA Channel n state"
        " machine and controls.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_apbh_ch1_debug1
    },
    {
        "CH1_DEBUG2",
        "This register gives debug visibility for the APB and AHB byte counts f"
        "or DMA Channel n.",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_apbh_ch1_debug2
    },
    {
        "CH2_CURCMDAR",
        "The APBH DMA channel n current command address register points to the "
        "multiword command that is currently being executed.",
        4, // Width in bytes
        0x000001e0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch2_curcmdar
    },
    {
        "CH2_NXTCMDAR",
        "The APBH DMA Channel n Next Command Address register contains the addr"
        "ess of the next multiword command to be executed.",
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_ch2_nxtcmdar
    },
    {
        "CH2_CMD",
        "The APBH DMA Channel n command register specifies the DMA transaction "
        "to perform for the current command chain item.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_apbh_ch2_cmd
    },
    {
        "CH2_BAR",
        "The APBH DMA Channel n buffer address register contains a pointer to t"
        "he data buffer for the transfer.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch2_bar
    },
    {
        "CH2_SEMA",
        "The APBH DMA Channel n semaphore register is used to synchronize the A"
        "RM platform instruction stream and the DMA chain processing state.",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_ch2_sema
    },
    {
        "CH2_DEBUG1",
        "This register gives debug visibility into the APBH DMA Channel n state"
        " machine and controls.",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_apbh_ch2_debug1
    },
    {
        "CH2_DEBUG2",
        "This register gives debug visibility for the APB and AHB byte counts f"
        "or DMA Channel n.",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_apbh_ch2_debug2
    },
    {
        "CH3_CURCMDAR",
        "The APBH DMA channel n current command address register points to the "
        "multiword command that is currently being executed.",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch3_curcmdar
    },
    {
        "CH3_NXTCMDAR",
        "The APBH DMA Channel n Next Command Address register contains the addr"
        "ess of the next multiword command to be executed.",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_ch3_nxtcmdar
    },
    {
        "CH3_CMD",
        "The APBH DMA Channel n command register specifies the DMA transaction "
        "to perform for the current command chain item.",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_apbh_ch3_cmd
    },
    {
        "CH3_BAR",
        "The APBH DMA Channel n buffer address register contains a pointer to t"
        "he data buffer for the transfer.",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch3_bar
    },
    {
        "CH3_SEMA",
        "The APBH DMA Channel n semaphore register is used to synchronize the A"
        "RM platform instruction stream and the DMA chain processing state.",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_ch3_sema
    },
    {
        "CH3_DEBUG1",
        "This register gives debug visibility into the APBH DMA Channel n state"
        " machine and controls.",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_apbh_ch3_debug1
    },
    {
        "CH3_DEBUG2",
        "This register gives debug visibility for the APB and AHB byte counts f"
        "or DMA Channel n.",
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_apbh_ch3_debug2
    },
    {
        "CH4_CURCMDAR",
        "The APBH DMA channel n current command address register points to the "
        "multiword command that is currently being executed.",
        4, // Width in bytes
        0x000002c0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch4_curcmdar
    },
    {
        "CH4_NXTCMDAR",
        "The APBH DMA Channel n Next Command Address register contains the addr"
        "ess of the next multiword command to be executed.",
        4, // Width in bytes
        0x000002d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_ch4_nxtcmdar
    },
    {
        "CH4_CMD",
        "The APBH DMA Channel n command register specifies the DMA transaction "
        "to perform for the current command chain item.",
        4, // Width in bytes
        0x000002e0, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_apbh_ch4_cmd
    },
    {
        "CH4_BAR",
        "The APBH DMA Channel n buffer address register contains a pointer to t"
        "he data buffer for the transfer.",
        4, // Width in bytes
        0x000002f0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch4_bar
    },
    {
        "CH4_SEMA",
        "The APBH DMA Channel n semaphore register is used to synchronize the A"
        "RM platform instruction stream and the DMA chain processing state.",
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_ch4_sema
    },
    {
        "CH4_DEBUG1",
        "This register gives debug visibility into the APBH DMA Channel n state"
        " machine and controls.",
        4, // Width in bytes
        0x00000310, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_apbh_ch4_debug1
    },
    {
        "CH4_DEBUG2",
        "This register gives debug visibility for the APB and AHB byte counts f"
        "or DMA Channel n.",
        4, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_apbh_ch4_debug2
    },
    {
        "CH5_CURCMDAR",
        "The APBH DMA channel n current command address register points to the "
        "multiword command that is currently being executed.",
        4, // Width in bytes
        0x00000330, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch5_curcmdar
    },
    {
        "CH5_NXTCMDAR",
        "The APBH DMA Channel n Next Command Address register contains the addr"
        "ess of the next multiword command to be executed.",
        4, // Width in bytes
        0x00000340, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_ch5_nxtcmdar
    },
    {
        "CH5_CMD",
        "The APBH DMA Channel n command register specifies the DMA transaction "
        "to perform for the current command chain item.",
        4, // Width in bytes
        0x00000350, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_apbh_ch5_cmd
    },
    {
        "CH5_BAR",
        "The APBH DMA Channel n buffer address register contains a pointer to t"
        "he data buffer for the transfer.",
        4, // Width in bytes
        0x00000360, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch5_bar
    },
    {
        "CH5_SEMA",
        "The APBH DMA Channel n semaphore register is used to synchronize the A"
        "RM platform instruction stream and the DMA chain processing state.",
        4, // Width in bytes
        0x00000370, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_ch5_sema
    },
    {
        "CH5_DEBUG1",
        "This register gives debug visibility into the APBH DMA Channel n state"
        " machine and controls.",
        4, // Width in bytes
        0x00000380, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_apbh_ch5_debug1
    },
    {
        "CH5_DEBUG2",
        "This register gives debug visibility for the APB and AHB byte counts f"
        "or DMA Channel n.",
        4, // Width in bytes
        0x00000390, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_apbh_ch5_debug2
    },
    {
        "CH6_CURCMDAR",
        "The APBH DMA channel n current command address register points to the "
        "multiword command that is currently being executed.",
        4, // Width in bytes
        0x000003a0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch6_curcmdar
    },
    {
        "CH6_NXTCMDAR",
        "The APBH DMA Channel n Next Command Address register contains the addr"
        "ess of the next multiword command to be executed.",
        4, // Width in bytes
        0x000003b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_ch6_nxtcmdar
    },
    {
        "CH6_CMD",
        "The APBH DMA Channel n command register specifies the DMA transaction "
        "to perform for the current command chain item.",
        4, // Width in bytes
        0x000003c0, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_apbh_ch6_cmd
    },
    {
        "CH6_BAR",
        "The APBH DMA Channel n buffer address register contains a pointer to t"
        "he data buffer for the transfer.",
        4, // Width in bytes
        0x000003d0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch6_bar
    },
    {
        "CH6_SEMA",
        "The APBH DMA Channel n semaphore register is used to synchronize the A"
        "RM platform instruction stream and the DMA chain processing state.",
        4, // Width in bytes
        0x000003e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_ch6_sema
    },
    {
        "CH6_DEBUG1",
        "This register gives debug visibility into the APBH DMA Channel n state"
        " machine and controls.",
        4, // Width in bytes
        0x000003f0, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_apbh_ch6_debug1
    },
    {
        "CH6_DEBUG2",
        "This register gives debug visibility for the APB and AHB byte counts f"
        "or DMA Channel n.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_apbh_ch6_debug2
    },
    {
        "CH7_CURCMDAR",
        "The APBH DMA channel n current command address register points to the "
        "multiword command that is currently being executed.",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch7_curcmdar
    },
    {
        "CH7_NXTCMDAR",
        "The APBH DMA Channel n Next Command Address register contains the addr"
        "ess of the next multiword command to be executed.",
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_ch7_nxtcmdar
    },
    {
        "CH7_CMD",
        "The APBH DMA Channel n command register specifies the DMA transaction "
        "to perform for the current command chain item.",
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_apbh_ch7_cmd
    },
    {
        "CH7_BAR",
        "The APBH DMA Channel n buffer address register contains a pointer to t"
        "he data buffer for the transfer.",
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch7_bar
    },
    {
        "CH7_SEMA",
        "The APBH DMA Channel n semaphore register is used to synchronize the A"
        "RM platform instruction stream and the DMA chain processing state.",
        4, // Width in bytes
        0x00000450, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_ch7_sema
    },
    {
        "CH7_DEBUG1",
        "This register gives debug visibility into the APBH DMA Channel n state"
        " machine and controls.",
        4, // Width in bytes
        0x00000460, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_apbh_ch7_debug1
    },
    {
        "CH7_DEBUG2",
        "This register gives debug visibility for the APB and AHB byte counts f"
        "or DMA Channel n.",
        4, // Width in bytes
        0x00000470, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_apbh_ch7_debug2
    },
    {
        "CH8_CURCMDAR",
        "The APBH DMA channel n current command address register points to the "
        "multiword command that is currently being executed.",
        4, // Width in bytes
        0x00000480, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch8_curcmdar
    },
    {
        "CH8_NXTCMDAR",
        "The APBH DMA Channel n Next Command Address register contains the addr"
        "ess of the next multiword command to be executed.",
        4, // Width in bytes
        0x00000490, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_ch8_nxtcmdar
    },
    {
        "CH8_CMD",
        "The APBH DMA Channel n command register specifies the DMA transaction "
        "to perform for the current command chain item.",
        4, // Width in bytes
        0x000004a0, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_apbh_ch8_cmd
    },
    {
        "CH8_BAR",
        "The APBH DMA Channel n buffer address register contains a pointer to t"
        "he data buffer for the transfer.",
        4, // Width in bytes
        0x000004b0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch8_bar
    },
    {
        "CH8_SEMA",
        "The APBH DMA Channel n semaphore register is used to synchronize the A"
        "RM platform instruction stream and the DMA chain processing state.",
        4, // Width in bytes
        0x000004c0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_ch8_sema
    },
    {
        "CH8_DEBUG1",
        "This register gives debug visibility into the APBH DMA Channel n state"
        " machine and controls.",
        4, // Width in bytes
        0x000004d0, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_apbh_ch8_debug1
    },
    {
        "CH8_DEBUG2",
        "This register gives debug visibility for the APB and AHB byte counts f"
        "or DMA Channel n.",
        4, // Width in bytes
        0x000004e0, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_apbh_ch8_debug2
    },
    {
        "CH9_CURCMDAR",
        "The APBH DMA channel n current command address register points to the "
        "multiword command that is currently being executed.",
        4, // Width in bytes
        0x000004f0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch9_curcmdar
    },
    {
        "CH9_NXTCMDAR",
        "The APBH DMA Channel n Next Command Address register contains the addr"
        "ess of the next multiword command to be executed.",
        4, // Width in bytes
        0x00000500, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_ch9_nxtcmdar
    },
    {
        "CH9_CMD",
        "The APBH DMA Channel n command register specifies the DMA transaction "
        "to perform for the current command chain item.",
        4, // Width in bytes
        0x00000510, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_apbh_ch9_cmd
    },
    {
        "CH9_BAR",
        "The APBH DMA Channel n buffer address register contains a pointer to t"
        "he data buffer for the transfer.",
        4, // Width in bytes
        0x00000520, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch9_bar
    },
    {
        "CH9_SEMA",
        "The APBH DMA Channel n semaphore register is used to synchronize the A"
        "RM platform instruction stream and the DMA chain processing state.",
        4, // Width in bytes
        0x00000530, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_ch9_sema
    },
    {
        "CH9_DEBUG1",
        "This register gives debug visibility into the APBH DMA Channel n state"
        " machine and controls.",
        4, // Width in bytes
        0x00000540, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_apbh_ch9_debug1
    },
    {
        "CH9_DEBUG2",
        "This register gives debug visibility for the APB and AHB byte counts f"
        "or DMA Channel n.",
        4, // Width in bytes
        0x00000550, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_apbh_ch9_debug2
    },
    {
        "CH10_CURCMDAR",
        "The APBH DMA channel n current command address register points to the "
        "multiword command that is currently being executed.",
        4, // Width in bytes
        0x00000560, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch10_curcmdar
    },
    {
        "CH10_NXTCMDAR",
        "The APBH DMA Channel n Next Command Address register contains the addr"
        "ess of the next multiword command to be executed.",
        4, // Width in bytes
        0x00000570, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_ch10_nxtcmdar
    },
    {
        "CH10_CMD",
        "The APBH DMA Channel n command register specifies the DMA transaction "
        "to perform for the current command chain item.",
        4, // Width in bytes
        0x00000580, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_apbh_ch10_cmd
    },
    {
        "CH10_BAR",
        "The APBH DMA Channel n buffer address register contains a pointer to t"
        "he data buffer for the transfer.",
        4, // Width in bytes
        0x00000590, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch10_bar
    },
    {
        "CH10_SEMA",
        "The APBH DMA Channel n semaphore register is used to synchronize the A"
        "RM platform instruction stream and the DMA chain processing state.",
        4, // Width in bytes
        0x000005a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_ch10_sema
    },
    {
        "CH10_DEBUG1",
        "This register gives debug visibility into the APBH DMA Channel n state"
        " machine and controls.",
        4, // Width in bytes
        0x000005b0, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_apbh_ch10_debug1
    },
    {
        "CH10_DEBUG2",
        "This register gives debug visibility for the APB and AHB byte counts f"
        "or DMA Channel n.",
        4, // Width in bytes
        0x000005c0, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_apbh_ch10_debug2
    },
    {
        "CH11_CURCMDAR",
        "The APBH DMA channel n current command address register points to the "
        "multiword command that is currently being executed.",
        4, // Width in bytes
        0x000005d0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch11_curcmdar
    },
    {
        "CH11_NXTCMDAR",
        "The APBH DMA Channel n Next Command Address register contains the addr"
        "ess of the next multiword command to be executed.",
        4, // Width in bytes
        0x000005e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_ch11_nxtcmdar
    },
    {
        "CH11_CMD",
        "The APBH DMA Channel n command register specifies the DMA transaction "
        "to perform for the current command chain item.",
        4, // Width in bytes
        0x000005f0, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_apbh_ch11_cmd
    },
    {
        "CH11_BAR",
        "The APBH DMA Channel n buffer address register contains a pointer to t"
        "he data buffer for the transfer.",
        4, // Width in bytes
        0x00000600, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch11_bar
    },
    {
        "CH11_SEMA",
        "The APBH DMA Channel n semaphore register is used to synchronize the A"
        "RM platform instruction stream and the DMA chain processing state.",
        4, // Width in bytes
        0x00000610, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_ch11_sema
    },
    {
        "CH11_DEBUG1",
        "This register gives debug visibility into the APBH DMA Channel n state"
        " machine and controls.",
        4, // Width in bytes
        0x00000620, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_apbh_ch11_debug1
    },
    {
        "CH11_DEBUG2",
        "This register gives debug visibility for the APB and AHB byte counts f"
        "or DMA Channel n.",
        4, // Width in bytes
        0x00000630, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_apbh_ch11_debug2
    },
    {
        "CH12_CURCMDAR",
        "The APBH DMA channel n current command address register points to the "
        "multiword command that is currently being executed.",
        4, // Width in bytes
        0x00000640, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch12_curcmdar
    },
    {
        "CH12_NXTCMDAR",
        "The APBH DMA Channel n Next Command Address register contains the addr"
        "ess of the next multiword command to be executed.",
        4, // Width in bytes
        0x00000650, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_ch12_nxtcmdar
    },
    {
        "CH12_CMD",
        "The APBH DMA Channel n command register specifies the DMA transaction "
        "to perform for the current command chain item.",
        4, // Width in bytes
        0x00000660, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_apbh_ch12_cmd
    },
    {
        "CH12_BAR",
        "The APBH DMA Channel n buffer address register contains a pointer to t"
        "he data buffer for the transfer.",
        4, // Width in bytes
        0x00000670, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch12_bar
    },
    {
        "CH12_SEMA",
        "The APBH DMA Channel n semaphore register is used to synchronize the A"
        "RM platform instruction stream and the DMA chain processing state.",
        4, // Width in bytes
        0x00000680, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_ch12_sema
    },
    {
        "CH12_DEBUG1",
        "This register gives debug visibility into the APBH DMA Channel n state"
        " machine and controls.",
        4, // Width in bytes
        0x00000690, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_apbh_ch12_debug1
    },
    {
        "CH12_DEBUG2",
        "This register gives debug visibility for the APB and AHB byte counts f"
        "or DMA Channel n.",
        4, // Width in bytes
        0x000006a0, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_apbh_ch12_debug2
    },
    {
        "CH13_CURCMDAR",
        "The APBH DMA channel n current command address register points to the "
        "multiword command that is currently being executed.",
        4, // Width in bytes
        0x000006b0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch13_curcmdar
    },
    {
        "CH13_NXTCMDAR",
        "The APBH DMA Channel n Next Command Address register contains the addr"
        "ess of the next multiword command to be executed.",
        4, // Width in bytes
        0x000006c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_ch13_nxtcmdar
    },
    {
        "CH13_CMD",
        "The APBH DMA Channel n command register specifies the DMA transaction "
        "to perform for the current command chain item.",
        4, // Width in bytes
        0x000006d0, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_apbh_ch13_cmd
    },
    {
        "CH13_BAR",
        "The APBH DMA Channel n buffer address register contains a pointer to t"
        "he data buffer for the transfer.",
        4, // Width in bytes
        0x000006e0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch13_bar
    },
    {
        "CH13_SEMA",
        "The APBH DMA Channel n semaphore register is used to synchronize the A"
        "RM platform instruction stream and the DMA chain processing state.",
        4, // Width in bytes
        0x000006f0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_ch13_sema
    },
    {
        "CH13_DEBUG1",
        "This register gives debug visibility into the APBH DMA Channel n state"
        " machine and controls.",
        4, // Width in bytes
        0x00000700, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_apbh_ch13_debug1
    },
    {
        "CH13_DEBUG2",
        "This register gives debug visibility for the APB and AHB byte counts f"
        "or DMA Channel n.",
        4, // Width in bytes
        0x00000710, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_apbh_ch13_debug2
    },
    {
        "CH14_CURCMDAR",
        "The APBH DMA channel n current command address register points to the "
        "multiword command that is currently being executed.",
        4, // Width in bytes
        0x00000720, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch14_curcmdar
    },
    {
        "CH14_NXTCMDAR",
        "The APBH DMA Channel n Next Command Address register contains the addr"
        "ess of the next multiword command to be executed.",
        4, // Width in bytes
        0x00000730, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_ch14_nxtcmdar
    },
    {
        "CH14_CMD",
        "The APBH DMA Channel n command register specifies the DMA transaction "
        "to perform for the current command chain item.",
        4, // Width in bytes
        0x00000740, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_apbh_ch14_cmd
    },
    {
        "CH14_BAR",
        "The APBH DMA Channel n buffer address register contains a pointer to t"
        "he data buffer for the transfer.",
        4, // Width in bytes
        0x00000750, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch14_bar
    },
    {
        "CH14_SEMA",
        "The APBH DMA Channel n semaphore register is used to synchronize the A"
        "RM platform instruction stream and the DMA chain processing state.",
        4, // Width in bytes
        0x00000760, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_ch14_sema
    },
    {
        "CH14_DEBUG1",
        "This register gives debug visibility into the APBH DMA Channel n state"
        " machine and controls.",
        4, // Width in bytes
        0x00000770, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_apbh_ch14_debug1
    },
    {
        "CH14_DEBUG2",
        "This register gives debug visibility for the APB and AHB byte counts f"
        "or DMA Channel n.",
        4, // Width in bytes
        0x00000780, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_apbh_ch14_debug2
    },
    {
        "CH15_CURCMDAR",
        "The APBH DMA channel n current command address register points to the "
        "multiword command that is currently being executed.",
        4, // Width in bytes
        0x00000790, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch15_curcmdar
    },
    {
        "CH15_NXTCMDAR",
        "The APBH DMA Channel n Next Command Address register contains the addr"
        "ess of the next multiword command to be executed.",
        4, // Width in bytes
        0x000007a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_apbh_ch15_nxtcmdar
    },
    {
        "CH15_CMD",
        "The APBH DMA Channel n command register specifies the DMA transaction "
        "to perform for the current command chain item.",
        4, // Width in bytes
        0x000007b0, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_apbh_ch15_cmd
    },
    {
        "CH15_BAR",
        "The APBH DMA Channel n buffer address register contains a pointer to t"
        "he data buffer for the transfer.",
        4, // Width in bytes
        0x000007c0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_apbh_ch15_bar
    },
    {
        "CH15_SEMA",
        "The APBH DMA Channel n semaphore register is used to synchronize the A"
        "RM platform instruction stream and the DMA chain processing state.",
        4, // Width in bytes
        0x000007d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_apbh_ch15_sema
    },
    {
        "CH15_DEBUG1",
        "This register gives debug visibility into the APBH DMA Channel n state"
        " machine and controls.",
        4, // Width in bytes
        0x000007e0, // Base address offset
        true, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_apbh_ch15_debug1
    },
    {
        "CH15_DEBUG2",
        "This register gives debug visibility for the APB and AHB byte counts f"
        "or DMA Channel n.",
        4, // Width in bytes
        0x000007f0, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_apbh_ch15_debug2
    },
    {
        "VERSION",
        "This register always returns a known read value for debug purposes it "
        "indicates the version of the block.",
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_apbh_version
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ASRC
#endif

// Bitfields in register ASRC_ASRCTR.
static const field_t hw_asrc_asrctr[] =
{
    {
        "ASRCEN",
        "ASRC Enable Enable the operation of ASRC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASREA",
        "ASRC Enable A Enable the operation of the conversion A of ASRC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASREB",
        "ASRC Enable B Enable the operation of the conversion B of ASRC.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASREC",
        "ASRC Enable C Enable the operation of the conversion C of ASRC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRST",
        "Software Reset This bit is self-clear bit.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "IDRA",
        "Use Ideal Ratio for Pair A When USRA=0, this bit has no usage.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USRA",
        "Use Ratio for Pair A Use ratio as the input to ASRC.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDRB",
        "Use Ideal Ratio for Pair B When USRB=0, this bit has no usage.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USRB",
        "Use Ratio for Pair B Use ratio as the input to ASRC.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDRC",
        "Use Ideal Ratio for Pair C When USRC=0, this bit has no usage.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USRC",
        "Use Ratio for Pair C Use ratio as the input to ASRC.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATSA",
        "ASRC Pair A Automatic Selection For Processing Options When this bit i"
        "s 1, pair A will automatic update its pre-processing and post-processi"
        "ng options (ASRCFG: PREMODA, ASRCFG:POSTMODA see ASRC Misc Control Reg"
        "ister 1 for Pair CASRC Filter Configuration Status Register ) based on"
        " the frequencies it detected.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATSB",
        "ASRC Pair B Automatic Selection For Processing Options When this bit i"
        "s 1, pair B will automatic update its pre-processing and post-processi"
        "ng options (ASRCFG: PREMODB, ASRCFG:POSTMODB see ASRC Misc Control Reg"
        "ister 1 for Pair CASRC Filter Configuration Status Register ) based on"
        " the frequencies it detected.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATSC",
        "ASRC Pair C Automatic Selection For Processing Options When this bit i"
        "s 1, pair C will automatic update its pre-processing and post-processi"
        "ng options (ASRCFG: PREMODC, ASRCFG:POSTMODC see ASRC Misc Control Reg"
        "ister 1 for Pair CASRC Filter Configuration Status Register ) based on"
        " the frequencies it detected.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIER.
static const field_t hw_asrc_asrier[] =
{
    {
        "ADIEA",
        "Data Input A Interrupt Enable Enables the data input A Interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADIEB",
        "Data Input B Interrupt Enable Enables the data input B interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADIEC",
        "Data Input C Interrupt Enable Enables the data input C interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADOEA",
        "Data Output A Interrupt Enable Enables the data output A interrupt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADOEB",
        "Data Output B Interrupt Enable Enables the data output B interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADOEC",
        "Data Output C Interrupt Enable Enables the data output C interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOLIE",
        "Overload Interrupt Enable Enables the overload interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AFPWE",
        "FP in Wait State Interrupt Enable Enables the FP in wait state interru"
        "pt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCNCR.
static const field_t hw_asrc_asrcncr[] =
{
    {
        "ANCA",
        "Number of A Channels",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ANCB",
        "Number of B Channels",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ANCC",
        "Number of C ChannelsANCC+ANCB+ANCA<=10.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCFG.
static const field_t hw_asrc_asrcfg[] =
{
    {
        "PREMODA",
        "Pre-Processing Configuration for Conversion Pair A These bits will be "
        "read/write by user if ASRCTR:ATSA=0, and can also be automatically upd"
        "ated by the ASRC internal logic if ASRCTR:ATSA=1 (see ASRC Misc Contro"
        "l Register 1 for Pair CASRC Control Register ).",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POSTMODA",
        "Post-Processing Configuration for Conversion Pair A These bits will be"
        " read/write by user if ASRCTR:ATSA=0, and can also be automatically up"
        "dated by the ASRC internal logic if ASRCTR:ATSA=1 (see ASRC Misc Contr"
        "ol Register 1 for Pair CASRC Control Register ).",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREMODB",
        "Pre-Processing Configuration for Conversion Pair B These bits will be "
        "read/write by user if ASRCTR:ATSB=0, and can also be automatically upd"
        "ated by the ASRC internal logic if ASRCTR:ATSB=1 (see ASRC Misc Contro"
        "l Register 1 for Pair CASRC Control Register ).",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POSTMODB",
        "Post-Processing Configuration for Conversion Pair B These bits will be"
        " read/write by user if ASRCTR:ATSB=0, and can also be automatically up"
        "dated by the ASRC internal logic if ASRCTR:ATSB=1 (see ASRC Misc Contr"
        "ol Register 1 for Pair CASRC Control Register ).",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREMODC",
        "Pre-Processing Configuration for Conversion Pair C These bits will be "
        "read/write by user if ASRCTR:ATSC=0, and can also be automatically upd"
        "ated by the ASRC internal logic if ASRCTR:ATSC=1 (see ASRC Misc Contro"
        "l Register 1 for Pair CASRC Control Register ).",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POSTMODC",
        "Post-Processing Configuration for Conversion Pair C These bits will be"
        " read/write by user if ASRCTR:ATSC=0, and can also be automatically up"
        "dated by the ASRC internal logic if ASRCTR:ATSC=1 (see ASRC Misc Contr"
        "ol Register 1 for Pair CASRC Control Register ).",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NDPRA",
        "Not Use Default Parameters for RAM-stored Parameters For Conversion Pa"
        "ir A",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NDPRB",
        "Not Use Default Parameters for RAM-stored Parameters For Conversion Pa"
        "ir B",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NDPRC",
        "Not Use Default Parameters for RAM-stored Parameters For Conversion Pa"
        "ir C",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INIRQA",
        "Initialization for Conversion Pair A is served When this bit is 1, it "
        "means the initialization for conversion pair A is served.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INIRQB",
        "Initialization for Conversion Pair B is served When this bit is 1, it "
        "means the initialization for conversion pair B is served.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INIRQC",
        "Initialization for Conversion Pair C is served When this bit is 1, it "
        "means the initialization for conversion pair C is served.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCSR.
static const field_t hw_asrc_asrcsr[] =
{
    {
        "AICSA",
        "Input Clock Source A",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICSB",
        "Input Clock Source B",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICSC",
        "Input Clock Source C",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCSA",
        "Output Clock Source A",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCSB",
        "Output Clock Source B",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCSC",
        "Output Clock Source C",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCDR1.
static const field_t hw_asrc_asrcdr1[] =
{
    {
        "AICPA",
        "Input Clock Prescaler A Specify the prescaling factor of the input pre"
        "scaler A.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICDA",
        "Input Clock Divider A Specify the divide ratio of the input clock divi"
        "der A.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICPB",
        "Input Clock Prescaler B Specify the prescaling factor of the input pre"
        "scaler B.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICDB",
        "Input Clock Divider B Specify the divide ratio of the input clock divi"
        "der B.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCPA",
        "Output Clock Prescaler A Specify the prescaling factor of the output p"
        "rescaler A.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCDA",
        "Output Clock Divider A Specify the divide ratio of the output clock di"
        "vider A.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCPB",
        "Output Clock Prescaler B Specify the prescaling factor of the output p"
        "rescaler B.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCDB",
        "Output Clock Divider B Specify the divide ratio of the output clock di"
        "vider B.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCDR2.
static const field_t hw_asrc_asrcdr2[] =
{
    {
        "AICPC",
        "Input Clock Prescaler C Specify the prescaling factor of the input pre"
        "scaler C.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AICDC",
        "Input Clock Divider C Specify the divide ratio of the input clock divi"
        "der C.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCPC",
        "Output Clock Prescaler C Specify the prescaling factor of the output p"
        "rescaler C.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AOCDC",
        "Output Clock Divider C Specify the divide ratio of the output clock di"
        "vider C.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRSTR.
static const field_t hw_asrc_asrstr[] =
{
    {
        "AIDEA",
        "Number of data in Input Data Buffer A is less than threshold When set,"
        " this bit indicates that number of data still available in ASRDIRA is "
        "less than threshold and the processor can write data to ASRDIRA.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIDEB",
        "Number of data in Input Data Buffer B is less than threshold When set,"
        " this bit indicates that number of data still available in ASRDIRB is "
        "less than threshold and the processor can write data to ASRDIRB.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIDEC",
        "Number of data in Input Data Buffer C is less than threshold When set,"
        " this bit indicates that number of data still available in ASRDIRC is "
        "less than threshold and the processor can write data to ASRDIRC.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODFA",
        "Number of data in Output Data Buffer A is greater than threshold When "
        "set, this bit indicates that number of data already existing in ASRDOR"
        "A is greater than threshold and the processor can read data from ASRDO"
        "RA.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODFB",
        "Number of data in Output Data Buffer B is greater than threshold When "
        "set, this bit indicates that number of data already existing in ASRDOR"
        "B is greater than threshold and the processor can read data from ASRDO"
        "RB.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODFC",
        "Number of data in Output Data Buffer C is greater than threshold When "
        "set, this bit indicates that number of data already existing in ASRDOR"
        "C is greater than threshold and the processor can read data from ASRDO"
        "RC.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AOLE",
        "Overload Error Flag When set, this bit indicates that the task rate is"
        " too high for the ASRC to handle.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FPWT",
        "FP is in wait states This bit is for debug only.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIDUA",
        "Input Data Buffer A has underflowed When set, this bit indicates that "
        "input data buffer A has underflowed.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIDUB",
        "Input Data Buffer B has underflowed When set, this bit indicates that "
        "input data buffer B has underflowed.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIDUC",
        "Input Data Buffer C has underflowed When set, this bit indicates that "
        "input data buffer C has underflowed.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODOA",
        "Output Data Buffer A has overflowed When set, this bit indicates that "
        "output data buffer A has overflowed.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODOB",
        "Output Data Buffer B has overflowed When set, this bit indicates that "
        "output data buffer B has overflowed.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AODOC",
        "Output Data Buffer C has overflowed When set, this bit indicates that "
        "output data buffer C has overflowed.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIOLA",
        "Pair A Input Task Overload When set, this bit indicates that pair A in"
        "put task is oveloaded.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIOLB",
        "Pair B Input Task Overload When set, this bit indicates that pair B in"
        "put task is oveloaded.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AIOLC",
        "Pair C Input Task Overload When set, this bit indicates that pair C in"
        "put task is oveloaded.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AOOLA",
        "Pair A Output Task Overload When set, this bit indicates that pair A o"
        "utput task is oveloaded.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AOOLB",
        "Pair B Output Task Overload When set, this bit indicates that pair B o"
        "utput task is oveloaded.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AOOLC",
        "Pair C Output Task Overload When set, this bit indicates that pair C o"
        "utput task is oveloaded.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ATQOL",
        "Task Queue FIFO overload When set, this bit indicates that task queue "
        "FIFO logic is oveloaded.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DSLCNT",
        "DSL Counter Input to FIFO ready When set, this bit indicates that new "
        "DSL counter information is stored in the internal ASRC FIFO.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRPMn1.
static const field_t hw_asrc_asrpmn1[] =
{
    {
        "PARAMETER_VALUE",
        "See recommended values table.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRPMn2.
static const field_t hw_asrc_asrpmn2[] =
{
    {
        "PARAMETER_VALUE",
        "See recommended values table.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRPMn3.
static const field_t hw_asrc_asrpmn3[] =
{
    {
        "PARAMETER_VALUE",
        "See recommended values table.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRPMn4.
static const field_t hw_asrc_asrpmn4[] =
{
    {
        "PARAMETER_VALUE",
        "See recommended values table.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRPMn5.
static const field_t hw_asrc_asrpmn5[] =
{
    {
        "PARAMETER_VALUE",
        "See recommended values table.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRTFR1.
static const field_t hw_asrc_asrtfr1[] =
{
    {
        "TF_BASE",
        "Base address for task queue FIFO.",
        6, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF_FILL",
        "Current number of entries in task queue FIFO.",
        13, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRCCR.
static const field_t hw_asrc_asrccr[] =
{
    {
        "ACIA",
        "The channel counter for Pair A's input FIFO These bits stand for the c"
        "urrent channel being accessed through shared peripheral bus for Pair A"
        "'s input FIFO's usage.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACIB",
        "The channel counter for Pair B's input FIFO These bits stand for the c"
        "urrent channel being accessed through shared peripheral bus for Pair B"
        "'s input FIFO's usage.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACIC",
        "The channel counter for Pair C's input FIFO These bits stand for the c"
        "urrent channel being accessed through shared peripheral bus for Pair C"
        "'s input FIFO's usage.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACOA",
        "The channel counter for Pair A's output FIFO These bits stand for the "
        "current channel being accessed through shared peripheral bus for Pair "
        "A's output FIFO's usage.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACOB",
        "The channel counter for Pair B's output FIFO These bits stand for the "
        "current channel being accessed through shared peripheral bus for Pair "
        "B's output FIFO's usage.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACOC",
        "The channel counter for Pair C's output FIFO These bits stand for the "
        "current channel being accessed through shared peripheral bus for Pair "
        "C's output FIFO's usage.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDIA.
static const field_t hw_asrc_asrdia[] =
{
    {
        "DATA",
        "Audio data input",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDOA.
static const field_t hw_asrc_asrdoa[] =
{
    {
        "DATA",
        "Audio data output",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDIB.
static const field_t hw_asrc_asrdib[] =
{
    {
        "DATA",
        "Audio data input",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDOB.
static const field_t hw_asrc_asrdob[] =
{
    {
        "DATA",
        "Audio data output",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDIC.
static const field_t hw_asrc_asrdic[] =
{
    {
        "DATA",
        "Audio data input",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRDOC.
static const field_t hw_asrc_asrdoc[] =
{
    {
        "DATA",
        "Audio data output",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRHA.
static const field_t hw_asrc_asridrha[] =
{
    {
        "IDRATIOA",
        "IDRATIOA[31:24].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRLA.
static const field_t hw_asrc_asridrla[] =
{
    {
        "IDRATIOA",
        "IDRATIOA[23:0].",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRHB.
static const field_t hw_asrc_asridrhb[] =
{
    {
        "IDRATIOB",
        "IDRATIOB[31:24].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRLB.
static const field_t hw_asrc_asridrlb[] =
{
    {
        "IDRATIOB",
        "IDRATIOB[23:0].",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRHC.
static const field_t hw_asrc_asridrhc[] =
{
    {
        "IDRATIOC",
        "IDRATIOC[31:24].",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRIDRLC.
static const field_t hw_asrc_asridrlc[] =
{
    {
        "IDRATIOC",
        "IDRATIOC[23:0].",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASR76K.
static const field_t hw_asrc_asr76k[] =
{
    {
        "ASR76K",
        "Value for the period of the 76kHz sampling clock.",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASR56K.
static const field_t hw_asrc_asr56k[] =
{
    {
        "ASR56K",
        "Value for the period of the 56kHz sampling clock",
        0, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCRA.
static const field_t hw_asrc_asrmcra[] =
{
    {
        "INFIFO_THRESHOLDA",
        "The threshold for Pair A's input FIFO per channel These bits stand for"
        " the threshold for Pair A's input FIFO per channel.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNOFA",
        "Re-sync Output FIFO Channel Counter If bit set, force ASRCCR:ACOA=0.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNIFA",
        "Re-sync Input FIFO Channel Counter If bit set, force ASRCCR:ACIA=0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTFIFO_THRESHOLDA",
        "The threshold for Pair A's output FIFO per channel These bits stand fo"
        "r the threshold for Pair A's output FIFO per channel.",
        12, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASSPOLYA",
        "Bypass Polyphase Filtering for Pair A This bit will determine whether "
        "the polyphase filtering part of Pair A conversion will be bypassed.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUFSTALLA",
        "Stall Pair A conversion in case of Buffer Near Empty/Full Condition Th"
        "is bit will determine whether the near empty/full FIFO condition will "
        "stall the rate conversion for pair A.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTTHRSHA",
        "Use external thresholds for FIFO control of Pair A This bit will deter"
        "mine whether the FIFO thresholds externally defined in this register i"
        "s used to control ASRC internal FIFO logic for pair A.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZEROBUFA",
        "Initialize buf of Pair A when pair A is enabled.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRFSTA.
static const field_t hw_asrc_asrfsta[] =
{
    {
        "INFIFO_FILLA",
        "The fillings for Pair A's input FIFO per channel These bits stand for "
        "the fillings for Pair A's input FIFO per channel.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAEA",
        "Input FIFO is near Empty for Pair A This bit is to indicate whether th"
        "e input FIFO of Pair A is near empty.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OUTFIFO_FILLA",
        "The fillings for Pair A's output FIFO per channel These bits stand for"
        " the fillings for Pair A's output FIFO per channel.",
        12, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OAFA",
        "Output FIFO is near Full for Pair A This bit is to indicate whether th"
        "e output FIFO of Pair A is near full.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCRB.
static const field_t hw_asrc_asrmcrb[] =
{
    {
        "INFIFO_THRESHOLDB",
        "The threshold for Pair B's input FIFO per channel These bits stand for"
        " the threshold for Pair B's input FIFO per channel.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNOFB",
        "Re-sync Output FIFO Channel Counter If bit set, force ASRCCR:ACOB=0.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNIFB",
        "Re-sync Input FIFO Channel Counter If bit set, force ASRCCR:ACIB=0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTFIFO_THRESHOLDB",
        "The threshold for Pair B's output FIFO per channel These bits stand fo"
        "r the threshold for Pair B's output FIFO per channel.",
        12, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASSPOLYB",
        "Bypass Polyphase Filtering for Pair B This bit will determine whether "
        "the polyphase filtering part of Pair B conversion will be bypassed.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUFSTALLB",
        "Stall Pair B conversion in case of Buffer Near Empty/Full Condition Th"
        "is bit will determine whether the near empty/full FIFO condition will "
        "stall the rate conversion for pair B.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTTHRSHB",
        "Use external thresholds for FIFO control of Pair B This bit will deter"
        "mine whether the FIFO thresholds externally defined in this register i"
        "s used to control ASRC internal FIFO logic for pair B.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZEROBUFB",
        "Initialize buf of Pair B when pair B is enabled This bit is used to co"
        "ntrol whether the buffer is to be zeroized when pair B is enabled.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRFSTB.
static const field_t hw_asrc_asrfstb[] =
{
    {
        "INFIFO_FILLB",
        "The fillings for Pair B's input FIFO per channel These bits stand for "
        "the fillings for Pair B's input FIFO per channel.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAEB",
        "Input FIFO is near Empty for Pair B This bit is to indicate whether th"
        "e input FIFO of Pair B is near empty.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OUTFIFO_FILLB",
        "The fillings for Pair B's output FIFO per channel These bits stand for"
        " the fillings for Pair B's output FIFO per channel.",
        12, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OAFB",
        "Output FIFO is near Full for Pair B This bit is to indicate whether th"
        "e output FIFO of Pair B is near full.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCRC.
static const field_t hw_asrc_asrmcrc[] =
{
    {
        "INFIFO_THRESHOLDC",
        "The threshold for Pair C's input FIFO per channel These bits stand for"
        " the threshold for Pair C's input FIFO per channel.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNOFC",
        "Re-sync Output FIFO Channel Counter If bit set, force ASRCCR:ACOC=0.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSYNIFC",
        "Re-sync Input FIFO Channel Counter If bit set, force ASRCCR:ACIC=0.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTFIFO_THRESHOLDC",
        "The threshold for Pair C's output FIFO per channel These bits stand fo"
        "r the threshold for Pair C's output FIFO per channel.",
        12, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASSPOLYC",
        "Bypass Polyphase Filtering for Pair C This bit will determine whether "
        "the polyphase filtering part of Pair C conversion will be bypassed.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUFSTALLC",
        "Stall Pair C conversion in case of Buffer Near Empty/Full Condition Th"
        "is bit will determine whether the near empty/full FIFO condition will "
        "stall the rate conversion for pair C.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXTTHRSHC",
        "Use external thresholds for FIFO control of Pair C This bit will deter"
        "mine whether the FIFO thresholds externally defined in this register i"
        "s used to control ASRC internal FIFO logic for pair C.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZEROBUFC",
        "Initialize buf of Pair C when pair C is enabled This bit is used to co"
        "ntrol whether the buffer is to be zeroized when pair C is enabled.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRFSTC.
static const field_t hw_asrc_asrfstc[] =
{
    {
        "INFIFO_FILLC",
        "The fillings for Pair C's input FIFO per channel These bits stand for "
        "the fillings for Pair C's input FIFO per channel.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAEC",
        "Input FIFO is near Empty for Pair C This bit is to indicate whether th"
        "e input FIFO of Pair C is near empty.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OUTFIFO_FILLC",
        "The fillings for Pair C's output FIFO per channel These bits stand for"
        " the fillings for Pair C's output FIFO per channel.",
        12, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OAFC",
        "Output FIFO is near Full for Pair C This bit is to indicate whether th"
        "e output FIFO of Pair C is near full.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCR1A.
static const field_t hw_asrc_asrmcr1a[] =
{
    {
        "OW16",
        "Bit Width Option of the output FIFO This bit will determine the bit wi"
        "dth option of the output FIFO.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSGN",
        "Sign Extension Option of the output FIFO This bit will determine the s"
        "ign extension option of the output FIFO.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OMSB",
        "Data Alignment of the output FIFO This bit will determine the data ali"
        "gnment of the output FIFO.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IMSB",
        "Data Alignment of the input FIFO This bit will determine the data alig"
        "nment of the input FIFO.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IWD",
        "Data Width of the input FIFO These three bits will determine the bitwi"
        "dth for the audio data into ASRC All other settings not shown are rese"
        "rved.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCR1B.
static const field_t hw_asrc_asrmcr1b[] =
{
    {
        "OW16",
        "Bit Width Option of the output FIFO This bit will determine the bit wi"
        "dth option of the output FIFO.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSGN",
        "Sign Extension Option of the output FIFO This bit will determine the s"
        "ign extension option of the output FIFO.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OMSB",
        "Data Alignment of the output FIFO This bit will determine the data ali"
        "gnment of the output FIFO.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IMSB",
        "Data Alignment of the input FIFO This bit will determine the data alig"
        "nment of the input FIFO.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IWD",
        "Data Width of the input FIFO These three bits will determine the bitwi"
        "dth for the audio data into ASRC All other settings not shown are rese"
        "rved.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ASRC_ASRMCR1C.
static const field_t hw_asrc_asrmcr1c[] =
{
    {
        "OW16",
        "Bit Width Option of the output FIFO This bit will determine the bit wi"
        "dth option of the output FIFO.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSGN",
        "Sign Extension Option of the output FIFO This bit will determine the s"
        "ign extension option of the output FIFO.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OMSB",
        "Data Alignment of the output FIFO This bit will determine the data ali"
        "gnment of the output FIFO.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IMSB",
        "Data Alignment of the input FIFO This bit will determine the data alig"
        "nment of the input FIFO.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IWD",
        "Data Width of the input FIFO These three bits will determine the bitwi"
        "dth for the audio data into ASRC All other settings not shown are rese"
        "rved.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ASRC module.
static const reg_t hw_asrc[] =
{
    {
        "ASRCTR",
        "The ASRC control register (ASRCTR) is a 24-bit read/write register tha"
        "t controls the ASRC operations.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_asrc_asrctr
    },
    {
        "ASRIER",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_asrc_asrier
    },
    {
        "ASRCNCR",
        "The ASRC channel number configuration register (ASRCNCR) is a 24-bit r"
        "ead/write register that sets the number of channels used by each ASRC "
        "conversion pair.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_asrc_asrcncr
    },
    {
        "ASRCFG",
        "The ASRC configuration status register (ASRCFG) is a 24-bit read/write"
        " register that sets and/or automatically senses the ASRC operations.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_asrc_asrcfg
    },
    {
        "ASRCSR",
        "The ASRC clock source register (ASRCSR) is a 24-bit read/write registe"
        "r that controls the sources of the input and output clocks of the ASRC"
        ".",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_asrc_asrcsr
    },
    {
        "ASRCDR1",
        "The ASRC clock divider register (ASRCDR1) is a 24-bit read/write regis"
        "ter that controls the division factors of the ASRC input and output cl"
        "ock sources.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_asrc_asrcdr1
    },
    {
        "ASRCDR2",
        "The ASRC clock divider register (ASRCDR2) is a 24-bit read/write regis"
        "ter that controls the division factors of the ASRC input and output cl"
        "ock sources.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_asrc_asrcdr2
    },
    {
        "ASRSTR",
        "The ASRC status register (ASRSTR) is a 24-bit read-write register used"
        " by the processor core to examine the status of the ASRC block and cle"
        "ar the overload interrupt request and AOLE flag bit.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        22, // Number of bitfields
        hw_asrc_asrstr
    },
    {
        "ASRPMn1",
        "Parameter registers determine the performance of ASRC.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asrpmn1
    },
    {
        "ASRPMn2",
        "Parameter registers determine the performance of ASRC.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asrpmn2
    },
    {
        "ASRPMn3",
        "Parameter registers determine the performance of ASRC.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asrpmn3
    },
    {
        "ASRPMn4",
        "Parameter registers determine the performance of ASRC.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asrpmn4
    },
    {
        "ASRPMn5",
        "Parameter registers determine the performance of ASRC.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asrpmn5
    },
    {
        "ASRTFR1",
        "The register defines and shows the parameters for ASRC inner task queu"
        "e FIFOs.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_asrc_asrtfr1
    },
    {
        "ASRCCR",
        "The ASRC channel counter register (ASRCCR) is a 24-bit read/write regi"
        "ster that sets and reflects the current specific input/output FIFO bei"
        "ng accessed through shared peripheral bus for each ASRC conversion pai"
        "r.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_asrc_asrccr
    },
    {
        "ASRDIA",
        "These registers are the interface registers for the audio data input o"
        "f pair A,B,C respectively.",
        4, // Width in bytes
        0x00000060, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_asrc_asrdia
    },
    {
        "ASRDOA",
        "These registers are the interface registers for the audio data output "
        "of pair A,B,C respectively.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_asrc_asrdoa
    },
    {
        "ASRDIB",
        "These registers are the interface registers for the audio data input o"
        "f pair A,B,C respectively.",
        4, // Width in bytes
        0x00000068, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_asrc_asrdib
    },
    {
        "ASRDOB",
        "These registers are the interface registers for the audio data output "
        "of pair A,B,C respectively.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_asrc_asrdob
    },
    {
        "ASRDIC",
        "These registers are the interface registers for the audio data input o"
        "f pair A,B,C respectively.",
        4, // Width in bytes
        0x00000070, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_asrc_asrdic
    },
    {
        "ASRDOC",
        "These registers are the interface registers for the audio data output "
        "of pair A,B,C respectively.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_asrc_asrdoc
    },
    {
        "ASRIDRHA",
        "The ideal ratio registers (ASRIDRHA, ASRIDRLA) hold the ratio value ID"
        "RATIOA.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asridrha
    },
    {
        "ASRIDRLA",
        "The ideal ratio registers (ASRIDRHA, ASRIDRLA) hold the ratio value ID"
        "RATIOA.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asridrla
    },
    {
        "ASRIDRHB",
        "The ideal ratio registers (ASRIDRHB, ASRIDRLB) hold the ratio value ID"
        "RATIOB.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asridrhb
    },
    {
        "ASRIDRLB",
        "The ideal ratio registers (ASRIDRHB, ASRIDRLB) hold the ratio value ID"
        "RATIOB.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asridrlb
    },
    {
        "ASRIDRHC",
        "The ideal ratio registers (ASRIDRHC, ASRIDRLC) hold the ratio value ID"
        "RATIOC.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asridrhc
    },
    {
        "ASRIDRLC",
        "The ideal ratio registers (ASRIDRHC, ASRIDRLC) hold the ratio value ID"
        "RATIOC.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asridrlc
    },
    {
        "ASR76K",
        "The register (ASR76K) holds the period of the 76kHz sampling clock in "
        "terms of the ASRC processing clock with frequency FsASRC.",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asr76k
    },
    {
        "ASR56K",
        "The register (ASR56K) holds the period of the 56kHz sampling clock in "
        "terms of the ASRC processing clock with frequency FsASRC.",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_asrc_asr56k
    },
    {
        "ASRMCRA",
        "The register (ASRMCRA) is used to control Pair A internal logic.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_asrc_asrmcra
    },
    {
        "ASRFSTA",
        "The register (ASRFSTA) is used to show Pair A internal FIFO conditions"
        ".",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_asrc_asrfsta
    },
    {
        "ASRMCRB",
        "The register (ASRMCRB) is used to control Pair B internal logic.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_asrc_asrmcrb
    },
    {
        "ASRFSTB",
        "The register (ASRFSTB) is used to show Pair B internal FIFO conditions"
        ".",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_asrc_asrfstb
    },
    {
        "ASRMCRC",
        "The register (ASRMCRC) is used to control Pair C internal logic.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_asrc_asrmcrc
    },
    {
        "ASRFSTC",
        "The register (ASRFSTC) is used to show Pair C internal FIFO conditions"
        ".",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_asrc_asrfstc
    },
    {
        "ASRMCR1A",
        "The register (ASRMCR1x) is used to control Pair x internal logic (for "
        "data alignment etc.).",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_asrc_asrmcr1a
    },
    {
        "ASRMCR1B",
        "The register (ASRMCR1x) is used to control Pair x internal logic (for "
        "data alignment etc.).",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_asrc_asrmcr1b
    },
    {
        "ASRMCR1C",
        "The register (ASRMCR1x) is used to control Pair x internal logic (for "
        "data alignment etc.).",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_asrc_asrmcr1c
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark BCH
#endif

// Bitfields in register BCH_CTRL.
static const field_t hw_bch_ctrl[] =
{
    {
        "COMPLETE_IRQ",
        "This bit indicates the state of the external interrupt line.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "This read-only field is reserved and always has the value 0.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_STALL_IRQ",
        "DEBUG STALL Interrupt Status.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "AHB Bus interface Error Interrupt Status.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "This read-only field is reserved and always has the value 0.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETE_IRQ_EN",
        "1 = interrupt on completion of correction is enabled.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "This read-only field is reserved and always has the value 0.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_STALL_IRQ_EN",
        "1 = interrupt on debug stall mode is enabled.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "This read-only field is reserved and always has the value 0",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M2M_ENABLE",
        "NOTE! WRITING THIS BIT INITIATES A MEMORY-TO-MEMORY OPERATION.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2M_ENCODE",
        "Selects encode (parity generation) or decode (correction) mode for mem"
        "ory-to-memory operations.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2M_LAYOUT",
        "Selects the flash page format for memory-to-memory operations.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD4",
        "This read-only field is reserved and always has the value 0",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUGSYNDROME",
        "(For debug purposes only).",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "This read-only field is reserved and always has the value 0.",
        23, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to 0 for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to 0 to enable normal BCH operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_CTRL_SET.
static const field_t hw_bch_ctrl_set[] =
{
    {
        "COMPLETE_IRQ",
        "This bit indicates the state of the external interrupt line.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "This read-only field is reserved and always has the value 0.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_STALL_IRQ",
        "DEBUG STALL Interrupt Status.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "AHB Bus interface Error Interrupt Status.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "This read-only field is reserved and always has the value 0.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETE_IRQ_EN",
        "1 = interrupt on completion of correction is enabled.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "This read-only field is reserved and always has the value 0.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_STALL_IRQ_EN",
        "1 = interrupt on debug stall mode is enabled.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "This read-only field is reserved and always has the value 0",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M2M_ENABLE",
        "NOTE! WRITING THIS BIT INITIATES A MEMORY-TO-MEMORY OPERATION.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2M_ENCODE",
        "Selects encode (parity generation) or decode (correction) mode for mem"
        "ory-to-memory operations.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2M_LAYOUT",
        "Selects the flash page format for memory-to-memory operations.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD4",
        "This read-only field is reserved and always has the value 0",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUGSYNDROME",
        "(For debug purposes only).",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "This read-only field is reserved and always has the value 0.",
        23, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to 0 for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to 0 to enable normal BCH operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_CTRL_CLR.
static const field_t hw_bch_ctrl_clr[] =
{
    {
        "COMPLETE_IRQ",
        "This bit indicates the state of the external interrupt line.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "This read-only field is reserved and always has the value 0.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_STALL_IRQ",
        "DEBUG STALL Interrupt Status.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "AHB Bus interface Error Interrupt Status.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "This read-only field is reserved and always has the value 0.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETE_IRQ_EN",
        "1 = interrupt on completion of correction is enabled.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "This read-only field is reserved and always has the value 0.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_STALL_IRQ_EN",
        "1 = interrupt on debug stall mode is enabled.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "This read-only field is reserved and always has the value 0",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M2M_ENABLE",
        "NOTE! WRITING THIS BIT INITIATES A MEMORY-TO-MEMORY OPERATION.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2M_ENCODE",
        "Selects encode (parity generation) or decode (correction) mode for mem"
        "ory-to-memory operations.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2M_LAYOUT",
        "Selects the flash page format for memory-to-memory operations.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD4",
        "This read-only field is reserved and always has the value 0",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUGSYNDROME",
        "(For debug purposes only).",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "This read-only field is reserved and always has the value 0.",
        23, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to 0 for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to 0 to enable normal BCH operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_CTRL_TOG.
static const field_t hw_bch_ctrl_tog[] =
{
    {
        "COMPLETE_IRQ",
        "This bit indicates the state of the external interrupt line.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "This read-only field is reserved and always has the value 0.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_STALL_IRQ",
        "DEBUG STALL Interrupt Status.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "AHB Bus interface Error Interrupt Status.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "This read-only field is reserved and always has the value 0.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETE_IRQ_EN",
        "1 = interrupt on completion of correction is enabled.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "This read-only field is reserved and always has the value 0.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG_STALL_IRQ_EN",
        "1 = interrupt on debug stall mode is enabled.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "This read-only field is reserved and always has the value 0",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "M2M_ENABLE",
        "NOTE! WRITING THIS BIT INITIATES A MEMORY-TO-MEMORY OPERATION.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2M_ENCODE",
        "Selects encode (parity generation) or decode (correction) mode for mem"
        "ory-to-memory operations.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "M2M_LAYOUT",
        "Selects the flash page format for memory-to-memory operations.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD4",
        "This read-only field is reserved and always has the value 0",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUGSYNDROME",
        "(For debug purposes only).",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "This read-only field is reserved and always has the value 0.",
        23, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to 0 for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to 0 to enable normal BCH operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_STATUS0.
static const field_t hw_bch_status0[] =
{
    {
        "RSVD0",
        "This read-only field is reserved and always has the value 0.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNCORRECTABLE",
        "1 = Uncorrectable error encountered during last processing cycle.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECTED",
        "1 = At least one correctable error encountered during last processing "
        "cycle.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALLONES",
        "1 = All data bits of this transaction are ONE.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "This read-only field is reserved and always has the value 0.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STATUS_BLK0",
        "Count of symbols in error during processing of first block of flash (m"
        "etadata block).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETED_CE",
        "This is the chip enable number corresponding to the NAND device from w"
        "hich this data came.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HANDLE",
        "Software supplies a 12 bit handle for this transfer as part of the GPM"
        "I DMA PIO operation that started the transaction.",
        20, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_STATUS0_SET.
static const field_t hw_bch_status0_set[] =
{
    {
        "RSVD0",
        "This read-only field is reserved and always has the value 0.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNCORRECTABLE",
        "1 = Uncorrectable error encountered during last processing cycle.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECTED",
        "1 = At least one correctable error encountered during last processing "
        "cycle.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALLONES",
        "1 = All data bits of this transaction are ONE.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "This read-only field is reserved and always has the value 0.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STATUS_BLK0",
        "Count of symbols in error during processing of first block of flash (m"
        "etadata block).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETED_CE",
        "This is the chip enable number corresponding to the NAND device from w"
        "hich this data came.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HANDLE",
        "Software supplies a 12 bit handle for this transfer as part of the GPM"
        "I DMA PIO operation that started the transaction.",
        20, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_STATUS0_CLR.
static const field_t hw_bch_status0_clr[] =
{
    {
        "RSVD0",
        "This read-only field is reserved and always has the value 0.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNCORRECTABLE",
        "1 = Uncorrectable error encountered during last processing cycle.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECTED",
        "1 = At least one correctable error encountered during last processing "
        "cycle.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALLONES",
        "1 = All data bits of this transaction are ONE.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "This read-only field is reserved and always has the value 0.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STATUS_BLK0",
        "Count of symbols in error during processing of first block of flash (m"
        "etadata block).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETED_CE",
        "This is the chip enable number corresponding to the NAND device from w"
        "hich this data came.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HANDLE",
        "Software supplies a 12 bit handle for this transfer as part of the GPM"
        "I DMA PIO operation that started the transaction.",
        20, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_STATUS0_TOG.
static const field_t hw_bch_status0_tog[] =
{
    {
        "RSVD0",
        "This read-only field is reserved and always has the value 0.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UNCORRECTABLE",
        "1 = Uncorrectable error encountered during last processing cycle.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CORRECTED",
        "1 = At least one correctable error encountered during last processing "
        "cycle.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALLONES",
        "1 = All data bits of this transaction are ONE.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "This read-only field is reserved and always has the value 0.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STATUS_BLK0",
        "Count of symbols in error during processing of first block of flash (m"
        "etadata block).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COMPLETED_CE",
        "This is the chip enable number corresponding to the NAND device from w"
        "hich this data came.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HANDLE",
        "Software supplies a 12 bit handle for this transfer as part of the GPM"
        "I DMA PIO operation that started the transaction.",
        20, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_MODE.
static const field_t hw_bch_mode[] =
{
    {
        "ERASE_THRESHOLD",
        "This value indicates the maximum number of zero bits on a flash subpag"
        "e for it to be considered erased.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "This read-only field is reserved and always has the value 0.",
        8, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_MODE_SET.
static const field_t hw_bch_mode_set[] =
{
    {
        "ERASE_THRESHOLD",
        "This value indicates the maximum number of zero bits on a flash subpag"
        "e for it to be considered erased.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "This read-only field is reserved and always has the value 0.",
        8, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_MODE_CLR.
static const field_t hw_bch_mode_clr[] =
{
    {
        "ERASE_THRESHOLD",
        "This value indicates the maximum number of zero bits on a flash subpag"
        "e for it to be considered erased.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "This read-only field is reserved and always has the value 0.",
        8, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_MODE_TOG.
static const field_t hw_bch_mode_tog[] =
{
    {
        "ERASE_THRESHOLD",
        "This value indicates the maximum number of zero bits on a flash subpag"
        "e for it to be considered erased.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "This read-only field is reserved and always has the value 0.",
        8, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_ENCODEPTR.
static const field_t hw_bch_encodeptr[] =
{
    {
        "ADDR",
        "Address pointer to encode buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_ENCODEPTR_SET.
static const field_t hw_bch_encodeptr_set[] =
{
    {
        "ADDR",
        "Address pointer to encode buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_ENCODEPTR_CLR.
static const field_t hw_bch_encodeptr_clr[] =
{
    {
        "ADDR",
        "Address pointer to encode buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_ENCODEPTR_TOG.
static const field_t hw_bch_encodeptr_tog[] =
{
    {
        "ADDR",
        "Address pointer to encode buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DATAPTR.
static const field_t hw_bch_dataptr[] =
{
    {
        "ADDR",
        "Address pointer to data buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DATAPTR_SET.
static const field_t hw_bch_dataptr_set[] =
{
    {
        "ADDR",
        "Address pointer to data buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DATAPTR_CLR.
static const field_t hw_bch_dataptr_clr[] =
{
    {
        "ADDR",
        "Address pointer to data buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DATAPTR_TOG.
static const field_t hw_bch_dataptr_tog[] =
{
    {
        "ADDR",
        "Address pointer to data buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_METAPTR.
static const field_t hw_bch_metaptr[] =
{
    {
        "ADDR",
        "Address pointer to metadata buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_METAPTR_SET.
static const field_t hw_bch_metaptr_set[] =
{
    {
        "ADDR",
        "Address pointer to metadata buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_METAPTR_CLR.
static const field_t hw_bch_metaptr_clr[] =
{
    {
        "ADDR",
        "Address pointer to metadata buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_METAPTR_TOG.
static const field_t hw_bch_metaptr_tog[] =
{
    {
        "ADDR",
        "Address pointer to metadata buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_LAYOUTSELECT.
static const field_t hw_bch_layoutselect[] =
{
    {
        "CS0_SELECT",
        "Selects which layout is used for chip select 0.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS1_SELECT",
        "Selects which layout is used for chip select 1.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS2_SELECT",
        "Selects which layout is used for chip select 2.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS3_SELECT",
        "Selects which layout is used for chip select 3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS4_SELECT",
        "Selects which layout is used for chip select 4.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS5_SELECT",
        "Selects which layout is used for chip select 5.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS6_SELECT",
        "Selects which layout is used for chip select 6.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS7_SELECT",
        "Selects which layout is used for chip select 7.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS8_SELECT",
        "Selects which layout is used for chip select 8.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS9_SELECT",
        "Selects which layout is used for chip select 9.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS10_SELECT",
        "Selects which layout is used for chip select 10.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS11_SELECT",
        "Selects which layout is used for chip select 11.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS12_SELECT",
        "Selects which layout is used for chip select 12.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS13_SELECT",
        "Selects which layout is used for chip select 13.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS14_SELECT",
        "Selects which layout is used for chip select 14.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS15_SELECT",
        "Selects which layout is used for chip select 15.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_LAYOUTSELECT_SET.
static const field_t hw_bch_layoutselect_set[] =
{
    {
        "CS0_SELECT",
        "Selects which layout is used for chip select 0.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS1_SELECT",
        "Selects which layout is used for chip select 1.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS2_SELECT",
        "Selects which layout is used for chip select 2.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS3_SELECT",
        "Selects which layout is used for chip select 3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS4_SELECT",
        "Selects which layout is used for chip select 4.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS5_SELECT",
        "Selects which layout is used for chip select 5.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS6_SELECT",
        "Selects which layout is used for chip select 6.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS7_SELECT",
        "Selects which layout is used for chip select 7.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS8_SELECT",
        "Selects which layout is used for chip select 8.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS9_SELECT",
        "Selects which layout is used for chip select 9.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS10_SELECT",
        "Selects which layout is used for chip select 10.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS11_SELECT",
        "Selects which layout is used for chip select 11.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS12_SELECT",
        "Selects which layout is used for chip select 12.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS13_SELECT",
        "Selects which layout is used for chip select 13.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS14_SELECT",
        "Selects which layout is used for chip select 14.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS15_SELECT",
        "Selects which layout is used for chip select 15.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_LAYOUTSELECT_CLR.
static const field_t hw_bch_layoutselect_clr[] =
{
    {
        "CS0_SELECT",
        "Selects which layout is used for chip select 0.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS1_SELECT",
        "Selects which layout is used for chip select 1.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS2_SELECT",
        "Selects which layout is used for chip select 2.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS3_SELECT",
        "Selects which layout is used for chip select 3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS4_SELECT",
        "Selects which layout is used for chip select 4.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS5_SELECT",
        "Selects which layout is used for chip select 5.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS6_SELECT",
        "Selects which layout is used for chip select 6.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS7_SELECT",
        "Selects which layout is used for chip select 7.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS8_SELECT",
        "Selects which layout is used for chip select 8.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS9_SELECT",
        "Selects which layout is used for chip select 9.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS10_SELECT",
        "Selects which layout is used for chip select 10.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS11_SELECT",
        "Selects which layout is used for chip select 11.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS12_SELECT",
        "Selects which layout is used for chip select 12.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS13_SELECT",
        "Selects which layout is used for chip select 13.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS14_SELECT",
        "Selects which layout is used for chip select 14.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS15_SELECT",
        "Selects which layout is used for chip select 15.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_LAYOUTSELECT_TOG.
static const field_t hw_bch_layoutselect_tog[] =
{
    {
        "CS0_SELECT",
        "Selects which layout is used for chip select 0.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS1_SELECT",
        "Selects which layout is used for chip select 1.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS2_SELECT",
        "Selects which layout is used for chip select 2.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS3_SELECT",
        "Selects which layout is used for chip select 3.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS4_SELECT",
        "Selects which layout is used for chip select 4.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS5_SELECT",
        "Selects which layout is used for chip select 5.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS6_SELECT",
        "Selects which layout is used for chip select 6.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS7_SELECT",
        "Selects which layout is used for chip select 7.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS8_SELECT",
        "Selects which layout is used for chip select 8.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS9_SELECT",
        "Selects which layout is used for chip select 9.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS10_SELECT",
        "Selects which layout is used for chip select 10.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS11_SELECT",
        "Selects which layout is used for chip select 11.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS12_SELECT",
        "Selects which layout is used for chip select 12.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS13_SELECT",
        "Selects which layout is used for chip select 13.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS14_SELECT",
        "Selects which layout is used for chip select 14.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS15_SELECT",
        "Selects which layout is used for chip select 15.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH0LAYOUT0.
static const field_t hw_bch_flash0layout0[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH0LAYOUT0_SET.
static const field_t hw_bch_flash0layout0_set[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH0LAYOUT0_CLR.
static const field_t hw_bch_flash0layout0_clr[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH0LAYOUT0_TOG.
static const field_t hw_bch_flash0layout0_tog[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH0LAYOUT1.
static const field_t hw_bch_flash0layout1[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH0LAYOUT1_SET.
static const field_t hw_bch_flash0layout1_set[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH0LAYOUT1_CLR.
static const field_t hw_bch_flash0layout1_clr[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH0LAYOUT1_TOG.
static const field_t hw_bch_flash0layout1_tog[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH1LAYOUT0.
static const field_t hw_bch_flash1layout0[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH1LAYOUT0_SET.
static const field_t hw_bch_flash1layout0_set[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH1LAYOUT0_CLR.
static const field_t hw_bch_flash1layout0_clr[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH1LAYOUT0_TOG.
static const field_t hw_bch_flash1layout0_tog[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH1LAYOUT1.
static const field_t hw_bch_flash1layout1[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH1LAYOUT1_SET.
static const field_t hw_bch_flash1layout1_set[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH1LAYOUT1_CLR.
static const field_t hw_bch_flash1layout1_clr[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH1LAYOUT1_TOG.
static const field_t hw_bch_flash1layout1_tog[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH2LAYOUT0.
static const field_t hw_bch_flash2layout0[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH2LAYOUT0_SET.
static const field_t hw_bch_flash2layout0_set[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH2LAYOUT0_CLR.
static const field_t hw_bch_flash2layout0_clr[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH2LAYOUT0_TOG.
static const field_t hw_bch_flash2layout0_tog[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH2LAYOUT1.
static const field_t hw_bch_flash2layout1[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH2LAYOUT1_SET.
static const field_t hw_bch_flash2layout1_set[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH2LAYOUT1_CLR.
static const field_t hw_bch_flash2layout1_clr[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH2LAYOUT1_TOG.
static const field_t hw_bch_flash2layout1_tog[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH3LAYOUT0.
static const field_t hw_bch_flash3layout0[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH3LAYOUT0_SET.
static const field_t hw_bch_flash3layout0_set[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH3LAYOUT0_CLR.
static const field_t hw_bch_flash3layout0_clr[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH3LAYOUT0_TOG.
static const field_t hw_bch_flash3layout0_tog[] =
{
    {
        "DATA0_SIZE",
        "Indicates the size of the data 0 block (in DWORDS / four bytes) to be "
        "stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC0",
        "Indicates the ECC level for the first block on the flash page.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "META_SIZE",
        "Indicates the size of the metadata (in bytes) to be stored on a flash "
        "page.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NBLOCKS",
        "Number of subsequent blocks on the flash page (excluding the data0 blo"
        "ck).",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH3LAYOUT1.
static const field_t hw_bch_flash3layout1[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH3LAYOUT1_SET.
static const field_t hw_bch_flash3layout1_set[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH3LAYOUT1_CLR.
static const field_t hw_bch_flash3layout1_clr[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_FLASH3LAYOUT1_TOG.
static const field_t hw_bch_flash3layout1_tog[] =
{
    {
        "DATAN_SIZE",
        "Indicates the size of the subsequent data blocks (in DWORDS / four byt"
        "es) to be stored on the flash page.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GF13_0_GF14_1",
        "Select GF13 or GF14: 0-GF13; 1-GF14",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECCN",
        "Indicates the ECC level for the subsequent blocks on the flash page (b"
        "locks 1-n).",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAGE_SIZE",
        "Indicates the total size of the flash page (in bytes).",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DEBUG0.
static const field_t hw_bch_debug0[] =
{
    {
        "DEBUG_REG_SELECT",
        "The value loaded in this bit field is used to select the internal regi"
        "ster state view of KES engine or the Chien search engine.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "This read-only field is reserved and always has the value 0.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BM_KES_TEST_BYPASS",
        "1 = Point all SYND_GEN writes to dummy area at the end of the AUXILLIA"
        "RY block so that diagnostics can preload all payload, parity bytes and"
        " computed syndrome bytes for test the KES engine.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_STALL",
        "Set to one to cause KES FSM to stall after notifying Chien search engi"
        "ne to start processing its block but before notifying the bus master t"
        "hat the KES computation is complete.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_STEP",
        "Toggling this bit causes the KES FSM to skip passed the stall state if"
        " it is in DEBUG_STALL mode and completed processing a block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_STANDALONE",
        "Set to one, cause the KES engine to suppress toggling the KES_BM_DONE "
        "signal to the bus master and suppress toggling the CF_BM_DONE signal b"
        "y the CF engine.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_KICK",
        "Toggling causes KES engine FSM to start as if kick by the Bus Master.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_MODE4K",
        "When running the stand alone debug mode on the error calculator, the s"
        "tate of this bit is presented to the KES engine as the input mode (4K "
        "or 2K pages).",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_PAYLOAD_FLAG",
        "When running the stand alone debug mode on the error calculator, the s"
        "tate of this bit is presented to the KES engine as the input payload f"
        "lag.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_SHIFT_SYND",
        "Toggling this bit causes the value in BCH_DEBUG0_KES_SYNDROME_SYMBOL t"
        "o be shift into the syndrome register array at the input to the KES en"
        "gine.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_SYNDROME_SYMBOL",
        "The 9 bit value in this bit field shifts into the syndrome register ar"
        "ray at the input of the KES engine whenever BCH_DEBUG0_KES_DEBUG_SHIFT"
        "_SYND is toggled.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "This read-only field is reserved and always has the value 0.",
        25, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DEBUG0_SET.
static const field_t hw_bch_debug0_set[] =
{
    {
        "DEBUG_REG_SELECT",
        "The value loaded in this bit field is used to select the internal regi"
        "ster state view of KES engine or the Chien search engine.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "This read-only field is reserved and always has the value 0.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BM_KES_TEST_BYPASS",
        "1 = Point all SYND_GEN writes to dummy area at the end of the AUXILLIA"
        "RY block so that diagnostics can preload all payload, parity bytes and"
        " computed syndrome bytes for test the KES engine.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_STALL",
        "Set to one to cause KES FSM to stall after notifying Chien search engi"
        "ne to start processing its block but before notifying the bus master t"
        "hat the KES computation is complete.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_STEP",
        "Toggling this bit causes the KES FSM to skip passed the stall state if"
        " it is in DEBUG_STALL mode and completed processing a block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_STANDALONE",
        "Set to one, cause the KES engine to suppress toggling the KES_BM_DONE "
        "signal to the bus master and suppress toggling the CF_BM_DONE signal b"
        "y the CF engine.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_KICK",
        "Toggling causes KES engine FSM to start as if kick by the Bus Master.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_MODE4K",
        "When running the stand alone debug mode on the error calculator, the s"
        "tate of this bit is presented to the KES engine as the input mode (4K "
        "or 2K pages).",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_PAYLOAD_FLAG",
        "When running the stand alone debug mode on the error calculator, the s"
        "tate of this bit is presented to the KES engine as the input payload f"
        "lag.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_SHIFT_SYND",
        "Toggling this bit causes the value in BCH_DEBUG0_KES_SYNDROME_SYMBOL t"
        "o be shift into the syndrome register array at the input to the KES en"
        "gine.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_SYNDROME_SYMBOL",
        "The 9 bit value in this bit field shifts into the syndrome register ar"
        "ray at the input of the KES engine whenever BCH_DEBUG0_KES_DEBUG_SHIFT"
        "_SYND is toggled.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "This read-only field is reserved and always has the value 0.",
        25, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DEBUG0_CLR.
static const field_t hw_bch_debug0_clr[] =
{
    {
        "DEBUG_REG_SELECT",
        "The value loaded in this bit field is used to select the internal regi"
        "ster state view of KES engine or the Chien search engine.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "This read-only field is reserved and always has the value 0.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BM_KES_TEST_BYPASS",
        "1 = Point all SYND_GEN writes to dummy area at the end of the AUXILLIA"
        "RY block so that diagnostics can preload all payload, parity bytes and"
        " computed syndrome bytes for test the KES engine.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_STALL",
        "Set to one to cause KES FSM to stall after notifying Chien search engi"
        "ne to start processing its block but before notifying the bus master t"
        "hat the KES computation is complete.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_STEP",
        "Toggling this bit causes the KES FSM to skip passed the stall state if"
        " it is in DEBUG_STALL mode and completed processing a block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_STANDALONE",
        "Set to one, cause the KES engine to suppress toggling the KES_BM_DONE "
        "signal to the bus master and suppress toggling the CF_BM_DONE signal b"
        "y the CF engine.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_KICK",
        "Toggling causes KES engine FSM to start as if kick by the Bus Master.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_MODE4K",
        "When running the stand alone debug mode on the error calculator, the s"
        "tate of this bit is presented to the KES engine as the input mode (4K "
        "or 2K pages).",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_PAYLOAD_FLAG",
        "When running the stand alone debug mode on the error calculator, the s"
        "tate of this bit is presented to the KES engine as the input payload f"
        "lag.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_SHIFT_SYND",
        "Toggling this bit causes the value in BCH_DEBUG0_KES_SYNDROME_SYMBOL t"
        "o be shift into the syndrome register array at the input to the KES en"
        "gine.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_SYNDROME_SYMBOL",
        "The 9 bit value in this bit field shifts into the syndrome register ar"
        "ray at the input of the KES engine whenever BCH_DEBUG0_KES_DEBUG_SHIFT"
        "_SYND is toggled.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "This read-only field is reserved and always has the value 0.",
        25, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DEBUG0_TOG.
static const field_t hw_bch_debug0_tog[] =
{
    {
        "DEBUG_REG_SELECT",
        "The value loaded in this bit field is used to select the internal regi"
        "ster state view of KES engine or the Chien search engine.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "This read-only field is reserved and always has the value 0.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BM_KES_TEST_BYPASS",
        "1 = Point all SYND_GEN writes to dummy area at the end of the AUXILLIA"
        "RY block so that diagnostics can preload all payload, parity bytes and"
        " computed syndrome bytes for test the KES engine.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_STALL",
        "Set to one to cause KES FSM to stall after notifying Chien search engi"
        "ne to start processing its block but before notifying the bus master t"
        "hat the KES computation is complete.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_STEP",
        "Toggling this bit causes the KES FSM to skip passed the stall state if"
        " it is in DEBUG_STALL mode and completed processing a block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_STANDALONE",
        "Set to one, cause the KES engine to suppress toggling the KES_BM_DONE "
        "signal to the bus master and suppress toggling the CF_BM_DONE signal b"
        "y the CF engine.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_KICK",
        "Toggling causes KES engine FSM to start as if kick by the Bus Master.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_MODE4K",
        "When running the stand alone debug mode on the error calculator, the s"
        "tate of this bit is presented to the KES engine as the input mode (4K "
        "or 2K pages).",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_PAYLOAD_FLAG",
        "When running the stand alone debug mode on the error calculator, the s"
        "tate of this bit is presented to the KES engine as the input payload f"
        "lag.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_SHIFT_SYND",
        "Toggling this bit causes the value in BCH_DEBUG0_KES_SYNDROME_SYMBOL t"
        "o be shift into the syndrome register array at the input to the KES en"
        "gine.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KES_DEBUG_SYNDROME_SYMBOL",
        "The 9 bit value in this bit field shifts into the syndrome register ar"
        "ray at the input of the KES engine whenever BCH_DEBUG0_KES_DEBUG_SHIFT"
        "_SYND is toggled.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "This read-only field is reserved and always has the value 0.",
        25, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGKESREAD.
static const field_t hw_bch_dbgkesread[] =
{
    {
        "VALUES",
        "This register returns the ROM BIST CRC value after a BIST test.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGKESREAD_SET.
static const field_t hw_bch_dbgkesread_set[] =
{
    {
        "VALUES",
        "This register returns the ROM BIST CRC value after a BIST test.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGKESREAD_CLR.
static const field_t hw_bch_dbgkesread_clr[] =
{
    {
        "VALUES",
        "This register returns the ROM BIST CRC value after a BIST test.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGKESREAD_TOG.
static const field_t hw_bch_dbgkesread_tog[] =
{
    {
        "VALUES",
        "This register returns the ROM BIST CRC value after a BIST test.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGCSFEREAD.
static const field_t hw_bch_dbgcsferead[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGCSFEREAD_SET.
static const field_t hw_bch_dbgcsferead_set[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGCSFEREAD_CLR.
static const field_t hw_bch_dbgcsferead_clr[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGCSFEREAD_TOG.
static const field_t hw_bch_dbgcsferead_tog[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGSYNDGENREAD.
static const field_t hw_bch_dbgsyndgenread[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGSYNDGENREAD_SET.
static const field_t hw_bch_dbgsyndgenread_set[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGSYNDGENREAD_CLR.
static const field_t hw_bch_dbgsyndgenread_clr[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGSYNDGENREAD_TOG.
static const field_t hw_bch_dbgsyndgenread_tog[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGAHBMREAD.
static const field_t hw_bch_dbgahbmread[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGAHBMREAD_SET.
static const field_t hw_bch_dbgahbmread_set[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGAHBMREAD_CLR.
static const field_t hw_bch_dbgahbmread_clr[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DBGAHBMREAD_TOG.
static const field_t hw_bch_dbgahbmread_tog[] =
{
    {
        "VALUES",
        "Reserved",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_BLOCKNAME.
static const field_t hw_bch_blockname[] =
{
    {
        "NAME",
        "The name is in the ASCII characters BCH (0x20, H, C, B).",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_BLOCKNAME_SET.
static const field_t hw_bch_blockname_set[] =
{
    {
        "NAME",
        "The name is in the ASCII characters BCH (0x20, H, C, B).",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_BLOCKNAME_CLR.
static const field_t hw_bch_blockname_clr[] =
{
    {
        "NAME",
        "The name is in the ASCII characters BCH (0x20, H, C, B).",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_BLOCKNAME_TOG.
static const field_t hw_bch_blockname_tog[] =
{
    {
        "NAME",
        "The name is in the ASCII characters BCH (0x20, H, C, B).",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_VERSION.
static const field_t hw_bch_version[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value indicates the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value indicates the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_VERSION_SET.
static const field_t hw_bch_version_set[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value indicates the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value indicates the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_VERSION_CLR.
static const field_t hw_bch_version_clr[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value indicates the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value indicates the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_VERSION_TOG.
static const field_t hw_bch_version_tog[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value indicates the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value indicates the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DEBUG1.
static const field_t hw_bch_debug1[] =
{
    {
        "ERASED_ZERO_COUNT",
        "The zero counts on one page.",
        0, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD",
        "This read-only field is reserved and always has the value 0.",
        9, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG1_PREERASECHK",
        "Blank page enables pre-erase check.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DEBUG1_SET.
static const field_t hw_bch_debug1_set[] =
{
    {
        "ERASED_ZERO_COUNT",
        "The zero counts on one page.",
        0, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD",
        "This read-only field is reserved and always has the value 0.",
        9, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG1_PREERASECHK",
        "Blank page enables pre-erase check.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DEBUG1_CLR.
static const field_t hw_bch_debug1_clr[] =
{
    {
        "ERASED_ZERO_COUNT",
        "The zero counts on one page.",
        0, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD",
        "This read-only field is reserved and always has the value 0.",
        9, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG1_PREERASECHK",
        "Blank page enables pre-erase check.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register BCH_DEBUG1_TOG.
static const field_t hw_bch_debug1_tog[] =
{
    {
        "ERASED_ZERO_COUNT",
        "The zero counts on one page.",
        0, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD",
        "This read-only field is reserved and always has the value 0.",
        9, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEBUG1_PREERASECHK",
        "Blank page enables pre-erase check.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a BCH module.
static const reg_t hw_bch[] =
{
    {
        "CTRL",
        "The BCH CTRL provides overall control of the hardware ECC accelerator",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_bch_ctrl
    },
    {
        "CTRL_SET",
        "The BCH CTRL provides overall control of the hardware ECC accelerator",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_bch_ctrl_set
    },
    {
        "CTRL_CLR",
        "The BCH CTRL provides overall control of the hardware ECC accelerator",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_bch_ctrl_clr
    },
    {
        "CTRL_TOG",
        "The BCH CTRL provides overall control of the hardware ECC accelerator",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_bch_ctrl_tog
    },
    {
        "STATUS0",
        "The BCH STAT register provides visibility into the run-time status of "
        "the BCH and status information when processing is complete.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_bch_status0
    },
    {
        "STATUS0_SET",
        "The BCH STAT register provides visibility into the run-time status of "
        "the BCH and status information when processing is complete.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_bch_status0_set
    },
    {
        "STATUS0_CLR",
        "The BCH STAT register provides visibility into the run-time status of "
        "the BCH and status information when processing is complete.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_bch_status0_clr
    },
    {
        "STATUS0_TOG",
        "The BCH STAT register provides visibility into the run-time status of "
        "the BCH and status information when processing is complete.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        8, // Number of bitfields
        hw_bch_status0_tog
    },
    {
        "MODE",
        "The BCH MODE register provides additional mode controls.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_bch_mode
    },
    {
        "MODE_SET",
        "The BCH MODE register provides additional mode controls.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_bch_mode_set
    },
    {
        "MODE_CLR",
        "The BCH MODE register provides additional mode controls.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_bch_mode_clr
    },
    {
        "MODE_TOG",
        "The BCH MODE register provides additional mode controls.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_bch_mode_tog
    },
    {
        "ENCODEPTR",
        "When performing memory to memory operations, indicates the address of "
        "the encode buffer.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_encodeptr
    },
    {
        "ENCODEPTR_SET",
        "When performing memory to memory operations, indicates the address of "
        "the encode buffer.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_encodeptr_set
    },
    {
        "ENCODEPTR_CLR",
        "When performing memory to memory operations, indicates the address of "
        "the encode buffer.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_encodeptr_clr
    },
    {
        "ENCODEPTR_TOG",
        "When performing memory to memory operations, indicates the address of "
        "the encode buffer.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_encodeptr_tog
    },
    {
        "DATAPTR",
        "When performing memory to memory operations, indicates the address of "
        "the data buffer.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_dataptr
    },
    {
        "DATAPTR_SET",
        "When performing memory to memory operations, indicates the address of "
        "the data buffer.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_dataptr_set
    },
    {
        "DATAPTR_CLR",
        "When performing memory to memory operations, indicates the address of "
        "the data buffer.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_dataptr_clr
    },
    {
        "DATAPTR_TOG",
        "When performing memory to memory operations, indicates the address of "
        "the data buffer.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_dataptr_tog
    },
    {
        "METAPTR",
        "When performing memory to memory operations, indicates the address of "
        "the metadata buffer.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_metaptr
    },
    {
        "METAPTR_SET",
        "When performing memory to memory operations, indicates the address of "
        "the metadata buffer.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_metaptr_set
    },
    {
        "METAPTR_CLR",
        "When performing memory to memory operations, indicates the address of "
        "the metadata buffer.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_metaptr_clr
    },
    {
        "METAPTR_TOG",
        "When performing memory to memory operations, indicates the address of "
        "the metadata buffer.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_bch_metaptr_tog
    },
    {
        "LAYOUTSELECT",
        "The BCH LAYOUTSELECT register provides a mapping of chip selects to la"
        "yout registers.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_bch_layoutselect
    },
    {
        "LAYOUTSELECT_SET",
        "The BCH LAYOUTSELECT register provides a mapping of chip selects to la"
        "yout registers.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_bch_layoutselect_set
    },
    {
        "LAYOUTSELECT_CLR",
        "The BCH LAYOUTSELECT register provides a mapping of chip selects to la"
        "yout registers.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_bch_layoutselect_clr
    },
    {
        "LAYOUTSELECT_TOG",
        "The BCH LAYOUTSELECT register provides a mapping of chip selects to la"
        "yout registers.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_bch_layoutselect_tog
    },
    {
        "FLASH0LAYOUT0",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash0layout0
    },
    {
        "FLASH0LAYOUT0_SET",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash0layout0_set
    },
    {
        "FLASH0LAYOUT0_CLR",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash0layout0_clr
    },
    {
        "FLASH0LAYOUT0_TOG",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash0layout0_tog
    },
    {
        "FLASH0LAYOUT1",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash0layout1
    },
    {
        "FLASH0LAYOUT1_SET",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash0layout1_set
    },
    {
        "FLASH0LAYOUT1_CLR",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash0layout1_clr
    },
    {
        "FLASH0LAYOUT1_TOG",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash0layout1_tog
    },
    {
        "FLASH1LAYOUT0",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash1layout0
    },
    {
        "FLASH1LAYOUT0_SET",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash1layout0_set
    },
    {
        "FLASH1LAYOUT0_CLR",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash1layout0_clr
    },
    {
        "FLASH1LAYOUT0_TOG",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash1layout0_tog
    },
    {
        "FLASH1LAYOUT1",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash1layout1
    },
    {
        "FLASH1LAYOUT1_SET",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash1layout1_set
    },
    {
        "FLASH1LAYOUT1_CLR",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash1layout1_clr
    },
    {
        "FLASH1LAYOUT1_TOG",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000bc, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash1layout1_tog
    },
    {
        "FLASH2LAYOUT0",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash2layout0
    },
    {
        "FLASH2LAYOUT0_SET",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash2layout0_set
    },
    {
        "FLASH2LAYOUT0_CLR",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash2layout0_clr
    },
    {
        "FLASH2LAYOUT0_TOG",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash2layout0_tog
    },
    {
        "FLASH2LAYOUT1",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash2layout1
    },
    {
        "FLASH2LAYOUT1_SET",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash2layout1_set
    },
    {
        "FLASH2LAYOUT1_CLR",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash2layout1_clr
    },
    {
        "FLASH2LAYOUT1_TOG",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash2layout1_tog
    },
    {
        "FLASH3LAYOUT0",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash3layout0
    },
    {
        "FLASH3LAYOUT0_SET",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash3layout0_set
    },
    {
        "FLASH3LAYOUT0_CLR",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash3layout0_clr
    },
    {
        "FLASH3LAYOUT0_TOG",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_bch_flash3layout0_tog
    },
    {
        "FLASH3LAYOUT1",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash3layout1
    },
    {
        "FLASH3LAYOUT1_SET",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash3layout1_set
    },
    {
        "FLASH3LAYOUT1_CLR",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash3layout1_clr
    },
    {
        "FLASH3LAYOUT1_TOG",
        "The flash format register contains a description of the logical layout"
        " of data on the flash device.",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_bch_flash3layout1_tog
    },
    {
        "DEBUG0",
        "The hardware BCH accelerator internal state machines and signals can b"
        "e seen in the ECC debug register.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_bch_debug0
    },
    {
        "DEBUG0_SET",
        "The hardware BCH accelerator internal state machines and signals can b"
        "e seen in the ECC debug register.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_bch_debug0_set
    },
    {
        "DEBUG0_CLR",
        "The hardware BCH accelerator internal state machines and signals can b"
        "e seen in the ECC debug register.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_bch_debug0_clr
    },
    {
        "DEBUG0_TOG",
        "The hardware BCH accelerator internal state machines and signals can b"
        "e seen in the ECC debug register.",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_bch_debug0_tog
    },
    {
        "DBGKESREAD",
        "The hardware BCH ECC accelerator key equation solver internal state ma"
        "chines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgkesread
    },
    {
        "DBGKESREAD_SET",
        "The hardware BCH ECC accelerator key equation solver internal state ma"
        "chines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgkesread_set
    },
    {
        "DBGKESREAD_CLR",
        "The hardware BCH ECC accelerator key equation solver internal state ma"
        "chines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgkesread_clr
    },
    {
        "DBGKESREAD_TOG",
        "The hardware BCH ECC accelerator key equation solver internal state ma"
        "chines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgkesread_tog
    },
    {
        "DBGCSFEREAD",
        "The hardware BCH ECC accelerator Chien Search internal state machines "
        "and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgcsferead
    },
    {
        "DBGCSFEREAD_SET",
        "The hardware BCH ECC accelerator Chien Search internal state machines "
        "and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgcsferead_set
    },
    {
        "DBGCSFEREAD_CLR",
        "The hardware BCH ECC accelerator Chien Search internal state machines "
        "and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgcsferead_clr
    },
    {
        "DBGCSFEREAD_TOG",
        "The hardware BCH ECC accelerator Chien Search internal state machines "
        "and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgcsferead_tog
    },
    {
        "DBGSYNDGENREAD",
        "The hardware BCH ECC accelerator syndrome generator internal state mac"
        "hines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgsyndgenread
    },
    {
        "DBGSYNDGENREAD_SET",
        "The hardware BCH ECC accelerator syndrome generator internal state mac"
        "hines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgsyndgenread_set
    },
    {
        "DBGSYNDGENREAD_CLR",
        "The hardware BCH ECC accelerator syndrome generator internal state mac"
        "hines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgsyndgenread_clr
    },
    {
        "DBGSYNDGENREAD_TOG",
        "The hardware BCH ECC accelerator syndrome generator internal state mac"
        "hines and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgsyndgenread_tog
    },
    {
        "DBGAHBMREAD",
        "The hardware BCH ECC accelerator bus master, ECC controller internal s"
        "tate machines, and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgahbmread
    },
    {
        "DBGAHBMREAD_SET",
        "The hardware BCH ECC accelerator bus master, ECC controller internal s"
        "tate machines, and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgahbmread_set
    },
    {
        "DBGAHBMREAD_CLR",
        "The hardware BCH ECC accelerator bus master, ECC controller internal s"
        "tate machines, and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgahbmread_clr
    },
    {
        "DBGAHBMREAD_TOG",
        "The hardware BCH ECC accelerator bus master, ECC controller internal s"
        "tate machines, and signals can be seen in the ECC debug registers.",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_dbgahbmread_tog
    },
    {
        "BLOCKNAME",
        "Read only view of the block name string BCH.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_blockname
    },
    {
        "BLOCKNAME_SET",
        "Read only view of the block name string BCH.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_blockname_set
    },
    {
        "BLOCKNAME_CLR",
        "Read only view of the block name string BCH.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_blockname_clr
    },
    {
        "BLOCKNAME_TOG",
        "Read only view of the block name string BCH.",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_bch_blockname_tog
    },
    {
        "VERSION",
        "This register always returns a known read value for debug purposes and"
        " indicates the version of the block and RTL version in use.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_bch_version
    },
    {
        "VERSION_SET",
        "This register always returns a known read value for debug purposes and"
        " indicates the version of the block and RTL version in use.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_bch_version_set
    },
    {
        "VERSION_CLR",
        "This register always returns a known read value for debug purposes and"
        " indicates the version of the block and RTL version in use.",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_bch_version_clr
    },
    {
        "VERSION_TOG",
        "This register always returns a known read value for debug purposes and"
        " indicates the version of the block and RTL version in use.",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_bch_version_tog
    },
    {
        "DEBUG1",
        "The BCH_DEBUG1 register provides erased zero count information and pre"
        "-erase check.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_bch_debug1
    },
    {
        "DEBUG1_SET",
        "The BCH_DEBUG1 register provides erased zero count information and pre"
        "-erase check.",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_bch_debug1_set
    },
    {
        "DEBUG1_CLR",
        "The BCH_DEBUG1 register provides erased zero count information and pre"
        "-erase check.",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_bch_debug1_clr
    },
    {
        "DEBUG1_TOG",
        "The BCH_DEBUG1 register provides erased zero count information and pre"
        "-erase check.",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_bch_debug1_tog
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark CCM
#endif

// Bitfields in register CCM_CCR.
static const field_t hw_ccm_ccr[] =
{
    {
        "OSCNT",
        "Oscillator ready counter value.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COSC_EN",
        "On chip oscillator enable bit - this bit value is reflected on the out"
        "put cosc_en.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG_BYPASS_COUNT",
        "Counter for analog_reg_bypass signal assertion after standby voltage r"
        "equest by PMIC_STBY_REQ.",
        21, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBC_EN",
        "Enable for REG_BYPASS_COUNTER.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCDR.
static const field_t hw_ccm_ccdr[] =
{
    {
        "MMDC_MASK",
        "During divider ratio mmdc_axi_podf change or sync mux periph2_clk_sel "
        "change (but not jtag) or SRC request during warm reset, mask handshake"
        " with mmdc module.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSR.
static const field_t hw_ccm_csr[] =
{
    {
        "REF_EN_B",
        "Status of the value of CCM_REF_EN_B output of ccm",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "COSC_READY",
        "Status indication of on board oscillator.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCSR.
static const field_t hw_ccm_ccsr[] =
{
    {
        "PLL3_SW_CLK_SEL",
        "Selects source to generate pll3_sw_clk.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL1_SW_CLK_SEL",
        "Selects source to generate pll1_sw_clk.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SECONDARY_CLK_SEL",
        "Select source to generate secondary_clk",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STEP_SEL",
        "Selects the option to be chosen for the step frequency when shifting A"
        "RM frequency.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CACRR.
static const field_t hw_ccm_cacrr[] =
{
    {
        "ARM_PODF",
        "Divider for ARM clock root.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CBCDR.
static const field_t hw_ccm_cbcdr[] =
{
    {
        "PERIPH2_CLK2_PODF",
        "Divider for periph2_clk2 podf.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FABRIC_MMDC_PODF",
        "Post divider for fabric / mmdc clock.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_CLK_SEL",
        "AXI clock source select",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_ALT_CLK_SEL",
        "AXI alternative clock select",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPG_PODF",
        "Divider for ipg podf.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHB_PODF",
        "Divider for AHB PODF.",
        10, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_PODF",
        "Post divider for axi clock.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH_CLK_SEL",
        "Selector for peripheral main clock (source of MMDC_CLK_ROOT).",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH2_CLK_SEL",
        "Selector for peripheral2 main clock (source of mmdc_clk_root ).",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH_CLK2_PODF",
        "Divider for periph2 clock podf.",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CBCMR.
static const field_t hw_ccm_cbcmr[] =
{
    {
        "PERIPH_CLK2_SEL",
        "Selector for peripheral clk2 clock multiplexer",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRE_PERIPH_CLK_SEL",
        "Selector for pre_periph clock multiplexer",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH2_CLK2_SEL",
        "Selector for periph2_clk2 clock multiplexer",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRE_PERIPH2_CLK_SEL",
        "Selector for pre_periph2 clock multiplexer",
        21, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_PODF",
        "Post-divider for lcdif1 clock.",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCMR1.
static const field_t hw_ccm_cscmr1[] =
{
    {
        "PERCLK_PODF",
        "Divider for perclk podf.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERCLK_CLK_SEL",
        "Selector for the perclk clock multiplexor",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QSPI1_CLK_SEL",
        "QSPI1 clock select",
        7, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SAI1_CLK_SEL",
        "Selector for sai1 clock multiplexer",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SAI2_CLK_SEL",
        "Selector for sai2 clock multiplexer",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SAI3_CLK_SEL",
        "Selector for sai3 clock multiplexer",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC1_CLK_SEL",
        "Selector for usdhc1 clock multiplexer",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC2_CLK_SEL",
        "Selector for usdhc2 clock multiplexer",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCH_CLK_SEL",
        "Selector for bch clock multiplexer",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPMI_CLK_SEL",
        "Selector for gpmi clock multiplexer",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLK_EIM_SLOW_PODF",
        "Divider for aclk_eim_slow clock root.",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QSPI1_PODF",
        "Divider for QSPI1 clock root",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLK_EIM_SLOW_SEL",
        "Selector for aclk_eim_slow root clock multiplexer",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCMR2.
static const field_t hw_ccm_cscmr2[] =
{
    {
        "CAN_CLK_PODF",
        "Divider for can clock podf.",
        2, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAN_CLK_SEL",
        "Selector for FlexCAN clock multiplexer",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDB_DI0_DIV",
        "Control for divider of ldb clock for di0",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDB_DI1_DIV",
        "Control for divider of ldb clock for di1",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_CLK_SEL",
        "Selector for vid clock multiplexer",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_CLK_PRE_PODF",
        "Post-divider for vid clock root",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_CLK_PODF",
        "Post-divider for vid clock root",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCDR1.
static const field_t hw_ccm_cscdr1[] =
{
    {
        "UART_CLK_PODF",
        "Divider for uart clock podf.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UART_CLK_SEL",
        "Selector for the UART clock multiplexor",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC1_PODF",
        "Divider for usdhc1 clock podf.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USDHC2_PODF",
        "Divider for usdhc2 clock.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCH_PODF",
        "Divider for bch clock podf.",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPMI_PODF",
        "Divider for gpmi clock pred.",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CS1CDR.
static const field_t hw_ccm_cs1cdr[] =
{
    {
        "SAI1_CLK_PODF",
        "Divider for sai1 clock podf.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SAI1_CLK_PRED",
        "Divider for sai1 clock pred.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SAI3_CLK_PODF",
        "Divider for sai3 clock podf.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SAI3_CLK_PRED",
        "Divider for sai3 clock pred.",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CS2CDR.
static const field_t hw_ccm_cs2cdr[] =
{
    {
        "SAI2_CLK_PODF",
        "Divider for sai2 clock podf.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SAI2_CLK_PRED",
        "Divider for sai2 clock pred.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LDB_DI0_CLK_SEL",
        "Selector for ldb_di0 clock multiplexerMultiplexor should be updated wh"
        "en both input and output clocks are gated.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENFC_CLK_SEL",
        "Selector for enfc clock multiplexer Multiplexor should be updated when"
        " output clock is gated.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENFC_CLK_PRED",
        "Divider for enfc clock pred divider.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENFC_CLK_PODF",
        "Divider for enfc clock divider.",
        21, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CDCDR.
static const field_t hw_ccm_cdcdr[] =
{
    {
        "SPDIF0_CLK_SEL",
        "Selector for spdif0 clock multiplexer",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIF0_CLK_PODF",
        "Divider for spdif0 clock podf.",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIF0_CLK_PRED",
        "Divider for spdif0 clock pred.",
        25, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CHSCCDR.
static const field_t hw_ccm_chsccdr[] =
{
    {
        "SIM_CLK_SEL",
        "Selector for SIM root clock multiplexer",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIM_PODF",
        "Divider for SIM clock divider.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIM_PRE_CLK_SEL",
        "Selector for SIM root clock pre-multiplexer",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCDR2.
static const field_t hw_ccm_cscdr2[] =
{
    {
        "LCDIF1_CLK_SEL",
        "Selector for lcdif1 root clock multiplexer",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_PRED",
        "Pre-divider for lcdif1 clock.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_PRE_CLK_SEL",
        "Selector for lcdif1 root clock pre-multiplexer",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECSPI_CLK_SEL",
        "Selector for the ECSPI clock multiplexor",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECSPI_CLK_PODF",
        "Divider for ecspi clock podf.",
        19, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CSCDR3.
static const field_t hw_ccm_cscdr3[] =
{
    {
        "CSI_CLK_SEL",
        "Selector for csi clock multiplexer",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_PODF",
        "Post divider for csi_core clock.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CWDR.
static const field_t hw_ccm_cwdr[] =
{
    { 0 } // Terminator
};

// Bitfields in register CCM_CDHIPR.
static const field_t hw_ccm_cdhipr[] =
{
    {
        "AXI_PODF_BUSY",
        "Busy indicator for axi_podf.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB_PODF_BUSY",
        "Busy indicator for ahb_podf.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MMDC_PODF_BUSY",
        "Busy indicator for mmdc_axi_podf.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PERIPH2_CLK_SEL_BUSY",
        "Busy indicator for periph2_clk_sel mux control.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PERIPH_CLK_SEL_BUSY",
        "Busy indicator for periph_clk_sel mux control.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ARM_PODF_BUSY",
        "Busy indicator for arm_podf.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CLPCR.
static const field_t hw_ccm_clpcr[] =
{
    {
        "LPM",
        "Setting the low power mode that system will enter on next assertion of"
        " dsm_request signal.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARM_CLK_DIS_ON_LPM",
        "Define if ARM clocks (arm_clk, soc_mxclk, soc_pclk, soc_dbg_pclk, vl_w"
        "rck) will be disabled on wait mode.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBYOS",
        "Standby clock oscillator bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIS_REF_OSC",
        "dis_ref_osc - in run mode, software can manually control closing of ex"
        "ternal reference oscillator clock, i.e.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSTBY",
        "Voltage standby request bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STBY_COUNT",
        "Standby counter definition.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COSC_PWRDOWN",
        "In run mode, software can manually control powering down of on chip os"
        "cillator, i.e.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_MMDC_LPM_HS",
        "Bypass handshake with mmdc on next entrance to low power mode (STOP or"
        " WAIT).",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_CORE0_WFI",
        "Mask WFI of core0 for entering low power mode Assertion of all bits[27"
        ":22] will generate low power mode request",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_SCU_IDLE",
        "Mask SCU IDLE for entering low power mode Assertion of all bits[27:22]"
        " will generate low power mode request",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_L2CC_IDLE",
        "Mask L2CC IDLE for entering low power mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CISR.
static const field_t hw_ccm_cisr[] =
{
    {
        "LRF_PLL",
        "CCM interrupt request 2 generated due to lock of all enabled and not b"
        "ypaseed PLLs",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COSC_READY",
        "CCM interrupt request 2 generated due to on board oscillator ready, i."
        "e.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_PODF_LOADED",
        "CCM interrupt request 1 generated due to frequency change of axi_podf",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH2_CLK_SEL_LOADED",
        "CCM interrupt request 1 generated due to frequency change of periph2_c"
        "lk_sel",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHB_PODF_LOADED",
        "CCM interrupt request 1 generated due to frequency change of ahb_podf",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MMDC_PODF_LOADED",
        "CCM interrupt request 1 generated due to frequency change of mmdc_podf"
        "_ loaded",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PERIPH_CLK_SEL_LOADED",
        "CCM interrupt request 1 generated due to update of periph_clk_sel.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARM_PODF_LOADED",
        "CCM interrupt request 1 generated due to frequency change of arm_podf.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CIMR.
static const field_t hw_ccm_cimr[] =
{
    {
        "MASK_LRF_PLL",
        "mask interrupt generation due to lrf of PLLs",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_COSC_READY",
        "mask interrupt generation due to on board oscillator ready",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_AXI_PODF_LOADED",
        "mask interrupt generation due to frequency change of axi_podf",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_PERIPH2_CLK_SEL_LOADED",
        "mask interrupt generation due to update of periph2_clk_sel.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_AHB_PODF_LOADED",
        "mask interrupt generation due to frequency change of ahb_podf",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_MMDC_PODF_LOADED",
        "mask interrupt generation due to update of mask_mmdc_podf",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_PERIPH_CLK_SEL_LOADED",
        "mask interrupt generation due to update of periph_clk_sel.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARM_PODF_LOADED",
        "mask interrupt generation due to frequency change of arm_podf",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCOSR.
static const field_t hw_ccm_ccosr[] =
{
    {
        "CLKO_SEL",
        "Selection of the clock to be generated on CCM_CLKO1",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO1_DIV",
        "Setting the divider of CCM_CLKO1",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO1_EN",
        "Enable of CCM_CLKO1 clock",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_OUT_SEL",
        "CCM_CLKO1 output to reflect CCM_CLKO1 or CCM_CLKO2 clocks",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO2_SEL",
        "Selection of the clock to be generated on CCM_CLKO2",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO2_DIV",
        "Setting the divider of CCM_CLKO2",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKO2_EN",
        "Enable of CCM_CLKO2 clock",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CGPR.
static const field_t hw_ccm_cgpr[] =
{
    {
        "PMIC_DELAY_SCALER",
        "Defines clock dividion of clock for stby_count (pmic delay counter)",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MMDC_EXT_CLK_DIS",
        "Disable external clock driver of MMDC during STOP mode",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EFUSE_PROG_SUPPLY_GATE",
        "Defines the value of the output signal cgpr_dout[4].",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYS_MEM_DS_CTRL",
        "System memory DS control",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPL",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_MEM_CLK_LPM",
        "Control for the Deep Sleep signal to the ARM Platform memories with ad"
        "ditional control logic based on the ARM WFI signal.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR0.
static const field_t hw_ccm_ccgr0[] =
{
    {
        "CG0",
        "aips_tz1 clocks (aips_tz1_clk_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "aips_tz2 clocks (aips_tz2_clk_enable)",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "apbhdma hclk clock (apbhdma_hclk_enable)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "asrc clock (asrc_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "caam_secure_mem clock (caam_secure_mem_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "caam_wrapper_aclk clock (caam_wrapper_aclk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "caam_wrapper_ipg clock (caam_wrapper_ipg_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "can1 clock (can1_clk_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "can1_serial clock (can1_serial_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "can2 clock (can2_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "can2_serial clock (can2_serial_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "CPU debug clocks (arm_dbg_clk_enable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "dcic1 clocks (dcic1_clk_enable) gpt2 bus clocks (gpt2_bus_clk_enable)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "gpt2 serial clocks (gpt2_serial_clk_enable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "uart2 clock (uart2_clk_enable)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "gpio2_clocks (gpio2_clk_enable)",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR1.
static const field_t hw_ccm_ccgr1[] =
{
    {
        "CG0",
        "ecspi1 clocks (ecspi1_clk_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "ecspi2 clocks (ecspi2_clk_enable)",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "ecspi3 clocks (ecspi3_clk_enable)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "ecspi4 clocks (ecspi4_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "adc2 clock (adc2_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "uart3 clock (uart3_clk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "epit1 clocks (epit1_clk_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "epit2 clocks (epit2_clk_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "adc1 clock (adc1_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "sim_s clock (sim_s_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "gpt bus clock (gpt_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "gpt serial clock (gpt_serial_clk_enable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "uart4 clock (uart4_clk_enable)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "gpio1 clock (gpio1_clk_enable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "csu clock (csu_clk_enable)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "gpio5 clock (gpio5_clk_enable)",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR2.
static const field_t hw_ccm_ccgr2[] =
{
    {
        "CG0",
        "Reserved",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "csi clock (csi_clk_enable)",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "Reserved",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "i2c1_serial clock (i2c1_serial_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "i2c2_serial clock (i2c2_serial_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "i2c3_serial clock (i2c3_serial_clk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "OCOTP_CTRL clock (iim_clk_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "iomux_ipt_clk_io clock (iomux_ipt_clk_io_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "ipmux1 clock (ipmux1_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "ipmux2 clock (ipmux2_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "ipmux3 clock (ipmux3_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "ipsync_ip2apb_tzasc1_ipg clocks (ipsync_ip2apb_tzasc1_ipg_master_clk_e"
        "nable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "Reserved",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "gpio3 clock (gpio3_clk_enable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "lcd clocks (lcd_clk_enable)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "pxp clocks (pxp_clk_enable)",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR3.
static const field_t hw_ccm_ccgr3[] =
{
    {
        "CG0",
        "Reserved",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "uart5 clock (uart5_clk_enable)",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "enet clock (enet_clk_enable)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "uart6 clock (uart6_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "CA7 CCM DAP clock (ccm_dap_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "lcdif1 pix clock (lcdif1_pix_clk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "gpio4 clock (gpio4_clk_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "qspi1 clock (qspi1_clk_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "wdog1 clock (wdog1_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "a7 clkdiv patch clock (a7_clkdiv_patch_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "mmdc_core_aclk_fast_core_p0 clock (mmdc_core_aclk_fast_core_p0_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "Reserved",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "mmdc_core_ipg_clk_p0 clock (mmdc_core_ipg_clk_p0_enable)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "mmdc_core_ipg_clk_p1 clock (mmdc_core_ipg_clk_p1_enable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "axi clock (axi_clk_enable)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "Reserved",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR4.
static const field_t hw_ccm_ccgr4[] =
{
    {
        "CG0",
        "pcie clock (pcie_root_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "iomuxc clock (iomuxc_clk_enable)",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "iomuxc gpr clock (iomuxc_gpr_clk_enable)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "sim_cpu clock (sim_cpu_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "cxapbsyncbridge slave clock (cxapbsyncbridge_slave_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "tsc_dig clock (tsc_clk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "pl301_mx6qper1_bch clocks (pl301_mx6qper1_bchclk_enable) This gates bc"
        "h_clk_root to sim_m fabric.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "pl301_mx6qper2_mainclk_enable (pl301_mx6qper2_mainclk_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "pwm1 clocks (pwm1_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "pwm2 clocks (pwm2_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "pwm3 clocks (pwm3_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "pwm4 clocks (pwm4_clk_enable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "rawnand_u_bch_input_apb clock (rawnand_u_bch_input_apb_clk_enable)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "rawnand_u_gpmi_bch_input_bch clock (rawnand_u_gpmi_bch_input_bch_clk_e"
        "nable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "rawnand_u_gpmi_bch_input_gpmi_io clock (rawnand_u_gpmi_bch_input_gpmi_"
        "io_clk_enable)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "rawnand_u_gpmi_input_apb clock (rawnand_u_gpmi_input_apb_clk_enable)",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR5.
static const field_t hw_ccm_ccgr5[] =
{
    {
        "CG0",
        "rom clock (rom_clk_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "stcr clock (stcr_clk_enable)",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "snvs dryice clock (snvs_dryice_clk_enable)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "sdma clock (sdma_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "kpp clock (kpp_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "wdog2 clock (wdog2_clk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "spba clock (spba_clk_enable)",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "spdif / audio clock (spdif_clk_enable, audio_clk_root)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "sim_main clock (sim_main_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "snvs_hp clock (snvs_hp_clk_enable)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "snvs_lp clock (snvs_lp_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "sai3 clock (sai3_clk_enable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "uart1 clock (uart1_clk_enable)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "uart7 clock (uart7_clk_enable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "sai1 clock (sai1_clk_enable)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "sai2 clock (sai2_clk_enable)",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CCGR6.
static const field_t hw_ccm_ccgr6[] =
{
    {
        "CG0",
        "usboh3 clock (usboh3_clk_enable)",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG1",
        "usdhc1 clocks (usdhc1_clk_enable)",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG2",
        "usdhc2 clocks (usdhc2_clk_enable)",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG3",
        "sim1_clock (sim1_clk_enable)",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG4",
        "sim2_clock (sim2_clk_enable)",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG5",
        "eim_slow clocks (eim_slow_clk_enable)",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG6",
        "Reserved",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG7",
        "uart8 clocks (uart8_clk_enable)",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG8",
        "pwm8 clocks (pwm8_clk_enable)",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG9",
        "Reserved",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG10",
        "wdog3 clock (wdog3_clk_enable)",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG11",
        "anadig clocks (anadig_clk_enable)",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG12",
        "i2c4 serial clock (i2c4_serial_clk_enable)",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG13",
        "pwm5 clocks (pwm5_clk_enable)",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG14",
        "pwm6 clocks (pwm6_clk_enable)",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CG15",
        "pwm7 clocks (pwm7_clk_enable)",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_CMEOR.
static const field_t hw_ccm_cmeor[] =
{
    {
        "MOD_EN_OV_GPT",
        "Overide clock enable signal from GPT - clock will not be gated based o"
        "n GPT's signal 'ipg_enable_clk' .",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_EPIT",
        "Overide clock enable signal from EPIT - clock will not be gated based "
        "on EPIT's signal 'ipg_enable_clk' .",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_USDHC",
        "overide clock enable signal from USDHC.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_CAN2_CPI",
        "Overide clock enable signal from CAN2 - clock will not be gated based "
        "on CAN's signal 'enable_clk_cpi'.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MOD_EN_OV_CAN1_CPI",
        "Overide clock enable signal from CAN1 - clock will not be gated based "
        "on CAN's signal 'enable_clk_cpi'.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a CCM module.
static const reg_t hw_ccm[] =
{
    {
        "CCR",
        "The figure below represents the CCM Control Register (CCR), which cont"
        "ains bits to control general operation of CCM.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ccm_ccr
    },
    {
        "CCDR",
        "The figure below represents the CCM Control Divider Register (CCDR), w"
        "hich contains bits that control the loading of the dividers that need "
        "handshake with the modules they affect.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_ccdr
    },
    {
        "CSR",
        "The figure below represents the CCM status Register (CSR).",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_ccm_csr
    },
    {
        "CCSR",
        "The figure below represents the CCM Clock Switcher register (CCSR).",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ccm_ccsr
    },
    {
        "CACRR",
        "The figure below represents the CCM Arm Clock Root register (CACRR).",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_cacrr
    },
    {
        "CBCDR",
        "The figure below represents the CCM Bus Clock Divider Register (CBCDR)"
        ".",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ccm_cbcdr
    },
    {
        "CBCMR",
        "The figure below represents the CCM Bus Clock Multiplexer Register (CB"
        "CMR).",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ccm_cbcmr
    },
    {
        "CSCMR1",
        "The figure below represents the CCM Serial Clock Multiplexer Register "
        "1 (CSCMR1).",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_ccm_cscmr1
    },
    {
        "CSCMR2",
        "The figure below represents the CCM Serial Clock Multiplexer Register "
        "2 (CSCMR2).",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_cscmr2
    },
    {
        "CSCDR1",
        "The figure below represents the CCM Serial Clock Divider Register 1 (C"
        "SCDR1).",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ccm_cscdr1
    },
    {
        "CS1CDR",
        "The figure below represents the CCM SAI1, and SAI3 Clock Divider Regis"
        "ter (CS1CDR).",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_ccm_cs1cdr
    },
    {
        "CS2CDR",
        "The figure below represents the CCM SAI2, LDB Clock Divider Register ("
        "CS2CDR).",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ccm_cs2cdr
    },
    {
        "CDCDR",
        "The figure below represents the CCM DI Clock Divider Register (CDCDR).",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ccm_cdcdr
    },
    {
        "CHSCCDR",
        "The figure below represents the CCM HSC Clock Divider Register (CHSCCD"
        "R).",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ccm_chsccdr
    },
    {
        "CSCDR2",
        "The figure below represents the CCM Serial Clock Divider Register 2(CS"
        "CDR2).",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ccm_cscdr2
    },
    {
        "CSCDR3",
        "The figure below represents the CCM Serial Clock Divider Register 3(CS"
        "CDR3).",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ccm_cscdr3
    },
    {
        "CWDR",
        "The figure below represents the CCM Wakeup Detector Register (CWDR).",
        4, // Width in bytes
        0x00000044, // Base address offset
        false, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_ccm_cwdr
    },
    {
        "CDHIPR",
        "The figure below represents the CCM Divider Handshake In-Process Regis"
        "ter (CDHIPR).",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_ccm_cdhipr
    },
    {
        "CLPCR",
        "The figure below represents the CCM Low Power Control Register (CLPCR)"
        ".",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ccm_clpcr
    },
    {
        "CISR",
        "The figure below represents the CCM Interrupt Status Register (CISR).",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_cisr
    },
    {
        "CIMR",
        "The figure below represents the CCM Interrupt Mask Register (CIMR).",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_cimr
    },
    {
        "CCOSR",
        "The figure below represents the CCM Clock Output Source Register (CCOS"
        "R).",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_ccosr
    },
    {
        "CGPR",
        "Fast PLL enable.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ccm_cgpr
    },
    {
        "CCGR0",
        "CG(i) bits CCGR 0-6 These bits are used to turn on/off the clock to ea"
        "ch module independently.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr0
    },
    {
        "CCGR1",
        "The figure below represents the CCM Clock Gating Register 1(CCM_CCGR1)"
        ".",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr1
    },
    {
        "CCGR2",
        "The figure below represents the CCM Clock Gating Register 2 (CCM_CCGR2"
        ").",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr2
    },
    {
        "CCGR3",
        "The figure below represents the CCM Clock Gating Register 3 (CCM_CCGR3"
        ").",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr3
    },
    {
        "CCGR4",
        "The figure below represents the CCM Clock Gating Register 4 (CCM_CCGR4"
        ").",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr4
    },
    {
        "CCGR5",
        "The figure below represents the CCM Clock Gating Register 5 (CCM_CCGR5"
        ").",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr5
    },
    {
        "CCGR6",
        "The figure below represents the CCM Clock Gating Register 6 (CCM_CCGR6"
        ").",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_ccm_ccgr6
    },
    {
        "CMEOR",
        "The follow figure represents the CCM Module Enable Override Register ("
        "CMEOR).",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ccm_cmeor
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark CCM_ANALOG
#endif

// Bitfields in register CCM_ANALOG_ANALOG_PLL_ARM.
static const field_t hw_ccm_analog_analog_pll_arm[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_SEL",
        "Reserved",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_ARM_SET.
static const field_t hw_ccm_analog_analog_pll_arm_set[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_SEL",
        "Reserved",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_ARM_CLR.
static const field_t hw_ccm_analog_analog_pll_arm_clr[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_SEL",
        "Reserved",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_ARM_TOG.
static const field_t hw_ccm_analog_analog_pll_arm_tog[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL_SEL",
        "Reserved",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_USB1.
static const field_t hw_ccm_analog_analog_pll_usb1[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "Powers the 9-phase PLL outputs for USBPHYn.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_USB1_SET.
static const field_t hw_ccm_analog_analog_pll_usb1_set[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "Powers the 9-phase PLL outputs for USBPHYn.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_USB1_CLR.
static const field_t hw_ccm_analog_analog_pll_usb1_clr[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "Powers the 9-phase PLL outputs for USBPHYn.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_USB1_TOG.
static const field_t hw_ccm_analog_analog_pll_usb1_tog[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "Powers the 9-phase PLL outputs for USBPHYn.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_USB2.
static const field_t hw_ccm_analog_analog_pll_usb2[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "0: 8-phase PLL outputs for USBPHY1 are powered down.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_USB2_SET.
static const field_t hw_ccm_analog_analog_pll_usb2_set[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "0: 8-phase PLL outputs for USBPHY1 are powered down.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_USB2_CLR.
static const field_t hw_ccm_analog_analog_pll_usb2_clr[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "0: 8-phase PLL outputs for USBPHY1 are powered down.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_USB2_TOG.
static const field_t hw_ccm_analog_analog_pll_usb2_tog[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_USB_CLKS",
        "0: 8-phase PLL outputs for USBPHY1 are powered down.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWER",
        "Powers up the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable the PLL clock output.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_SYS.
static const field_t hw_ccm_analog_analog_pll_sys[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_SYS_SET.
static const field_t hw_ccm_analog_analog_pll_sys_set[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_SYS_CLR.
static const field_t hw_ccm_analog_analog_pll_sys_clr[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_SYS_TOG.
static const field_t hw_ccm_analog_analog_pll_sys_tog[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_SYS_SS.
static const field_t hw_ccm_analog_analog_pll_sys_ss[] =
{
    {
        "STEP",
        "Frequency change step = step/CCM_ANALOG_PLL_SYS_DENOM[B]*24MHz.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP",
        "Frequency change = stop/CCM_ANALOG_PLL_SYS_DENOM[B]*24MHz.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_SYS_NUM.
static const field_t hw_ccm_analog_analog_pll_sys_num[] =
{
    {
        "A",
        "30 bit numerator (A) of fractional loop divider (signed integer).",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_SYS_DENOM.
static const field_t hw_ccm_analog_analog_pll_sys_denom[] =
{
    {
        "B",
        "30 bit Denominator (B) of fractional loop divider (unsigned integer).",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_AUDIO.
static const field_t hw_ccm_analog_analog_pll_audio[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_AUDIO_SET.
static const field_t hw_ccm_analog_analog_pll_audio_set[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_AUDIO_CLR.
static const field_t hw_ccm_analog_analog_pll_audio_clr[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_AUDIO_TOG.
static const field_t hw_ccm_analog_analog_pll_audio_tog[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enable PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_AUDIO_NUM.
static const field_t hw_ccm_analog_analog_pll_audio_num[] =
{
    {
        "A",
        "30 bit numerator of fractional loop divider.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_AUDIO_DENOM.
static const field_t hw_ccm_analog_analog_pll_audio_denom[] =
{
    {
        "B",
        "30 bit Denominator of fractional loop divider.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_VIDEO.
static const field_t hw_ccm_analog_analog_pll_video[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enalbe PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_VIDEO_SET.
static const field_t hw_ccm_analog_analog_pll_video_set[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enalbe PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_VIDEO_CLR.
static const field_t hw_ccm_analog_analog_pll_video_clr[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enalbe PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_VIDEO_TOG.
static const field_t hw_ccm_analog_analog_pll_video_tog[] =
{
    {
        "DIV_SELECT",
        "This field controls the PLL loop divider.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enalbe PLL output",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIV_SELECT",
        "These bits implement a divider after the PLL, but before the enable an"
        "d bypass mux.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_VIDEO_NUM.
static const field_t hw_ccm_analog_analog_pll_video_num[] =
{
    {
        "A",
        "30 bit numerator of fractional loop divider(Signed number), absolute v"
        "alue should be less than denominator",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_VIDEO_DENOM.
static const field_t hw_ccm_analog_analog_pll_video_denom[] =
{
    {
        "B",
        "30 bit Denominator of fractional loop divider.",
        0, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_ENET.
static const field_t hw_ccm_analog_analog_pll_enet[] =
{
    {
        "ENET0_DIV_SELECT",
        "Controls the frequency of the ethernet0 reference clock.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_DIV_SELECT",
        "Controls the frequency of the ethernet1 reference clock.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_125M_EN",
        "Enable the PLL providing the ENET1 125 MHz reference clock.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_125M",
        "Enables an offset in the phase frequency detector.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET2_125M_EN",
        "Enable the PLL providing the ENET2 125 MHz reference clock",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET_25M_REF_EN",
        "Enable the PLL providing ENET 25 MHz reference clock",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_ENET_SET.
static const field_t hw_ccm_analog_analog_pll_enet_set[] =
{
    {
        "ENET0_DIV_SELECT",
        "Controls the frequency of the ethernet0 reference clock.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_DIV_SELECT",
        "Controls the frequency of the ethernet1 reference clock.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_125M_EN",
        "Enable the PLL providing the ENET1 125 MHz reference clock.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_125M",
        "Enables an offset in the phase frequency detector.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET2_125M_EN",
        "Enable the PLL providing the ENET2 125 MHz reference clock",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET_25M_REF_EN",
        "Enable the PLL providing ENET 25 MHz reference clock",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_ENET_CLR.
static const field_t hw_ccm_analog_analog_pll_enet_clr[] =
{
    {
        "ENET0_DIV_SELECT",
        "Controls the frequency of the ethernet0 reference clock.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_DIV_SELECT",
        "Controls the frequency of the ethernet1 reference clock.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_125M_EN",
        "Enable the PLL providing the ENET1 125 MHz reference clock.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_125M",
        "Enables an offset in the phase frequency detector.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET2_125M_EN",
        "Enable the PLL providing the ENET2 125 MHz reference clock",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET_25M_REF_EN",
        "Enable the PLL providing ENET 25 MHz reference clock",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PLL_ENET_TOG.
static const field_t hw_ccm_analog_analog_pll_enet_tog[] =
{
    {
        "ENET0_DIV_SELECT",
        "Controls the frequency of the ethernet0 reference clock.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_DIV_SELECT",
        "Controls the frequency of the ethernet1 reference clock.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POWERDOWN",
        "Powers down the PLL.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_125M_EN",
        "Enable the PLL providing the ENET1 125 MHz reference clock.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_CLK_SRC",
        "Determines the bypass source.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypass the PLL.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_OFFSET_EN",
        "Enables an offset in the phase frequency detector.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_125M",
        "Enables an offset in the phase frequency detector.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET2_125M_EN",
        "Enable the PLL providing the ENET2 125 MHz reference clock",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET_25M_REF_EN",
        "Enable the PLL providing ENET 25 MHz reference clock",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "1 - PLL is currently locked; 0 - PLL is not currently locked.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PFD_480.
static const field_t hw_ccm_analog_analog_pfd_480[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PFD_480_SET.
static const field_t hw_ccm_analog_analog_pfd_480_set[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PFD_480_CLR.
static const field_t hw_ccm_analog_analog_pfd_480_clr[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PFD_480_TOG.
static const field_t hw_ccm_analog_analog_pfd_480_tog[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PFD_528.
static const field_t hw_ccm_analog_analog_pfd_528[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PFD_528_SET.
static const field_t hw_ccm_analog_analog_pfd_528_set[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PFD_528_CLR.
static const field_t hw_ccm_analog_analog_pfd_528_clr[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_PFD_528_TOG.
static const field_t hw_ccm_analog_analog_pfd_528_tog[] =
{
    {
        "PFD0_FRAC",
        "This field controls the fractional divide value.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD0_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD0_CLKGATE",
        "If set to 1, the IO fractional divider clock (reference ref_pfd0) is o"
        "ff (power savings).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_FRAC",
        "This field controls the fractional divide value.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD1_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD1_CLKGATE",
        "IO Clock Gate.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_FRAC",
        "This field controls the fractional divide value.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD2_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD2_CLKGATE",
        "IO Clock Gate.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_FRAC",
        "This field controls the fractional divide value.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD3_STABLE",
        "This read-only bitfield is for DIAGNOSTIC PURPOSES ONLY since the frac"
        "tional divider should become stable quickly enough that this field wil"
        "l never need to be used by either device driver or application code.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFD3_CLKGATE",
        "IO Clock Gate.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC0.
static const field_t hw_ccm_analog_analog_misc0[] =
{
    {
        "REFTOP_PWD",
        "Control bit to power-down the analog bandgap reference circuitry.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_SELFBIASOFF",
        "Control bit to disable the self-bias circuit in the analog bandgap.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGADJ",
        "Not related to CCM.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGUP",
        "Status bit that signals the analog bandgap voltage is up and stable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_MODE_CONFIG",
        "Configure the analog behavior in stop mode.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCON_HIGH_SNVS",
        "This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_I",
        "This field determines the bias current in the 24MHz oscillator.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_XTALOK",
        "Status bit that signals that the output of the 24-MHz crystal oscillat"
        "or is stable.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSC_XTALOK_EN",
        "This bit enables the detector that signals when the 24MHz crystal osci"
        "llator is stable.Not related to CCM.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_CTRL",
        "This bit allows disabling the clock gate (always ungated) for the xtal"
        " 24MHz clock that clocks the digital logic in the analog block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_DELAY",
        "This field specifies the delay between powering up the XTAL 24MHz cloc"
        "k and releasing the clock to the digital logic inside the analog block"
        ".",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_XTAL_SOURCE",
        "This field indicates which chip source is being used for the rtc clock"
        ".Not related to CCM.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTAL_24M_PWD",
        "This field powers down the 24M crystal oscillator if set true.Not rela"
        "ted to CCM.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_PLL_PREDIV",
        "Predivider for the source clock of the PLL's.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC0_SET.
static const field_t hw_ccm_analog_analog_misc0_set[] =
{
    {
        "REFTOP_PWD",
        "Control bit to power-down the analog bandgap reference circuitry.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_SELFBIASOFF",
        "Control bit to disable the self-bias circuit in the analog bandgap.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGADJ",
        "Not related to CCM.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGUP",
        "Status bit that signals the analog bandgap voltage is up and stable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_MODE_CONFIG",
        "Configure the analog behavior in stop mode.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCON_HIGH_SNVS",
        "This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_I",
        "This field determines the bias current in the 24MHz oscillator.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_XTALOK",
        "Status bit that signals that the output of the 24-MHz crystal oscillat"
        "or is stable.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSC_XTALOK_EN",
        "This bit enables the detector that signals when the 24MHz crystal osci"
        "llator is stable.Not related to CCM.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_CTRL",
        "This bit allows disabling the clock gate (always ungated) for the xtal"
        " 24MHz clock that clocks the digital logic in the analog block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_DELAY",
        "This field specifies the delay between powering up the XTAL 24MHz cloc"
        "k and releasing the clock to the digital logic inside the analog block"
        ".",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_XTAL_SOURCE",
        "This field indicates which chip source is being used for the rtc clock"
        ".Not related to CCM.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTAL_24M_PWD",
        "This field powers down the 24M crystal oscillator if set true.Not rela"
        "ted to CCM.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_PLL_PREDIV",
        "Predivider for the source clock of the PLL's.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC0_CLR.
static const field_t hw_ccm_analog_analog_misc0_clr[] =
{
    {
        "REFTOP_PWD",
        "Control bit to power-down the analog bandgap reference circuitry.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_SELFBIASOFF",
        "Control bit to disable the self-bias circuit in the analog bandgap.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGADJ",
        "Not related to CCM.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGUP",
        "Status bit that signals the analog bandgap voltage is up and stable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_MODE_CONFIG",
        "Configure the analog behavior in stop mode.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCON_HIGH_SNVS",
        "This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_I",
        "This field determines the bias current in the 24MHz oscillator.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_XTALOK",
        "Status bit that signals that the output of the 24-MHz crystal oscillat"
        "or is stable.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSC_XTALOK_EN",
        "This bit enables the detector that signals when the 24MHz crystal osci"
        "llator is stable.Not related to CCM.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_CTRL",
        "This bit allows disabling the clock gate (always ungated) for the xtal"
        " 24MHz clock that clocks the digital logic in the analog block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_DELAY",
        "This field specifies the delay between powering up the XTAL 24MHz cloc"
        "k and releasing the clock to the digital logic inside the analog block"
        ".",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_XTAL_SOURCE",
        "This field indicates which chip source is being used for the rtc clock"
        ".Not related to CCM.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTAL_24M_PWD",
        "This field powers down the 24M crystal oscillator if set true.Not rela"
        "ted to CCM.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_PLL_PREDIV",
        "Predivider for the source clock of the PLL's.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC0_TOG.
static const field_t hw_ccm_analog_analog_misc0_tog[] =
{
    {
        "REFTOP_PWD",
        "Control bit to power-down the analog bandgap reference circuitry.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_SELFBIASOFF",
        "Control bit to disable the self-bias circuit in the analog bandgap.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGADJ",
        "Not related to CCM.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGUP",
        "Status bit that signals the analog bandgap voltage is up and stable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_MODE_CONFIG",
        "Configure the analog behavior in stop mode.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCON_HIGH_SNVS",
        "This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_I",
        "This field determines the bias current in the 24MHz oscillator.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_XTALOK",
        "Status bit that signals that the output of the 24-MHz crystal oscillat"
        "or is stable.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSC_XTALOK_EN",
        "This bit enables the detector that signals when the 24MHz crystal osci"
        "llator is stable.Not related to CCM.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_CTRL",
        "This bit allows disabling the clock gate (always ungated) for the xtal"
        " 24MHz clock that clocks the digital logic in the analog block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_DELAY",
        "This field specifies the delay between powering up the XTAL 24MHz cloc"
        "k and releasing the clock to the digital logic inside the analog block"
        ".",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_XTAL_SOURCE",
        "This field indicates which chip source is being used for the rtc clock"
        ".Not related to CCM.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTAL_24M_PWD",
        "This field powers down the 24M crystal oscillator if set true.Not rela"
        "ted to CCM.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_PLL_PREDIV",
        "Predivider for the source clock of the PLL's.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC1.
static const field_t hw_ccm_analog_analog_misc1[] =
{
    {
        "PFD_480_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_480 clocks an"
        "ytime the USB1_PLL_480 is unlocked or powered off.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_528_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_528 clocks an"
        "ytime the PLL_528 is unlocked or powered off.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPPANIC",
        "This status bit is set to one when the temperature sensor panic interr"
        "upt asserts for a panic high temperature.Not related to CCM.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPLOW",
        "This status bit is set to one when the temperature sensor low interrup"
        "t asserts for low temperature.Not related to CCM.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPHIGH",
        "This status bit is set to one when the temperature sensor high interru"
        "pt asserts for high temperature.Not related to CCM.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC1_SET.
static const field_t hw_ccm_analog_analog_misc1_set[] =
{
    {
        "PFD_480_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_480 clocks an"
        "ytime the USB1_PLL_480 is unlocked or powered off.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_528_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_528 clocks an"
        "ytime the PLL_528 is unlocked or powered off.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPPANIC",
        "This status bit is set to one when the temperature sensor panic interr"
        "upt asserts for a panic high temperature.Not related to CCM.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPLOW",
        "This status bit is set to one when the temperature sensor low interrup"
        "t asserts for low temperature.Not related to CCM.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPHIGH",
        "This status bit is set to one when the temperature sensor high interru"
        "pt asserts for high temperature.Not related to CCM.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC1_CLR.
static const field_t hw_ccm_analog_analog_misc1_clr[] =
{
    {
        "PFD_480_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_480 clocks an"
        "ytime the USB1_PLL_480 is unlocked or powered off.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_528_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_528 clocks an"
        "ytime the PLL_528 is unlocked or powered off.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPPANIC",
        "This status bit is set to one when the temperature sensor panic interr"
        "upt asserts for a panic high temperature.Not related to CCM.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPLOW",
        "This status bit is set to one when the temperature sensor low interrup"
        "t asserts for low temperature.Not related to CCM.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPHIGH",
        "This status bit is set to one when the temperature sensor high interru"
        "pt asserts for high temperature.Not related to CCM.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC1_TOG.
static const field_t hw_ccm_analog_analog_misc1_tog[] =
{
    {
        "PFD_480_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_480 clocks an"
        "ytime the USB1_PLL_480 is unlocked or powered off.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_528_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_528 clocks an"
        "ytime the PLL_528 is unlocked or powered off.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPPANIC",
        "This status bit is set to one when the temperature sensor panic interr"
        "upt asserts for a panic high temperature.Not related to CCM.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPLOW",
        "This status bit is set to one when the temperature sensor low interrup"
        "t asserts for low temperature.Not related to CCM.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPHIGH",
        "This status bit is set to one when the temperature sensor high interru"
        "pt asserts for high temperature.Not related to CCM.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC2.
static const field_t hw_ccm_analog_analog_misc2[] =
{
    {
        "REG0_BO_OFFSET",
        "This field defines the brown out voltage offset for the CORE power dom"
        "ain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.Not related to CCM.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "When USB is in low power suspend mode this Control bit is used to indi"
        "cate if other system peripherals require the USB PLL3 clock when the S"
        "oC is not in low power mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_BO_STATUS",
        "Reg1 brownout status bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.Not related to CCM.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC2_SET.
static const field_t hw_ccm_analog_analog_misc2_set[] =
{
    {
        "REG0_BO_OFFSET",
        "This field defines the brown out voltage offset for the CORE power dom"
        "ain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.Not related to CCM.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "When USB is in low power suspend mode this Control bit is used to indi"
        "cate if other system peripherals require the USB PLL3 clock when the S"
        "oC is not in low power mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_BO_STATUS",
        "Reg1 brownout status bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.Not related to CCM.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC2_CLR.
static const field_t hw_ccm_analog_analog_misc2_clr[] =
{
    {
        "REG0_BO_OFFSET",
        "This field defines the brown out voltage offset for the CORE power dom"
        "ain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.Not related to CCM.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "When USB is in low power suspend mode this Control bit is used to indi"
        "cate if other system peripherals require the USB PLL3 clock when the S"
        "oC is not in low power mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_BO_STATUS",
        "Reg1 brownout status bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.Not related to CCM.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CCM_ANALOG_ANALOG_MISC2_TOG.
static const field_t hw_ccm_analog_analog_misc2_tog[] =
{
    {
        "REG0_BO_OFFSET",
        "This field defines the brown out voltage offset for the CORE power dom"
        "ain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.Not related to CCM.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "When USB is in low power suspend mode this Control bit is used to indi"
        "cate if other system peripherals require the USB PLL3 clock when the S"
        "oC is not in low power mode.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_BO_STATUS",
        "Reg1 brownout status bit.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG1_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.Not related to CCM.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.Not related to CCM.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG1_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).Not related to CCM.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a CCM_ANALOG module.
static const reg_t hw_ccm_analog[] =
{
    {
        "ANALOG_PLL_ARM",
        "The control register provides control for the system PLL.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_arm
    },
    {
        "ANALOG_PLL_ARM_SET",
        "The control register provides control for the system PLL.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_arm_set
    },
    {
        "ANALOG_PLL_ARM_CLR",
        "The control register provides control for the system PLL.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_arm_clr
    },
    {
        "ANALOG_PLL_ARM_TOG",
        "The control register provides control for the system PLL.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_arm_tog
    },
    {
        "ANALOG_PLL_USB1",
        "The control register provides control for USBPHY0 480MHz PLL.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_usb1
    },
    {
        "ANALOG_PLL_USB1_SET",
        "The control register provides control for USBPHY0 480MHz PLL.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_usb1_set
    },
    {
        "ANALOG_PLL_USB1_CLR",
        "The control register provides control for USBPHY0 480MHz PLL.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_usb1_clr
    },
    {
        "ANALOG_PLL_USB1_TOG",
        "The control register provides control for USBPHY0 480MHz PLL.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_usb1_tog
    },
    {
        "ANALOG_PLL_USB2",
        "The control register provides control for USBPHY1 480MHz PLL.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_usb2
    },
    {
        "ANALOG_PLL_USB2_SET",
        "The control register provides control for USBPHY1 480MHz PLL.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_usb2_set
    },
    {
        "ANALOG_PLL_USB2_CLR",
        "The control register provides control for USBPHY1 480MHz PLL.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_usb2_clr
    },
    {
        "ANALOG_PLL_USB2_TOG",
        "The control register provides control for USBPHY1 480MHz PLL.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_usb2_tog
    },
    {
        "ANALOG_PLL_SYS",
        "The control register provides control for the 528MHz PLL.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_sys
    },
    {
        "ANALOG_PLL_SYS_SET",
        "The control register provides control for the 528MHz PLL.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_sys_set
    },
    {
        "ANALOG_PLL_SYS_CLR",
        "The control register provides control for the 528MHz PLL.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_sys_clr
    },
    {
        "ANALOG_PLL_SYS_TOG",
        "The control register provides control for the 528MHz PLL.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_pll_sys_tog
    },
    {
        "ANALOG_PLL_SYS_SS",
        "This register contains the 528 PLL spread spectrum controls.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ccm_analog_analog_pll_sys_ss
    },
    {
        "ANALOG_PLL_SYS_NUM",
        "This register contains the numerator of 528MHz PLL fractional loop div"
        "ider (signed number).",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_analog_pll_sys_num
    },
    {
        "ANALOG_PLL_SYS_DENOM",
        "This register contains the Denominator of 528MHz PLL fractional loop d"
        "ivider.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_analog_pll_sys_denom
    },
    {
        "ANALOG_PLL_AUDIO",
        "The control register provides control for the audio PLL.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_analog_pll_audio
    },
    {
        "ANALOG_PLL_AUDIO_SET",
        "The control register provides control for the audio PLL.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_analog_pll_audio_set
    },
    {
        "ANALOG_PLL_AUDIO_CLR",
        "The control register provides control for the audio PLL.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_analog_pll_audio_clr
    },
    {
        "ANALOG_PLL_AUDIO_TOG",
        "The control register provides control for the audio PLL.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_analog_pll_audio_tog
    },
    {
        "ANALOG_PLL_AUDIO_NUM",
        "This register contains the numerator (A) of Audio PLL fractional loop "
        "divider.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_analog_pll_audio_num
    },
    {
        "ANALOG_PLL_AUDIO_DENOM",
        "This register contains the Denominator (B) of Audio PLL fractional loo"
        "p divider.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_analog_pll_audio_denom
    },
    {
        "ANALOG_PLL_VIDEO",
        "The control register provides control for the Video PLL.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_analog_pll_video
    },
    {
        "ANALOG_PLL_VIDEO_SET",
        "The control register provides control for the Video PLL.",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_analog_pll_video_set
    },
    {
        "ANALOG_PLL_VIDEO_CLR",
        "The control register provides control for the Video PLL.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_analog_pll_video_clr
    },
    {
        "ANALOG_PLL_VIDEO_TOG",
        "The control register provides control for the Video PLL.",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ccm_analog_analog_pll_video_tog
    },
    {
        "ANALOG_PLL_VIDEO_NUM",
        "This register contains the numerator (A) of Video PLL fractional loop "
        "divider.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_analog_pll_video_num
    },
    {
        "ANALOG_PLL_VIDEO_DENOM",
        "This register contains the Denominator (B) of Video PLL fractional loo"
        "p divider.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ccm_analog_analog_pll_video_denom
    },
    {
        "ANALOG_PLL_ENET",
        "The control register provides control for the ENET PLL.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ccm_analog_analog_pll_enet
    },
    {
        "ANALOG_PLL_ENET_SET",
        "The control register provides control for the ENET PLL.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ccm_analog_analog_pll_enet_set
    },
    {
        "ANALOG_PLL_ENET_CLR",
        "The control register provides control for the ENET PLL.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ccm_analog_analog_pll_enet_clr
    },
    {
        "ANALOG_PLL_ENET_TOG",
        "The control register provides control for the ENET PLL.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_ccm_analog_analog_pll_enet_tog
    },
    {
        "ANALOG_PFD_480",
        "The PFD_480 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_analog_pfd_480
    },
    {
        "ANALOG_PFD_480_SET",
        "The PFD_480 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_analog_pfd_480_set
    },
    {
        "ANALOG_PFD_480_CLR",
        "The PFD_480 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_analog_pfd_480_clr
    },
    {
        "ANALOG_PFD_480_TOG",
        "The PFD_480 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_analog_pfd_480_tog
    },
    {
        "ANALOG_PFD_528",
        "The PFD_528 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_analog_pfd_528
    },
    {
        "ANALOG_PFD_528_SET",
        "The PFD_528 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_analog_pfd_528_set
    },
    {
        "ANALOG_PFD_528_CLR",
        "The PFD_528 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_analog_pfd_528_clr
    },
    {
        "ANALOG_PFD_528_TOG",
        "The PFD_528 control register provides control for PFD clock generation"
        ".",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_ccm_analog_analog_pfd_528_tog
    },
    {
        "ANALOG_MISC0",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_analog_analog_misc0
    },
    {
        "ANALOG_MISC0_SET",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_analog_analog_misc0_set
    },
    {
        "ANALOG_MISC0_CLR",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_analog_analog_misc0_clr
    },
    {
        "ANALOG_MISC0_TOG",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_ccm_analog_analog_misc0_tog
    },
    {
        "ANALOG_MISC1",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_misc1
    },
    {
        "ANALOG_MISC1_SET",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_misc1_set
    },
    {
        "ANALOG_MISC1_CLR",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_misc1_clr
    },
    {
        "ANALOG_MISC1_TOG",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ccm_analog_analog_misc1_tog
    },
    {
        "ANALOG_MISC2",
        "This register defines the control for miscellaneous analog blocks.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_ccm_analog_analog_misc2
    },
    {
        "ANALOG_MISC2_SET",
        "This register defines the control for miscellaneous analog blocks.",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_ccm_analog_analog_misc2_set
    },
    {
        "ANALOG_MISC2_CLR",
        "This register defines the control for miscellaneous analog blocks.",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_ccm_analog_analog_misc2_clr
    },
    {
        "ANALOG_MISC2_TOG",
        "This register defines the control for miscellaneous analog blocks.",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_ccm_analog_analog_misc2_tog
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark CSI
#endif

// Bitfields in register CSI_CSICR1.
static const field_t hw_csi_csicr1[] =
{
    {
        "PIXEL_BIT",
        "Pixel Bit.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REDGE",
        "Valid Pixel Clock Edge Select.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INV_PCLK",
        "Invert Pixel Clock Input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INV_DATA",
        "Invert Data Input.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GCLK_MODE",
        "Gated Clock Mode Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_RXFIFO",
        "Asynchronous RXFIFO Clear.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_STATFIFO",
        "Asynchronous STATFIFO Clear.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PACK_DIR",
        "Data Packing Direction.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCC",
        "FIFO Clear Control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCIR_EN",
        "CCIR656 Interface Enable.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "HSYNC Polarity Select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOF_INTEN",
        "Start Of Frame (SOF) Interrupt Enable.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOF_POL",
        "SOF Interrupt Polarity.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFF_INTEN",
        "RxFIFO Full Interrupt Enable.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FB1_DMA_DONE_INTEN",
        "Frame Buffer1 DMA Transfer Done Interrupt Enable.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FB2_DMA_DONE_INTEN",
        "Frame Buffer2 DMA Transfer Done Interrupt Enable.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATFF_INTEN",
        "STATFIFO Full Interrupt Enable.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFF_DMA_DONE_INTEN",
        "STATFIFO DMA Transfer Done Interrupt Enable.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF_OR_INTEN",
        "RxFIFO Overrun Interrupt Enable.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SF_OR_INTEN",
        "STAT FIFO Overrun Interrupt Enable.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COF_INT_EN",
        "Change Of Image Field (COF) Interrupt Enable.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_MODE",
        "Video mode select.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRP_IF_EN",
        "CSI-PrP Interface Enable.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EOF_INT_EN",
        "End-of-Frame Interrupt Enable.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXT_VSYNC",
        "External VSYNC Enable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWAP16_EN",
        "SWAP 16-Bit Enable.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSICR2.
static const field_t hw_csi_csicr2[] =
{
    {
        "HSC",
        "Horizontal Skip Count.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSC",
        "Vertical Skip Count.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LVRM",
        "Live View Resolution Mode.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BTS",
        "Bayer Tile Start.",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCE",
        "Skip Count Enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AFS",
        "Auto Focus Spread.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRM",
        "Double Resolution Mode.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_BURST_TYPE_SFF",
        "Burst Type of DMA Transfer from STATFIFO.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_BURST_TYPE_RFF",
        "Burst Type of DMA Transfer from RxFIFO.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSICR3.
static const field_t hw_csi_csicr3[] =
{
    {
        "ECC_AUTO_EN",
        "Automatic Error Correction Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_INT_EN",
        "Error Detection Interrupt Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZERO_PACK_EN",
        "Dummy Zero Packing Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWO_8BIT_SENSOR",
        "Two 8-bit Sensor Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFF_LEVEL",
        "RxFIFO Full Level.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HRESP_ERR_EN",
        "Hresponse Error Enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATFF_LEVEL",
        "STATFIFO Full Level.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_REQ_EN_SFF",
        "DMA Request Enable for STATFIFO.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_REQ_EN_RFF",
        "DMA Request Enable for RxFIFO.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_REFLASH_SFF",
        "Reflash DMA Controller for STATFIFO.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_REFLASH_RFF",
        "Reflash DMA Controller for RxFIFO.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRMCNT_RST",
        "Frame Count Reset.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRMCNT",
        "Frame Counter.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSISTATFIFO.
static const field_t hw_csi_csistatfifo[] =
{
    {
        "STAT",
        "Static data from sensor",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIRFIFO.
static const field_t hw_csi_csirfifo[] =
{
    {
        "IMAGE",
        "Received image data",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIRXCNT.
static const field_t hw_csi_csirxcnt[] =
{
    {
        "RXCNT",
        "RxFIFO Count.",
        0, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSISR.
static const field_t hw_csi_csisr[] =
{
    {
        "DRDY",
        "RXFIFO Data Ready.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_INT",
        "CCIR Error Interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HRESP_ERR_INT",
        "Hresponse Error Interrupt Status.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COF_INT",
        "Change Of Field Interrupt Status.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F1_INT",
        "CCIR Field 1 Interrupt Status.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F2_INT",
        "CCIR Field 2 Interrupt Status.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOF_INT",
        "Start of Frame Interrupt Status.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EOF_INT",
        "End of Frame (EOF) Interrupt Status.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFF_INT",
        "RXFIFO Full Interrupt Status.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_TSF_DONE_FB1",
        "DMA Transfer Done in Frame Buffer1.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_TSF_DONE_FB2",
        "DMA Transfer Done in Frame Buffer2.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATFF_INT",
        "STATFIFO Full Interrupt Status.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_TSF_DONE_SFF",
        "DMA Transfer Done from StatFIFO.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RF_OR_INT",
        "RxFIFO Overrun Interrupt Status.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SF_OR_INT",
        "STATFIFO Overrun Interrupt Status.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_FIELD1_DONE",
        "When DMA field 0 is complete, this bit will be set to 1(clear by writi"
        "ng 1).",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_FIELD0_DONE",
        "When DMA field 0 is complete, this bit will be set to 1(clear by writi"
        "ng 1).",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BASEADDR_CHHANGE_ERROR",
        "When using base address switching enable, this bit will be 1 when swit"
        "ching occur before DMA complete.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIDMASA_STATFIFO.
static const field_t hw_csi_csidmasa_statfifo[] =
{
    {
        "DMA_START_ADDR_SFF",
        "DMA Start Address for STATFIFO.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIDMATS_STATFIFO.
static const field_t hw_csi_csidmats_statfifo[] =
{
    {
        "DMA_TSF_SIZE_SFF",
        "DMA Transfer Size for STATFIFO.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIDMASA_FB1.
static const field_t hw_csi_csidmasa_fb1[] =
{
    {
        "DMA_START_ADDR_FB1",
        "DMA Start Address in Frame Buffer1.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIDMASA_FB2.
static const field_t hw_csi_csidmasa_fb2[] =
{
    {
        "DMA_START_ADDR_FB2",
        "DMA Start Address in Frame Buffer2.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIFBUF_PARA.
static const field_t hw_csi_csifbuf_para[] =
{
    {
        "FBUF_STRIDE",
        "Frame Buffer Parameter.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEINTERLACE_STRIDE",
        "DEINTERLACE_STRIDE is only used in the deinterlace mode.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSIIMAG_PARA.
static const field_t hw_csi_csiimag_para[] =
{
    {
        "IMAGE_HEIGHT",
        "Image Height.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IMAGE_WIDTH",
        "Image Width.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register CSI_CSICR18.
static const field_t hw_csi_csicr18[] =
{
    {
        "NTSC_EN",
        "This bit is used to select NTSC/PAL mode When input is TVDECODER or st"
        "andard CCIR656 video.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEINTERLACE_EN",
        "This bit is used to select the output method When input is standard CC"
        "IR656 video.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PARALLEL24_EN",
        "When input is parallel rgb888/yuv444 24bit, this bit can be enabled.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BASEADDR_SWITCH_EN",
        "When this bit is enabled, CSI DMA will switch the base address accordi"
        "ng to BASEADDR_SWITCH_SEL rather than atomically by DMA completed.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BASEADDR_SWITCH_SEL",
        "CSI 2 base addresses switching method.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIELD0_DONE_IE",
        "In interlace mode, fileld 0 means interrupt enabled.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_FIELD1_DONE_IE",
        "When in interlace mode, field 1 done interrupt enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LAST_DMA_REQ_SEL",
        "Choosing the last DMA request condition.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BASEADDR_CHANGE_ERROR_IE",
        "Base address change error interrupt enable signal.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RGB888A_FORMAT_SEL",
        "Output is 32-bit format.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AHB_HPROT",
        "Hprot value in AHB bus protocol.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_LCDIF_BUFFER_LINES",
        "The number of lines are used in handshake mode with LCDIF.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_OPTION",
        "These bits used to choose the method to mask the CSI input.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_ENABLE",
        "CSI global enable signal.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a CSI module.
static const reg_t hw_csi[] =
{
    {
        "CSICR1",
        "This register controls the sensor interface timing and interrupt gener"
        "ation.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_csi_csicr1
    },
    {
        "CSICR2",
        "This register provides the statistic block with data about which live "
        "view resolution is being used, and the starting sensor pixel of the Ba"
        "yer pattern.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_csi_csicr2
    },
    {
        "CSICR3",
        "This read/write register acts as an extension of the functionality of "
        "the CSI Control register 1, adding additional control and features.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_csi_csicr3
    },
    {
        "CSISTATFIFO",
        "The StatFIFO is a read-only register containing statistic data from th"
        "e sensor.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_csi_csistatfifo
    },
    {
        "CSIRFIFO",
        "This read-only register contains received image data.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_csi_csirfifo
    },
    {
        "CSIRXCNT",
        "This register works for EOF interrupt generation.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csirxcnt
    },
    {
        "CSISR",
        "This read/write register shows sensor interface status, and which kind"
        " of interrupt is being generated.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_csi_csisr
    },
    {
        "CSIDMASA_STATFIFO",
        "This register provides the start address for the embedded DMA controll"
        "er of STATFIFO.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csidmasa_statfifo
    },
    {
        "CSIDMATS_STATFIFO",
        "This register provides the total transfer size for the embedded DMA co"
        "ntroller of STATFIFO.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csidmats_statfifo
    },
    {
        "CSIDMASA_FB1",
        "This register provides the start address in the frame buffer1 for the "
        "embedded DMA controller of RxFIFO.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csidmasa_fb1
    },
    {
        "CSIDMASA_FB2",
        "This register provides the start address in the frame buffer2 for the "
        "embedded DMA controller of RxFIFO.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_csi_csidmasa_fb2
    },
    {
        "CSIFBUF_PARA",
        "This register provides the stride of the frame buffer to show how many"
        " words to skip before starting to write the next row of the image.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_csi_csifbuf_para
    },
    {
        "CSIIMAG_PARA",
        "This register provides the width and the height of the image from the "
        "sensor.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_csi_csiimag_para
    },
    {
        "CSICR18",
        "This read/write register acts as an extension of the functionality of "
        "the CSI Control register 1",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_csi_csicr18
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ECSPI
#endif

// Bitfields in register ECSPI_RXDATA.
static const field_t hw_ecspi_rxdata[] =
{
    {
        "ECSPI_RXDATA",
        "Receive Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_TXDATA.
static const field_t hw_ecspi_txdata[] =
{
    {
        "ECSPI_TXDATA",
        "Transmit Data.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_CONREG.
static const field_t hw_ecspi_conreg[] =
{
    {
        "EN",
        "SPI Block Enable Control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HT",
        "Hardware Trigger Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XCH",
        "SPI Exchange Bit.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMC",
        "Start Mode Control.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHANNEL_MODE",
        "SPI CHANNEL MODE selects the mode for each SPI channel.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POST_DIVIDER",
        "SPI Post Divider.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRE_DIVIDER",
        "SPI Pre Divider.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRCTL",
        "SPI Data Ready Control.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CHANNEL_SELECT",
        "SPI CHANNEL SELECT bits.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_LENGTH",
        "Burst Length.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_CONFIGREG.
static const field_t hw_ecspi_configreg[] =
{
    {
        "SCLK_PHA",
        "SPI Clock/Data Phase Control.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCLK_POL",
        "SPI Clock Polarity Control.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SS_CTL",
        "SPI SS Wave Form Select.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SS_POL",
        "SPI SS Polarity Select.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_CTL",
        "DATA CTL.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCLK_CTL",
        "SCLK CTL.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HT_LENGTH",
        "HT LENGTH.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_INTREG.
static const field_t hw_ecspi_intreg[] =
{
    {
        "TEEN",
        "TXFIFO Empty Interrupt enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDREN",
        "TXFIFO Data Request Interrupt enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFEN",
        "TXFIFO Full Interrupt enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RREN",
        "RXFIFO Ready Interrupt enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDREN",
        "RXFIFO Data Request Interrupt enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFEN",
        "RXFIFO Full Interrupt enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROEN",
        "RXFIFO Overflow Interrupt enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCEN",
        "Transfer Completed Interrupt enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_DMAREG.
static const field_t hw_ecspi_dmareg[] =
{
    {
        "TX_THRESHOLD",
        "TX THRESHOLD.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEDEN",
        "TXFIFO Empty DMA Request Enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_THRESHOLD",
        "RX THRESHOLD.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDEN",
        "RXFIFO DMA Request Enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_DMA_LENGTH",
        "RX DMA LENGTH.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXTDEN",
        "RXFIFO TAIL DMA Request Enable.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_STATREG.
static const field_t hw_ecspi_statreg[] =
{
    {
        "TE",
        "TXFIFO Empty.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TDR",
        "TXFIFO Data Request.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TF",
        "TXFIFO Full.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RR",
        "RXFIFO Ready.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDR",
        "RXFIFO Data Request.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RF",
        "RXFIFO Full.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RO",
        "RXFIFO Overflow.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TC",
        "Transfer Completed Status bit.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_PERIODREG.
static const field_t hw_ecspi_periodreg[] =
{
    {
        "SAMPLE_PERIOD",
        "Sample Period Control.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSRC",
        "Clock Source Control.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSD_CTL",
        "Chip Select Delay Control bits.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_TESTREG.
static const field_t hw_ecspi_testreg[] =
{
    {
        "TXCNT",
        "TXFIFO Counter.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXCNT",
        "RXFIFO Counter.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBC",
        "Loop Back Control.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ECSPI_MSGDATA.
static const field_t hw_ecspi_msgdata[] =
{
    {
        "ECSPI_MSGDATA",
        "ECSPI_MSGDATA holds the top word of MSG Data FIFO.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a ECSPI module.
static const reg_t hw_ecspi[] =
{
    {
        "RXDATA",
        "The Receive Data register (ECSPI_RXDATA) is a read-only register that "
        "forms the top word of the 64 x 32 receive FIFO.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ecspi_rxdata
    },
    {
        "TXDATA",
        "The Transmit Data (ECSPI_TXDATA) register is a write-only data registe"
        "r that forms the bottom word of the 64 x 32 TXFIFO.",
        4, // Width in bytes
        0x00000004, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ecspi_txdata
    },
    {
        "CONREG",
        "The Control Register (ECSPI_CONREG) allows software to enable the ECSP"
        "I , configure its operating modes, specify the divider value, and SPI_"
        "RDY control signal, and define the transfer length.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_ecspi_conreg
    },
    {
        "CONFIGREG",
        "The Config Register (ECSPI_CONFIGREG) allows software to configure eac"
        "h SPI channel, configure its operating modes, specify the phase and po"
        "larity of the clock, configure the Chip Select (SS), and define the HT"
        " transfer length.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_ecspi_configreg
    },
    {
        "INTREG",
        "The Interrupt Control Register (ECSPI_INTREG) enables the generation o"
        "f interrupts to the host processor.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ecspi_intreg
    },
    {
        "DMAREG",
        "The Direct Memory Access Control Register (ECSPI_DMAREG) provides soft"
        "ware a way to use an on-chip DMA controller for ECSPI data.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_ecspi_dmareg
    },
    {
        "STATREG",
        "The ECSPI Status Register (ECSPI_STATREG) reflects the status of the E"
        "CSPI's operating condition.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_ecspi_statreg
    },
    {
        "PERIODREG",
        "The Sample Period Control Register (ECSPI_PERIODREG) provides software"
        " a way to insert delays (wait states) between consecutive SPI transfer"
        "s.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ecspi_periodreg
    },
    {
        "TESTREG",
        "The Test Control Register (ECSPI_TESTREG) provides software a mechanis"
        "m to internally connect the receive and transmit devices of the ECSPI "
        ", and monitor the contents of the receive and transmit FIFOs.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ecspi_testreg
    },
    {
        "MSGDATA",
        "The Message Data Register (ECSPI_MSGDATA) forms the top word of the 16"
        " x 32 MSG Data FIFO.",
        4, // Width in bytes
        0x00000040, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_ecspi_msgdata
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark EIM
#endif

// Bitfields in register EIM_CS0GCR1.
static const field_t hw_eim_cs0gcr1[] =
{
    {
        "CSEN",
        "CS Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Synchronous Write Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        "Synchronous Read Data.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        "Multiplexed Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        "Write Fix Latency.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        "Read Fix Latency.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        "Configuration Register Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        "Configuration Register Enable Polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        "Write Continuous.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Burst Clock Divisor.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "Burst Clock Start.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        "Data Port Size.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        "Supervisor Protect.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        "CS Recovery.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        "Address UnShifted.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        "Gap Between Chip Selects.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Write Protect.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        "Page Size.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0GCR2.
static const field_t hw_eim_cs0gcr2[] =
{
    {
        "ADH",
        "Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        "Data Acknowledge Poling Start.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        "Data Acknowledge Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        "Data Acknowledge Polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        "Muxed 16 bypass grant.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0RCR1.
static const field_t hw_eim_cs0rcr1[] =
{
    {
        "RCSN",
        "Read CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        "Read CS Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "OE Negation.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        "OE Assertion.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        "ADV Negation.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        "Read ADV Low.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        "ADV Assertion.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        "Read Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0RCR2.
static const field_t hw_eim_cs0rcr2[] =
{
    {
        "RBEN",
        "Read BE Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        "Read BE enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        "Read BE Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Read Latency.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        "Page Access Time.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        "Asynchronous Page Read.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0WCR1.
static const field_t hw_eim_cs0wcr1[] =
{
    {
        "WCSN",
        "Write CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        "Write CS Assertion.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        "WE Negation.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        "WE Assertion.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        "BE[3:0] Negation.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        "BE Assertion.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        "ADV Negation.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        "ADV Assertion.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        "Write Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        "Write Byte Enable Disable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        "Write ADV Low.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS0WCR2.
static const field_t hw_eim_cs0wcr2[] =
{
    {
        "WBCDD",
        "Write Burst Clock Divisor Decrement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1GCR1.
static const field_t hw_eim_cs1gcr1[] =
{
    {
        "CSEN",
        "CS Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Synchronous Write Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        "Synchronous Read Data.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        "Multiplexed Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        "Write Fix Latency.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        "Read Fix Latency.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        "Configuration Register Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        "Configuration Register Enable Polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        "Write Continuous.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Burst Clock Divisor.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "Burst Clock Start.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        "Data Port Size.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        "Supervisor Protect.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        "CS Recovery.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        "Address UnShifted.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        "Gap Between Chip Selects.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Write Protect.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        "Page Size.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1GCR2.
static const field_t hw_eim_cs1gcr2[] =
{
    {
        "ADH",
        "Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        "Data Acknowledge Poling Start.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        "Data Acknowledge Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        "Data Acknowledge Polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        "Muxed 16 bypass grant.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1RCR1.
static const field_t hw_eim_cs1rcr1[] =
{
    {
        "RCSN",
        "Read CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        "Read CS Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "OE Negation.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        "OE Assertion.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        "ADV Negation.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        "Read ADV Low.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        "ADV Assertion.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        "Read Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1RCR2.
static const field_t hw_eim_cs1rcr2[] =
{
    {
        "RBEN",
        "Read BE Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        "Read BE enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        "Read BE Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Read Latency.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        "Page Access Time.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        "Asynchronous Page Read.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1WCR1.
static const field_t hw_eim_cs1wcr1[] =
{
    {
        "WCSN",
        "Write CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        "Write CS Assertion.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        "WE Negation.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        "WE Assertion.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        "BE[3:0] Negation.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        "BE Assertion.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        "ADV Negation.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        "ADV Assertion.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        "Write Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        "Write Byte Enable Disable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        "Write ADV Low.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS1WCR2.
static const field_t hw_eim_cs1wcr2[] =
{
    {
        "WBCDD",
        "Write Burst Clock Divisor Decrement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2GCR1.
static const field_t hw_eim_cs2gcr1[] =
{
    {
        "CSEN",
        "CS Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Synchronous Write Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        "Synchronous Read Data.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        "Multiplexed Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        "Write Fix Latency.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        "Read Fix Latency.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        "Configuration Register Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        "Configuration Register Enable Polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        "Write Continuous.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Burst Clock Divisor.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "Burst Clock Start.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        "Data Port Size.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        "Supervisor Protect.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        "CS Recovery.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        "Address UnShifted.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        "Gap Between Chip Selects.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Write Protect.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        "Page Size.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2GCR2.
static const field_t hw_eim_cs2gcr2[] =
{
    {
        "ADH",
        "Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        "Data Acknowledge Poling Start.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        "Data Acknowledge Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        "Data Acknowledge Polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        "Muxed 16 bypass grant.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2RCR1.
static const field_t hw_eim_cs2rcr1[] =
{
    {
        "RCSN",
        "Read CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        "Read CS Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "OE Negation.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        "OE Assertion.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        "ADV Negation.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        "Read ADV Low.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        "ADV Assertion.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        "Read Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2RCR2.
static const field_t hw_eim_cs2rcr2[] =
{
    {
        "RBEN",
        "Read BE Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        "Read BE enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        "Read BE Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Read Latency.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        "Page Access Time.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        "Asynchronous Page Read.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2WCR1.
static const field_t hw_eim_cs2wcr1[] =
{
    {
        "WCSN",
        "Write CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        "Write CS Assertion.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        "WE Negation.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        "WE Assertion.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        "BE[3:0] Negation.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        "BE Assertion.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        "ADV Negation.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        "ADV Assertion.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        "Write Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        "Write Byte Enable Disable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        "Write ADV Low.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS2WCR2.
static const field_t hw_eim_cs2wcr2[] =
{
    {
        "WBCDD",
        "Write Burst Clock Divisor Decrement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3GCR1.
static const field_t hw_eim_cs3gcr1[] =
{
    {
        "CSEN",
        "CS Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Synchronous Write Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        "Synchronous Read Data.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        "Multiplexed Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        "Write Fix Latency.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        "Read Fix Latency.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        "Configuration Register Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        "Configuration Register Enable Polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        "Write Continuous.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Burst Clock Divisor.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "Burst Clock Start.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        "Data Port Size.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        "Supervisor Protect.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        "CS Recovery.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        "Address UnShifted.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        "Gap Between Chip Selects.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Write Protect.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        "Page Size.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3GCR2.
static const field_t hw_eim_cs3gcr2[] =
{
    {
        "ADH",
        "Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        "Data Acknowledge Poling Start.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        "Data Acknowledge Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        "Data Acknowledge Polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        "Muxed 16 bypass grant.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3RCR1.
static const field_t hw_eim_cs3rcr1[] =
{
    {
        "RCSN",
        "Read CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        "Read CS Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "OE Negation.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        "OE Assertion.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        "ADV Negation.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        "Read ADV Low.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        "ADV Assertion.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        "Read Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3RCR2.
static const field_t hw_eim_cs3rcr2[] =
{
    {
        "RBEN",
        "Read BE Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        "Read BE enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        "Read BE Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Read Latency.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        "Page Access Time.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        "Asynchronous Page Read.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3WCR1.
static const field_t hw_eim_cs3wcr1[] =
{
    {
        "WCSN",
        "Write CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        "Write CS Assertion.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        "WE Negation.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        "WE Assertion.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        "BE[3:0] Negation.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        "BE Assertion.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        "ADV Negation.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        "ADV Assertion.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        "Write Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        "Write Byte Enable Disable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        "Write ADV Low.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS3WCR2.
static const field_t hw_eim_cs3wcr2[] =
{
    {
        "WBCDD",
        "Write Burst Clock Divisor Decrement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4GCR1.
static const field_t hw_eim_cs4gcr1[] =
{
    {
        "CSEN",
        "CS Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Synchronous Write Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        "Synchronous Read Data.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        "Multiplexed Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        "Write Fix Latency.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        "Read Fix Latency.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        "Configuration Register Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        "Configuration Register Enable Polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        "Write Continuous.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Burst Clock Divisor.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "Burst Clock Start.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        "Data Port Size.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        "Supervisor Protect.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        "CS Recovery.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        "Address UnShifted.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        "Gap Between Chip Selects.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Write Protect.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        "Page Size.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4GCR2.
static const field_t hw_eim_cs4gcr2[] =
{
    {
        "ADH",
        "Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        "Data Acknowledge Poling Start.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        "Data Acknowledge Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        "Data Acknowledge Polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        "Muxed 16 bypass grant.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4RCR1.
static const field_t hw_eim_cs4rcr1[] =
{
    {
        "RCSN",
        "Read CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        "Read CS Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "OE Negation.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        "OE Assertion.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        "ADV Negation.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        "Read ADV Low.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        "ADV Assertion.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        "Read Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4RCR2.
static const field_t hw_eim_cs4rcr2[] =
{
    {
        "RBEN",
        "Read BE Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        "Read BE enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        "Read BE Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Read Latency.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        "Page Access Time.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        "Asynchronous Page Read.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4WCR1.
static const field_t hw_eim_cs4wcr1[] =
{
    {
        "WCSN",
        "Write CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        "Write CS Assertion.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        "WE Negation.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        "WE Assertion.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        "BE[3:0] Negation.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        "BE Assertion.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        "ADV Negation.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        "ADV Assertion.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        "Write Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        "Write Byte Enable Disable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        "Write ADV Low.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS4WCR2.
static const field_t hw_eim_cs4wcr2[] =
{
    {
        "WBCDD",
        "Write Burst Clock Divisor Decrement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5GCR1.
static const field_t hw_eim_cs5gcr1[] =
{
    {
        "CSEN",
        "CS Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Synchronous Write Data.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRD",
        "Synchronous Read Data.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUM",
        "Multiplexed Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WFL",
        "Write Fix Latency.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFL",
        "Read Fix Latency.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRE",
        "Configuration Register Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREP",
        "Configuration Register Enable Polarity.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WC",
        "Write Continuous.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Burst Clock Divisor.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "Burst Clock Start.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSZ",
        "Data Port Size.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SP",
        "Supervisor Protect.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSREC",
        "CS Recovery.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUS",
        "Address UnShifted.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBC",
        "Gap Between Chip Selects.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP",
        "Write Protect.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSZ",
        "Page Size.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5GCR2.
static const field_t hw_eim_cs5gcr2[] =
{
    {
        "ADH",
        "Address hold time - This bit field determine the address hold time aft"
        "er ADV negation when mum = 1 (muxed mode).",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAPS",
        "Data Acknowledge Poling Start.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAE",
        "Data Acknowledge Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAP",
        "Data Acknowledge Polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX16_BYP_GRANT",
        "Muxed 16 bypass grant.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5RCR1.
static const field_t hw_eim_cs5rcr1[] =
{
    {
        "RCSN",
        "Read CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCSA",
        "Read CS Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEN",
        "OE Negation.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OEA",
        "OE Assertion.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVN",
        "ADV Negation.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAL",
        "Read ADV Low.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RADVA",
        "ADV Assertion.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWSC",
        "Read Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5RCR2.
static const field_t hw_eim_cs5rcr2[] =
{
    {
        "RBEN",
        "Read BE Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBE",
        "Read BE enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBEA",
        "Read BE Assertion.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Read Latency.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAT",
        "Page Access Time.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "APR",
        "Asynchronous Page Read.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5WCR1.
static const field_t hw_eim_cs5wcr1[] =
{
    {
        "WCSN",
        "Write CS Negation.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WCSA",
        "Write CS Assertion.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEN",
        "WE Negation.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WEA",
        "WE Assertion.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEN",
        "BE[3:0] Negation.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBEA",
        "BE Assertion.",
        15, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVN",
        "ADV Negation.",
        18, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WADVA",
        "ADV Assertion.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WWSC",
        "Write Wait State Control.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WBED",
        "Write Byte Enable Disable.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAL",
        "Write ADV Low.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_CS5WCR2.
static const field_t hw_eim_cs5wcr2[] =
{
    {
        "WBCDD",
        "Write Burst Clock Divisor Decrement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EIM_WCR.
static const field_t hw_eim_wcr[] =
{
    {
        "BCM",
        "Burst Clock Mode.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GBCD",
        "General Burst Clock Divisor.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CONT_BCLK_SEL",
        "When this bit is set BCLK pin output continuous clock.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTEN",
        "Interrupt Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTPOL",
        "Interrupt Polarity.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG_EN",
        "Memory WDOG enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG_LIMIT",
        "Memory Watchdog (WDOG) cycle limit.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRUN_ACLK_EN",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a EIM module.
static const reg_t hw_eim[] =
{
    {
        "CS0GCR1",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs0gcr1
    },
    {
        "CS0GCR2",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs0gcr2
    },
    {
        "CS0RCR1",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs0rcr1
    },
    {
        "CS0RCR2",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs0rcr2
    },
    {
        "CS0WCR1",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs0wcr1
    },
    {
        "CS0WCR2",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs0wcr2
    },
    {
        "CS1GCR1",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs1gcr1
    },
    {
        "CS1GCR2",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs1gcr2
    },
    {
        "CS1RCR1",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs1rcr1
    },
    {
        "CS1RCR2",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs1rcr2
    },
    {
        "CS1WCR1",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs1wcr1
    },
    {
        "CS1WCR2",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs1wcr2
    },
    {
        "CS2GCR1",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs2gcr1
    },
    {
        "CS2GCR2",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs2gcr2
    },
    {
        "CS2RCR1",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs2rcr1
    },
    {
        "CS2RCR2",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs2rcr2
    },
    {
        "CS2WCR1",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs2wcr1
    },
    {
        "CS2WCR2",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs2wcr2
    },
    {
        "CS3GCR1",
        "",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs3gcr1
    },
    {
        "CS3GCR2",
        "",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs3gcr2
    },
    {
        "CS3RCR1",
        "",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs3rcr1
    },
    {
        "CS3RCR2",
        "",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs3rcr2
    },
    {
        "CS3WCR1",
        "",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs3wcr1
    },
    {
        "CS3WCR2",
        "",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs3wcr2
    },
    {
        "CS4GCR1",
        "",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs4gcr1
    },
    {
        "CS4GCR2",
        "",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs4gcr2
    },
    {
        "CS4RCR1",
        "",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs4rcr1
    },
    {
        "CS4RCR2",
        "",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs4rcr2
    },
    {
        "CS4WCR1",
        "",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs4wcr1
    },
    {
        "CS4WCR2",
        "",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs4wcr2
    },
    {
        "CS5GCR1",
        "",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_eim_cs5gcr1
    },
    {
        "CS5GCR2",
        "",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_eim_cs5gcr2
    },
    {
        "CS5RCR1",
        "",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_cs5rcr1
    },
    {
        "CS5RCR2",
        "",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_eim_cs5rcr2
    },
    {
        "CS5WCR1",
        "",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_eim_cs5wcr1
    },
    {
        "CS5WCR2",
        "",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_eim_cs5wcr2
    },
    {
        "WCR",
        "",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_eim_wcr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark EMVSIM
#endif

// Bitfields in register EMVSIM_VER_ID.
static const field_t hw_emvsim_ver_id[] =
{
    {
        "VER",
        "EMV SIM Version Number used on the chip 31:16 - Major Version (example"
        ": 01.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_PARAM.
static const field_t hw_emvsim_param[] =
{
    {
        "RX_FIFO_DEPTH",
        "Value of parameter for Receive FIFO Depth (in Bytes)",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_FIFO_DEPTH",
        "Value of parameter for Transmit FIFO Depth (in Bytes)",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_CLKCFG.
static const field_t hw_emvsim_clkcfg[] =
{
    {
        "CLK_PRSC",
        "The value written to this register will determine the desired card clo"
        "ck frequency.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPCNT1_CLK_SEL",
        "Selects which clock source is used by EMV SIM Module general purpose c"
        "ounter 1.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPCNT0_CLK_SEL",
        "Selects which clock source is used by EMV SIM Module general purpose c"
        "ounter 0.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_DIVISOR.
static const field_t hw_emvsim_divisor[] =
{
    {
        "DIVISOR_VALUE",
        "The value written to this register will be used to generate the ETU bi"
        "t period that will be used by the transmitter and receiver.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_CTRL.
static const field_t hw_emvsim_ctrl[] =
{
    {
        "IC",
        "Used to configure the EMV SIM to use either inverse convention or dire"
        "ct convention for its data format.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICM",
        "Enables initial character mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ANACK",
        "Enables NACK generation for parity errors in receieved messages or whe"
        "n invalid initial characters are received in ICM mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ONACK",
        "Enables NACK generation when Rx FIFO is full and another message is re"
        "ady for writing into the FIFO.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FLSH_RX",
        "This bit operates as an EMV SIM receiver reset.",
        8, // LSB
        8, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FLSH_TX",
        "This bit operates as an EMV SIM transmitter reset.",
        9, // LSB
        9, // MSB
        false, // Readable
        false // Writable
    },
    {
        "SW_RST",
        "Used to reset the entire EMV SIM module.",
        10, // LSB
        10, // MSB
        false, // Readable
        false // Writable
    },
    {
        "KILL_CLOCKS",
        "Used to enable/disable the clock input to the EMV SIM module.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZE_EN",
        "Used to configure the operation of the EMV SIM module when a processor"
        " DOZE instruction is executed.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_EN",
        "Used to configure the operation of the EMV SIM module when a processor"
        " STOP instruction is executed.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCV_EN",
        "Used to enable/disable the EMV SIM receiver block.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XMT_EN",
        "Used to enable/disable the EMV SIM transmitter block.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCVR_11",
        "Used to configure the EMV SIM module receiver for 11 ETU operation (th"
        "at is, 1 Stop bit).",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_DMA_EN",
        "Enables assertion of DMA read request when Receive FIFO reaches the pr"
        "ogrammed data threshold value.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_DMA_EN",
        "Enables assertion of DMA write request when Transmit FIFO is empty.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INV_CRC_VAL",
        "This bit control whether the bits within the CRC Output value will be "
        "inverted (1's complement) or not.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_OUT_FLIP",
        "This bit control whether the bits in the CRC output bytes will be reve"
        "rsed or not.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_IN_FLIP",
        "This bit control whether the bits in the CRC input byte will be revers"
        "ed before CRC calculation or not.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CWT_EN",
        "Enables the character wait time counter.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LRC_EN",
        "This bit enables the calculation of the 8-bit LRC value for both recei"
        "ver and transmitter.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_EN",
        "This bit enables the calculation of the 16-bit CRC value for both rece"
        "iver and transmitter.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XMT_CRC_LRC",
        "This bit specifies whether or not to transmit the redundancy checking "
        "data (LRC or CRC) at the end of a transmission (that is, when the FIFO"
        " becomes empty).",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWT_EN",
        "Writing a '1' to this bit will enable the BWT and BGT functions.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_INT_MASK.
static const field_t hw_emvsim_int_mask[] =
{
    {
        "RDT_IM",
        "Used to enable/disable the ability of the RDTF flag in the RX_STATUS r"
        "egister to generate EMV SIM interrupts.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TC_IM",
        "Used to enable/disable the ability of the TCF flag in the TX_STATUS re"
        "gister to generate EMV SIM interrupts.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFO_IM",
        "Used to enable/disable the ability of the RFO flag in the RX_STATUS re"
        "gister to generate EMV SIM interrupts.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETC_IM",
        "Used to enable/disable the ability of the ETC flag in the TX_STATUS re"
        "gister to generate EMV SIM interrupts.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFE_IM",
        "Used to enable/disable the ability of the TFE flag in the TX_STATUS re"
        "gister to generate EMV SIM interrupts.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNACK_IM",
        "Used to enable/disable the ability of the TNTE flag in the TX_STATUS r"
        "egister to generate EMV SIM interrupts.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFF_IM",
        "Used to enable/disable the ability of the TFF flag in the TX_STATUS re"
        "gister to generate EMV SIM interrupts.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDT_IM",
        "Used to enable/disable the ability of the TDTF flag in the TX_STATUS r"
        "egister to generate EMV SIM interrupts.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPCNT0_IM",
        "Used to enable/disable the ability of the GPCNT0_TO flag in the TX_STA"
        "TUS register to generate EMV SIM interrupts.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CWT_ERR_IM",
        "Used to enable/disable the ability of the CWT_ERR flag in the RX_STATU"
        "S register to generate EMV SIM interrupts.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RNACK_IM",
        "Used to enable/disable the ability of the RTE flag in the RX_STATUS re"
        "gister to generate EMV SIM interrupts.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWT_ERR_IM",
        "Used to enable/disable the ability of the BWT_ERR flag in the RX_STATU"
        "S register to generate EMV SIM interrupts.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGT_ERR_IM",
        "Used to enable/disable the ability of the BGT_ERR flag in the RX_STATU"
        "S register to generate EMV SIM interrupts.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPCNT1_IM",
        "Used to enable/disable the ability of the GPCNT1_TO flag in the TX_STA"
        "TUS register to generate EMV SIM interrupts.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_DATA_IM",
        "Used to enable/disable the ability of the RX_DATA flag in the RX_STATU"
        "S register to generate EMV SIM interrupts.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEF_IM",
        "Used to enable/disable the ability of the PEF flag in the RX_STATUS re"
        "gister to generate EMV SIM interrupts.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_RX_THD.
static const field_t hw_emvsim_rx_thd[] =
{
    {
        "RDT",
        "Determines the number of bytes that must exist in the Receive FIFO to "
        "trigger the receive data threshold interrupt flag (RDTF).",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RNCK_THD",
        "Used to specify the number of consecutive NACK's transmitted by the EM"
        "V SIM module, for a given character, before the receive threshold erro"
        "r (RTE) flag is triggered.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_TX_THD.
static const field_t hw_emvsim_tx_thd[] =
{
    {
        "TDT",
        "Used to set the threshold value for the Transmit FIFO at which the TDT"
        "F bit in the TX_STATUS register will be set.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNCK_THD",
        "Used to set the NACK threshold for the transmitter.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_RX_STATUS.
static const field_t hw_emvsim_rx_status[] =
{
    {
        "RFO",
        "Used to indicate that the EMV SIM was unable to store received data du"
        "e to already unread bytes in the FIFO (FIFO full or almost full).",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_DATA",
        "Interrupt asserted when a new data byte is received and entered into t"
        "he Receive FIFO.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDTF",
        "Interrupt flag asserted when total bytes in the Receive FIFO equal or "
        "is greater than the programmed receive threshold RDT[3:0].",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LRC_OK",
        "Used to indicate when the calculated 8-bit LRC value is correct for th"
        "e current input data stream.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CRC_OK",
        "Used to indicate when the calculated 16-bit CRC value matches the expe"
        "cted value for the current input data stream.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CWT_ERR",
        "Used to indicate when the time between received characters is equal to"
        " or greater than the value programmed in the CHAR_WAIT register.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTE",
        "Used to indicate whether the number of consecutive NACK's generated by"
        " the EMV SIM module in response to receive parity errors, for the byte"
        " being received, equals the value programmed in the RTH[3:0] in the RX"
        "_THRESHOLD register.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWT_ERR",
        "Used to indicate if the block wait time has been exceeded.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGT_ERR",
        "Used to indicate if the block guard time was too small.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEF",
        "Used to indicate if a received byte had a parity error or not.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FEF",
        "Used to indicate if the current received byte did not have proper STOP"
        " bits.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_WPTR",
        "Value of write pointer of Receive FIFO",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_CNT",
        "These bits indicate the number of bytes stored in the receive FIFO.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_TX_STATUS.
static const field_t hw_emvsim_tx_status[] =
{
    {
        "TNTE",
        "Used to indicate the transmit NACK threshold has been reached.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFE",
        "Used to indicate that the EMV SIM transmit FIFO has been emptied.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETCF",
        "Used to indicate that the EMV SIM transmitter has finished sending the"
        " last byte in transmit FIFO (if XMT_CRC_LRC = 0) or finished sending t"
        "he LRC or CRC byte (if XMT_CRC_LRC = 1).",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCF",
        "Used to indicate whether the EMV SIM transmitter is ready for a new tr"
        "ansmission.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFF",
        "Used to indicate when the Transmit FIFO has been written with maximum "
        "number of bytes that it can store.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDTF",
        "Interrupt flag asserted when total bytes in the Transmit FIFO is less "
        "than or equal to the programmed transmit data threshold TDT[3:0].",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPCNT0_TO",
        "Used to indicate when the General Purpose Counter 0 has reached the GP"
        "CNT0_VAL value in the GPCNT_VAL register.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPCNT1_TO",
        "Used to indicate when the General Purpose Counter 1 has reached the GP"
        "CNT1_VAL value in the GPCNT_VAL register.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_RPTR",
        "Value of the read pointer of transmit FIFO.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_CNT",
        "These bits indicate the number of bytes stored in the transmit FIFO.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_PCSR.
static const field_t hw_emvsim_pcsr[] =
{
    {
        "SAPD",
        "Used to enable/disable the auto power down feature.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SVCC_EN",
        "Used to control the state of the SVEN pin on Smart Card port.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VCCENP",
        "Used to control the polarity of the SVEN output pad via the SVCC_EN bi"
        "t.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRST",
        "Used to control state of reset line to the Smart Card.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCEN",
        "Used to enable/disable the clock to the Smart Card.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCSP",
        "Used to control the polarity of the idle EMV SIM clock when the clock "
        "is disabled by SCEN.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPD",
        "Writing a '1' to this location will start the autopower down sequence "
        "provided the auto power down feature is enabled by writing '1' to SAPD"
        " bit of this register.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIM",
        "Interrupt mask for the presence detect interrupt flag (SPDIF).",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDIF",
        "Status flag to indicate that an insertion or removal of a Smart Card h"
        "as been detected on port.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPDP",
        "This bit reflects the state of the Smart Card Presence Detect pin.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPDES",
        "Controls which edge of the Smart Card Presence Detect pin is used to d"
        "etect the presence of the Smart Card.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_RX_BUF.
static const field_t hw_emvsim_rx_buf[] =
{
    {
        "RX_BYTE",
        "Provides the byte value from the top of the receive FIFO.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_TX_BUF.
static const field_t hw_emvsim_tx_buf[] =
{
    {
        "TX_BYTE",
        "Write to this register to fill the transmit FIFO with the bytes to be "
        "transmitted.",
        0, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_TX_GETU.
static const field_t hw_emvsim_tx_getu[] =
{
    {
        "GETU",
        "Used to control the number of additional Elementary Time Units (ETUs) "
        "inserted between bytes transmitted by the EMV SIM transmitter.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_CWT_VAL.
static const field_t hw_emvsim_cwt_val[] =
{
    {
        "CWT",
        "The value written to this register will specify the number of ETU time"
        "s allowed between characters.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_BWT_VAL.
static const field_t hw_emvsim_bwt_val[] =
{
    {
        "BWT",
        "The time from START bit of last byte sent from the EMV SIM module to t"
        "he START bit of the first byte sent from the Smart Card must be less t"
        "han the value in this register.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_BGT_VAL.
static const field_t hw_emvsim_bgt_val[] =
{
    {
        "BGT",
        "The value in this register is the block guard time.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_GPCNT0_VAL.
static const field_t hw_emvsim_gpcnt0_val[] =
{
    {
        "GPCNT0",
        "The value written to this register will be used to compare to the gene"
        "ral purpose counter 0 in the EMV SIM module.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EMVSIM_GPCNT1_VAL.
static const field_t hw_emvsim_gpcnt1_val[] =
{
    {
        "GPCNT1",
        "The value written to this register will be used to compare to the gene"
        "ral purpose counter in the EMV SIM module.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a EMVSIM module.
static const reg_t hw_emvsim[] =
{
    {
        "VER_ID",
        "Version ID for the IP.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_emvsim_ver_id
    },
    {
        "PARAM",
        "This register provides details on the parameter settings that were use"
        "d while including this module in the chip.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_emvsim_param
    },
    {
        "CLKCFG",
        "This register provides configuration details to enable the right clock"
        " frequency of clocks used by EMV SIM module.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_emvsim_clkcfg
    },
    {
        "DIVISOR",
        "This regiter configures the divisor value to generate the baud clock w"
        "hich will drive the card clock and also generate the transmit and rece"
        "ive clocks and respective ETUs.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_emvsim_divisor
    },
    {
        "CTRL",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        23, // Number of bitfields
        hw_emvsim_ctrl
    },
    {
        "INT_MASK",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_emvsim_int_mask
    },
    {
        "RX_THD",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_emvsim_rx_thd
    },
    {
        "TX_THD",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_emvsim_tx_thd
    },
    {
        "RX_STATUS",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_emvsim_rx_status
    },
    {
        "TX_STATUS",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_emvsim_tx_status
    },
    {
        "PCSR",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_emvsim_pcsr
    },
    {
        "RX_BUF",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_emvsim_rx_buf
    },
    {
        "TX_BUF",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_emvsim_tx_buf
    },
    {
        "TX_GETU",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_emvsim_tx_getu
    },
    {
        "CWT_VAL",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_emvsim_cwt_val
    },
    {
        "BWT_VAL",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_emvsim_bwt_val
    },
    {
        "BGT_VAL",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_emvsim_bgt_val
    },
    {
        "GPCNT0_VAL",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_emvsim_gpcnt0_val
    },
    {
        "GPCNT1_VAL",
        "",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_emvsim_gpcnt1_val
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ENET
#endif

// Bitfields in register ENET_EIR.
static const field_t hw_enet_eir[] =
{
    {
        "TS_TIMER",
        "The adjustable timer reached the period event.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TS_AVAIL",
        "Indicates that the timestamp of the last transmitted timing frame is a"
        "vailable in the ATSTMP register.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP",
        "Read-only status bit to indicate that a magic packet has been detected"
        ".",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLR",
        "Indicates a frame was received with a payload length error.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UN",
        "Indicates the transmit FIFO became empty before the complete frame was"
        " transmitted.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Indicates a collision occurred on each of 16 successive attempts to tr"
        "ansmit the frame.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LC",
        "Indicates a collision occurred beyond the collision window (slot time)"
        " in half-duplex mode.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EBERR",
        "Indicates a system bus error occurred when a uDMA transaction is under"
        "way.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MII",
        "Indicates that the MII has completed the data transfer requested.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXB",
        "Indicates a receive buffer descriptor is not the last in the frame has"
        " been updated.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXF",
        "Indicates a frame has been received and the last corresponding buffer "
        "descriptor has been updated.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXB",
        "Indicates a transmit buffer descriptor has been updated.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXF",
        "Indicates a frame has been transmitted and the last corresponding buff"
        "er descriptor has been updated.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRA",
        "This interrupt is asserted after the transmitter is put into a pause s"
        "tate after completion of the frame currently being transmitted.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BABT",
        "Indicates the transmitted frame length exceeds RCR[MAX_FL] bytes.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BABR",
        "Indicates a frame was received with length in excess of RCR[MAX_FL] by"
        "tes.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_EIMR.
static const field_t hw_enet_eimr[] =
{
    {
        "TS_TIMER",
        "Corresponds to interrupt source EIR[TS_TIMER] register and determines "
        "whether an interrupt condition can generate an interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TS_AVAIL",
        "Corresponds to interrupt source EIR[TS_AVAIL] register and determines "
        "whether an interrupt condition can generate an interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP",
        "Corresponds to interrupt source EIR[WAKEUP] register and determines wh"
        "ether an interrupt condition can generate an interrupt.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLR",
        "Corresponds to interrupt source EIR[PLR] and determines whether an int"
        "errupt condition can generate an interrupt.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UN",
        "Corresponds to interrupt source EIR[UN] and determines whether an inte"
        "rrupt condition can generate an interrupt.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RL",
        "Corresponds to interrupt source EIR[RL] and determines whether an inte"
        "rrupt condition can generate an interrupt.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LC",
        "Corresponds to interrupt source EIR[LC] and determines whether an inte"
        "rrupt condition can generate an interrupt.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EBERR",
        "Corresponds to interrupt source EIR[EBERR] and determines whether an i"
        "nterrupt condition can generate an interrupt.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MII",
        "Corresponds to interrupt source EIR[MII] and determines whether an int"
        "errupt condition can generate an interrupt.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXB",
        "Corresponds to interrupt source EIR[RXB] and determines whether an int"
        "errupt condition can generate an interrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXF",
        "Corresponds to interrupt source EIR[RXF] and determines whether an int"
        "errupt condition can generate an interrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXB",
        "Corresponds to interrupt source EIR[TXB] and determines whether an int"
        "errupt condition can generate an interrupt.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXF",
        "Corresponds to interrupt source EIR[TXF] and determines whether an int"
        "errupt condition can generate an interrupt.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRA",
        "Corresponds to interrupt source EIR[GRA] and determines whether an int"
        "errupt condition can generate an interrupt.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BABT",
        "Corresponds to interrupt source EIR[BABT] and determines whether an in"
        "terrupt condition can generate an interrupt.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BABR",
        "Corresponds to interrupt source EIR[BABR] and determines whether an in"
        "terrupt condition can generate an interrupt.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RDAR.
static const field_t hw_enet_rdar[] =
{
    {
        "RDAR",
        "Always set to 1 when this register is written, regardless of the value"
        " written.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TDAR.
static const field_t hw_enet_tdar[] =
{
    {
        "TDAR",
        "Always set to 1 when this register is written, regardless of the value"
        " written.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ECR.
static const field_t hw_enet_ecr[] =
{
    {
        "RESET",
        "When this field is set, it clears the ETHEREN field.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETHEREN",
        "Enables/disables the Ethernet MAC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAGICEN",
        "Enables/disables magic packet detection.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLEEP",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN1588",
        "Enables enhanced functionality of the MAC.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "Enables the MAC to enter hardware freeze mode when the device enters d"
        "ebug mode.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBSWP",
        "Swaps the byte locations of the buffer descriptors.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_MMFR.
static const field_t hw_enet_mmfr[] =
{
    {
        "DATA",
        "This is the field for data to be written to or read from the PHY regis"
        "ter.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TA",
        "This field must be programmed to 10 to generate a valid MII management"
        " frame.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RA",
        "See (Clause 22) or (Clause 45) for correct value.",
        18, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PA",
        "See (Clause 22) or (Clause 45) for correct value.",
        23, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OP",
        "See (Clause 22) or (Clause 45) for correct value.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ST",
        "See (Clause 22) or (Clause 45) for correct value.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_MSCR.
static const field_t hw_enet_mscr[] =
{
    {
        "MII_SPEED",
        "Controls the frequency of the MII management interface clock (MDC) rel"
        "ative to the internal module clock.",
        1, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIS_PRE",
        "Enables/disables prepending a preamble to the MII management frame.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOLDTIME",
        "IEEE802.3 clause 22 defines a minimum of 10 ns for the hold time on th"
        "e MDIO output.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_MIBC.
static const field_t hw_enet_mibc[] =
{
    {
        "MIB_CLEAR",
        "This field is not self-clearing.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MIB_IDLE",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIB_DIS",
        "If this control field is set,",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RCR.
static const field_t hw_enet_rcr[] =
{
    {
        "LOOP",
        "This is an MII internal loopback, therefore MII_MODE must be written t"
        "o 1 and RMII_MODE must be written to 0.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRT",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MII_MODE",
        "This field must always be set.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROM",
        "All frames are accepted regardless of address matching.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BC_REJ",
        "If set, frames with destination address (DA) equal to 0xFFFF_FFFF_FFFF"
        " are rejected unless the PROM field is set.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FCE",
        "If set, the receiver detects PAUSE frames.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RMII_MODE",
        "Specifies whether the MAC is configured for MII mode or RMII operation"
        " .",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RMII_10T",
        "Enables 10-Mbit/s mode of the RMII .",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PADEN",
        "Specifies whether the MAC removes padding from received frames.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAUFWD",
        "Specifies whether pause frames are terminated or forwarded.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRCFWD",
        "Specifies whether the CRC field of received frames is transmitted or s"
        "tripped.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CFEN",
        "Enables/disables the MAC control frame.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MAX_FL",
        "Resets to decimal 1518.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NLC",
        "Enables/disables a payload length check.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GRS",
        "Read-only status indicating that the MAC receive datapath is stopped.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCR.
static const field_t hw_enet_tcr[] =
{
    {
        "GTS",
        "When this field is set, MAC stops transmission after any frame current"
        "ly transmitted is complete and EIR[GRA] is set.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FDEN",
        "If this field is set, frames transmit independent of carrier sense and"
        " collision inputs.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFC_PAUSE",
        "Pauses frame transmission.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFC_PAUSE",
        "This status field is set when a full-duplex flow control pause frame i"
        "s received and the transmitter pauses for the duration defined in this"
        " pause frame.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADDSEL",
        "If ADDINS is set, indicates the MAC address that overwrites the source"
        " MAC address.",
        5, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDINS",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRCFWD",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_PALR.
static const field_t hw_enet_palr[] =
{
    {
        "PADDR1",
        "Bytes 0 (bits 31:24), 1 (bits 23:16), 2 (bits 15:8), and 3 (bits 7:0) "
        "of the 6-byte individual address are used for exact match and the sour"
        "ce address field in PAUSE frames.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_PAUR.
static const field_t hw_enet_paur[] =
{
    {
        "TYPE",
        "These fields have a constant value of 0x8808.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PADDR2",
        "Bytes 4 (bits 31:24) and 5 (bits 23:16) of the 6-byte individual addre"
        "ss used for exact match, and the source address field in PAUSE frames.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_OPD.
static const field_t hw_enet_opd[] =
{
    {
        "PAUSE_DUR",
        "Pause duration field used in PAUSE frames.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPCODE",
        "These fields have a constant value of 0x0001.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TXIC.
static const field_t hw_enet_txic[] =
{
    {
        "ICTT",
        "Interrupt coalescing timer threshold in units of 64 clock periods.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICFT",
        "This value determines the number of frames needed to be transmitted fo"
        "r raising an interrupt.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICCS",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICEN",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RXIC.
static const field_t hw_enet_rxic[] =
{
    {
        "ICTT",
        "Interrupt coalescing timer threshold in units of 64 clock periods.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICFT",
        "This value determines the number of frames needed to be received for r"
        "aising an interrupt.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICCS",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICEN",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IAUR.
static const field_t hw_enet_iaur[] =
{
    {
        "IADDR1",
        "Contains the upper 32 bits of the 64-bit hash table used in the addres"
        "s recognition process for receive frames with a unicast address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IALR.
static const field_t hw_enet_ialr[] =
{
    {
        "IADDR2",
        "Contains the lower 32 bits of the 64-bit hash table used in the addres"
        "s recognition process for receive frames with a unicast address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_GAUR.
static const field_t hw_enet_gaur[] =
{
    {
        "GADDR1",
        "Contains the upper 32 bits of the 64-bit hash table used in the addres"
        "s recognition process for receive frames with a multicast address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_GALR.
static const field_t hw_enet_galr[] =
{
    {
        "GADDR2",
        "Contains the lower 32 bits of the 64-bit hash table used in the addres"
        "s recognition process for receive frames with a multicast address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TFWR.
static const field_t hw_enet_tfwr[] =
{
    {
        "TFWR",
        "If TFWR[STRFWD] is cleared, this field indicates the number of bytes, "
        "in steps of 64 bytes, written to the transmit FIFO before transmission"
        " of a frame begins.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STRFWD",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RDSR.
static const field_t hw_enet_rdsr[] =
{
    {
        "R_DES_START",
        "Pointer to the beginning of the receive buffer descriptor queue.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TDSR.
static const field_t hw_enet_tdsr[] =
{
    {
        "X_DES_START",
        "Pointer to the beginning of the transmit buffer descriptor queue.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_MRBR.
static const field_t hw_enet_mrbr[] =
{
    {
        "R_BUF_SIZE",
        "Receive buffer size in bytes.",
        4, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RSFL.
static const field_t hw_enet_rsfl[] =
{
    {
        "RX_SECTION_FULL",
        "Value, in 64-bit words, of the receive FIFO section full threshold.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RSEM.
static const field_t hw_enet_rsem[] =
{
    {
        "RX_SECTION_EMPTY",
        "Value, in 64-bit words, of the receive FIFO section empty threshold.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STAT_SECTION_EMPTY",
        "Defines number of frames in the receive FIFO, independent of its size,"
        " that can be accepted.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RAEM.
static const field_t hw_enet_raem[] =
{
    {
        "RX_ALMOST_EMPTY",
        "Value, in 64-bit words, of the receive FIFO almost empty threshold.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RAFL.
static const field_t hw_enet_rafl[] =
{
    {
        "RX_ALMOST_FULL",
        "Value, in 64-bit words, of the receive FIFO almost full threshold.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TSEM.
static const field_t hw_enet_tsem[] =
{
    {
        "TX_SECTION_EMPTY",
        "Value, in 64-bit words, of the transmit FIFO section empty threshold.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TAEM.
static const field_t hw_enet_taem[] =
{
    {
        "TX_ALMOST_EMPTY",
        "Value, in 64-bit words, of the transmit FIFO almost empty threshold.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TAFL.
static const field_t hw_enet_tafl[] =
{
    {
        "TX_ALMOST_FULL",
        "Value, in 64-bit words, of the transmit FIFO almost full threshold.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TIPG.
static const field_t hw_enet_tipg[] =
{
    {
        "IPG",
        "Indicates the IPG, in bytes, between transmitted frames.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_FTRL.
static const field_t hw_enet_ftrl[] =
{
    {
        "TRUNC_FL",
        "Indicates the value a receive frame is truncated, if it is greater tha"
        "n this value.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TACC.
static const field_t hw_enet_tacc[] =
{
    {
        "SHIFT16",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPCHK",
        "Enables insertion of IP header checksum.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROCHK",
        "Enables insertion of protocol checksum.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RACC.
static const field_t hw_enet_racc[] =
{
    {
        "PADREM",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPDIS",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRODIS",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LINEDIS",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHIFT16",
        "When this field is set, the actual frame data starts at bit 16 of the "
        "first word read from the RX FIFO aligning the Ethernet payload on a 32"
        "-bit boundary.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_DROP.
static const field_t hw_enet_rmon_t_drop[] =
{
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_PACKETS.
static const field_t hw_enet_rmon_t_packets[] =
{
    {
        "TXPKTS",
        "Transmit packet count",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_BC_PKT.
static const field_t hw_enet_rmon_t_bc_pkt[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_MC_PKT.
static const field_t hw_enet_rmon_t_mc_pkt[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_CRC_ALIGN.
static const field_t hw_enet_rmon_t_crc_align[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_UNDERSIZE.
static const field_t hw_enet_rmon_t_undersize[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_OVERSIZE.
static const field_t hw_enet_rmon_t_oversize[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_FRAG.
static const field_t hw_enet_rmon_t_frag[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_JAB.
static const field_t hw_enet_rmon_t_jab[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_COL.
static const field_t hw_enet_rmon_t_col[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_P64.
static const field_t hw_enet_rmon_t_p64[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_P65TO127.
static const field_t hw_enet_rmon_t_p65to127[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_P128TO255.
static const field_t hw_enet_rmon_t_p128to255[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_P256TO511.
static const field_t hw_enet_rmon_t_p256to511[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_P512TO1023.
static const field_t hw_enet_rmon_t_p512to1023[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_P1024TO2047.
static const field_t hw_enet_rmon_t_p1024to2047[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_P_GTE2048.
static const field_t hw_enet_rmon_t_p_gte2048[] =
{
    {
        "TXPKTS",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_T_OCTETS.
static const field_t hw_enet_rmon_t_octets[] =
{
    {
        "TXOCTS",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_DROP.
static const field_t hw_enet_ieee_t_drop[] =
{
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_FRAME_OK.
static const field_t hw_enet_ieee_t_frame_ok[] =
{
    {
        "COUNT",
        "Does not increment for the broadcast frames when broadcast reject is e"
        "nabled and promiscuous mode is disabled within the receive control reg"
        "ister (RCR).",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_1COL.
static const field_t hw_enet_ieee_t_1col[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_MCOL.
static const field_t hw_enet_ieee_t_mcol[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_DEF.
static const field_t hw_enet_ieee_t_def[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_LCOL.
static const field_t hw_enet_ieee_t_lcol[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_EXCOL.
static const field_t hw_enet_ieee_t_excol[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_MACERR.
static const field_t hw_enet_ieee_t_macerr[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_CSERR.
static const field_t hw_enet_ieee_t_cserr[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_SQE.
static const field_t hw_enet_ieee_t_sqe[] =
{
    {
        "COUNT",
        "Counter not implemented (always reads zero) as no SQE information is a"
        "vailable.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_FDXFC.
static const field_t hw_enet_ieee_t_fdxfc[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_T_OCTETS_OK.
static const field_t hw_enet_ieee_t_octets_ok[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_PACKETS.
static const field_t hw_enet_rmon_r_packets[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_BC_PKT.
static const field_t hw_enet_rmon_r_bc_pkt[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_MC_PKT.
static const field_t hw_enet_rmon_r_mc_pkt[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_CRC_ALIGN.
static const field_t hw_enet_rmon_r_crc_align[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_UNDERSIZE.
static const field_t hw_enet_rmon_r_undersize[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_OVERSIZE.
static const field_t hw_enet_rmon_r_oversize[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_FRAG.
static const field_t hw_enet_rmon_r_frag[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_JAB.
static const field_t hw_enet_rmon_r_jab[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_RESVD_0.
static const field_t hw_enet_rmon_r_resvd_0[] =
{
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_P64.
static const field_t hw_enet_rmon_r_p64[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_P65TO127.
static const field_t hw_enet_rmon_r_p65to127[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_P128TO255.
static const field_t hw_enet_rmon_r_p128to255[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_P256TO511.
static const field_t hw_enet_rmon_r_p256to511[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_P512TO1023.
static const field_t hw_enet_rmon_r_p512to1023[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_P1024TO2047.
static const field_t hw_enet_rmon_r_p1024to2047[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_P_GTE2048.
static const field_t hw_enet_rmon_r_p_gte2048[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_RMON_R_OCTETS.
static const field_t hw_enet_rmon_r_octets[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_R_DROP.
static const field_t hw_enet_ieee_r_drop[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_R_FRAME_OK.
static const field_t hw_enet_ieee_r_frame_ok[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_R_CRC.
static const field_t hw_enet_ieee_r_crc[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_R_ALIGN.
static const field_t hw_enet_ieee_r_align[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_R_MACERR.
static const field_t hw_enet_ieee_r_macerr[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_R_FDXFC.
static const field_t hw_enet_ieee_r_fdxfc[] =
{
    {
        "COUNT",
        "",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_IEEE_R_OCTETS_OK.
static const field_t hw_enet_ieee_r_octets_ok[] =
{
    {
        "COUNT",
        "Counts total octets (includes header and FCS fields).",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATCR.
static const field_t hw_enet_atcr[] =
{
    {
        "EN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFEN",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OFFRST",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEREN",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PINPER",
        "Enables event signal output assertion on period event.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESTART",
        "Resets the timer to zero.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAPTURE",
        "When this field is set, all other fields are ignored during a write.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLAVE",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATVR.
static const field_t hw_enet_atvr[] =
{
    {
        "ATIME",
        "A write sets the timer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATOFF.
static const field_t hw_enet_atoff[] =
{
    {
        "OFFSET",
        "Offset value for one-shot event generation.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATPER.
static const field_t hw_enet_atper[] =
{
    {
        "PERIOD",
        "Value for generating periodic events.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATCOR.
static const field_t hw_enet_atcor[] =
{
    {
        "COR",
        "Defines after how many timer clock cycles (ts_clk) the correction coun"
        "ter should be reset and trigger a correction increment on the timer.",
        0, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATINC.
static const field_t hw_enet_atinc[] =
{
    {
        "INC",
        "The timer increments by this amount each clock cycle.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INC_CORR",
        "This value is added every time the correction timer expires (every clo"
        "ck cycle given in ATCOR).",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_ATSTMP.
static const field_t hw_enet_atstmp[] =
{
    {
        "TIMESTAMP",
        "Timestamp of the last frame transmitted by the core that had TxBD[TS] "
        "set .",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TGSR.
static const field_t hw_enet_tgsr[] =
{
    {
        "TF0",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF1",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF2",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF3",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCSR0.
static const field_t hw_enet_tcsr0[] =
{
    {
        "TDRE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMODE",
        "Updating the Timer Mode field takes a few cycles to register because i"
        "t is synchronized to the 1588 clock.",
        2, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF",
        "Sets when input capture or output compare occurs.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPWC",
        "Specifies the pulse width associated with TMODE values of 1110 or 11X1"
        ".",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCCR0.
static const field_t hw_enet_tccr0[] =
{
    {
        "TCC",
        "This register is double buffered between the module clock and 1588 clo"
        "ck domains.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCSR1.
static const field_t hw_enet_tcsr1[] =
{
    {
        "TDRE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMODE",
        "Updating the Timer Mode field takes a few cycles to register because i"
        "t is synchronized to the 1588 clock.",
        2, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF",
        "Sets when input capture or output compare occurs.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPWC",
        "Specifies the pulse width associated with TMODE values of 1110 or 11X1"
        ".",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCCR1.
static const field_t hw_enet_tccr1[] =
{
    {
        "TCC",
        "This register is double buffered between the module clock and 1588 clo"
        "ck domains.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCSR2.
static const field_t hw_enet_tcsr2[] =
{
    {
        "TDRE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMODE",
        "Updating the Timer Mode field takes a few cycles to register because i"
        "t is synchronized to the 1588 clock.",
        2, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF",
        "Sets when input capture or output compare occurs.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPWC",
        "Specifies the pulse width associated with TMODE values of 1110 or 11X1"
        ".",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCCR2.
static const field_t hw_enet_tccr2[] =
{
    {
        "TCC",
        "This register is double buffered between the module clock and 1588 clo"
        "ck domains.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCSR3.
static const field_t hw_enet_tcsr3[] =
{
    {
        "TDRE",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMODE",
        "Updating the Timer Mode field takes a few cycles to register because i"
        "t is synchronized to the 1588 clock.",
        2, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TF",
        "Sets when input capture or output compare occurs.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPWC",
        "Specifies the pulse width associated with TMODE values of 1110 or 11X1"
        ".",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ENET_TCCR3.
static const field_t hw_enet_tccr3[] =
{
    {
        "TCC",
        "This register is double buffered between the module clock and 1588 clo"
        "ck domains.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ENET module.
static const reg_t hw_enet[] =
{
    {
        "EIR",
        "When an event occurs that sets a bit in EIR, an interrupt occurs if th"
        "e corresponding bit in the interrupt mask register (EIMR) is also set.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_enet_eir
    },
    {
        "EIMR",
        "EIMR controls which interrupt events are allowed to generate actual in"
        "terrupts.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_enet_eimr
    },
    {
        "RDAR",
        "RDAR is a command register, written by the user, to indicate that the "
        "receive descriptor ring has been updated, that is, that the driver pro"
        "duced empty receive buffers with the empty bit set.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_rdar
    },
    {
        "TDAR",
        "The TDAR is a command register that the user writes to indicate that t"
        "he transmit descriptor ring has been updated, that is, that transmit b"
        "uffers have been produced by the driver with the ready bit set in the "
        "buffer descriptor.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tdar
    },
    {
        "ECR",
        "ECR is a read/write user register, though hardware may also alter fiel"
        "ds in this register.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_enet_ecr
    },
    {
        "MMFR",
        "Writing to MMFR triggers a management frame transaction to the PHY dev"
        "ice unless MSCR is programmed to zero.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_enet_mmfr
    },
    {
        "MSCR",
        "MSCR provides control of the MII clock (MDC pin) frequency and allows "
        "a preamble drop on the MII management frame.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_enet_mscr
    },
    {
        "MIBC",
        "MIBC is a read/write register controlling and observing the state of t"
        "he MIB block.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_enet_mibc
    },
    {
        "RCR",
        "",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_enet_rcr
    },
    {
        "TCR",
        "TCR is read/write and configures the transmit block.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_enet_tcr
    },
    {
        "PALR",
        "PALR contains the lower 32 bits (bytes 0, 1, 2, 3) of the 48-bit addre"
        "ss used in the address recognition process to compare with the destina"
        "tion address (DA) field of receive frames with an individual DA.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_palr
    },
    {
        "PAUR",
        "PAUR contains the upper 16 bits (bytes 4 and 5) of the 48-bit address "
        "used in the address recognition process to compare with the destinatio"
        "n address (DA) field of receive frames with an individual DA.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_enet_paur
    },
    {
        "OPD",
        "OPD is read/write accessible.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_enet_opd
    },
    {
        "TXIC",
        "See Interrupt coalescence for more information.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_enet_txic
    },
    {
        "RXIC",
        "See Interrupt coalescence for more information.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_enet_rxic
    },
    {
        "IAUR",
        "IAUR contains the upper 32 bits of the 64-bit individual address hash "
        "table.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_iaur
    },
    {
        "IALR",
        "IALR contains the lower 32 bits of the 64-bit individual address hash "
        "table.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_ialr
    },
    {
        "GAUR",
        "GAUR contains the upper 32 bits of the 64-bit hash table used in the a"
        "ddress recognition process for receive frames with a multicast address"
        ".",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_gaur
    },
    {
        "GALR",
        "GALR contains the lower 32 bits of the 64-bit hash table used in the a"
        "ddress recognition process for receive frames with a multicast address"
        ".",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_galr
    },
    {
        "TFWR",
        "If TFWR[STRFWD] is cleared, TFWR[TFWR] controls the amount of data req"
        "uired in the transmit FIFO before transmission of a frame can begin.",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_enet_tfwr
    },
    {
        "RDSR",
        "RDSR points to the beginning of the circular receive buffer descriptor"
        " queue in external memory.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_rdsr
    },
    {
        "TDSR",
        "TDSR provides a pointer to the beginning of the circular transmit buff"
        "er descriptor queue in external memory.",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tdsr
    },
    {
        "MRBR",
        "The MRBR is a user-programmable register that dictates the maximum siz"
        "e of all receive buffers.",
        4, // Width in bytes
        0x00000188, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_mrbr
    },
    {
        "RSFL",
        "",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_rsfl
    },
    {
        "RSEM",
        "",
        4, // Width in bytes
        0x00000194, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_enet_rsem
    },
    {
        "RAEM",
        "",
        4, // Width in bytes
        0x00000198, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_raem
    },
    {
        "RAFL",
        "",
        4, // Width in bytes
        0x0000019c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_rafl
    },
    {
        "TSEM",
        "",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tsem
    },
    {
        "TAEM",
        "",
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_taem
    },
    {
        "TAFL",
        "",
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tafl
    },
    {
        "TIPG",
        "",
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tipg
    },
    {
        "FTRL",
        "",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_ftrl
    },
    {
        "TACC",
        "TACC controls accelerator actions when sending frames.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_enet_tacc
    },
    {
        "RACC",
        "",
        4, // Width in bytes
        0x000001c4, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_enet_racc
    },
    {
        "RMON_T_DROP",
        "",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_enet_rmon_t_drop
    },
    {
        "RMON_T_PACKETS",
        "",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_packets
    },
    {
        "RMON_T_BC_PKT",
        "RMON Tx Broadcast Packets",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_bc_pkt
    },
    {
        "RMON_T_MC_PKT",
        "",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_mc_pkt
    },
    {
        "RMON_T_CRC_ALIGN",
        "",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_crc_align
    },
    {
        "RMON_T_UNDERSIZE",
        "",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_undersize
    },
    {
        "RMON_T_OVERSIZE",
        "",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_oversize
    },
    {
        "RMON_T_FRAG",
        ".",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_frag
    },
    {
        "RMON_T_JAB",
        "",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_jab
    },
    {
        "RMON_T_COL",
        "",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_col
    },
    {
        "RMON_T_P64",
        ".",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_p64
    },
    {
        "RMON_T_P65TO127",
        "",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_p65to127
    },
    {
        "RMON_T_P128TO255",
        "",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_p128to255
    },
    {
        "RMON_T_P256TO511",
        "",
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_p256to511
    },
    {
        "RMON_T_P512TO1023",
        ".",
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_p512to1023
    },
    {
        "RMON_T_P1024TO2047",
        "",
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_p1024to2047
    },
    {
        "RMON_T_P_GTE2048",
        "",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_p_gte2048
    },
    {
        "RMON_T_OCTETS",
        "",
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_t_octets
    },
    {
        "IEEE_T_DROP",
        "",
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_enet_ieee_t_drop
    },
    {
        "IEEE_T_FRAME_OK",
        "",
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_frame_ok
    },
    {
        "IEEE_T_1COL",
        "",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_1col
    },
    {
        "IEEE_T_MCOL",
        "",
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_mcol
    },
    {
        "IEEE_T_DEF",
        "",
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_def
    },
    {
        "IEEE_T_LCOL",
        "",
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_lcol
    },
    {
        "IEEE_T_EXCOL",
        "",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_excol
    },
    {
        "IEEE_T_MACERR",
        "",
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_macerr
    },
    {
        "IEEE_T_CSERR",
        "",
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_cserr
    },
    {
        "IEEE_T_SQE",
        "",
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_sqe
    },
    {
        "IEEE_T_FDXFC",
        "",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_fdxfc
    },
    {
        "IEEE_T_OCTETS_OK",
        "",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_t_octets_ok
    },
    {
        "RMON_R_PACKETS",
        "",
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_packets
    },
    {
        "RMON_R_BC_PKT",
        "",
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_bc_pkt
    },
    {
        "RMON_R_MC_PKT",
        "",
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_mc_pkt
    },
    {
        "RMON_R_CRC_ALIGN",
        "",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_crc_align
    },
    {
        "RMON_R_UNDERSIZE",
        "",
        4, // Width in bytes
        0x00000294, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_undersize
    },
    {
        "RMON_R_OVERSIZE",
        "",
        4, // Width in bytes
        0x00000298, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_oversize
    },
    {
        "RMON_R_FRAG",
        "",
        4, // Width in bytes
        0x0000029c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_frag
    },
    {
        "RMON_R_JAB",
        "",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_jab
    },
    {
        "RMON_R_RESVD_0",
        "",
        4, // Width in bytes
        0x000002a4, // Base address offset
        false, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_enet_rmon_r_resvd_0
    },
    {
        "RMON_R_P64",
        "",
        4, // Width in bytes
        0x000002a8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_p64
    },
    {
        "RMON_R_P65TO127",
        "",
        4, // Width in bytes
        0x000002ac, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_p65to127
    },
    {
        "RMON_R_P128TO255",
        "",
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_p128to255
    },
    {
        "RMON_R_P256TO511",
        "",
        4, // Width in bytes
        0x000002b4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_p256to511
    },
    {
        "RMON_R_P512TO1023",
        "",
        4, // Width in bytes
        0x000002b8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_p512to1023
    },
    {
        "RMON_R_P1024TO2047",
        "",
        4, // Width in bytes
        0x000002bc, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_p1024to2047
    },
    {
        "RMON_R_P_GTE2048",
        "",
        4, // Width in bytes
        0x000002c0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_p_gte2048
    },
    {
        "RMON_R_OCTETS",
        "",
        4, // Width in bytes
        0x000002c4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_rmon_r_octets
    },
    {
        "IEEE_R_DROP",
        "Counter increments if a frame with invalid or missing SFD character is"
        " detected and has been dropped.",
        4, // Width in bytes
        0x000002c8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_r_drop
    },
    {
        "IEEE_R_FRAME_OK",
        "",
        4, // Width in bytes
        0x000002cc, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_r_frame_ok
    },
    {
        "IEEE_R_CRC",
        "",
        4, // Width in bytes
        0x000002d0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_r_crc
    },
    {
        "IEEE_R_ALIGN",
        "",
        4, // Width in bytes
        0x000002d4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_r_align
    },
    {
        "IEEE_R_MACERR",
        "",
        4, // Width in bytes
        0x000002d8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_r_macerr
    },
    {
        "IEEE_R_FDXFC",
        "",
        4, // Width in bytes
        0x000002dc, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_r_fdxfc
    },
    {
        "IEEE_R_OCTETS_OK",
        "",
        4, // Width in bytes
        0x000002e0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_ieee_r_octets_ok
    },
    {
        "ATCR",
        "ATCR command fields can trigger the corresponding events directly.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_enet_atcr
    },
    {
        "ATVR",
        "",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_atvr
    },
    {
        "ATOFF",
        "",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_atoff
    },
    {
        "ATPER",
        "",
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_atper
    },
    {
        "ATCOR",
        "",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_atcor
    },
    {
        "ATINC",
        "",
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_enet_atinc
    },
    {
        "ATSTMP",
        "",
        4, // Width in bytes
        0x00000418, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_enet_atstmp
    },
    {
        "TGSR",
        "",
        4, // Width in bytes
        0x00000604, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_enet_tgsr
    },
    {
        "TCSR0",
        "",
        4, // Width in bytes
        0x00000608, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_enet_tcsr0
    },
    {
        "TCCR0",
        "",
        4, // Width in bytes
        0x0000060c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tccr0
    },
    {
        "TCSR1",
        "",
        4, // Width in bytes
        0x00000610, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_enet_tcsr1
    },
    {
        "TCCR1",
        "",
        4, // Width in bytes
        0x00000614, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tccr1
    },
    {
        "TCSR2",
        "",
        4, // Width in bytes
        0x00000618, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_enet_tcsr2
    },
    {
        "TCCR2",
        "",
        4, // Width in bytes
        0x0000061c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tccr2
    },
    {
        "TCSR3",
        "",
        4, // Width in bytes
        0x00000620, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_enet_tcsr3
    },
    {
        "TCCR3",
        "",
        4, // Width in bytes
        0x00000624, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_enet_tccr3
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark EPIT
#endif

// Bitfields in register EPIT_CR.
static const field_t hw_epit_cr[] =
{
    {
        "EN",
        "This bit enables the EPIT.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENMOD",
        "EPIT enable mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCIEN",
        "Output compare interrupt enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RLD",
        "Counter reload control.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESCALAR",
        "Counter clock prescaler value.",
        4, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Software reset.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IOVW",
        "EPIT counter overwrite enable.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "This bit is used to keep the EPIT functional in debug mode.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAITEN",
        "This read/write control bit enables the operation of the EPIT during w"
        "ait mode.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPEN",
        "EPIT stop mode enable.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OM",
        "EPIT output mode.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKSRC",
        "Select clock source These bits determine which clock input is to be se"
        "lected for running the counter.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPIT_SR.
static const field_t hw_epit_sr[] =
{
    {
        "OCIF",
        "Output compare interrupt flag.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPIT_LR.
static const field_t hw_epit_lr[] =
{
    {
        "LOAD",
        "Load value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPIT_CMPR.
static const field_t hw_epit_cmpr[] =
{
    {
        "COMPARE",
        "Compare Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register EPIT_CNR.
static const field_t hw_epit_cnr[] =
{
    {
        "COUNT",
        "Counter value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a EPIT module.
static const reg_t hw_epit[] =
{
    {
        "CR",
        "The EPIT control register (EPIT_CR) is used to configure the operating"
        " settings of the EPIT.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_epit_cr
    },
    {
        "SR",
        "The EPIT status register (EPIT_SR) has a single status bit for the out"
        "put compare event.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epit_sr
    },
    {
        "LR",
        "The EPIT load register (EPIT_LR) contains the value that is to be load"
        "ed into the counter when EPIT counter reaches zero if the RLD bit in E"
        "PIT_CR is set.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epit_lr
    },
    {
        "CMPR",
        "The EPIT compare register (EPIT_CMPR) holds the value that determines "
        "when a compare event is generated.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_epit_cmpr
    },
    {
        "CNR",
        "The EPIT counter register (EPIT_CNR) contains the current count value "
        "and can be read at any time without disturbing the counter.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_epit_cnr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark FLEXCAN
#endif

// Bitfields in register FLEXCAN_MCR.
static const field_t hw_flexcan_mcr[] =
{
    {
        "MAXMB",
        "This 7-bit field defines the number of the last Message Buffers that w"
        "ill take part in the matching and arbitration processes.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDAM",
        "This 2-bit field identifies the format of the elements of the Rx FIFO "
        "filter table, as shown below.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AEN",
        "This bit is supplied for backwards compatibility reasons.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPRIO_EN",
        "This bit is provided for backwards compatibility reasons.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRMQ",
        "This bit indicates whether Rx matching process will be based either on"
        " individual masking and queue or on masking scheme with RXMGMASK, RX14"
        "MASK and RX15MASK, RXFGMASK.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRX_DIS",
        "This bit defines whether FlexCAN is allowed to receive frames transmit"
        "ted by itself.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAK_SRC",
        "This bit defines whether the integrated low-pass filter is applied to "
        "protect the FLEXCAN_RX input from spurious wake up.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPM_ACK",
        "This read-only bit indicates that FLEXCAN is either in Disable Mode or"
        " Stop Mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WRN_EN",
        "When asserted, this bit enables the generation of the TWRN_INT and RWR"
        "N_INT flags in the Error and Status Register.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLF_WAK",
        "This bit enables the Self Wake Up feature when FLEXCAN is in Stop Mode"
        ".",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUPV",
        "This bit configures some of the FLEXCAN registers to be either in Supe"
        "rvisor or User Mode.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRZ_ACK",
        "This read-only bit indicates that FLEXCAN is in Freeze Mode and its pr"
        "escaler is stopped.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SOFT_RST",
        "When this bit is asserted, FlexCAN resets its internal state machines "
        "and some of the memory mapped registers.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAK_MSK",
        "This bit enables the Wake Up Interrupt generation.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NOT_RDY",
        "This read-only bit indicates that FLEXCAN is either in Disable Mode, S"
        "top Mode or Freeze Mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HALT",
        "Assertion of this bit puts the FLEXCAN module into Freeze Mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFEN",
        "This bit controls whether the Rx FIFO feature is enabled or not.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRZ",
        "The FRZ bit specifies the FLEXCAN behavior when the HALT bit in the MC"
        "R Register is set or when Debug Mode is requested at ARM level.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MDIS",
        "This bit controls whether FLEXCAN is enabled or not.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_CTRL1.
static const field_t hw_flexcan_ctrl1[] =
{
    {
        "PROP_SEG",
        "This 3-bit field defines the length of the Propagation Segment in the "
        "bit time.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOM",
        "This bit configures FLEXCAN to operate in Listen Only Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LBUF",
        "This bit defines the ordering mechanism for Message Buffer transmissio"
        "n.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TSYN",
        "This bit enables a mechanism that resets the free-running timer each t"
        "ime a message is received in Message Buffer 0.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOFF_REC",
        "This bit defines how FLEXCAN recovers from Bus Off state.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMP",
        "This bit defines the sampling mode of CAN bits at the FLEXCAN_RX.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWRN_MSK",
        "This bit provides a mask for the Rx Warning Interrupt associated with "
        "the RWRN_INT flag in the Error and Status Register.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWRN_MSK",
        "This bit provides a mask for the Tx Warning Interrupt associated with "
        "the TWRN_INT flag in the Error and Status Register.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPB",
        "This bit configures FlexCAN to operate in Loop-Back Mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR_MSK",
        "This bit provides a mask for the Error Interrupt.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOFF_MSK",
        "This bit provides a mask for the Bus Off Interrupt.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSEG2",
        "This 3-bit field defines the length of Phase Buffer Segment 2 in the b"
        "it time.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSEG1",
        "This 3-bit field defines the length of Phase Buffer Segment 1 in the b"
        "it time.",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RJW",
        "This 2-bit field defines the maximum number of time quanta One time qu"
        "antum is equal to the Sclock period.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESDIV",
        "This 8-bit field defines the ratio between the PE clock frequency and "
        "the Serial Clock (Sclock) frequency.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_TIMER.
static const field_t hw_flexcan_timer[] =
{
    {
        "TIMER",
        "TIMER",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RXMGMASK.
static const field_t hw_flexcan_rxmgmask[] =
{
    {
        "MG31_MG0",
        "These bits mask the Mailbox filter bits as shown in the figure above.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RX14MASK.
static const field_t hw_flexcan_rx14mask[] =
{
    {
        "RX14M31_RX14M0",
        "These bits mask Mailbox 14 filter bits in the same fashion as RXMGMASK"
        " masks other Mailboxes filters (see RXMGMASKRx Mailboxes Global Mask R"
        "egister )",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RX15MASK.
static const field_t hw_flexcan_rx15mask[] =
{
    {
        "RX15M31_RX15M0",
        "These bits mask Mailbox 15 filter bits in the same fashion as RXMGMASK"
        " masks other Mailboxes filters (see RXMGMASKRx Mailboxes Global Mask R"
        "egister ).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_ECR.
static const field_t hw_flexcan_ecr[] =
{
    {
        "TX_ERR_COUNTER",
        "Tx_Err_Counter",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX_ERR_COUNTER",
        "Rx_Err_Counter",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_ESR1.
static const field_t hw_flexcan_esr1[] =
{
    {
        "WAK_INT",
        "When FLEXCAN is Stop Mode and a recessive to dominant transition is de"
        "tected on the CAN bus and if the WAK_MSK bit in the MCR Register is se"
        "t, an interrupt is generated to the ARM.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ERR_INT",
        "This bit indicates that at least one of the Error Bits (bits 15-10) is"
        " set.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOFF_INT",
        "This bit is set when FLEXCAN enters 'Bus Off' state.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RX",
        "This bit indicates if FlexCAN is receiving a message.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FLT_CONF",
        "If the LOM bit in the Control Register is asserted, after some delay t"
        "hat depends on the CAN bit timing the FLT_CONF field will indicate \"E"
        "rror Passive\".",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX",
        "This bit indicates if FLEXCAN is transmitting a message.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDLE",
        "This bit indicates when CAN bus is in IDLE state.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RX_WRN",
        "This bit indicates when repetitive errors are occurring during message"
        " reception.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX_WRN",
        "This bit indicates when repetitive errors are occurring during message"
        " transmission.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STF_ERR",
        "This bit indicates that a Stuffing Error has been detected.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FRM_ERR",
        "This bit indicates that a Form Error has been detected by the receiver"
        " node, i.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CRC_ERR",
        "This bit indicates that a CRC Error has been detected by the receiver "
        "node, i.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ACK_ERR",
        "This bit indicates that an Acknowledge Error has been detected by the "
        "transmitter node, i.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BIT0_ERR",
        "This bit indicates when an inconsistency occurs between the transmitte"
        "d and the received bit in a message.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BIT1_ERR",
        "This bit indicates when an inconsistency occurs between the transmitte"
        "d and the received bit in a message.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RWRN_INT",
        "If the WRN_EN bit in MCR is asserted, the RWRN_INT bit is set when the"
        " RX_WRN flag transition from '0' to '1', meaning that the Rx error cou"
        "nters reached 96.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWRN_INT",
        "If the WRN_EN bit in MCR is asserted, the TWRN_INT bit is set when the"
        " TX_WRN flag transition from '0' to '1', meaning that the Tx error cou"
        "nter reached 96.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNCH",
        "This read-only flag indicates whether the FlexCAN is synchronized to t"
        "he CAN bus and able to participate in the communication process.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_IMASK2.
static const field_t hw_flexcan_imask2[] =
{
    {
        "BUF63M_BUF32M",
        "Each bit enables or disables the respective FLEXCAN Message Buffer (MB"
        "32 to MB63) Interrupt.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_IMASK1.
static const field_t hw_flexcan_imask1[] =
{
    {
        "BUF31M_BUF0M",
        "Each bit enables or disables the respective FLEXCAN Message Buffer (MB"
        "0 to MB31) Interrupt.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_IFLAG2.
static const field_t hw_flexcan_iflag2[] =
{
    {
        "BUF63I_BUF32I",
        "Each bit flags the respective FLEXCAN Message Buffer (MB32 to MB63) in"
        "terrupt.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_IFLAG1.
static const field_t hw_flexcan_iflag1[] =
{
    {
        "BUF4I_BUF0I",
        "If the Rx FIFO is not enabled, these bits flag the interrupts for MB0 "
        "to MB4.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUF5I",
        "If the Rx FIFO is not enabled, this bit flags the interrupt for MB5.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUF6I",
        "If the Rx FIFO is not enabled, this bit flags the interrupt for MB6.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUF7I",
        "If the Rx FIFO is not enabled, this bit flags the interrupt for MB7.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUF31I_BUF8I",
        "Each bit flags the respective FLEXCAN Message Buffer (MB8 to MB31) int"
        "errupt.",
        8, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_CTRL2.
static const field_t hw_flexcan_ctrl2[] =
{
    {
        "EACEN",
        "This bit controls the comparison of IDE and RTR bits within Rx Mailbox"
        "es filters with their corresponding bits in the incoming frame by the "
        "matching process.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RRS",
        "If this bit is asserted Remote Request Frame is submitted to a matchin"
        "g process and stored in the corresponding Message Buffer in the same f"
        "ashion of a Data Frame.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MRP",
        "If this bit is set the matching process starts from the Mailboxes and "
        "if no match occurs the matching continues on the Rx FIFO.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TASD",
        "This 5-bit field indicates how many CAN bits the Tx arbitration proces"
        "s start point can be delayed from the first bit of CRC field on CAN bu"
        "s.",
        19, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFFN",
        "This 4-bit field defines the number of Rx FIFO filters according to .",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRMFRZ",
        "Enable unrestricted write access to FlexCAN memory in Freeze mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_ESR2.
static const field_t hw_flexcan_esr2[] =
{
    {
        "IMB",
        "If ESR2[VPS] is asserted, this bit indicates whether there is any inac"
        "tive Mailbox (CODE field is either 0b1000 or 0b0000).",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VPS",
        "This bit indicates whether IMB and LPTM contents are currently valid o"
        "r not.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LPTM",
        "If ESR2[VPS] is asserted, his 7-bit field indicates the lowest number "
        "inactive Mailbox (refer to IMB bit description).",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_CRCR.
static const field_t hw_flexcan_crcr[] =
{
    {
        "TXCRC",
        "This field indicates the CRC value of the last message transmitted.",
        0, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MBCRC",
        "This field indicates the number of the Mailbox corresponding to the va"
        "lue in TXCRC field.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RXFGMASK.
static const field_t hw_flexcan_rxfgmask[] =
{
    {
        "FGM31_FGM0",
        "These bits mask the ID Filter Table elements bits in a perfect alignme"
        "nt.RXFGMASKRx FIFO Global Mask Register shows in detail which FGM bits"
        " mask each IDAF field.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RXFIR.
static const field_t hw_flexcan_rxfir[] =
{
    {
        "IDHIT",
        "This 9-bit field indicates which Identifier Acceptance Filter (see Rx "
        "FIFO StructureWhen the MCR[RFEN] bit is set, the memory area from $80 "
        "to $DC (which is normally occupied by MBs 0 to 5) is used by the recep"
        "tion FIFO engine.",
        0, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_RXIMR0_RXIMR63.
static const field_t hw_flexcan_rximr0_rximr63[] =
{
    {
        "MI31_MI0",
        "These bits mask both Mailbox filter and Rx FIFO ID Filter Table elemen"
        "t in distinct ways.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register FLEXCAN_GFWR.
static const field_t hw_flexcan_gfwr[] =
{
    {
        "GFWR",
        "It determines the Glitch Filter Width.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a FLEXCAN module.
static const reg_t hw_flexcan[] =
{
    {
        "MCR",
        "This register defines global system configurations, such as the module"
        " operation mode (e.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_flexcan_mcr
    },
    {
        "CTRL1",
        "This register is defined for specific FLEXCAN control features related"
        " to the CAN bus, such as bit-rate, programmable sampling point within "
        "an Rx bit, Loop Back Mode, Listen Only Mode, Bus Off recovery behavior"
        " and interrupt enabling (Bus-Off, Error, Warning).",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_flexcan_ctrl1
    },
    {
        "TIMER",
        "This register represents a 16-bit free running counter that can be rea"
        "d and written by the ARM.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_timer
    },
    {
        "RXMGMASK",
        "RXMGMASK is provided for legacy support.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_rxmgmask
    },
    {
        "RX14MASK",
        "RX14MASK is provided for legacy support, asserting the MCR[IRMQ] bit c"
        "auses the RX14MASK to have no effect on the module operation.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_rx14mask
    },
    {
        "RX15MASK",
        "RX15MASK is provided for legacy support, asserting the MCR[IRMQ] bit c"
        "auses the RX15MASK Register to have no effect on the module operation.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_rx15mask
    },
    {
        "ECR",
        "This register has 2 8-bit fields reflecting the value of two FLEXCAN e"
        "rror counters: Transmit Error Counter (Tx_Err_Counter field) and Recei"
        "ve Error Counter (Rx_Err_Counter field).",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_flexcan_ecr
    },
    {
        "ESR1",
        "This register reflects various error conditions, some general status o"
        "f the device and it is the source of four interrupts to the ARM.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_flexcan_esr1
    },
    {
        "IMASK2",
        "This register allows any number of a range of 32 Message Buffer Interr"
        "upts to be enabled or disabled.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_imask2
    },
    {
        "IMASK1",
        "This register allows to enable or disable any number of a range of 32 "
        "Message Buffer Interrupts.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_imask1
    },
    {
        "IFLAG2",
        "This register defines the flags for 32 Message Buffer interrupts.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_iflag2
    },
    {
        "IFLAG1",
        "This register defines the flags for 32 Message Buffer interrupts and F"
        "IFO interrupts.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_flexcan_iflag1
    },
    {
        "CTRL2",
        "This register contains control bits for CAN errors, FIFO features and "
        "mode selection.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_flexcan_ctrl2
    },
    {
        "ESR2",
        "This register reflects various interrupt flags and some general status"
        ".",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_flexcan_esr2
    },
    {
        "CRCR",
        "This register provides information about the CRC of transmitted messag"
        "es",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_flexcan_crcr
    },
    {
        "RXFGMASK",
        "If Rx FIFO is enabled RXFGMASK is used to mask the Rx FIFO ID Filter T"
        "able elements that do not have a corresponding RXIMR according to CTRL"
        "2[RFFN] field setting.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_rxfgmask
    },
    {
        "RXFIR",
        "RXFIR provides information on Rx FIFO.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_flexcan_rxfir
    },
    {
        "RXIMR0_RXIMR63",
        "RXIMR are used as acceptance masks for ID filtering in Rx MBs and the "
        "Rx FIFO.",
        4, // Width in bytes
        0x00000880, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_rximr0_rximr63
    },
    {
        "GFWR",
        "The Glitch Filter just takes effects when FLEXCAN enters the STOP mode"
        ".",
        4, // Width in bytes
        0x000009e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_flexcan_gfwr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPC
#endif

// Bitfields in register GPC_CNTR.
static const field_t hw_gpc_cntr[] =
{
    {
        "GPU_VPU_PDN_REQ",
        "GPU Power Down request.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_VPU_PUP_REQ",
        "GPU Power Up request.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEGA_PDN_REQ",
        "MEGA domain power down request.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEGA_PUP_REQ",
        "MEGA domain power up request.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PDN_REQ",
        "Display Power Down request.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PUP_REQ",
        "Display Power Up request.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_PHY_PDN_REQ",
        "PCIE PHY power down request.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCIE_PHY_PUP_REQ",
        "PCIE PHY power up request.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFS0CR",
        "DVFS0 (ARM) Change request (bit is read-only)",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VADC_ANALOG_OFF",
        "Indication to VADC whether the analog power to VADC is available or no"
        "t",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VADC_EXT_PWD_N",
        "VADC power down bit",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPCIRQM",
        "GPC interrupt/event masking",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PGE",
        "L2 Cache Power Gate Enable",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_PGR.
static const field_t hw_gpc_pgr[] =
{
    {
        "DRCIC",
        "Debug ref cir in mux control",
        29, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_IMR1.
static const field_t hw_gpc_imr1[] =
{
    {
        "IMR1",
        "IRQ[63:32] masking bits: 1-irq masked, 0-irq is not masked",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_IMR2.
static const field_t hw_gpc_imr2[] =
{
    {
        "IMR2",
        "IRQ[95:64] masking bits: 1-irq masked, 0-irq is not masked",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_IMR3.
static const field_t hw_gpc_imr3[] =
{
    {
        "IMR3",
        "IRQ[127:96] masking bits: 1-irq masked, 0-irq is not masked",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_IMR4.
static const field_t hw_gpc_imr4[] =
{
    {
        "IMR4",
        "IRQ[159:128] masking bits: 1-irq masked, 0-irq is not masked",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_ISR1.
static const field_t hw_gpc_isr1[] =
{
    {
        "ISR1",
        "IRQ[63:32] status, read only",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_ISR2.
static const field_t hw_gpc_isr2[] =
{
    {
        "ISR2",
        "IRQ[95:64] status, read only",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_ISR3.
static const field_t hw_gpc_isr3[] =
{
    {
        "ISR3",
        "IRQ[127:96] status, read only",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPC_ISR4.
static const field_t hw_gpc_isr4[] =
{
    {
        "ISR4",
        "IRQ[159:128] status, read only",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPC module.
static const reg_t hw_gpc[] =
{
    {
        "CNTR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_gpc_cntr
    },
    {
        "PGR",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_pgr
    },
    {
        "IMR1",
        "IMR1 Register - masking of irq[63:32].",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_imr1
    },
    {
        "IMR2",
        "IMR2 Register - masking of irq[95:64].",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_imr2
    },
    {
        "IMR3",
        "IMR3 Register - masking of irq[127:96].",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_imr3
    },
    {
        "IMR4",
        "IMR4 Register - masking of irq[159:128].",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpc_imr4
    },
    {
        "ISR1",
        "ISR1 Register - status of irq [63:32].",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpc_isr1
    },
    {
        "ISR2",
        "ISR2 Register - status of irq [95:64].",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpc_isr2
    },
    {
        "ISR3",
        "ISR3 Register - status of irq [127:96].",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpc_isr3
    },
    {
        "ISR4",
        "ISR4 Register - status of irq [159:128].",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpc_isr4
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPIO
#endif

// Bitfields in register GPIO_DR.
static const field_t hw_gpio_dr[] =
{
    {
        "DR",
        "Data bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_GDIR.
static const field_t hw_gpio_gdir[] =
{
    {
        "GDIR",
        "GPIO direction bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_PSR.
static const field_t hw_gpio_psr[] =
{
    {
        "PSR",
        "GPIO pad status bits (status bits).",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_ICR1.
static const field_t hw_gpio_icr1[] =
{
    {
        "ICR0",
        "Interrupt configuration 1 fields.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR1",
        "Interrupt configuration 1 fields.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR2",
        "Interrupt configuration 1 fields.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR3",
        "Interrupt configuration 1 fields.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR4",
        "Interrupt configuration 1 fields.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR5",
        "Interrupt configuration 1 fields.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR6",
        "Interrupt configuration 1 fields.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR7",
        "Interrupt configuration 1 fields.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR8",
        "Interrupt configuration 1 fields.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR9",
        "Interrupt configuration 1 fields.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR10",
        "Interrupt configuration 1 fields.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR11",
        "Interrupt configuration 1 fields.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR12",
        "Interrupt configuration 1 fields.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR13",
        "Interrupt configuration 1 fields.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR14",
        "Interrupt configuration 1 fields.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR15",
        "Interrupt configuration 1 fields.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_ICR2.
static const field_t hw_gpio_icr2[] =
{
    {
        "ICR16",
        "Interrupt configuration 2 fields.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR17",
        "Interrupt configuration 2 fields.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR18",
        "Interrupt configuration 2 fields.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR19",
        "Interrupt configuration 2 fields.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR20",
        "Interrupt configuration 2 fields.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR21",
        "Interrupt configuration 2 fields.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR22",
        "Interrupt configuration 2 fields.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR23",
        "Interrupt configuration 2 fields.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR24",
        "Interrupt configuration 2 fields.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR25",
        "Interrupt configuration 2 fields.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR26",
        "Interrupt configuration 2 fields.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR27",
        "Interrupt configuration 2 fields.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR28",
        "Interrupt configuration 2 fields.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR29",
        "Interrupt configuration 2 fields.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR30",
        "Interrupt configuration 2 fields.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICR31",
        "Interrupt configuration 2 fields.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_IMR.
static const field_t hw_gpio_imr[] =
{
    {
        "IMR",
        "Interrupt Mask bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_ISR.
static const field_t hw_gpio_isr[] =
{
    {
        "ISR",
        "Interrupt status bits - Bit n of this register is asserted (active hig"
        "h) when the active condition (as determined by the corresponding ICR b"
        "it) is detected on the GPIO input and is waiting for service.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPIO_EDGE_SEL.
static const field_t hw_gpio_edge_sel[] =
{
    {
        "GPIO_EDGE_SEL",
        "Edge select.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPIO module.
static const reg_t hw_gpio[] =
{
    {
        "DR",
        "The 32-bit GPIO_DR register stores data that is ready to be driven to "
        "the output lines.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_dr
    },
    {
        "GDIR",
        "GPIO_GDIR functions as direction control when the IOMUXC is in GPIO mo"
        "de.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_gdir
    },
    {
        "PSR",
        "GPIO_PSR is a read-only register.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpio_psr
    },
    {
        "ICR1",
        "GPIO_ICR1 contains 16 two-bit fields, where each field specifies the i"
        "nterrupt configuration for a different input signal.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_gpio_icr1
    },
    {
        "ICR2",
        "GPIO_ICR2 contains 16 two-bit fields, where each field specifies the i"
        "nterrupt configuration for a different input signal.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_gpio_icr2
    },
    {
        "IMR",
        "GPIO_IMR contains masking bits for each interrupt line.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_imr
    },
    {
        "ISR",
        "The GPIO_ISR functions as an interrupt status indicator.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_isr
    },
    {
        "EDGE_SEL",
        "GPIO_EDGE_SEL may be used to override the ICR registers' configuration"
        ".",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpio_edge_sel
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPMI
#endif

// Bitfields in register GPMI_CTRL0.
static const field_t hw_gpmi_ctrl0[] =
{
    {
        "XFER_COUNT",
        "Number of bytes to transfer for this command.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS_INCREMENT",
        "In ATA mode, the address will increment with each cycle.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS",
        "Specifies the three address lines for ATA mode.",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS",
        "Selects which chip select is active for this command.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "This bit should only be changed when RUN==0.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMMAND_MODE",
        "WRITE = 0x0 Write mode.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UDMA",
        "DISABLED = 0x0 Use ATA-PIO mode on the external bus.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_CS",
        "For ATA/NAND mode: 0= Deassert chip select (CS) after RUN is complete.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_IRQ_EN",
        "When set to '1' and ATA_IRQ pin is asserted, the GPMI_IRQ output will "
        "assert.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUN",
        "The GPMI is busy running a command whenever this bit is set to '1'.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Set this bit zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set to zero for normal operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_CTRL0_SET.
static const field_t hw_gpmi_ctrl0_set[] =
{
    {
        "XFER_COUNT",
        "Number of bytes to transfer for this command.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS_INCREMENT",
        "In ATA mode, the address will increment with each cycle.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS",
        "Specifies the three address lines for ATA mode.",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS",
        "Selects which chip select is active for this command.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "This bit should only be changed when RUN==0.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMMAND_MODE",
        "WRITE = 0x0 Write mode.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UDMA",
        "DISABLED = 0x0 Use ATA-PIO mode on the external bus.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_CS",
        "For ATA/NAND mode: 0= Deassert chip select (CS) after RUN is complete.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_IRQ_EN",
        "When set to '1' and ATA_IRQ pin is asserted, the GPMI_IRQ output will "
        "assert.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUN",
        "The GPMI is busy running a command whenever this bit is set to '1'.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Set this bit zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set to zero for normal operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_CTRL0_CLR.
static const field_t hw_gpmi_ctrl0_clr[] =
{
    {
        "XFER_COUNT",
        "Number of bytes to transfer for this command.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS_INCREMENT",
        "In ATA mode, the address will increment with each cycle.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS",
        "Specifies the three address lines for ATA mode.",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS",
        "Selects which chip select is active for this command.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "This bit should only be changed when RUN==0.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMMAND_MODE",
        "WRITE = 0x0 Write mode.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UDMA",
        "DISABLED = 0x0 Use ATA-PIO mode on the external bus.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_CS",
        "For ATA/NAND mode: 0= Deassert chip select (CS) after RUN is complete.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_IRQ_EN",
        "When set to '1' and ATA_IRQ pin is asserted, the GPMI_IRQ output will "
        "assert.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUN",
        "The GPMI is busy running a command whenever this bit is set to '1'.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Set this bit zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set to zero for normal operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_CTRL0_TOG.
static const field_t hw_gpmi_ctrl0_tog[] =
{
    {
        "XFER_COUNT",
        "Number of bytes to transfer for this command.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS_INCREMENT",
        "In ATA mode, the address will increment with each cycle.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS",
        "Specifies the three address lines for ATA mode.",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS",
        "Selects which chip select is active for this command.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "This bit should only be changed when RUN==0.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMMAND_MODE",
        "WRITE = 0x0 Write mode.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UDMA",
        "DISABLED = 0x0 Use ATA-PIO mode on the external bus.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK_CS",
        "For ATA/NAND mode: 0= Deassert chip select (CS) after RUN is complete.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_IRQ_EN",
        "When set to '1' and ATA_IRQ pin is asserted, the GPMI_IRQ output will "
        "assert.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RUN",
        "The GPMI is busy running a command whenever this bit is set to '1'.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Set this bit zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set to zero for normal operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_COMPARE.
static const field_t hw_gpmi_compare[] =
{
    {
        "REFERENCE",
        "16-bit value which is XORed with data read from the NAND device.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK",
        "16-bit mask which is applied after the read data is XORed with the REF"
        "ERENCE bit field.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_ECCCTRL.
static const field_t hw_gpmi_eccctrl[] =
{
    {
        "BUFFER_MASK",
        "ECC buffer information.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RANDOMIZER_ENABLE",
        "Enable randomizer function.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ECC",
        "Enable ECC processing of GPMI transfers.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_CMD",
        "ECC Command information.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Always write zeroes to this bit field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HANDLE",
        "This is a register available to software to attach an identifier to a "
        "transaction in progress.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_ECCCTRL_SET.
static const field_t hw_gpmi_eccctrl_set[] =
{
    {
        "BUFFER_MASK",
        "ECC buffer information.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RANDOMIZER_ENABLE",
        "Enable randomizer function.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ECC",
        "Enable ECC processing of GPMI transfers.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_CMD",
        "ECC Command information.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Always write zeroes to this bit field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HANDLE",
        "This is a register available to software to attach an identifier to a "
        "transaction in progress.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_ECCCTRL_CLR.
static const field_t hw_gpmi_eccctrl_clr[] =
{
    {
        "BUFFER_MASK",
        "ECC buffer information.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RANDOMIZER_ENABLE",
        "Enable randomizer function.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ECC",
        "Enable ECC processing of GPMI transfers.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_CMD",
        "ECC Command information.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Always write zeroes to this bit field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HANDLE",
        "This is a register available to software to attach an identifier to a "
        "transaction in progress.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_ECCCTRL_TOG.
static const field_t hw_gpmi_eccctrl_tog[] =
{
    {
        "BUFFER_MASK",
        "ECC buffer information.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RANDOMIZER_ENABLE",
        "Enable randomizer function.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ECC",
        "Enable ECC processing of GPMI transfers.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECC_CMD",
        "ECC Command information.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Always write zeroes to this bit field.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HANDLE",
        "This is a register available to software to attach an identifier to a "
        "transaction in progress.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_ECCCOUNT.
static const field_t hw_gpmi_ecccount[] =
{
    {
        "COUNT",
        "Number of bytes to pass through ECC.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RANDOMIZER_PAGE",
        "Set NAND page number needed to be randomized.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_PAYLOAD.
static const field_t hw_gpmi_payload[] =
{
    {
        "RSVD0",
        "Always write zeroes to this bit field.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADDRESS",
        "Pointer to an array of one or more 512 byte payload buffers.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_AUXILIARY.
static const field_t hw_gpmi_auxiliary[] =
{
    {
        "RSVD0",
        "Always write zeroes to this bit field.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADDRESS",
        "Pointer to ECC control structure and meta-data storage.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_CTRL1.
static const field_t hw_gpmi_ctrl1[] =
{
    {
        "GPMI_MODE",
        "ATA mode is only supported on channel zero.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAMERA_MODE",
        "When set to 1 and ATA UDMA is enabled the UDMA interface becomes a cam"
        "era interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATA_IRQRDY_POLARITY",
        "For ATA MODE: Note NAND_RDY_BUSY[3:2] are not affected by this bit.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_RESET",
        "ENABLED = 0x0 NANDF_WP_B(WPN) pin is held low (asserted).",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABORT_WAIT_FOR_READY_CHANNEL",
        "Abort a wait for ready command on selected channel.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABORT_WAIT_REQUEST",
        "Request to abort \"wait for ready\" command on channel indicated by AB"
        "ORT_WAIT_FOR_READY_CHANNEL.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_EN",
        "When set to 1 each DMA request will generate a 4-transfer burst on the"
        " APB bus.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_IRQ",
        "This bit is set when a timeout occurs using the Device_Busy_Timeout va"
        "lue.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_IRQ",
        "This bit is set when an Interrupt is received from the ATA device.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA2ECC_MODE",
        "This is mainly for testing HWECC without involving the Nand device.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDN_DELAY",
        "This variable is a factor in the calculated delay to apply to the inte"
        "rnal read strobe for correct read data sampling.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_PERIOD",
        "Set this bit to 1 if the GPMI clock period is greater than 16ns for pr"
        "oper DLL operation.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_ENABLE",
        "Set this bit to 1 to enable the GPMI DLL.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCH_MODE",
        "This bit selects which error correction unit will access GPMI.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GANGED_RDYBUSY",
        "Set this bit to 1 will force all Nand RDY_BUSY inputs to be sourced fr"
        "om (tied to) RDY_BUSY0.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_IRQ_EN",
        "Setting this bit to '1' will enable timeout IRQ for transfers in ATA m"
        "ode only, and for WAIT_FOR_READY commands in both ATA and Nand mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEST_TRIGGER",
        "Test Trigger Enable",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRN_DLY_SEL",
        "Since the GPMI write strobe (WRN) is a fast clock pin, the delay on th"
        "is signal can be programmed to match the load on this pin.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DECOUPLE_CS",
        "Decouple Chip Select from DMA Channel.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSYNCMODE",
        "source synchronouse mode 1 or asynchrous mode 0.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_CS",
        "force the CS value is be updated to external chip select pin, even GPM"
        "I is idle.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPMI_CLK_DIV2_EN",
        "This bit should be reset to 0 in asynchronous mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOGGLE_MODE",
        "enable samsung toggle mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRITE_CLK_STOP",
        "In onfi source synchronous mode, host may save power during the data w"
        "rite cycles by holding the CLK signal high (i.e.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSYNC_CLK_STOP",
        "set this bit to 1 will stop the source synchronous mode clk.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_CLK_STOP",
        "set this bit to 1 will stop gpmi io working clk.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_CTRL1_SET.
static const field_t hw_gpmi_ctrl1_set[] =
{
    {
        "GPMI_MODE",
        "ATA mode is only supported on channel zero.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAMERA_MODE",
        "When set to 1 and ATA UDMA is enabled the UDMA interface becomes a cam"
        "era interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATA_IRQRDY_POLARITY",
        "For ATA MODE: Note NAND_RDY_BUSY[3:2] are not affected by this bit.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_RESET",
        "ENABLED = 0x0 NANDF_WP_B(WPN) pin is held low (asserted).",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABORT_WAIT_FOR_READY_CHANNEL",
        "Abort a wait for ready command on selected channel.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABORT_WAIT_REQUEST",
        "Request to abort \"wait for ready\" command on channel indicated by AB"
        "ORT_WAIT_FOR_READY_CHANNEL.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_EN",
        "When set to 1 each DMA request will generate a 4-transfer burst on the"
        " APB bus.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_IRQ",
        "This bit is set when a timeout occurs using the Device_Busy_Timeout va"
        "lue.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_IRQ",
        "This bit is set when an Interrupt is received from the ATA device.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA2ECC_MODE",
        "This is mainly for testing HWECC without involving the Nand device.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDN_DELAY",
        "This variable is a factor in the calculated delay to apply to the inte"
        "rnal read strobe for correct read data sampling.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_PERIOD",
        "Set this bit to 1 if the GPMI clock period is greater than 16ns for pr"
        "oper DLL operation.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_ENABLE",
        "Set this bit to 1 to enable the GPMI DLL.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCH_MODE",
        "This bit selects which error correction unit will access GPMI.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GANGED_RDYBUSY",
        "Set this bit to 1 will force all Nand RDY_BUSY inputs to be sourced fr"
        "om (tied to) RDY_BUSY0.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_IRQ_EN",
        "Setting this bit to '1' will enable timeout IRQ for transfers in ATA m"
        "ode only, and for WAIT_FOR_READY commands in both ATA and Nand mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEST_TRIGGER",
        "Test Trigger Enable",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRN_DLY_SEL",
        "Since the GPMI write strobe (WRN) is a fast clock pin, the delay on th"
        "is signal can be programmed to match the load on this pin.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DECOUPLE_CS",
        "Decouple Chip Select from DMA Channel.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSYNCMODE",
        "source synchronouse mode 1 or asynchrous mode 0.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_CS",
        "force the CS value is be updated to external chip select pin, even GPM"
        "I is idle.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPMI_CLK_DIV2_EN",
        "This bit should be reset to 0 in asynchronous mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOGGLE_MODE",
        "enable samsung toggle mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRITE_CLK_STOP",
        "In onfi source synchronous mode, host may save power during the data w"
        "rite cycles by holding the CLK signal high (i.e.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSYNC_CLK_STOP",
        "set this bit to 1 will stop the source synchronous mode clk.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_CLK_STOP",
        "set this bit to 1 will stop gpmi io working clk.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_CTRL1_CLR.
static const field_t hw_gpmi_ctrl1_clr[] =
{
    {
        "GPMI_MODE",
        "ATA mode is only supported on channel zero.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAMERA_MODE",
        "When set to 1 and ATA UDMA is enabled the UDMA interface becomes a cam"
        "era interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATA_IRQRDY_POLARITY",
        "For ATA MODE: Note NAND_RDY_BUSY[3:2] are not affected by this bit.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_RESET",
        "ENABLED = 0x0 NANDF_WP_B(WPN) pin is held low (asserted).",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABORT_WAIT_FOR_READY_CHANNEL",
        "Abort a wait for ready command on selected channel.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABORT_WAIT_REQUEST",
        "Request to abort \"wait for ready\" command on channel indicated by AB"
        "ORT_WAIT_FOR_READY_CHANNEL.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_EN",
        "When set to 1 each DMA request will generate a 4-transfer burst on the"
        " APB bus.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_IRQ",
        "This bit is set when a timeout occurs using the Device_Busy_Timeout va"
        "lue.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_IRQ",
        "This bit is set when an Interrupt is received from the ATA device.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA2ECC_MODE",
        "This is mainly for testing HWECC without involving the Nand device.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDN_DELAY",
        "This variable is a factor in the calculated delay to apply to the inte"
        "rnal read strobe for correct read data sampling.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_PERIOD",
        "Set this bit to 1 if the GPMI clock period is greater than 16ns for pr"
        "oper DLL operation.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_ENABLE",
        "Set this bit to 1 to enable the GPMI DLL.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCH_MODE",
        "This bit selects which error correction unit will access GPMI.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GANGED_RDYBUSY",
        "Set this bit to 1 will force all Nand RDY_BUSY inputs to be sourced fr"
        "om (tied to) RDY_BUSY0.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_IRQ_EN",
        "Setting this bit to '1' will enable timeout IRQ for transfers in ATA m"
        "ode only, and for WAIT_FOR_READY commands in both ATA and Nand mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEST_TRIGGER",
        "Test Trigger Enable",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRN_DLY_SEL",
        "Since the GPMI write strobe (WRN) is a fast clock pin, the delay on th"
        "is signal can be programmed to match the load on this pin.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DECOUPLE_CS",
        "Decouple Chip Select from DMA Channel.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSYNCMODE",
        "source synchronouse mode 1 or asynchrous mode 0.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_CS",
        "force the CS value is be updated to external chip select pin, even GPM"
        "I is idle.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPMI_CLK_DIV2_EN",
        "This bit should be reset to 0 in asynchronous mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOGGLE_MODE",
        "enable samsung toggle mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRITE_CLK_STOP",
        "In onfi source synchronous mode, host may save power during the data w"
        "rite cycles by holding the CLK signal high (i.e.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSYNC_CLK_STOP",
        "set this bit to 1 will stop the source synchronous mode clk.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_CLK_STOP",
        "set this bit to 1 will stop gpmi io working clk.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_CTRL1_TOG.
static const field_t hw_gpmi_ctrl1_tog[] =
{
    {
        "GPMI_MODE",
        "ATA mode is only supported on channel zero.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CAMERA_MODE",
        "When set to 1 and ATA UDMA is enabled the UDMA interface becomes a cam"
        "era interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATA_IRQRDY_POLARITY",
        "For ATA MODE: Note NAND_RDY_BUSY[3:2] are not affected by this bit.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_RESET",
        "ENABLED = 0x0 NANDF_WP_B(WPN) pin is held low (asserted).",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABORT_WAIT_FOR_READY_CHANNEL",
        "Abort a wait for ready command on selected channel.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABORT_WAIT_REQUEST",
        "Request to abort \"wait for ready\" command on channel indicated by AB"
        "ORT_WAIT_FOR_READY_CHANNEL.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_EN",
        "When set to 1 each DMA request will generate a 4-transfer burst on the"
        " APB bus.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_IRQ",
        "This bit is set when a timeout occurs using the Device_Busy_Timeout va"
        "lue.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_IRQ",
        "This bit is set when an Interrupt is received from the ATA device.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA2ECC_MODE",
        "This is mainly for testing HWECC without involving the Nand device.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RDN_DELAY",
        "This variable is a factor in the calculated delay to apply to the inte"
        "rnal read strobe for correct read data sampling.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_PERIOD",
        "Set this bit to 1 if the GPMI clock period is greater than 16ns for pr"
        "oper DLL operation.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_ENABLE",
        "Set this bit to 1 to enable the GPMI DLL.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCH_MODE",
        "This bit selects which error correction unit will access GPMI.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GANGED_RDYBUSY",
        "Set this bit to 1 will force all Nand RDY_BUSY inputs to be sourced fr"
        "om (tied to) RDY_BUSY0.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIMEOUT_IRQ_EN",
        "Setting this bit to '1' will enable timeout IRQ for transfers in ATA m"
        "ode only, and for WAIT_FOR_READY commands in both ATA and Nand mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEST_TRIGGER",
        "Test Trigger Enable",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRN_DLY_SEL",
        "Since the GPMI write strobe (WRN) is a fast clock pin, the delay on th"
        "is signal can be programmed to match the load on this pin.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DECOUPLE_CS",
        "Decouple Chip Select from DMA Channel.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSYNCMODE",
        "source synchronouse mode 1 or asynchrous mode 0.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_CS",
        "force the CS value is be updated to external chip select pin, even GPM"
        "I is idle.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPMI_CLK_DIV2_EN",
        "This bit should be reset to 0 in asynchronous mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOGGLE_MODE",
        "enable samsung toggle mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WRITE_CLK_STOP",
        "In onfi source synchronous mode, host may save power during the data w"
        "rite cycles by holding the CLK signal high (i.e.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SSYNC_CLK_STOP",
        "set this bit to 1 will stop the source synchronous mode clk.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEV_CLK_STOP",
        "set this bit to 1 will stop gpmi io working clk.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_TIMING0.
static const field_t hw_gpmi_timing0[] =
{
    {
        "DATA_SETUP",
        "Data bus setup time in GPMICLK cycles.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_HOLD",
        "Data bus hold time in GPMICLK cycles.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRESS_SETUP",
        "Number of GPMICLK cycles that the CE/ADDR signals are active before a "
        "strobe is asserted.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Always write zeroes to this bit field.",
        24, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_TIMING1.
static const field_t hw_gpmi_timing1[] =
{
    {
        "RSVD1",
        "Always write zeroes to this bit field.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEVICE_BUSY_TIMEOUT",
        "Timeout waiting for NAND Ready/Busy or ATA IRQ.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_TIMING2.
static const field_t hw_gpmi_timing2[] =
{
    {
        "DATA_PAUSE",
        "GPMI delay time from data pause to data resume in GPMICLK cycles.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMDADD_PAUSE",
        "GPMI delay time from command or addres pause to command or address res"
        "ume in GPMICLK cycles.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POSTAMBLE_DELAY",
        "GPMI post-amble delay in GPMICLK cycles.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREAMBLE_DELAY",
        "GPMI pre-amble delay in GPMICLK cycles.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CE_DELAY",
        "GPMI dealy from CEn assert to W/Rn changing edge.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Always write zeroes to this bit field.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "READ_LATENCY",
        "This field is for double data rate read latency configuration.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCR",
        "Only for Toggle NAND timing control delay (TCR+1) GPMICLK cycles for C"
        "En_B low to RE_B low, 0 is less than or equal to TCR, which is less th"
        "an the PREAMBLE_DELAY",
        27, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRPSTH",
        "Only for Toggle NAND timing control delay TRPSTH GPMICLK cycles for CE"
        "n_B high to RE_B high, A value of zero is interpreted as 8",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_DATA.
static const field_t hw_gpmi_data[] =
{
    {
        "DATA",
        "In 8-bit mode, one, two, three or four bytes can can be accessed to se"
        "nd the same number of bus cycles.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_STAT.
static const field_t hw_gpmi_stat[] =
{
    {
        "PRESENT",
        "UNAVAILABLE = 0x0 GPMI is not present in this product.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FIFO_FULL",
        "NOT_FULL = 0x0 FIFO is not full.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FIFO_EMPTY",
        "NOT_EMPTY = 0x0 FIFO is not empty.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INVALID_BUFFER_MASK",
        "Buffer Mask Validity bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ATA_IRQ",
        "Status of the ATA_IRQ input pin.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Always write zeroes to this bit field.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEV0_ERROR",
        "DMA channel 0 (Timeout or compare failure, depending on COMMAND_MODE).",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEV1_ERROR",
        "DMA channel 1 (Timeout or compare failure, depending on COMMAND_MODE).",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEV2_ERROR",
        "DMA channel 2 (Timeout or compare failure, depending on COMMAND_MODE).",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEV3_ERROR",
        "DMA channel 3 (Timeout or compare failure, depending on COMMAND_MODE).",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEV4_ERROR",
        "DMA channel 4 (Timeout or compare failure, depending on COMMAND_MODE).",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEV5_ERROR",
        "DMA channel 5 (Timeout or compare failure, depending on COMMAND_MODE).",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEV6_ERROR",
        "DMA channel 6 (Timeout or compare failure, depending on COMMAND_MODE).",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEV7_ERROR",
        "DMA channel 7 (Timeout or compare failure, depending on COMMAND_MODE).",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDY_TIMEOUT",
        "State of the RDY/BUSY Timeout Flags.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "READY_BUSY",
        "Read-only view of NAND Ready_Busy Input pins.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_DEBUG.
static const field_t hw_gpmi_debug[] =
{
    {
        "CMD_END",
        "Read Only view of the Command End toggle signals to DMA.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMAREQ",
        "Read-only view of DMA request line for 8 DMA channels.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMA_SENSE",
        "Read-only view of sense state of the 8 DMA channels.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT_FOR_READY_END",
        "Read Only view of the Wait_For_Ready End toggle signals to DMA.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_VERSION.
static const field_t hw_gpmi_version[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_DEBUG2.
static const field_t hw_gpmi_debug2[] =
{
    {
        "RDN_TAP",
        "This is the DLL tap calculated by the DLL controller.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UPDATE_WINDOW",
        "A 1 indicates that the DLL is busy generating the required delay.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VIEW_DELAYED_RDN",
        "Set to a 1 to select the delayed feedback RE_B to drive the GPMI_ADDR["
        "0] (Nand CLE) pin.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYND2GPMI_READY",
        "Data handshake Input from BCH.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYND2GPMI_VALID",
        "Data handshake Input from BCH.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPMI2SYND_READY",
        "Data handshake output to BCH.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GPMI2SYND_VALID",
        "Data handshake output to BCH.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYND2GPMI_BE",
        "Data byte enable Input from BCH.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAIN_STATE",
        "parameter MSM_IDLE = 4'h0, MSM_BYTCNT = 4'h1, MSM_WAITFE = 4'h2, MSM_W"
        "AITFR = 4'h3, MSM_DMAREQ = 4'h4, MSM_DMAACK = 4'h5, MSM_WAITFF = 4'h6,"
        " MSM_LDFIFO = 4'h7, MSM_LDDMAR = 4'h8, MSM_RDCMP = 4'h9, MSM_DONE = 4'"
        "hA.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIN_STATE",
        "parameter PSM_IDLE = 3'h0, PSM_BYTCNT = 3'h1, PSM_ADDR = 3'h2, PSM_STA"
        "LL = 3'h3, PSM_STROBE = 3'h4, PSM_ATARDY = 3'h5, PSM_DHOLD = 3'h6, PSM"
        "_DONE = 3'h7.",
        20, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUSY",
        "When asserted the GPMI is busy.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UDMA_STATE",
        "USM_IDLE = 4'h0, idle USM_DMARQ = 4'h1, DMA req USM_ACK = 4'h2, DMA AC"
        "K USM_FIFO_E = 4'h3, Fifo empty USM_WPAUSE = 4'h4, WR DMA Paused by de"
        "vice USM_TSTRB = 4'h5, Toggle HSTROBE USM_CAPTUR = 4'h6, Capture Stage"
        ", (data sampled with DSTROBE is valid) USM_DATOUT = 4'h7, Change Burst"
        " DATAOUT USM_CRC = 4'h8, Source CRC to Device USM_WAIT_R = 4'h9, Waiti"
        "ng for DDMARDY- USM_END = 4'ha; Negate DMAACK (end of DMA) USM_WAIT_S "
        "= 4'hb, Waiting for DSTROBE USM_RPAUSE = 4'hc, Rd DMA Paused by Host U"
        "SM_RSTOP = 4'hd, Rd DMA Stopped by Host USM_WTERM = 4'he, Wr DMA Termi"
        "nation State USM_RTERM = 4'hf, Rd DMA Termination state",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Always write zeroes to this bit field.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_DEBUG3.
static const field_t hw_gpmi_debug3[] =
{
    {
        "DEV_WORD_CNTR",
        "Reflects the number of bytes remains to be transferred on the ATA/Nand"
        " bus.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "APB_WORD_CNTR",
        "Reflects the number of bytes remains to be transferred on the APB bus.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_READ_DDR_DLL_CTRL.
static const field_t hw_gpmi_read_ddr_dll_ctrl[] =
{
    {
        "ENABLE",
        "Set this bit to 1 to enable the DLL and delay chain; otherwise; set to"
        " 0 to bypasses DLL.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESET",
        "Setting this bit to 1 force a reset on DLL.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLV_FORCE_UPD",
        "Setting this bit to 1, forces the slave delay line to update to the DL"
        "L calibrated value immediately.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLV_DLY_TARGET",
        "The delay target for the read clock is can be programmed in 1/16th inc"
        "rements of an GPMICLK half-period.",
        3, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GATE_UPDATE",
        "Setting this bit to 1, forces the slave delay line not update",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFCLK_ON",
        "set this bit to 1 will turn on the reference clock",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLV_OVERRIDE",
        "Set this bit to 1 to Enable manual override for slave delay chain usin"
        "g SLV_OVERRIDE_VAL; to set 0 to disable manual override.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLV_OVERRIDE_VAL",
        "When SLV_OVERRIDE=1 This field is used to select 1 of 256 physical tap"
        "s manually.",
        10, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SLV_UPDATE_INT",
        "Setting a value greater than 0 in this field, shall over-ride the defa"
        "ult slave delay-line update interval of 256 GPMICLK cycles.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_UPDATE_INT",
        "This field allows the user to add additional delay cycles to the DLL c"
        "ontrol loop (reference delay line control).",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_WRITE_DDR_DLL_CTRL.
static const field_t hw_gpmi_write_ddr_dll_ctrl[] =
{
    {
        "ENABLE",
        "Set this bit to 1 to enable the DLL and delay chain; otherwise; set to"
        " 0 to bypasses DLL.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESET",
        "Setting this bit to 1 force a reset on DLL.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLV_FORCE_UPD",
        "Setting this bit to 1, forces the slave delay line to update to the DL"
        "L calibrated value immediately.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLV_DLY_TARGET",
        "The delay target for the read clock can be programmed in 1/16th increm"
        "ents of an GPMICLK half-period.",
        3, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GATE_UPDATE",
        "Setting this bit to 1, forces the slave delay line not update",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFCLK_ON",
        "set this bit to 1 will turn on the reference clock",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLV_OVERRIDE",
        "Set this bit to 1 to Enable manual override for slave delay chain usin"
        "g SLV_OVERRIDE_VAL; to set 0 to disable manual override.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLV_OVERRIDE_VAL",
        "When SLV_OVERRIDE=1 This field is used to select 1 of 256 physical tap"
        "s manually.",
        10, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SLV_UPDATE_INT",
        "Setting a value greater than 0 in this field, shall over-ride the defa"
        "ult slave delay-line update interval of 256 GPMICLK cycles.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_UPDATE_INT",
        "This field allows the user to add additional delay cycles to the DLL c"
        "ontrol loop (reference delay line control).",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_READ_DDR_DLL_STS.
static const field_t hw_gpmi_read_ddr_dll_sts[] =
{
    {
        "SLV_LOCK",
        "Slave delay-line lock status.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SLV_SEL",
        "Slave delay line select status",
        1, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD0",
        "Reserved",
        9, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REF_LOCK",
        "Reference DLL lock status.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REF_SEL",
        "Reference delay line select status.",
        17, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        25, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPMI_WRITE_DDR_DLL_STS.
static const field_t hw_gpmi_write_ddr_dll_sts[] =
{
    {
        "SLV_LOCK",
        "Slave delay-line lock status.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SLV_SEL",
        "Slave delay line select status",
        1, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD0",
        "Reserved",
        9, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REF_LOCK",
        "Reference DLL lock status.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REF_SEL",
        "Reference delay line select status.",
        17, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved",
        25, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPMI module.
static const reg_t hw_gpmi[] =
{
    {
        "CTRL0",
        "The GPMI control register 0 specifies the GPMI transaction to perform "
        "for the current command chain item.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gpmi_ctrl0
    },
    {
        "CTRL0_SET",
        "The GPMI control register 0 specifies the GPMI transaction to perform "
        "for the current command chain item.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gpmi_ctrl0_set
    },
    {
        "CTRL0_CLR",
        "The GPMI control register 0 specifies the GPMI transaction to perform "
        "for the current command chain item.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gpmi_ctrl0_clr
    },
    {
        "CTRL0_TOG",
        "The GPMI control register 0 specifies the GPMI transaction to perform "
        "for the current command chain item.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_gpmi_ctrl0_tog
    },
    {
        "COMPARE",
        "The GPMI compare register specifies the expect data and the xor mask f"
        "or comparing to the status values read from the device.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_gpmi_compare
    },
    {
        "ECCCTRL",
        "The GPMI ECC control register handles configuration of the integrated "
        "ECC / Randomizer accelerator.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gpmi_eccctrl
    },
    {
        "ECCCTRL_SET",
        "The GPMI ECC control register handles configuration of the integrated "
        "ECC / Randomizer accelerator.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gpmi_eccctrl_set
    },
    {
        "ECCCTRL_CLR",
        "The GPMI ECC control register handles configuration of the integrated "
        "ECC / Randomizer accelerator.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gpmi_eccctrl_clr
    },
    {
        "ECCCTRL_TOG",
        "The GPMI ECC control register handles configuration of the integrated "
        "ECC / Randomizer accelerator.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gpmi_eccctrl_tog
    },
    {
        "ECCCOUNT",
        "The GPMI ECC Transfer Count Register contains the count of bytes that "
        "flow through the ECC / Randomizer sub­system.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_gpmi_ecccount
    },
    {
        "PAYLOAD",
        "The GPMI payload address register specifies the location of the data b"
        "uffers in system memory.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_gpmi_payload
    },
    {
        "AUXILIARY",
        "The GPMI auxiliary address register specifies the location of the auxi"
        "liary buffers in system memory.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_gpmi_auxiliary
    },
    {
        "CTRL1",
        "The GPMI control register 1 specifies additional control fields that a"
        "re not used on a per-transaction basis.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_gpmi_ctrl1
    },
    {
        "CTRL1_SET",
        "The GPMI control register 1 specifies additional control fields that a"
        "re not used on a per-transaction basis.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_gpmi_ctrl1_set
    },
    {
        "CTRL1_CLR",
        "The GPMI control register 1 specifies additional control fields that a"
        "re not used on a per-transaction basis.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_gpmi_ctrl1_clr
    },
    {
        "CTRL1_TOG",
        "The GPMI control register 1 specifies additional control fields that a"
        "re not used on a per-transaction basis.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_gpmi_ctrl1_tog
    },
    {
        "TIMING0",
        "The GPMI timing register 0 specifies the timing parameters that are us"
        "ed by the cycle state machine to guarantee the various setup, hold and"
        " cycle times for the external media type.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_gpmi_timing0
    },
    {
        "TIMING1",
        "The GPMI timing register 1 specifies the timeouts used when monitoring"
        " the NAND READY pin or the ATA IRQ and IOWAIT signals.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_gpmi_timing1
    },
    {
        "TIMING2",
        "The GPMI timing register 2 specifies the double data rate timing param"
        "eters that are used by the cycle state machine to guarantee the variou"
        "s cs delay, pre-amble delay, post-amble delay, command/address delay, "
        "data delay, TCR, TRPSTH, and read latency cycle times for the external"
        " media type.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_gpmi_timing2
    },
    {
        "DATA",
        "The GPMI DMA data transfer register is used by the DMA to read or writ"
        "e data to or from the ATA/NAND control state machine.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpmi_data
    },
    {
        "STAT",
        "The GPMI control and status register provides a read back path for var"
        "ious operational states of the GPMI controller.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        false, // Writable
        16, // Number of bitfields
        hw_gpmi_stat
    },
    {
        "DEBUG",
        "The GPMI debug information register provides a read back path for diag"
        "nostics to determine the current operating state of the GPMI controlle"
        "r.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_gpmi_debug
    },
    {
        "VERSION",
        "This register reflects the version number for the GPMI.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_gpmi_version
    },
    {
        "DEBUG2",
        "The GPMI Debug2 information register provides a read back path for dia"
        "gnostics to determine the cur­rent operating state of the GPMI contro"
        "ller.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_gpmi_debug2
    },
    {
        "DEBUG3",
        "The GPMI Debug3 information register provides a read back path for dia"
        "gnostics to determine the cur­rent operating state of the GPMI contro"
        "ller.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_gpmi_debug3
    },
    {
        "READ_DDR_DLL_CTRL",
        "GPMI DDR Read Delay Loop Lock Control Register.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_gpmi_read_ddr_dll_ctrl
    },
    {
        "WRITE_DDR_DLL_CTRL",
        "GPMI DDR Write Delay Loop Lock Control Register.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_gpmi_write_ddr_dll_ctrl
    },
    {
        "READ_DDR_DLL_STS",
        "GPMI Double Rate Read DLL Status Register, Read Only.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_gpmi_read_ddr_dll_sts
    },
    {
        "WRITE_DDR_DLL_STS",
        "GPMI Double Rate Write DLL Status Register, Read Only.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        false, // Writable
        6, // Number of bitfields
        hw_gpmi_write_ddr_dll_sts
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark GPT
#endif

// Bitfields in register GPT_CR.
static const field_t hw_gpt_cr[] =
{
    {
        "EN",
        "GPT Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENMOD",
        "GPT Enable mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "GPT debug mode enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAITEN",
        "GPT Wait Mode enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZEEN",
        "GPT Doze Mode Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPEN",
        "GPT Stop Mode enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKSRC",
        "Clock Source select.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRR",
        "Free-Run or Restart mode.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_24M",
        "Enable 24MHz clock input from crystal.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Software reset.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IM1",
        "See IM2",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IM2",
        "IM2 (bits 19-18, Input Capture Channel 2 operating mode) IM1 (bits 17-"
        "16, Input Capture Channel 1 operating mode) The IMn bit field determin"
        "es the transition on the input pin (for Input capture channel n), whic"
        "h will trigger a capture event.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OM1",
        "See OM3",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OM2",
        "See OM3",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OM3",
        "OM3 (bits 28-26) controls the Output Compare Channel 3 operating mode.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FO1",
        "See F03",
        29, // LSB
        29, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FO2",
        "See F03",
        30, // LSB
        30, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FO3",
        "FO3 Force Output Compare Channel 3 FO2 Force Output Compare Channel 2 "
        "FO1 Force Output Compare Channel 1 The FOn bit causes the pin action p"
        "rogrammed for the timer Output Compare n pin (according to the OMn bit"
        "s in this register).",
        31, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_PR.
static const field_t hw_gpt_pr[] =
{
    {
        "PRESCALER",
        "Prescaler bits.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESCALER24M",
        "Prescaler bits.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_SR.
static const field_t hw_gpt_sr[] =
{
    {
        "OF1",
        "See OF3",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF2",
        "See OF3",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF3",
        "OF3 Output Compare 3 Flag OF2 Output Compare 2 Flag OF1 Output Compare"
        " 1 Flag The OFn bit indicates that a compare event has occurred on Out"
        "put Compare channel n.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IF1",
        "See IF2",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IF2",
        "IF2 Input capture 2 Flag IF1 Input capture 1 Flag The IFn bit indicate"
        "s that a capture event has occurred on Input Capture channel n.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROV",
        "Rollover Flag.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_IR.
static const field_t hw_gpt_ir[] =
{
    {
        "OF1IE",
        "See OF3IE",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF2IE",
        "See OF3IE",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OF3IE",
        "OF3IE Output Compare 3 Interrupt Enable OF2IE Output Compare 2 Interru"
        "pt Enable OF1IE Output Compare 1 Interrupt Enable The OFnIE bit contro"
        "ls the Output Compare Channel n interrupt.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IF1IE",
        "See IF2IE",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IF2IE",
        "IF2IE Input capture 2 Interrupt Enable IF1IE Input capture 1 Interrupt"
        " Enable The IFnIE bit controls the IFnIE Input Capture n Interrupt Ena"
        "ble.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROVIE",
        "Rollover Interrupt Enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_OCR1.
static const field_t hw_gpt_ocr1[] =
{
    {
        "COMP",
        "Compare Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_OCR2.
static const field_t hw_gpt_ocr2[] =
{
    {
        "COMP",
        "Compare Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_OCR3.
static const field_t hw_gpt_ocr3[] =
{
    {
        "COMP",
        "Compare Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_ICR1.
static const field_t hw_gpt_icr1[] =
{
    {
        "CAPT",
        "Capture Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_ICR2.
static const field_t hw_gpt_icr2[] =
{
    {
        "CAPT",
        "Capture Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register GPT_CNT.
static const field_t hw_gpt_cnt[] =
{
    {
        "COUNT",
        "Counter Value.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a GPT module.
static const reg_t hw_gpt[] =
{
    {
        "CR",
        "The GPT Control Register (GPT_CR) is used to program and configure GPT"
        " operations.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_gpt_cr
    },
    {
        "PR",
        "The GPT Prescaler Register (GPT_PR) contains bits that determine the d"
        "ivide value of the clock that runs the counter.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_gpt_pr
    },
    {
        "SR",
        "The GPT Status Register (GPT_SR) contains bits that indicate that a co"
        "unter has rolled over, and if any event has occurred on the Input Capt"
        "ure and Output Compare channels.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gpt_sr
    },
    {
        "IR",
        "The GPT Interrupt Register (GPT_IR) contains bits that control whether"
        " interrupts are generated after rollover, input capture and output com"
        "pare events.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_gpt_ir
    },
    {
        "OCR1",
        "The GPT Compare Register 1 (GPT_OCR1) holds the value that determines "
        "when a compare event will be generated on Output Compare Channel 1.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpt_ocr1
    },
    {
        "OCR2",
        "The GPT Compare Register 2 (GPT_OCR2) holds the value that determines "
        "when a compare event will be generated on Output Compare Channel 2.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpt_ocr2
    },
    {
        "OCR3",
        "The GPT Compare Register 3 (GPT_OCR3) holds the value that determines "
        "when a compare event will be generated on Output Compare Channel 3.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_gpt_ocr3
    },
    {
        "ICR1",
        "The GPT Input Capture Register 1 (GPT_ICR1) is a read-only register th"
        "at holds the value that was in the counter during the last capture eve"
        "nt on Input Capture Channel 1.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpt_icr1
    },
    {
        "ICR2",
        "The GPT Input capture Register 2 (GPT_ICR2) is a read-only register wh"
        "ich holds the value that was in the counter during the last capture ev"
        "ent on input capture channel 2.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpt_icr2
    },
    {
        "CNT",
        "The GPT Counter Register (GPT_CNT) is the main counter's register.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_gpt_cnt
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark I2C
#endif

// Bitfields in register I2C_IADR.
static const field_t hw_i2c_iadr[] =
{
    {
        "ADR",
        "Slave address.",
        1, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2C_IFDR.
static const field_t hw_i2c_ifdr[] =
{
    {
        "IC",
        "I2C clock rate.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2C_I2CR.
static const field_t hw_i2c_i2cr[] =
{
    {
        "RSTA",
        "Repeat start.",
        2, // LSB
        2, // MSB
        false, // Readable
        false // Writable
    },
    {
        "TXAK",
        "Transmit acknowledge enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MTX",
        "Transmit/Receive mode select bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSTA",
        "Master/Slave mode select bit.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IIEN",
        "I2C interrupt enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IEN",
        "I2C enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2C_I2SR.
static const field_t hw_i2c_i2sr[] =
{
    {
        "RXAK",
        "Received acknowledge.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IIF",
        "I2C interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRW",
        "Slave read/write.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAL",
        "Arbitration lost.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IBB",
        "I2C bus busy bit.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IAAS",
        "I2C addressed as a slave bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ICF",
        "Data transferring bit.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2C_I2DR.
static const field_t hw_i2c_i2dr[] =
{
    {
        "DATA",
        "Data Byte.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a I2C module.
static const reg_t hw_i2c[] =
{
    {
        "IADR",
        "",
        2, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2c_iadr
    },
    {
        "IFDR",
        "The I2C_IFDR provides a programmable prescaler to configure the clock "
        "for bit-rate selection.",
        2, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2c_ifdr
    },
    {
        "I2CR",
        "The I2C_I2CR is used to enable the I2C and the I2C interrupt.",
        2, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_i2c_i2cr
    },
    {
        "I2SR",
        "The I2C_I2SR contains bits that indicate transaction direction and sta"
        "tus.",
        2, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_i2c_i2sr
    },
    {
        "I2DR",
        "In Master Receive mode, reading the data register allows a read to occ"
        "ur and initiates the next byte to be received.",
        2, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2c_i2dr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark I2S
#endif

// Bitfields in register I2S_TCSR.
static const field_t hw_i2s_tcsr[] =
{
    {
        "FRDE",
        "Enables/disables DMA requests.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWDE",
        "Enables/disables DMA requests.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRIE",
        "Enables/disables FIFO request interrupts.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWIE",
        "Enables/disables FIFO warning interrupts.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FEIE",
        "Enables/disables FIFO error interrupts.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEIE",
        "Enables/disables sync error interrupts.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSIE",
        "Enables/disables word start interrupts.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRF",
        "Indicates that the number of words in an enabled transmit channel FIFO"
        " is less than or equal to the transmit FIFO watermark.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FWF",
        "Indicates that an enabled transmit FIFO is empty.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FEF",
        "Indicates that an enabled transmit FIFO has underrun.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEF",
        "Indicates that an error in the externally-generated frame sync has bee"
        "n detected.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSF",
        "Indicates that the start of the configured word has been detected.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SR",
        "When set, resets the internal transmitter logic including the FIFO poi"
        "nters.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FR",
        "Resets the FIFO pointers.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BCE",
        "Enables the transmit bit clock, separately from the TE.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGE",
        "Enables/disables transmitter operation in Debug mode.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPE",
        "Configures transmitter operation in Stop mode.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TE",
        "Enables/disables the transmitter.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_TCR1.
static const field_t hw_i2s_tcr1[] =
{
    {
        "TFW",
        "Configures the watermark level for all enabled transmit channels.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_TCR2.
static const field_t hw_i2s_tcr2[] =
{
    {
        "DIV",
        "Divides down the audio master clock to generate the bit clock when con"
        "figured for an internal bit clock.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Configures the direction of the bit clock.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCP",
        "Configures the polarity of the bit clock.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSEL",
        "Selects the audio Master Clock option used to generate an internally g"
        "enerated bit clock.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCI",
        "When this field is set and using an internally generated bit clock in "
        "either synchronous or asynchronous mode, the bit clock actually used b"
        "y the transmitter is delayed by the pad output delay (the transmitter "
        "is clocked by the pad input as if the clock was externally generated).",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "This field swaps the bit clock used by the transmitter.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC",
        "Configures between asynchronous and synchronous modes of operation.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_TCR3.
static const field_t hw_i2s_tcr3[] =
{
    {
        "WDFL",
        "Configures which word sets the start of word flag.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCE",
        "Enables the corresponding data channel for transmit operation.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_TCR4.
static const field_t hw_i2s_tcr4[] =
{
    {
        "FSD",
        "Configures the direction of the frame sync.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSP",
        "Configures the polarity of the frame sync.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSE",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MF",
        "Configures whether the LSB or the MSB is transmitted first.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYWD",
        "Configures the length of the frame sync in number of bit clocks.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRSZ",
        "Configures the number of words in each frame.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_TCR5.
static const field_t hw_i2s_tcr5[] =
{
    {
        "FBT",
        "Configures the bit index for the first bit transmitted for each word i"
        "n the frame.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "W0W",
        "Configures the number of bits in the first word in each frame.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WNW",
        "Configures the number of bits in each word, for each word except the f"
        "irst in the frame.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_TDR0.
static const field_t hw_i2s_tdr0[] =
{
    {
        "TDR",
        "The corresponding TCR3[TCE] bit must be set before accessing the chann"
        "el's transmit data register.",
        0, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_TFR0.
static const field_t hw_i2s_tfr0[] =
{
    {
        "RFP",
        "FIFO read pointer for transmit data channel.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFP",
        "FIFO write pointer for transmit data channel.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_TMR.
static const field_t hw_i2s_tmr[] =
{
    {
        "TWM",
        "Configures whether the transmit word is masked (transmit data pin tris"
        "tated and transmit data not read from FIFO) for the corresponding word"
        " in the frame.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RCSR.
static const field_t hw_i2s_rcsr[] =
{
    {
        "FRDE",
        "Enables/disables DMA requests.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWDE",
        "Enables/disables DMA requests.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRIE",
        "Enables/disables FIFO request interrupts.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWIE",
        "Enables/disables FIFO warning interrupts.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FEIE",
        "Enables/disables FIFO error interrupts.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEIE",
        "Enables/disables sync error interrupts.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSIE",
        "Enables/disables word start interrupts.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRF",
        "Indicates that the number of words in an enabled receive channel FIFO "
        "is greater than the receive FIFO watermark.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FWF",
        "Indicates that an enabled receive FIFO is full.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FEF",
        "Indicates that an enabled receive FIFO has overflowed.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEF",
        "Indicates that an error in the externally-generated frame sync has bee"
        "n detected.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WSF",
        "Indicates that the start of the configured word has been detected.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SR",
        "Resets the internal receiver logic including the FIFO pointers.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FR",
        "Resets the FIFO pointers.",
        25, // LSB
        25, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BCE",
        "Enables the receive bit clock, separately from RE.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGE",
        "Enables/disables receiver operation in Debug mode.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPE",
        "Configures receiver operation in Stop mode.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RE",
        "Enables/disables the receiver.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RCR1.
static const field_t hw_i2s_rcr1[] =
{
    {
        "RFW",
        "Configures the watermark level for all enabled receiver channels.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RCR2.
static const field_t hw_i2s_rcr2[] =
{
    {
        "DIV",
        "Divides down the audio master clock to generate the bit clock when con"
        "figured for an internal bit clock.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCD",
        "Configures the direction of the bit clock.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCP",
        "Configures the polarity of the bit clock.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSEL",
        "Selects the audio Master Clock option used to generate an internally g"
        "enerated bit clock.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCI",
        "When this field is set and using an internally generated bit clock in "
        "either synchronous or asynchronous mode, the bit clock actually used b"
        "y the receiver is delayed by the pad output delay (the receiver is clo"
        "cked by the pad input as if the clock was externally generated).",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCS",
        "This field swaps the bit clock used by the receiver.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC",
        "Configures between asynchronous and synchronous modes of operation.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RCR3.
static const field_t hw_i2s_rcr3[] =
{
    {
        "WDFL",
        "Configures which word the start of word flag is set.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCE",
        "Enables the corresponding data channel for receive operation.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RCR4.
static const field_t hw_i2s_rcr4[] =
{
    {
        "FSD",
        "Configures the direction of the frame sync.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSP",
        "Configures the polarity of the frame sync.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSE",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MF",
        "Configures whether the LSB or the MSB is received first.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYWD",
        "Configures the length of the frame sync in number of bit clocks.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRSZ",
        "Configures the number of words in each frame.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RCR5.
static const field_t hw_i2s_rcr5[] =
{
    {
        "FBT",
        "Configures the bit index for the first bit received for each word in t"
        "he frame.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "W0W",
        "Configures the number of bits in the first word in each frame.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WNW",
        "Configures the number of bits in each word, for each word except the f"
        "irst in the frame.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RDR0.
static const field_t hw_i2s_rdr0[] =
{
    {
        "RDR",
        "The corresponding RCR3[RCE] bit must be set before accessing the chann"
        "el's receive data register.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RFR0.
static const field_t hw_i2s_rfr0[] =
{
    {
        "RFP",
        "FIFO read pointer for receive data channel.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WFP",
        "FIFO write pointer for receive data channel.",
        16, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register I2S_RMR.
static const field_t hw_i2s_rmr[] =
{
    {
        "RWM",
        "Configures whether the receive word is masked (received data ignored a"
        "nd not written to receive FIFO) for the corresponding word in the fram"
        "e.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a I2S module.
static const reg_t hw_i2s[] =
{
    {
        "TCSR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_i2s_tcsr
    },
    {
        "TCR1",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2s_tcr1
    },
    {
        "TCR2",
        "This register must not be altered when TCSR[TE] is set.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_i2s_tcr2
    },
    {
        "TCR3",
        "This register must not be altered when TCSR[TE] is set.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_i2s_tcr3
    },
    {
        "TCR4",
        "This register must not be altered when TCSR[TE] is set.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_i2s_tcr4
    },
    {
        "TCR5",
        "This register must not be altered when TCSR[TE] is set.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_i2s_tcr5
    },
    {
        "TDR0",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        false, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2s_tdr0
    },
    {
        "TFR0",
        "The MSB of the read and write pointers is used to distinguish between "
        "FIFO full and empty conditions.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_i2s_tfr0
    },
    {
        "TMR",
        "This register is double-buffered and updates: When TCSR[TE] is first s"
        "et At the end of each frame.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2s_tmr
    },
    {
        "RCSR",
        "",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_i2s_rcsr
    },
    {
        "RCR1",
        "",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2s_rcr1
    },
    {
        "RCR2",
        "This register must not be altered when RCSR[RE] is set.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_i2s_rcr2
    },
    {
        "RCR3",
        "This register must not be altered when RCSR[RE] is set.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_i2s_rcr3
    },
    {
        "RCR4",
        "This register must not be altered when RCSR[RE] is set.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_i2s_rcr4
    },
    {
        "RCR5",
        "This register must not be altered when RCSR[RE] is set.",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_i2s_rcr5
    },
    {
        "RDR0",
        "Reading this register introduces one additional peripheral clock wait "
        "state on each read.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_i2s_rdr0
    },
    {
        "RFR0",
        "The MSB of the read and write pointers is used to distinguish between "
        "FIFO full and empty conditions.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_i2s_rfr0
    },
    {
        "RMR",
        "This register is double-buffered and updates: When RCSR[RE] is first s"
        "et At the end of each frame This allows the masked words in each frame"
        " to change from frame to frame.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_i2s_rmr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark IOMUXC
#endif

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_BOOT_MODE0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_boot_mode0[] =
{
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_BOOT_MODE1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_boot_mode1[] =
{
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SNVS_TAMPER0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_snvs_tamper0[] =
{
    {
        "MUX_MODE",
        "ALT5 mode is only valid when TAMPER PIN is used as GPIO.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SNVS_TAMPER1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_snvs_tamper1[] =
{
    {
        "MUX_MODE",
        "ALT5 mode is only valid when TAMPER PIN is used as GPIO.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SNVS_TAMPER2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_snvs_tamper2[] =
{
    {
        "MUX_MODE",
        "ALT5 mode is only valid when TAMPER PIN is used as GPIO.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SNVS_TAMPER3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_snvs_tamper3[] =
{
    {
        "MUX_MODE",
        "ALT5 mode is only valid when TAMPER PIN is used as GPIO.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SNVS_TAMPER4.
static const field_t hw_iomuxc_sw_mux_ctl_pad_snvs_tamper4[] =
{
    {
        "MUX_MODE",
        "ALT5 mode is only valid when TAMPER PIN is used as GPIO.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SNVS_TAMPER5.
static const field_t hw_iomuxc_sw_mux_ctl_pad_snvs_tamper5[] =
{
    {
        "MUX_MODE",
        "ALT5 mode is only valid when TAMPER PIN is used as GPIO.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SNVS_TAMPER6.
static const field_t hw_iomuxc_sw_mux_ctl_pad_snvs_tamper6[] =
{
    {
        "MUX_MODE",
        "ALT5 mode is only valid when TAMPER PIN is used as GPIO.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SNVS_TAMPER7.
static const field_t hw_iomuxc_sw_mux_ctl_pad_snvs_tamper7[] =
{
    {
        "MUX_MODE",
        "ALT5 mode is only valid when TAMPER PIN is used as GPIO.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SNVS_TAMPER8.
static const field_t hw_iomuxc_sw_mux_ctl_pad_snvs_tamper8[] =
{
    {
        "MUX_MODE",
        "ALT5 mode is only valid when TAMPER PIN is used as GPIO.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SNVS_TAMPER9.
static const field_t hw_iomuxc_sw_mux_ctl_pad_snvs_tamper9[] =
{
    {
        "MUX_MODE",
        "ALT5 mode is only valid when TAMPER PIN is used as GPIO.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_JTAG_MOD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_jtag_mod[] =
{
    {
        "MUX_MODE",
        "Select 1 of 7 iomux modes to be used for pad: JTAG_MOD.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_JTAG_TMS.
static const field_t hw_iomuxc_sw_mux_ctl_pad_jtag_tms[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: JTAG_TMS.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_JTAG_TDO.
static const field_t hw_iomuxc_sw_mux_ctl_pad_jtag_tdo[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: JTAG_TDO.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_JTAG_TDI.
static const field_t hw_iomuxc_sw_mux_ctl_pad_jtag_tdi[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: JTAG_TDI.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_JTAG_TCK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_jtag_tck[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: JTAG_TCK.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_JTAG_TRST_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_jtag_trst_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 8 iomux modes to be used for pad: JTAG_TRST_B.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io00[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: GPIO1_IO00.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO01.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io01[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: GPIO1_IO01.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO02.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io02[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: GPIO1_IO02.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io03[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: GPIO1_IO03.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io04[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: GPIO1_IO04.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO05.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io05[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: GPIO1_IO05.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO06.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io06[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: GPIO1_IO06.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO07.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io07[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: GPIO1_IO07.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO08.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io08[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: GPIO1_IO08.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO09.
static const field_t hw_iomuxc_sw_mux_ctl_pad_gpio1_io09[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: GPIO1_IO09.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART1_TX_DATA.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart1_tx_data[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: UART1_TX_DATA.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART1_RX_DATA.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart1_rx_data[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: UART1_RX_DATA.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART1_CTS_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart1_cts_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: UART1_CTS_B.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART1_RTS_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart1_rts_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: UART1_RTS_B.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART2_TX_DATA.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart2_tx_data[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: UART2_TX_DATA.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART2_RX_DATA.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart2_rx_data[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: UART2_RX_DATA.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART2_CTS_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart2_cts_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: UART2_CTS_B.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART2_RTS_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart2_rts_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: UART2_RTS_B.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART3_TX_DATA.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart3_tx_data[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: UART3_TX_DATA.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART3_RX_DATA.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart3_rx_data[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: UART3_RX_DATA.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART3_CTS_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart3_cts_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: UART3_CTS_B.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART3_RTS_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart3_rts_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: UART3_RTS_B.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART4_TX_DATA.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart4_tx_data[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: UART4_TX_DATA.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART4_RX_DATA.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart4_rx_data[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: UART4_RX_DATA.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART5_TX_DATA.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart5_tx_data[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: UART5_TX_DATA.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_UART5_RX_DATA.
static const field_t hw_iomuxc_sw_mux_ctl_pad_uart5_rx_data[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: UART5_RX_DATA.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET1_RX_DATA0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet1_rx_data0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: ENET1_RX_DATA0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET1_RX_DATA1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet1_rx_data1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: ENET1_RX_DATA1.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET1_RX_EN.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet1_rx_en[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: ENET1_RX_EN.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET1_TX_DATA0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet1_tx_data0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: ENET1_TX_DATA0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET1_TX_DATA1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet1_tx_data1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: ENET1_TX_DATA1.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET1_TX_EN.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet1_tx_en[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: ENET1_TX_EN.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET1_TX_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet1_tx_clk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: ENET1_TX_CLK.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET1_RX_ER.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet1_rx_er[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: ENET1_RX_ER.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET2_RX_DATA0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet2_rx_data0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: ENET2_RX_DATA0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET2_RX_DATA1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet2_rx_data1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: ENET2_RX_DATA1.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET2_RX_EN.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet2_rx_en[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: ENET2_RX_EN.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET2_TX_DATA0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet2_tx_data0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: ENET2_TX_DATA0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET2_TX_DATA1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet2_tx_data1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: ENET2_TX_DATA1.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET2_TX_EN.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet2_tx_en[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: ENET2_TX_EN.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET2_TX_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet2_tx_clk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: ENET2_TX_CLK.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_ENET2_RX_ER.
static const field_t hw_iomuxc_sw_mux_ctl_pad_enet2_rx_er[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: ENET2_RX_ER.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_clk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_CLK.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_ENABLE.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_enable[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_ENABLE.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_HSYNC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_hsync[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_HSYNC.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_VSYNC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_vsync[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_VSYNC.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_RESET.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_reset[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_RESET.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA00.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data00[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA00.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA01.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data01[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA01.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA02.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data02[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA02.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA03.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data03[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA03.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA04.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data04[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA04.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA05.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data05[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA05.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA06.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data06[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA06.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA07.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data07[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA07.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA08.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data08[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA08.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA09.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data09[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA09.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA10.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data10[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA10.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA11.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data11[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA11.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA12.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data12[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA12.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA13.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data13[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA13.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA14.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data14[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA14.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA15.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data15[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA15.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA16.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data16[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA16.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA17.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data17[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA17.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA18.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data18[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA18.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA19.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data19[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA19.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA20.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data20[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA20.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA21.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data21[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA21.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA22.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data22[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA22.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_LCD_DATA23.
static const field_t hw_iomuxc_sw_mux_ctl_pad_lcd_data23[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: LCD_DATA23.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_RE_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_re_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_RE_B.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_WE_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_we_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_WE_B.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DATA00.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_data00[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_DATA00.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DATA01.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_data01[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_DATA01.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DATA02.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_data02[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_DATA02.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DATA03.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_data03[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_DATA03.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DATA04.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_data04[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_DATA04.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DATA05.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_data05[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_DATA05.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DATA06.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_data06[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_DATA06.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DATA07.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_data07[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_DATA07.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_ALE.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_ale[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_ALE.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_WP_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_wp_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_WP_B.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_READY_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_ready_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_READY_B.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_CE0_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_ce0_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_CE0_B.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_CE1_B.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_ce1_b[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_CE1_B.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_CLE.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_cle[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_CLE.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_NAND_DQS.
static const field_t hw_iomuxc_sw_mux_ctl_pad_nand_dqs[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: NAND_DQS.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_CMD.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_cmd[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: SD1_CMD.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_CLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_clk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: SD1_CLK.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DATA0.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_data0[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: SD1_DATA0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DATA1.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_data1[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: SD1_DATA1.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DATA2.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_data2[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: SD1_DATA2.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_SD1_DATA3.
static const field_t hw_iomuxc_sw_mux_ctl_pad_sd1_data3[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: SD1_DATA3.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_MCLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_mclk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: CSI_MCLK.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_PIXCLK.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_pixclk[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: CSI_PIXCLK.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_VSYNC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_vsync[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: CSI_VSYNC.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_HSYNC.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_hsync[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: CSI_HSYNC.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_DATA00.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_data00[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: CSI_DATA00.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_DATA01.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_data01[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: CSI_DATA01.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_DATA02.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_data02[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: CSI_DATA02.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_DATA03.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_data03[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: CSI_DATA03.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_DATA04.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_data04[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: CSI_DATA04.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_DATA05.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_data05[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: CSI_DATA05.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_DATA06.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_data06[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: CSI_DATA06.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_MUX_CTL_PAD_CSI_DATA07.
static const field_t hw_iomuxc_sw_mux_ctl_pad_csi_data07[] =
{
    {
        "MUX_MODE",
        "Select 1 of 9 iomux modes to be used for pad: CSI_DATA07.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SION",
        "Force the selected mux mode Input path no matter of MUX_MODE functiona"
        "lity.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR00.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr00[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ADDR00",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ADDR00",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ADDR00",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Read Only Field",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR01.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr01[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ADDR01",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ADDR01",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ADDR01",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Read Only Field",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR02.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr02[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ADDR02",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ADDR02",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ADDR02",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Read Only Field",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR03.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr03[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ADDR03",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ADDR03",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ADDR03",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Read Only Field",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR04.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr04[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ADDR04",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ADDR04",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ADDR04",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Read Only Field",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR05.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr05[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ADDR05",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ADDR05",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ADDR05",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Read Only Field",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR06.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr06[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ADDR06",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ADDR06",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ADDR06",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Read Only Field",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR07.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr07[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ADDR07",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ADDR07",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ADDR07",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Read Only Field",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR08.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr08[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ADDR08",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ADDR08",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ADDR08",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Read Only Field",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR09.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr09[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ADDR09",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ADDR09",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ADDR09",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Read Only Field",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR10.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr10[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ADDR10",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ADDR10",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ADDR10",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_ADDR10",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR11.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr11[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ADDR11",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ADDR11",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ADDR11",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_ADDR11",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR12.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr12[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ADDR12",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ADDR12",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ADDR12",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_ADDR12",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR13.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr13[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ADDR13",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ADDR13",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ADDR13",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_ADDR13",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR14.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr14[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ADDR14",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ADDR14",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ADDR14",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_ADDR14",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ADDR15.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_addr15[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ADDR15",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ADDR15",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ADDR15",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_ADDR15",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm0[] =
{
    {
        "DSE",
        "Select one out of next values for pad: DRAM_DQM0",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_DQM0",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_DQM0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_DQM0",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Read Only Field",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_DQM1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_dqm1[] =
{
    {
        "DSE",
        "Select one out of next values for pad: DRAM_DQM1",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_DQM1",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_DQM1",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_DQM1",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Read Only Field",
        20, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_RAS_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_ras_b[] =
{
    {
        "DSE",
        "Select one out of next values for pad: DRAM_RAS_B",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_RAS_B",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_RAS_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_RAS_B",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_RAS_B",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_CAS_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_cas_b[] =
{
    {
        "DSE",
        "Select one out of next values for pad: DRAM_CAS_B",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_CAS_B",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_CAS_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_CAS_B",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_CAS_B",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_CS0_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_cs0_b[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_CS0_B",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_CS0_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_CS0_B",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_CS0_B",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_CS1_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_cs1_b[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_CS1_B",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_CS1_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_CS1_B",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_CS1_B",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDWE_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdwe_b[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_SDWE_B",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_SDWE_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_SDWE_B",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_SDWE_B",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ODT0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_odt0[] =
{
    {
        "DSE",
        "Select one out of next values for pad: DRAM_ODT0",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ODT0",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: DRAM_ODT0",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: DRAM_ODT0",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: DRAM_ODT0",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ODT0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ODT0",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_ODT0",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_ODT1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_odt1[] =
{
    {
        "DSE",
        "Select one out of next values for pad: DRAM_ODT1",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_ODT1",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: DRAM_ODT1",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: DRAM_ODT1",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: DRAM_ODT1",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_ODT1",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_ODT1",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_ODT1",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdba0[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_SDBA0",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_SDBA0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_SDBA0",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_SDBA0",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdba1[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_SDBA1",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_SDBA1",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_SDBA1",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_SDBA1",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDBA2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdba2[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_SDBA2",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: DRAM_SDBA2",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: DRAM_SDBA2",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_SDBA2",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_SDBA2",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_SDBA2",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdcke0[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_SDCKE0",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: DRAM_SDCKE0",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: DRAM_SDCKE0",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: DRAM_SDCKE0",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_SDCKE0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_SDCKE0",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_SDCKE0",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCKE1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdcke1[] =
{
    {
        "DSE",
        "Read Only Field",
        3, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_SDCKE1",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: DRAM_SDCKE1",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: DRAM_SDCKE1",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: DRAM_SDCKE1",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_SDCKE1",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_SDCKE1",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_SDCKE1",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDCLK0_P.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdclk0_p[] =
{
    {
        "DSE",
        "Select one out of next values for pad: DRAM_SDCLK0_P",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_SDCLK0_P",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Read Only Field",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUE",
        "Read Only Field",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PUS",
        "Read Only Field",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_SDCLK0_P",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_SDCLK0_P",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_SDCLK0_P",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM_PADN",
        "Select one out of next values for pad: DRAM_SDCLK0_P",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS0_P.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs0_p[] =
{
    {
        "DSE",
        "Select one out of next values for pad: DRAM_SDQS0_P",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Read Only Field",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: DRAM_SDQS0_P",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: DRAM_SDQS0_P",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: DRAM_SDQS0_P",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Read Only Field",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_INPUT",
        "Read Only Field",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_SDQS0_P",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM_PADN",
        "Select one out of next values for pad: DRAM_SDQS0_P",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_SDQS1_P.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_sdqs1_p[] =
{
    {
        "DSE",
        "Select one out of next values for pad: DRAM_SDQS1_P",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Read Only Field",
        8, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: DRAM_SDQS1_P",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: DRAM_SDQS1_P",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: DRAM_SDQS1_P",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Read Only Field",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_INPUT",
        "Read Only Field",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR_SEL",
        "Read Only Field",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_SDQS1_P",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM_PADN",
        "Select one out of next values for pad: DRAM_SDQS1_P",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_DRAM_RESET.
static const field_t hw_iomuxc_sw_pad_ctl_pad_dram_reset[] =
{
    {
        "DSE",
        "Select one out of next values for pad: DRAM_RESET",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT",
        "Select one out of next values for pad: DRAM_RESET",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: DRAM_RESET",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: DRAM_RESET",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: DRAM_RESET",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: DRAM_RESET",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_INPUT",
        "Select one out of next values for pad: DRAM_RESET",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_SEL",
        "Select one out of next values for pad: DRAM_RESET",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DO_TRIM",
        "Select one out of next values for pad: DRAM_RESET",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_TEST_MODE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_test_mode[] =
{
    {
        "SRE",
        "Select one out of next values for pad: TEST_MODE",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: TEST_MODE",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: TEST_MODE",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: TEST_MODE",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: TEST_MODE",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: TEST_MODE",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: TEST_MODE",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_POR_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_por_b[] =
{
    {
        "SRE",
        "Select one out of next values for pad: POR_B",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: POR_B",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: POR_B",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: POR_B",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: POR_B",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: POR_B",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: POR_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ONOFF.
static const field_t hw_iomuxc_sw_pad_ctl_pad_onoff[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ONOFF",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ONOFF",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ONOFF",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ONOFF",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ONOFF",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ONOFF",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ONOFF",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SNVS_PMIC_ON_REQ.
static const field_t hw_iomuxc_sw_pad_ctl_pad_snvs_pmic_on_req[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SNVS_PMIC_ON_REQ",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SNVS_PMIC_ON_REQ",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SNVS_PMIC_ON_REQ",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SNVS_PMIC_ON_REQ",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SNVS_PMIC_ON_REQ",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SNVS_PMIC_ON_REQ",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SNVS_PMIC_ON_REQ",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CCM_PMIC_STBY_REQ.
static const field_t hw_iomuxc_sw_pad_ctl_pad_ccm_pmic_stby_req[] =
{
    {
        "SRE",
        "Select one out of next values for pad: CCM_PMIC_STBY_REQ",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: CCM_PMIC_STBY_REQ",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: CCM_PMIC_STBY_REQ",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: CCM_PMIC_STBY_REQ",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: CCM_PMIC_STBY_REQ",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: CCM_PMIC_STBY_REQ",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: CCM_PMIC_STBY_REQ",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_BOOT_MODE0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_boot_mode0[] =
{
    {
        "SRE",
        "Select one out of next values for pad: BOOT_MODE0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: BOOT_MODE0",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: BOOT_MODE0",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: BOOT_MODE0",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: BOOT_MODE0",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: BOOT_MODE0",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: BOOT_MODE0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_BOOT_MODE1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_boot_mode1[] =
{
    {
        "SRE",
        "Select one out of next values for pad: BOOT_MODE1",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: BOOT_MODE1",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: BOOT_MODE1",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: BOOT_MODE1",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: BOOT_MODE1",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: BOOT_MODE1",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: BOOT_MODE1",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SNVS_TAMPER0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_snvs_tamper0[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SNVS_TAMPER0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SNVS_TAMPER0",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SNVS_TAMPER0",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SNVS_TAMPER0",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SNVS_TAMPER0",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SNVS_TAMPER0",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SNVS_TAMPER0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SNVS_TAMPER1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_snvs_tamper1[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SNVS_TAMPER1",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SNVS_TAMPER1",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SNVS_TAMPER1",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SNVS_TAMPER1",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SNVS_TAMPER1",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SNVS_TAMPER1",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SNVS_TAMPER1",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SNVS_TAMPER2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_snvs_tamper2[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SNVS_TAMPER2",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SNVS_TAMPER2",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SNVS_TAMPER2",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SNVS_TAMPER2",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SNVS_TAMPER2",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SNVS_TAMPER2",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SNVS_TAMPER2",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SNVS_TAMPER3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_snvs_tamper3[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SNVS_TAMPER3",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SNVS_TAMPER3",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SNVS_TAMPER3",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SNVS_TAMPER3",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SNVS_TAMPER3",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SNVS_TAMPER3",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SNVS_TAMPER3",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SNVS_TAMPER4.
static const field_t hw_iomuxc_sw_pad_ctl_pad_snvs_tamper4[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SNVS_TAMPER4",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SNVS_TAMPER4",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SNVS_TAMPER4",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SNVS_TAMPER4",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SNVS_TAMPER4",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SNVS_TAMPER4",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SNVS_TAMPER4",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SNVS_TAMPER5.
static const field_t hw_iomuxc_sw_pad_ctl_pad_snvs_tamper5[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SNVS_TAMPER5",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SNVS_TAMPER5",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SNVS_TAMPER5",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SNVS_TAMPER5",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SNVS_TAMPER5",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SNVS_TAMPER5",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SNVS_TAMPER5",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SNVS_TAMPER6.
static const field_t hw_iomuxc_sw_pad_ctl_pad_snvs_tamper6[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SNVS_TAMPER6",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SNVS_TAMPER6",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SNVS_TAMPER6",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SNVS_TAMPER6",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SNVS_TAMPER6",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SNVS_TAMPER6",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SNVS_TAMPER6",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SNVS_TAMPER7.
static const field_t hw_iomuxc_sw_pad_ctl_pad_snvs_tamper7[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SNVS_TAMPER7",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SNVS_TAMPER7",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SNVS_TAMPER7",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SNVS_TAMPER7",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SNVS_TAMPER7",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SNVS_TAMPER7",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SNVS_TAMPER7",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SNVS_TAMPER8.
static const field_t hw_iomuxc_sw_pad_ctl_pad_snvs_tamper8[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SNVS_TAMPER8",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SNVS_TAMPER8",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SNVS_TAMPER8",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SNVS_TAMPER8",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SNVS_TAMPER8",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SNVS_TAMPER8",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SNVS_TAMPER8",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SNVS_TAMPER9.
static const field_t hw_iomuxc_sw_pad_ctl_pad_snvs_tamper9[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SNVS_TAMPER9",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SNVS_TAMPER9",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SNVS_TAMPER9",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SNVS_TAMPER9",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SNVS_TAMPER9",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SNVS_TAMPER9",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SNVS_TAMPER9",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_MOD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_mod[] =
{
    {
        "SRE",
        "Select one out of next values for pad: JTAG_MOD",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: JTAG_MOD",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: JTAG_MOD",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: JTAG_MOD",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: JTAG_MOD",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: JTAG_MOD",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: JTAG_MOD",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TMS.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_tms[] =
{
    {
        "SRE",
        "Select one out of next values for pad: JTAG_TMS",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: JTAG_TMS",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: JTAG_TMS",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: JTAG_TMS",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: JTAG_TMS",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: JTAG_TMS",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: JTAG_TMS",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TDO.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_tdo[] =
{
    {
        "SRE",
        "Select one out of next values for pad: JTAG_TDO",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: JTAG_TDO",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: JTAG_TDO",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: JTAG_TDO",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: JTAG_TDO",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: JTAG_TDO",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: JTAG_TDO",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TDI.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_tdi[] =
{
    {
        "SRE",
        "Select one out of next values for pad: JTAG_TDI",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: JTAG_TDI",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: JTAG_TDI",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: JTAG_TDI",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: JTAG_TDI",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: JTAG_TDI",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: JTAG_TDI",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TCK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_tck[] =
{
    {
        "SRE",
        "Select one out of next values for pad: JTAG_TCK",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: JTAG_TCK",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: JTAG_TCK",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: JTAG_TCK",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: JTAG_TCK",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: JTAG_TCK",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: JTAG_TCK",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_JTAG_TRST_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_jtag_trst_b[] =
{
    {
        "SRE",
        "Select one out of next values for pad: JTAG_TRST_B",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: JTAG_TRST_B",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Read Only Field",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: JTAG_TRST_B",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: JTAG_TRST_B",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: JTAG_TRST_B",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: JTAG_TRST_B",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: JTAG_TRST_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO00.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io00[] =
{
    {
        "SRE",
        "Select one out of next values for pad: GPIO1_IO00",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: GPIO1_IO00",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: GPIO1_IO00",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: GPIO1_IO00",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: GPIO1_IO00",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: GPIO1_IO00",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: GPIO1_IO00",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: GPIO1_IO00",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO01.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io01[] =
{
    {
        "SRE",
        "Select one out of next values for pad: GPIO1_IO01",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: GPIO1_IO01",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: GPIO1_IO01",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: GPIO1_IO01",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: GPIO1_IO01",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: GPIO1_IO01",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: GPIO1_IO01",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: GPIO1_IO01",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO02.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io02[] =
{
    {
        "SRE",
        "Select one out of next values for pad: GPIO1_IO02",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: GPIO1_IO02",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: GPIO1_IO02",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: GPIO1_IO02",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: GPIO1_IO02",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: GPIO1_IO02",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: GPIO1_IO02",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: GPIO1_IO02",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io03[] =
{
    {
        "SRE",
        "Select one out of next values for pad: GPIO1_IO03",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: GPIO1_IO03",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: GPIO1_IO03",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: GPIO1_IO03",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: GPIO1_IO03",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: GPIO1_IO03",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: GPIO1_IO03",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: GPIO1_IO03",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io04[] =
{
    {
        "SRE",
        "Select one out of next values for pad: GPIO1_IO04",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: GPIO1_IO04",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: GPIO1_IO04",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: GPIO1_IO04",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: GPIO1_IO04",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: GPIO1_IO04",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: GPIO1_IO04",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: GPIO1_IO04",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO05.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io05[] =
{
    {
        "SRE",
        "Select one out of next values for pad: GPIO1_IO05",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: GPIO1_IO05",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: GPIO1_IO05",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: GPIO1_IO05",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: GPIO1_IO05",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: GPIO1_IO05",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: GPIO1_IO05",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: GPIO1_IO05",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO06.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io06[] =
{
    {
        "SRE",
        "Select one out of next values for pad: GPIO1_IO06",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: GPIO1_IO06",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: GPIO1_IO06",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: GPIO1_IO06",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: GPIO1_IO06",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: GPIO1_IO06",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: GPIO1_IO06",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: GPIO1_IO06",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO07.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io07[] =
{
    {
        "SRE",
        "Select one out of next values for pad: GPIO1_IO07",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: GPIO1_IO07",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: GPIO1_IO07",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: GPIO1_IO07",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: GPIO1_IO07",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: GPIO1_IO07",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: GPIO1_IO07",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: GPIO1_IO07",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO08.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io08[] =
{
    {
        "SRE",
        "Select one out of next values for pad: GPIO1_IO08",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: GPIO1_IO08",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: GPIO1_IO08",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: GPIO1_IO08",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: GPIO1_IO08",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: GPIO1_IO08",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: GPIO1_IO08",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: GPIO1_IO08",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO09.
static const field_t hw_iomuxc_sw_pad_ctl_pad_gpio1_io09[] =
{
    {
        "SRE",
        "Select one out of next values for pad: GPIO1_IO09",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: GPIO1_IO09",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: GPIO1_IO09",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: GPIO1_IO09",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: GPIO1_IO09",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: GPIO1_IO09",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: GPIO1_IO09",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: GPIO1_IO09",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART1_TX_DATA.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart1_tx_data[] =
{
    {
        "SRE",
        "Select one out of next values for pad: UART1_TX_DATA",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: UART1_TX_DATA",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: UART1_TX_DATA",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: UART1_TX_DATA",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: UART1_TX_DATA",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: UART1_TX_DATA",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: UART1_TX_DATA",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: UART1_TX_DATA",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART1_RX_DATA.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart1_rx_data[] =
{
    {
        "SRE",
        "Select one out of next values for pad: UART1_RX_DATA",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: UART1_RX_DATA",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: UART1_RX_DATA",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: UART1_RX_DATA",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: UART1_RX_DATA",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: UART1_RX_DATA",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: UART1_RX_DATA",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: UART1_RX_DATA",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART1_CTS_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart1_cts_b[] =
{
    {
        "SRE",
        "Select one out of next values for pad: UART1_CTS_B",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: UART1_CTS_B",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: UART1_CTS_B",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: UART1_CTS_B",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: UART1_CTS_B",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: UART1_CTS_B",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: UART1_CTS_B",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: UART1_CTS_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART1_RTS_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart1_rts_b[] =
{
    {
        "SRE",
        "Select one out of next values for pad: UART1_RTS_B",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: UART1_RTS_B",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: UART1_RTS_B",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: UART1_RTS_B",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: UART1_RTS_B",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: UART1_RTS_B",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: UART1_RTS_B",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: UART1_RTS_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART2_TX_DATA.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart2_tx_data[] =
{
    {
        "SRE",
        "Select one out of next values for pad: UART2_TX_DATA",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: UART2_TX_DATA",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: UART2_TX_DATA",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: UART2_TX_DATA",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: UART2_TX_DATA",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: UART2_TX_DATA",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: UART2_TX_DATA",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: UART2_TX_DATA",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART2_RX_DATA.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart2_rx_data[] =
{
    {
        "SRE",
        "Select one out of next values for pad: UART2_RX_DATA",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: UART2_RX_DATA",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: UART2_RX_DATA",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: UART2_RX_DATA",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: UART2_RX_DATA",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: UART2_RX_DATA",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: UART2_RX_DATA",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: UART2_RX_DATA",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART2_CTS_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart2_cts_b[] =
{
    {
        "SRE",
        "Select one out of next values for pad: UART2_CTS_B",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: UART2_CTS_B",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: UART2_CTS_B",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: UART2_CTS_B",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: UART2_CTS_B",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: UART2_CTS_B",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: UART2_CTS_B",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: UART2_CTS_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART2_RTS_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart2_rts_b[] =
{
    {
        "SRE",
        "Select one out of next values for pad: UART2_RTS_B",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: UART2_RTS_B",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: UART2_RTS_B",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: UART2_RTS_B",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: UART2_RTS_B",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: UART2_RTS_B",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: UART2_RTS_B",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: UART2_RTS_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART3_TX_DATA.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart3_tx_data[] =
{
    {
        "SRE",
        "Select one out of next values for pad: UART3_TX_DATA",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: UART3_TX_DATA",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: UART3_TX_DATA",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: UART3_TX_DATA",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: UART3_TX_DATA",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: UART3_TX_DATA",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: UART3_TX_DATA",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: UART3_TX_DATA",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART3_RX_DATA.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart3_rx_data[] =
{
    {
        "SRE",
        "Select one out of next values for pad: UART3_RX_DATA",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: UART3_RX_DATA",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: UART3_RX_DATA",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: UART3_RX_DATA",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: UART3_RX_DATA",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: UART3_RX_DATA",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: UART3_RX_DATA",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: UART3_RX_DATA",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART3_CTS_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart3_cts_b[] =
{
    {
        "SRE",
        "Select one out of next values for pad: UART3_CTS_B",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: UART3_CTS_B",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: UART3_CTS_B",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: UART3_CTS_B",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: UART3_CTS_B",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: UART3_CTS_B",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: UART3_CTS_B",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: UART3_CTS_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART3_RTS_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart3_rts_b[] =
{
    {
        "SRE",
        "Select one out of next values for pad: UART3_RTS_B",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: UART3_RTS_B",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: UART3_RTS_B",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: UART3_RTS_B",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: UART3_RTS_B",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: UART3_RTS_B",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: UART3_RTS_B",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: UART3_RTS_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART4_TX_DATA.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart4_tx_data[] =
{
    {
        "SRE",
        "Select one out of next values for pad: UART4_TX_DATA",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: UART4_TX_DATA",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: UART4_TX_DATA",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: UART4_TX_DATA",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: UART4_TX_DATA",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: UART4_TX_DATA",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: UART4_TX_DATA",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: UART4_TX_DATA",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART4_RX_DATA.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart4_rx_data[] =
{
    {
        "SRE",
        "Select one out of next values for pad: UART4_RX_DATA",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: UART4_RX_DATA",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: UART4_RX_DATA",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: UART4_RX_DATA",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: UART4_RX_DATA",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: UART4_RX_DATA",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: UART4_RX_DATA",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: UART4_RX_DATA",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART5_TX_DATA.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart5_tx_data[] =
{
    {
        "SRE",
        "Select one out of next values for pad: UART5_TX_DATA",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: UART5_TX_DATA",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: UART5_TX_DATA",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: UART5_TX_DATA",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: UART5_TX_DATA",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: UART5_TX_DATA",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: UART5_TX_DATA",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: UART5_TX_DATA",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_UART5_RX_DATA.
static const field_t hw_iomuxc_sw_pad_ctl_pad_uart5_rx_data[] =
{
    {
        "SRE",
        "Select one out of next values for pad: UART5_RX_DATA",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: UART5_RX_DATA",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: UART5_RX_DATA",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: UART5_RX_DATA",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: UART5_RX_DATA",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: UART5_RX_DATA",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: UART5_RX_DATA",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: UART5_RX_DATA",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET1_RX_DATA0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet1_rx_data0[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ENET1_RX_DATA0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ENET1_RX_DATA0",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: ENET1_RX_DATA0",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ENET1_RX_DATA0",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ENET1_RX_DATA0",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ENET1_RX_DATA0",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ENET1_RX_DATA0",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ENET1_RX_DATA0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET1_RX_DATA1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet1_rx_data1[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ENET1_RX_DATA1",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ENET1_RX_DATA1",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: ENET1_RX_DATA1",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ENET1_RX_DATA1",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ENET1_RX_DATA1",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ENET1_RX_DATA1",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ENET1_RX_DATA1",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ENET1_RX_DATA1",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET1_RX_EN.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet1_rx_en[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ENET1_RX_EN",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ENET1_RX_EN",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: ENET1_RX_EN",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ENET1_RX_EN",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ENET1_RX_EN",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ENET1_RX_EN",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ENET1_RX_EN",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ENET1_RX_EN",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET1_TX_DATA0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet1_tx_data0[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ENET1_TX_DATA0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ENET1_TX_DATA0",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: ENET1_TX_DATA0",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ENET1_TX_DATA0",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ENET1_TX_DATA0",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ENET1_TX_DATA0",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ENET1_TX_DATA0",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ENET1_TX_DATA0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET1_TX_DATA1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet1_tx_data1[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ENET1_TX_DATA1",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ENET1_TX_DATA1",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: ENET1_TX_DATA1",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ENET1_TX_DATA1",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ENET1_TX_DATA1",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ENET1_TX_DATA1",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ENET1_TX_DATA1",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ENET1_TX_DATA1",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET1_TX_EN.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet1_tx_en[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ENET1_TX_EN",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ENET1_TX_EN",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: ENET1_TX_EN",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ENET1_TX_EN",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ENET1_TX_EN",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ENET1_TX_EN",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ENET1_TX_EN",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ENET1_TX_EN",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET1_TX_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet1_tx_clk[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ENET1_TX_CLK",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ENET1_TX_CLK",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: ENET1_TX_CLK",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ENET1_TX_CLK",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ENET1_TX_CLK",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ENET1_TX_CLK",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ENET1_TX_CLK",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ENET1_TX_CLK",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET1_RX_ER.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet1_rx_er[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ENET1_RX_ER",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ENET1_RX_ER",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: ENET1_RX_ER",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ENET1_RX_ER",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ENET1_RX_ER",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ENET1_RX_ER",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ENET1_RX_ER",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ENET1_RX_ER",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET2_RX_DATA0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet2_rx_data0[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ENET2_RX_DATA0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ENET2_RX_DATA0",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: ENET2_RX_DATA0",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ENET2_RX_DATA0",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ENET2_RX_DATA0",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ENET2_RX_DATA0",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ENET2_RX_DATA0",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ENET2_RX_DATA0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET2_RX_DATA1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet2_rx_data1[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ENET2_RX_DATA1",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ENET2_RX_DATA1",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: ENET2_RX_DATA1",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ENET2_RX_DATA1",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ENET2_RX_DATA1",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ENET2_RX_DATA1",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ENET2_RX_DATA1",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ENET2_RX_DATA1",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET2_RX_EN.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet2_rx_en[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ENET2_RX_EN",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ENET2_RX_EN",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: ENET2_RX_EN",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ENET2_RX_EN",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ENET2_RX_EN",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ENET2_RX_EN",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ENET2_RX_EN",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ENET2_RX_EN",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET2_TX_DATA0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet2_tx_data0[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ENET2_TX_DATA0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ENET2_TX_DATA0",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: ENET2_TX_DATA0",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ENET2_TX_DATA0",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ENET2_TX_DATA0",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ENET2_TX_DATA0",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ENET2_TX_DATA0",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ENET2_TX_DATA0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET2_TX_DATA1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet2_tx_data1[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ENET2_TX_DATA1",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ENET2_TX_DATA1",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: ENET2_TX_DATA1",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ENET2_TX_DATA1",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ENET2_TX_DATA1",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ENET2_TX_DATA1",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ENET2_TX_DATA1",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ENET2_TX_DATA1",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET2_TX_EN.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet2_tx_en[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ENET2_TX_EN",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ENET2_TX_EN",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: ENET2_TX_EN",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ENET2_TX_EN",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ENET2_TX_EN",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ENET2_TX_EN",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ENET2_TX_EN",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ENET2_TX_EN",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET2_TX_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet2_tx_clk[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ENET2_TX_CLK",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ENET2_TX_CLK",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: ENET2_TX_CLK",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ENET2_TX_CLK",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ENET2_TX_CLK",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ENET2_TX_CLK",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ENET2_TX_CLK",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ENET2_TX_CLK",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_ENET2_RX_ER.
static const field_t hw_iomuxc_sw_pad_ctl_pad_enet2_rx_er[] =
{
    {
        "SRE",
        "Select one out of next values for pad: ENET2_RX_ER",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: ENET2_RX_ER",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: ENET2_RX_ER",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: ENET2_RX_ER",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: ENET2_RX_ER",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: ENET2_RX_ER",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: ENET2_RX_ER",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: ENET2_RX_ER",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_clk[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_CLK",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_CLK",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_CLK",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_CLK",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_CLK",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_CLK",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_CLK",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_CLK",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_ENABLE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_enable[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_ENABLE",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_ENABLE",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_ENABLE",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_ENABLE",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_ENABLE",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_ENABLE",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_ENABLE",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_ENABLE",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_HSYNC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_hsync[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_HSYNC",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_HSYNC",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_HSYNC",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_HSYNC",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_HSYNC",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_HSYNC",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_HSYNC",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_HSYNC",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_VSYNC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_vsync[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_VSYNC",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_VSYNC",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_VSYNC",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_VSYNC",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_VSYNC",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_VSYNC",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_VSYNC",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_VSYNC",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_RESET.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_reset[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_RESET",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_RESET",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_RESET",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_RESET",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_RESET",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_RESET",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_RESET",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_RESET",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA00.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data00[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA00",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA00",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA00",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA00",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA00",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA00",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA00",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA00",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA01.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data01[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA01",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA01",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA01",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA01",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA01",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA01",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA01",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA01",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA02.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data02[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA02",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA02",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA02",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA02",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA02",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA02",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA02",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA02",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA03.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data03[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA03",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA03",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA03",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA03",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA03",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA03",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA03",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA03",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA04.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data04[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA04",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA04",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA04",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA04",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA04",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA04",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA04",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA04",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA05.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data05[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA05",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA05",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA05",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA05",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA05",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA05",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA05",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA05",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA06.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data06[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA06",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA06",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA06",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA06",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA06",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA06",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA06",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA06",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA07.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data07[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA07",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA07",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA07",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA07",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA07",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA07",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA07",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA07",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA08.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data08[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA08",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA08",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA08",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA08",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA08",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA08",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA08",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA08",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA09.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data09[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA09",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA09",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA09",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA09",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA09",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA09",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA09",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA09",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA10.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data10[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA10",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA10",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA10",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA10",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA10",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA10",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA10",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA10",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA11.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data11[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA11",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA11",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA11",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA11",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA11",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA11",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA11",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA11",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA12.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data12[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA12",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA12",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA12",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA12",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA12",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA12",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA12",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA12",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA13.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data13[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA13",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA13",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA13",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA13",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA13",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA13",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA13",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA13",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA14.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data14[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA14",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA14",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA14",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA14",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA14",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA14",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA14",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA14",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA15.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data15[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA15",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA15",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA15",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA15",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA15",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA15",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA15",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA15",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA16.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data16[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA16",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA16",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA16",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA16",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA16",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA16",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA16",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA16",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA17.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data17[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA17",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA17",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA17",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA17",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA17",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA17",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA17",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA17",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA18.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data18[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA18",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA18",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA18",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA18",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA18",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA18",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA18",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA18",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA19.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data19[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA19",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA19",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA19",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA19",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA19",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA19",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA19",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA19",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA20.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data20[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA20",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA20",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA20",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA20",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA20",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA20",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA20",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA20",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA21.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data21[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA21",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA21",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA21",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA21",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA21",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA21",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA21",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA21",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA22.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data22[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA22",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA22",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA22",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA22",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA22",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA22",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA22",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA22",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_LCD_DATA23.
static const field_t hw_iomuxc_sw_pad_ctl_pad_lcd_data23[] =
{
    {
        "SRE",
        "Select one out of next values for pad: LCD_DATA23",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: LCD_DATA23",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: LCD_DATA23",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: LCD_DATA23",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: LCD_DATA23",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: LCD_DATA23",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: LCD_DATA23",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: LCD_DATA23",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_RE_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_re_b[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_RE_B",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_RE_B",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_RE_B",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_RE_B",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_RE_B",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_RE_B",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_RE_B",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_RE_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_WE_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_we_b[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_WE_B",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_WE_B",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_WE_B",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_WE_B",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_WE_B",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_WE_B",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_WE_B",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_WE_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DATA00.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_data00[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_DATA00",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_DATA00",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_DATA00",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_DATA00",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_DATA00",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_DATA00",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_DATA00",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_DATA00",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DATA01.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_data01[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_DATA01",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_DATA01",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_DATA01",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_DATA01",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_DATA01",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_DATA01",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_DATA01",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_DATA01",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DATA02.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_data02[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_DATA02",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_DATA02",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_DATA02",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_DATA02",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_DATA02",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_DATA02",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_DATA02",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_DATA02",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DATA03.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_data03[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_DATA03",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_DATA03",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_DATA03",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_DATA03",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_DATA03",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_DATA03",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_DATA03",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_DATA03",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DATA04.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_data04[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_DATA04",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_DATA04",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_DATA04",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_DATA04",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_DATA04",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_DATA04",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_DATA04",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_DATA04",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DATA05.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_data05[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_DATA05",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_DATA05",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_DATA05",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_DATA05",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_DATA05",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_DATA05",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_DATA05",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_DATA05",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DATA06.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_data06[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_DATA06",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_DATA06",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_DATA06",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_DATA06",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_DATA06",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_DATA06",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_DATA06",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_DATA06",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DATA07.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_data07[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_DATA07",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_DATA07",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_DATA07",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_DATA07",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_DATA07",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_DATA07",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_DATA07",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_DATA07",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_ALE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_ale[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_ALE",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_ALE",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_ALE",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_ALE",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_ALE",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_ALE",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_ALE",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_ALE",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_WP_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_wp_b[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_WP_B",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_WP_B",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_WP_B",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_WP_B",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_WP_B",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_WP_B",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_WP_B",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_WP_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_READY_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_ready_b[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_READY_B",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_READY_B",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_READY_B",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_READY_B",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_READY_B",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_READY_B",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_READY_B",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_READY_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_CE0_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_ce0_b[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_CE0_B",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_CE0_B",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_CE0_B",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_CE0_B",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_CE0_B",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_CE0_B",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_CE0_B",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_CE0_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_CE1_B.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_ce1_b[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_CE1_B",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_CE1_B",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_CE1_B",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_CE1_B",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_CE1_B",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_CE1_B",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_CE1_B",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_CE1_B",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_CLE.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_cle[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_CLE",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_CLE",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_CLE",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_CLE",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_CLE",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_CLE",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_CLE",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_CLE",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_NAND_DQS.
static const field_t hw_iomuxc_sw_pad_ctl_pad_nand_dqs[] =
{
    {
        "SRE",
        "Select one out of next values for pad: NAND_DQS",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: NAND_DQS",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: NAND_DQS",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: NAND_DQS",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: NAND_DQS",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: NAND_DQS",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: NAND_DQS",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: NAND_DQS",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_CMD.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_cmd[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SD1_CMD",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SD1_CMD",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: SD1_CMD",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SD1_CMD",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SD1_CMD",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SD1_CMD",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SD1_CMD",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SD1_CMD",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_CLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_clk[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SD1_CLK",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SD1_CLK",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: SD1_CLK",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SD1_CLK",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SD1_CLK",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SD1_CLK",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SD1_CLK",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SD1_CLK",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DATA0.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_data0[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SD1_DATA0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SD1_DATA0",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: SD1_DATA0",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SD1_DATA0",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SD1_DATA0",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SD1_DATA0",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SD1_DATA0",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SD1_DATA0",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DATA1.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_data1[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SD1_DATA1",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SD1_DATA1",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: SD1_DATA1",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SD1_DATA1",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SD1_DATA1",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SD1_DATA1",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SD1_DATA1",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SD1_DATA1",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DATA2.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_data2[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SD1_DATA2",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SD1_DATA2",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: SD1_DATA2",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SD1_DATA2",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SD1_DATA2",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SD1_DATA2",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SD1_DATA2",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SD1_DATA2",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_SD1_DATA3.
static const field_t hw_iomuxc_sw_pad_ctl_pad_sd1_data3[] =
{
    {
        "SRE",
        "Select one out of next values for pad: SD1_DATA3",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: SD1_DATA3",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: SD1_DATA3",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: SD1_DATA3",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: SD1_DATA3",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: SD1_DATA3",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: SD1_DATA3",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: SD1_DATA3",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_MCLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_mclk[] =
{
    {
        "SRE",
        "Select one out of next values for pad: CSI_MCLK",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: CSI_MCLK",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: CSI_MCLK",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: CSI_MCLK",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: CSI_MCLK",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: CSI_MCLK",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: CSI_MCLK",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: CSI_MCLK",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_PIXCLK.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_pixclk[] =
{
    {
        "SRE",
        "Select one out of next values for pad: CSI_PIXCLK",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: CSI_PIXCLK",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: CSI_PIXCLK",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: CSI_PIXCLK",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: CSI_PIXCLK",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: CSI_PIXCLK",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: CSI_PIXCLK",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: CSI_PIXCLK",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_VSYNC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_vsync[] =
{
    {
        "SRE",
        "Select one out of next values for pad: CSI_VSYNC",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: CSI_VSYNC",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: CSI_VSYNC",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: CSI_VSYNC",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: CSI_VSYNC",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: CSI_VSYNC",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: CSI_VSYNC",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: CSI_VSYNC",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_HSYNC.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_hsync[] =
{
    {
        "SRE",
        "Select one out of next values for pad: CSI_HSYNC",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: CSI_HSYNC",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: CSI_HSYNC",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: CSI_HSYNC",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: CSI_HSYNC",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: CSI_HSYNC",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: CSI_HSYNC",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: CSI_HSYNC",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_DATA00.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_data00[] =
{
    {
        "SRE",
        "Select one out of next values for pad: CSI_DATA00",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: CSI_DATA00",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: CSI_DATA00",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: CSI_DATA00",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: CSI_DATA00",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: CSI_DATA00",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: CSI_DATA00",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: CSI_DATA00",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_DATA01.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_data01[] =
{
    {
        "SRE",
        "Select one out of next values for pad: CSI_DATA01",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: CSI_DATA01",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: CSI_DATA01",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: CSI_DATA01",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: CSI_DATA01",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: CSI_DATA01",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: CSI_DATA01",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: CSI_DATA01",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_DATA02.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_data02[] =
{
    {
        "SRE",
        "Select one out of next values for pad: CSI_DATA02",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: CSI_DATA02",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: CSI_DATA02",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: CSI_DATA02",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: CSI_DATA02",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: CSI_DATA02",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: CSI_DATA02",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: CSI_DATA02",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_DATA03.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_data03[] =
{
    {
        "SRE",
        "Select one out of next values for pad: CSI_DATA03",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: CSI_DATA03",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: CSI_DATA03",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: CSI_DATA03",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: CSI_DATA03",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: CSI_DATA03",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: CSI_DATA03",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: CSI_DATA03",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_DATA04.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_data04[] =
{
    {
        "SRE",
        "Select one out of next values for pad: CSI_DATA04",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: CSI_DATA04",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: CSI_DATA04",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: CSI_DATA04",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: CSI_DATA04",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: CSI_DATA04",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: CSI_DATA04",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: CSI_DATA04",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_DATA05.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_data05[] =
{
    {
        "SRE",
        "Select one out of next values for pad: CSI_DATA05",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: CSI_DATA05",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: CSI_DATA05",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: CSI_DATA05",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: CSI_DATA05",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: CSI_DATA05",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: CSI_DATA05",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: CSI_DATA05",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_DATA06.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_data06[] =
{
    {
        "SRE",
        "Select one out of next values for pad: CSI_DATA06",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: CSI_DATA06",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: CSI_DATA06",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: CSI_DATA06",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: CSI_DATA06",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: CSI_DATA06",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: CSI_DATA06",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: CSI_DATA06",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_PAD_CSI_DATA07.
static const field_t hw_iomuxc_sw_pad_ctl_pad_csi_data07[] =
{
    {
        "SRE",
        "Select one out of next values for pad: CSI_DATA07",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSE",
        "Select one out of next values for pad: CSI_DATA07",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPEED",
        "Select one out of next values for pad: CSI_DATA07",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODE",
        "Select one out of next values for pad: CSI_DATA07",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PKE",
        "Select one out of next values for pad: CSI_DATA07",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUE",
        "Select one out of next values for pad: CSI_DATA07",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PUS",
        "Select one out of next values for pad: CSI_DATA07",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYS",
        "Select one out of next values for pad: CSI_DATA07",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_ADDDS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_addds[] =
{
    {
        "DSE",
        "Select one out of next values for group: ADDDS (Pads: DRAM_ADDR00 DRAM"
        "_ADDR01 DRAM_ADDR02 DRAM_ADDR03 DRAM_ADDR04 DRAM_ADDR05 DRAM_ADDR06 DR"
        "AM_ADDR07 DRAM_ADDR08 DRAM_ADDR09 DRAM_ADDR10 DRAM_ADDR11 DRAM_ADDR12 "
        "DRAM_ADDR13 DRAM_ADDR14 DRAM_ADDR15 DRAM_SDBA0 DRAM_SDBA1)",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRMODE_CTL.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrmode_ctl[] =
{
    {
        "DDR_INPUT",
        "Select one out of next values for group: DDRMODE_CTL (Pads: DRAM_SDQS0"
        "_P DRAM_SDQS1_P)",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B0DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b0ds[] =
{
    {
        "DSE",
        "Select one out of next values for group: B0DS (Pads: DRAM_DATA00 DRAM_"
        "DATA01 DRAM_DATA02 DRAM_DATA03 DRAM_DATA04 DRAM_DATA05 DRAM_DATA06 DRA"
        "M_DATA07)",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRPK.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrpk[] =
{
    {
        "PUE",
        "Select one out of next values for group: DDRPK (Pads: DRAM_ADDR00 DRAM"
        "_ADDR01 DRAM_ADDR02 DRAM_ADDR03 DRAM_ADDR04 DRAM_ADDR05 DRAM_ADDR06 DR"
        "AM_ADDR07 DRAM_ADDR08 DRAM_ADDR09 DRAM_ADDR10 DRAM_ADDR11 DRAM_ADDR12 "
        "DRAM_ADDR13 DRAM_ADDR14 DRAM_ADDR15 DRAM_CAS_B DRAM_CS0_B DRAM_CS1_B D"
        "RAM_DATA00 DRAM_DATA01 DRAM_DATA02 DRAM_DATA03 DRAM_DATA04 DRAM_DATA05"
        " DRAM_DATA06 DRAM_DATA07 DRAM_DATA08 DRAM_DATA09 DRAM_DATA10 DRAM_DATA"
        "11 DRAM_DATA12 DRAM_DATA13 DRAM_DATA14 DRAM_DATA15 DRAM_DQM0 DRAM_DQM1"
        " DRAM_RAS_B DRAM_SDBA0 DRAM_SDBA1 DRAM_SDCLK0_P DRAM_SDWE_B)",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_CTLDS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ctlds[] =
{
    {
        "DSE",
        "Select one out of next values for group: CTLDS (Pads: DRAM_CS0_B DRAM_"
        "CS1_B DRAM_SDBA2 DRAM_SDCKE0 DRAM_SDCKE1 DRAM_SDWE_B)",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_B1DS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_b1ds[] =
{
    {
        "DSE",
        "Select one out of next values for group: B1DS (Pads: DRAM_DATA08 DRAM_"
        "DATA09 DRAM_DATA10 DRAM_DATA11 DRAM_DATA12 DRAM_DATA13 DRAM_DATA14 DRA"
        "M_DATA15)",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRHYS.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrhys[] =
{
    {
        "HYS",
        "Select one out of next values for group: DDRHYS (Pads: DRAM_DATA00 DRA"
        "M_DATA01 DRAM_DATA02 DRAM_DATA03 DRAM_DATA04 DRAM_DATA05 DRAM_DATA06 D"
        "RAM_DATA07 DRAM_DATA08 DRAM_DATA09 DRAM_DATA10 DRAM_DATA11 DRAM_DATA12"
        " DRAM_DATA13 DRAM_DATA14 DRAM_DATA15 DRAM_SDQS0_P DRAM_SDQS1_P)",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRPKE.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrpke[] =
{
    {
        "PKE",
        "Select one out of next values for group: DDRPKE (Pads: DRAM_ADDR00 DRA"
        "M_ADDR01 DRAM_ADDR02 DRAM_ADDR03 DRAM_ADDR04 DRAM_ADDR05 DRAM_ADDR06 D"
        "RAM_ADDR07 DRAM_ADDR08 DRAM_ADDR09 DRAM_ADDR10 DRAM_ADDR11 DRAM_ADDR12"
        " DRAM_ADDR13 DRAM_ADDR14 DRAM_ADDR15 DRAM_CAS_B DRAM_CS0_B DRAM_CS1_B "
        "DRAM_DATA00 DRAM_DATA01 DRAM_DATA02 DRAM_DATA03 DRAM_DATA04 DRAM_DATA0"
        "5 DRAM_DATA06 DRAM_DATA07 DRAM_DATA08 DRAM_DATA09 DRAM_DATA10 DRAM_DAT"
        "A11 DRAM_DATA12 DRAM_DATA13 DRAM_DATA14 DRAM_DATA15 DRAM_DQM0 DRAM_DQM"
        "1 DRAM_RAS_B DRAM_SDBA0 DRAM_SDBA1 DRAM_SDCLK0_P DRAM_SDWE_B)",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDRMODE.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddrmode[] =
{
    {
        "DDR_INPUT",
        "Select one out of next values for group: DDRMODE (Pads: DRAM_DATA00 DR"
        "AM_DATA01 DRAM_DATA02 DRAM_DATA03 DRAM_DATA04 DRAM_DATA05 DRAM_DATA06 "
        "DRAM_DATA07 DRAM_DATA08 DRAM_DATA09 DRAM_DATA10 DRAM_DATA11 DRAM_DATA1"
        "2 DRAM_DATA13 DRAM_DATA14 DRAM_DATA15)",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SW_PAD_CTL_GRP_DDR_TYPE.
static const field_t hw_iomuxc_sw_pad_ctl_grp_ddr_type[] =
{
    {
        "DDR_SEL",
        "Select one out of next values for group: DDR_TYPE (Pads: DRAM_ADDR00 D"
        "RAM_ADDR01 DRAM_ADDR02 DRAM_ADDR03 DRAM_ADDR04 DRAM_ADDR05 DRAM_ADDR06"
        " DRAM_ADDR07 DRAM_ADDR08 DRAM_ADDR09 DRAM_ADDR10 DRAM_ADDR11 DRAM_ADDR"
        "12 DRAM_ADDR13 DRAM_ADDR14 DRAM_ADDR15 DRAM_CAS_B DRAM_CS0_B DRAM_CS1_"
        "B DRAM_DATA00 DRAM_DATA01 DRAM_DATA02 DRAM_DATA03 DRAM_DATA04 DRAM_DAT"
        "A05 DRAM_DATA06 DRAM_DATA07 DRAM_DATA08 DRAM_DATA09 DRAM_DATA10 DRAM_D"
        "ATA11 DRAM_DATA12 DRAM_DATA13 DRAM_DATA14 DRAM_DATA15 DRAM_DQM0 DRAM_D"
        "QM1 DRAM_ODT0 DRAM_ODT1 DRAM_RAS_B DRAM_SDBA0 DRAM_SDBA1 DRAM_SDBA2 DR"
        "AM_SDCKE0 DRAM_SDCKE1 DRAM_SDCLK0_P DRAM_SDQS0_P DRAM_SDQS1_P DRAM_SDW"
        "E_B)",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USB_OTG1_ID_SELECT_INPUT.
static const field_t hw_iomuxc_usb_otg1_id_select_input[] =
{
    {
        "DAISY",
        "Instance: anatop, In Pin: usb_otg_id",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USB_OTG2_ID_SELECT_INPUT.
static const field_t hw_iomuxc_usb_otg2_id_select_input[] =
{
    {
        "DAISY",
        "Instance: anatop, In Pin: usb_uh1_id",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CCM_PMIC_READY_SELECT_INPUT.
static const field_t hw_iomuxc_ccm_pmic_ready_select_input[] =
{
    {
        "DAISY",
        "Instance: ccm, In Pin: pmic_ready",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA02_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data02_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d2",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA03_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data03_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d3",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA05_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data05_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d5",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA00_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data00_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA01_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data01_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d1",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA04_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data04_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d4",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA06_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data06_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d6",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA07_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data07_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d7",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA08_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data08_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d8",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA09_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data09_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d9",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA10_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data10_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d10",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA11_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data11_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d11",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA12_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data12_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d12",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA13_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data13_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d13",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA14_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data14_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d14",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA15_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data15_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d15",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA16_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data16_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d16",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA17_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data17_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d17",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA18_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data18_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d18",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA19_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data19_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d19",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA20_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data20_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d20",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA21_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data21_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d21",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA22_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data22_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d22",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_DATA23_SELECT_INPUT.
static const field_t hw_iomuxc_csi_data23_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_d23",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_HSYNC_SELECT_INPUT.
static const field_t hw_iomuxc_csi_hsync_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_hsync",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_PIXCLK_SELECT_INPUT.
static const field_t hw_iomuxc_csi_pixclk_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_pixclk",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_VSYNC_SELECT_INPUT.
static const field_t hw_iomuxc_csi_vsync_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: csi_vsync",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_CSI_FIELD_SELECT_INPUT.
static const field_t hw_iomuxc_csi_field_select_input[] =
{
    {
        "DAISY",
        "Instance: csi, In Pin: tvdecoder_in_field",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_SCLK_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_sclk_select_input[] =
{
    {
        "DAISY",
        "Instance: ecspi1, In Pin: cspi_clk_in",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_MISO_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_miso_select_input[] =
{
    {
        "DAISY",
        "Instance: ecspi1, In Pin: miso",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_MOSI_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_mosi_select_input[] =
{
    {
        "DAISY",
        "Instance: ecspi1, In Pin: mosi",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI1_SS0_B_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi1_ss0_b_select_input[] =
{
    {
        "DAISY",
        "Instance: ecspi1, In Pin: ss_b0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_SCLK_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_sclk_select_input[] =
{
    {
        "DAISY",
        "Instance: ecspi2, In Pin: cspi_clk_in",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_MISO_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_miso_select_input[] =
{
    {
        "DAISY",
        "Instance: ecspi2, In Pin: miso",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_MOSI_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_mosi_select_input[] =
{
    {
        "DAISY",
        "Instance: ecspi2, In Pin: mosi",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI2_SS0_B_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi2_ss0_b_select_input[] =
{
    {
        "DAISY",
        "Instance: ecspi2, In Pin: ss_b0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI3_SCLK_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi3_sclk_select_input[] =
{
    {
        "DAISY",
        "Instance: ecspi3, In Pin: cspi_clk_in",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI3_MISO_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi3_miso_select_input[] =
{
    {
        "DAISY",
        "Instance: ecspi3, In Pin: miso",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI3_MOSI_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi3_mosi_select_input[] =
{
    {
        "DAISY",
        "Instance: ecspi3, In Pin: mosi",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI3_SS0_B_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi3_ss0_b_select_input[] =
{
    {
        "DAISY",
        "Instance: ecspi3, In Pin: ss_b0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI4_SCLK_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi4_sclk_select_input[] =
{
    {
        "DAISY",
        "Instance: ecspi4, In Pin: cspi_clk_in",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI4_MISO_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi4_miso_select_input[] =
{
    {
        "DAISY",
        "Instance: ecspi4, In Pin: miso",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI4_MOSI_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi4_mosi_select_input[] =
{
    {
        "DAISY",
        "Instance: ecspi4, In Pin: mosi",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ECSPI4_SS0_B_SELECT_INPUT.
static const field_t hw_iomuxc_ecspi4_ss0_b_select_input[] =
{
    {
        "DAISY",
        "Instance: ecspi4, In Pin: ss_b0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET1_REF_CLK1_SELECT_INPUT.
static const field_t hw_iomuxc_enet1_ref_clk1_select_input[] =
{
    {
        "DAISY",
        "Instance: enet1, In Pin: rmii",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET1_MAC0_MDIO_SELECT_INPUT.
static const field_t hw_iomuxc_enet1_mac0_mdio_select_input[] =
{
    {
        "DAISY",
        "Instance: enet1, In Pin: mac0_mdio",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET2_REF_CLK2_SELECT_INPUT.
static const field_t hw_iomuxc_enet2_ref_clk2_select_input[] =
{
    {
        "DAISY",
        "Instance: enet2, In Pin: rmii",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_ENET2_MAC0_MDIO_SELECT_INPUT.
static const field_t hw_iomuxc_enet2_mac0_mdio_select_input[] =
{
    {
        "DAISY",
        "Instance: enet2, In Pin: mac0_mdio",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_FLEXCAN1_RX_SELECT_INPUT.
static const field_t hw_iomuxc_flexcan1_rx_select_input[] =
{
    {
        "DAISY",
        "Instance: flexcan1, In Pin: RX",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_FLEXCAN2_RX_SELECT_INPUT.
static const field_t hw_iomuxc_flexcan2_rx_select_input[] =
{
    {
        "DAISY",
        "Instance: flexcan2, In Pin: RX",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPT1_CAPTURE1_SELECT_INPUT.
static const field_t hw_iomuxc_gpt1_capture1_select_input[] =
{
    {
        "DAISY",
        "Instance: gpt1, In Pin: CAPTURE1",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPT1_CAPTURE2_SELECT_INPUT.
static const field_t hw_iomuxc_gpt1_capture2_select_input[] =
{
    {
        "DAISY",
        "Instance: gpt1, In Pin: CAPTURE2",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPT1_CLK_SELECT_INPUT.
static const field_t hw_iomuxc_gpt1_clk_select_input[] =
{
    {
        "DAISY",
        "Instance: gpt1, In Pin: CLK",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPT2_CAPTURE1_SELECT_INPUT.
static const field_t hw_iomuxc_gpt2_capture1_select_input[] =
{
    {
        "DAISY",
        "Instance: gpt2, In Pin: CAPTURE1",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPT2_CAPTURE2_SELECT_INPUT.
static const field_t hw_iomuxc_gpt2_capture2_select_input[] =
{
    {
        "DAISY",
        "Instance: gpt2, In Pin: CAPTURE2",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPT2_CLK_SELECT_INPUT.
static const field_t hw_iomuxc_gpt2_clk_select_input[] =
{
    {
        "DAISY",
        "Instance: gpt2, In Pin: CLK",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C1_SCL_SELECT_INPUT.
static const field_t hw_iomuxc_i2c1_scl_select_input[] =
{
    {
        "DAISY",
        "Instance: i2c1, In Pin: scl_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C1_SDA_SELECT_INPUT.
static const field_t hw_iomuxc_i2c1_sda_select_input[] =
{
    {
        "DAISY",
        "Instance: i2c1, In Pin: sda_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C2_SCL_SELECT_INPUT.
static const field_t hw_iomuxc_i2c2_scl_select_input[] =
{
    {
        "DAISY",
        "Instance: i2c2, In Pin: scl_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C2_SDA_SELECT_INPUT.
static const field_t hw_iomuxc_i2c2_sda_select_input[] =
{
    {
        "DAISY",
        "Instance: i2c2, In Pin: sda_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C3_SCL_SELECT_INPUT.
static const field_t hw_iomuxc_i2c3_scl_select_input[] =
{
    {
        "DAISY",
        "Instance: i2c3, In Pin: scl_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C3_SDA_SELECT_INPUT.
static const field_t hw_iomuxc_i2c3_sda_select_input[] =
{
    {
        "DAISY",
        "Instance: i2c3, In Pin: sda_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C4_SCL_SELECT_INPUT.
static const field_t hw_iomuxc_i2c4_scl_select_input[] =
{
    {
        "DAISY",
        "Instance: i2c4, In Pin: scl_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_I2C4_SDA_SELECT_INPUT.
static const field_t hw_iomuxc_i2c4_sda_select_input[] =
{
    {
        "DAISY",
        "Instance: i2c4, In Pin: sda_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_COL0_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_col0_select_input[] =
{
    {
        "DAISY",
        "Instance: kpp, In Pin: col0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_COL1_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_col1_select_input[] =
{
    {
        "DAISY",
        "Instance: kpp, In Pin: col1",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_COL2_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_col2_select_input[] =
{
    {
        "DAISY",
        "Instance: kpp, In Pin: col2",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_ROW0_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_row0_select_input[] =
{
    {
        "DAISY",
        "Instance: kpp, In Pin: row0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_ROW1_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_row1_select_input[] =
{
    {
        "DAISY",
        "Instance: kpp, In Pin: row1",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_KPP_ROW2_SELECT_INPUT.
static const field_t hw_iomuxc_kpp_row2_select_input[] =
{
    {
        "DAISY",
        "Instance: kpp, In Pin: row2",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_LCD_BUSY_SELECT_INPUT.
static const field_t hw_iomuxc_lcd_busy_select_input[] =
{
    {
        "DAISY",
        "Instance: lcdif, In Pin: lcdif_busy",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI1_MCLK_SELECT_INPUT.
static const field_t hw_iomuxc_sai1_mclk_select_input[] =
{
    {
        "DAISY",
        "Instance: sai1, In Pin: mclk2",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI1_RX_DATA_SELECT_INPUT.
static const field_t hw_iomuxc_sai1_rx_data_select_input[] =
{
    {
        "DAISY",
        "Instance: sai1, In Pin: RX_DATA0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI1_TX_BCLK_SELECT_INPUT.
static const field_t hw_iomuxc_sai1_tx_bclk_select_input[] =
{
    {
        "DAISY",
        "Instance: sai1, In Pin: TX_BCLK",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI1_TX_SYNC_SELECT_INPUT.
static const field_t hw_iomuxc_sai1_tx_sync_select_input[] =
{
    {
        "DAISY",
        "Instance: sai1, In Pin: TX_SYNC",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI2_MCLK_SELECT_INPUT.
static const field_t hw_iomuxc_sai2_mclk_select_input[] =
{
    {
        "DAISY",
        "Instance: sai2, In Pin: mclk2",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI2_RX_DATA_SELECT_INPUT.
static const field_t hw_iomuxc_sai2_rx_data_select_input[] =
{
    {
        "DAISY",
        "Instance: sai2, In Pin: RX_DATA0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI2_TX_BCLK_SELECT_INPUT.
static const field_t hw_iomuxc_sai2_tx_bclk_select_input[] =
{
    {
        "DAISY",
        "Instance: sai2, In Pin: TX_BCLK",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI2_TX_SYNC_SELECT_INPUT.
static const field_t hw_iomuxc_sai2_tx_sync_select_input[] =
{
    {
        "DAISY",
        "Instance: sai2, In Pin: TX_SYNC",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI3_MCLK_SELECT_INPUT.
static const field_t hw_iomuxc_sai3_mclk_select_input[] =
{
    {
        "DAISY",
        "Instance: sai3, In Pin: mclk2",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI3_RX_DATA_SELECT_INPUT.
static const field_t hw_iomuxc_sai3_rx_data_select_input[] =
{
    {
        "DAISY",
        "Instance: sai3, In Pin: RX_DATA0",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI3_TX_BCLK_SELECT_INPUT.
static const field_t hw_iomuxc_sai3_tx_bclk_select_input[] =
{
    {
        "DAISY",
        "Instance: sai3, In Pin: TX_BCLK",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SAI3_TX_SYNC_SELECT_INPUT.
static const field_t hw_iomuxc_sai3_tx_sync_select_input[] =
{
    {
        "DAISY",
        "Instance: sai3, In Pin: TX_SYNC",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SDMA_EVENTS0_SELECT_INPUT.
static const field_t hw_iomuxc_sdma_events0_select_input[] =
{
    {
        "DAISY",
        "Instance: sdma, In Pin: events14",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SDMA_EVENTS1_SELECT_INPUT.
static const field_t hw_iomuxc_sdma_events1_select_input[] =
{
    {
        "DAISY",
        "Instance: sdma, In Pin: events15",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SPDIF_IN_SELECT_INPUT.
static const field_t hw_iomuxc_spdif_in_select_input[] =
{
    {
        "DAISY",
        "Instance: spdif, In Pin: spdif_in1",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_SPDIF_EXT_CLK_SELECT_INPUT.
static const field_t hw_iomuxc_spdif_ext_clk_select_input[] =
{
    {
        "DAISY",
        "Instance: spdif, In Pin: tx_clk2",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART1_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart1_rts_b_select_input[] =
{
    {
        "DAISY",
        "Instance: uart1, In Pin: uart_rts_b",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART1_RX_DATA_SELECT_INPUT.
static const field_t hw_iomuxc_uart1_rx_data_select_input[] =
{
    {
        "DAISY",
        "Instance: uart1, In Pin: uart_RX_DATA",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART2_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart2_rts_b_select_input[] =
{
    {
        "DAISY",
        "Instance: uart2, In Pin: uart_rts_b",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART2_RX_DATA_SELECT_INPUT.
static const field_t hw_iomuxc_uart2_rx_data_select_input[] =
{
    {
        "DAISY",
        "Instance: uart2, In Pin: uart_RX_DATA",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART3_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart3_rts_b_select_input[] =
{
    {
        "DAISY",
        "Instance: uart3, In Pin: uart_rts_b",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART3_RX_DATA_SELECT_INPUT.
static const field_t hw_iomuxc_uart3_rx_data_select_input[] =
{
    {
        "DAISY",
        "Instance: uart3, In Pin: uart_RX_DATA",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART4_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart4_rts_b_select_input[] =
{
    {
        "DAISY",
        "Instance: uart4, In Pin: uart_rts_b",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART4_RX_DATA_SELECT_INPUT.
static const field_t hw_iomuxc_uart4_rx_data_select_input[] =
{
    {
        "DAISY",
        "Instance: uart4, In Pin: uart_RX_DATA",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART5_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart5_rts_b_select_input[] =
{
    {
        "DAISY",
        "Instance: uart5, In Pin: uart_rts_b",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART5_RX_DATA_SELECT_INPUT.
static const field_t hw_iomuxc_uart5_rx_data_select_input[] =
{
    {
        "DAISY",
        "Instance: uart5, In Pin: uart_RX_DATA",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART6_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart6_rts_b_select_input[] =
{
    {
        "DAISY",
        "Instance: uart6, In Pin: uart_rts_b",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART6_RX_DATA_SELECT_INPUT.
static const field_t hw_iomuxc_uart6_rx_data_select_input[] =
{
    {
        "DAISY",
        "Instance: uart6, In Pin: uart_RX_DATA",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART7_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart7_rts_b_select_input[] =
{
    {
        "DAISY",
        "Instance: uart7, In Pin: uart_rts_b",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART7_RX_DATA_SELECT_INPUT.
static const field_t hw_iomuxc_uart7_rx_data_select_input[] =
{
    {
        "DAISY",
        "Instance: uart7, In Pin: uart_RX_DATA",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART8_RTS_B_SELECT_INPUT.
static const field_t hw_iomuxc_uart8_rts_b_select_input[] =
{
    {
        "DAISY",
        "Instance: uart8, In Pin: uart_rts_b",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_UART8_RX_DATA_SELECT_INPUT.
static const field_t hw_iomuxc_uart8_rx_data_select_input[] =
{
    {
        "DAISY",
        "Instance: uart8, In Pin: uart_RX_DATA",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USB_OTG2_OC_SELECT_INPUT.
static const field_t hw_iomuxc_usb_otg2_oc_select_input[] =
{
    {
        "DAISY",
        "Instance: usb, In Pin: otg2_oc",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USB_OTG_OC_SELECT_INPUT.
static const field_t hw_iomuxc_usb_otg_oc_select_input[] =
{
    {
        "DAISY",
        "Instance: usb, In Pin: otg_oc",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC1_CD_B_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc1_cd_b_select_input[] =
{
    {
        "DAISY",
        "Instance: usdhc1, In Pin: card_det",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC1_WP_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc1_wp_select_input[] =
{
    {
        "DAISY",
        "Instance: usdhc1, In Pin: wp_on",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC2_CLK_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc2_clk_select_input[] =
{
    {
        "DAISY",
        "Instance: usdhc2, In Pin: CLK_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC2_CD_B_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc2_cd_b_select_input[] =
{
    {
        "DAISY",
        "Instance: usdhc2, In Pin: card_det",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC2_CMD_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc2_cmd_select_input[] =
{
    {
        "DAISY",
        "Instance: usdhc2, In Pin: cmd_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC2_DATA0_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc2_data0_select_input[] =
{
    {
        "DAISY",
        "Instance: usdhc2, In Pin: DATA0_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC2_DATA1_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc2_data1_select_input[] =
{
    {
        "DAISY",
        "Instance: usdhc2, In Pin: DATA1_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC2_DATA2_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc2_data2_select_input[] =
{
    {
        "DAISY",
        "Instance: usdhc2, In Pin: DATA2_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC2_DATA3_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc2_data3_select_input[] =
{
    {
        "DAISY",
        "Instance: usdhc2, In Pin: DATA3_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC2_DATA4_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc2_data4_select_input[] =
{
    {
        "DAISY",
        "Instance: usdhc2, In Pin: DATA4_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC2_DATA5_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc2_data5_select_input[] =
{
    {
        "DAISY",
        "Instance: usdhc2, In Pin: DATA5_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC2_DATA6_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc2_data6_select_input[] =
{
    {
        "DAISY",
        "Instance: usdhc2, In Pin: DATA6_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC2_DATA7_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc2_data7_select_input[] =
{
    {
        "DAISY",
        "Instance: usdhc2, In Pin: DATA7_in",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_USDHC2_WP_SELECT_INPUT.
static const field_t hw_iomuxc_usdhc2_wp_select_input[] =
{
    {
        "DAISY",
        "Instance: usdhc2, In Pin: wp_on",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a IOMUXC module.
static const reg_t hw_iomuxc[] =
{
    {
        "SW_MUX_CTL_PAD_BOOT_MODE0",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_boot_mode0
    },
    {
        "SW_MUX_CTL_PAD_BOOT_MODE1",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_boot_mode1
    },
    {
        "SW_MUX_CTL_PAD_SNVS_TAMPER0",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_snvs_tamper0
    },
    {
        "SW_MUX_CTL_PAD_SNVS_TAMPER1",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_snvs_tamper1
    },
    {
        "SW_MUX_CTL_PAD_SNVS_TAMPER2",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_snvs_tamper2
    },
    {
        "SW_MUX_CTL_PAD_SNVS_TAMPER3",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_snvs_tamper3
    },
    {
        "SW_MUX_CTL_PAD_SNVS_TAMPER4",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_snvs_tamper4
    },
    {
        "SW_MUX_CTL_PAD_SNVS_TAMPER5",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_snvs_tamper5
    },
    {
        "SW_MUX_CTL_PAD_SNVS_TAMPER6",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_snvs_tamper6
    },
    {
        "SW_MUX_CTL_PAD_SNVS_TAMPER7",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_snvs_tamper7
    },
    {
        "SW_MUX_CTL_PAD_SNVS_TAMPER8",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_snvs_tamper8
    },
    {
        "SW_MUX_CTL_PAD_SNVS_TAMPER9",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_snvs_tamper9
    },
    {
        "SW_MUX_CTL_PAD_JTAG_MOD",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_jtag_mod
    },
    {
        "SW_MUX_CTL_PAD_JTAG_TMS",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_jtag_tms
    },
    {
        "SW_MUX_CTL_PAD_JTAG_TDO",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_jtag_tdo
    },
    {
        "SW_MUX_CTL_PAD_JTAG_TDI",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_jtag_tdi
    },
    {
        "SW_MUX_CTL_PAD_JTAG_TCK",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_jtag_tck
    },
    {
        "SW_MUX_CTL_PAD_JTAG_TRST_B",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_jtag_trst_b
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO00",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io00
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO01",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io01
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO02",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io02
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO03",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io03
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO04",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io04
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO05",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io05
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO06",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io06
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO07",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io07
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO08",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io08
    },
    {
        "SW_MUX_CTL_PAD_GPIO1_IO09",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_gpio1_io09
    },
    {
        "SW_MUX_CTL_PAD_UART1_TX_DATA",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart1_tx_data
    },
    {
        "SW_MUX_CTL_PAD_UART1_RX_DATA",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart1_rx_data
    },
    {
        "SW_MUX_CTL_PAD_UART1_CTS_B",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart1_cts_b
    },
    {
        "SW_MUX_CTL_PAD_UART1_RTS_B",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart1_rts_b
    },
    {
        "SW_MUX_CTL_PAD_UART2_TX_DATA",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart2_tx_data
    },
    {
        "SW_MUX_CTL_PAD_UART2_RX_DATA",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart2_rx_data
    },
    {
        "SW_MUX_CTL_PAD_UART2_CTS_B",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart2_cts_b
    },
    {
        "SW_MUX_CTL_PAD_UART2_RTS_B",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart2_rts_b
    },
    {
        "SW_MUX_CTL_PAD_UART3_TX_DATA",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart3_tx_data
    },
    {
        "SW_MUX_CTL_PAD_UART3_RX_DATA",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart3_rx_data
    },
    {
        "SW_MUX_CTL_PAD_UART3_CTS_B",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart3_cts_b
    },
    {
        "SW_MUX_CTL_PAD_UART3_RTS_B",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart3_rts_b
    },
    {
        "SW_MUX_CTL_PAD_UART4_TX_DATA",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart4_tx_data
    },
    {
        "SW_MUX_CTL_PAD_UART4_RX_DATA",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart4_rx_data
    },
    {
        "SW_MUX_CTL_PAD_UART5_TX_DATA",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart5_tx_data
    },
    {
        "SW_MUX_CTL_PAD_UART5_RX_DATA",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_uart5_rx_data
    },
    {
        "SW_MUX_CTL_PAD_ENET1_RX_DATA0",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet1_rx_data0
    },
    {
        "SW_MUX_CTL_PAD_ENET1_RX_DATA1",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet1_rx_data1
    },
    {
        "SW_MUX_CTL_PAD_ENET1_RX_EN",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet1_rx_en
    },
    {
        "SW_MUX_CTL_PAD_ENET1_TX_DATA0",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet1_tx_data0
    },
    {
        "SW_MUX_CTL_PAD_ENET1_TX_DATA1",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet1_tx_data1
    },
    {
        "SW_MUX_CTL_PAD_ENET1_TX_EN",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet1_tx_en
    },
    {
        "SW_MUX_CTL_PAD_ENET1_TX_CLK",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet1_tx_clk
    },
    {
        "SW_MUX_CTL_PAD_ENET1_RX_ER",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet1_rx_er
    },
    {
        "SW_MUX_CTL_PAD_ENET2_RX_DATA0",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet2_rx_data0
    },
    {
        "SW_MUX_CTL_PAD_ENET2_RX_DATA1",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet2_rx_data1
    },
    {
        "SW_MUX_CTL_PAD_ENET2_RX_EN",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet2_rx_en
    },
    {
        "SW_MUX_CTL_PAD_ENET2_TX_DATA0",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet2_tx_data0
    },
    {
        "SW_MUX_CTL_PAD_ENET2_TX_DATA1",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet2_tx_data1
    },
    {
        "SW_MUX_CTL_PAD_ENET2_TX_EN",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000f8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet2_tx_en
    },
    {
        "SW_MUX_CTL_PAD_ENET2_TX_CLK",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet2_tx_clk
    },
    {
        "SW_MUX_CTL_PAD_ENET2_RX_ER",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_enet2_rx_er
    },
    {
        "SW_MUX_CTL_PAD_LCD_CLK",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_clk
    },
    {
        "SW_MUX_CTL_PAD_LCD_ENABLE",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_enable
    },
    {
        "SW_MUX_CTL_PAD_LCD_HSYNC",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_hsync
    },
    {
        "SW_MUX_CTL_PAD_LCD_VSYNC",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_vsync
    },
    {
        "SW_MUX_CTL_PAD_LCD_RESET",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_reset
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA00",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data00
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA01",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data01
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA02",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data02
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA03",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data03
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA04",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data04
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA05",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data05
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA06",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data06
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA07",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data07
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA08",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data08
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA09",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data09
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA10",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data10
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA11",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data11
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA12",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data12
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA13",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data13
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA14",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data14
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA15",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data15
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA16",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data16
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA17",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data17
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA18",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data18
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA19",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data19
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA20",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data20
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA21",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data21
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA22",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data22
    },
    {
        "SW_MUX_CTL_PAD_LCD_DATA23",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_lcd_data23
    },
    {
        "SW_MUX_CTL_PAD_NAND_RE_B",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_re_b
    },
    {
        "SW_MUX_CTL_PAD_NAND_WE_B",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_we_b
    },
    {
        "SW_MUX_CTL_PAD_NAND_DATA00",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_data00
    },
    {
        "SW_MUX_CTL_PAD_NAND_DATA01",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_data01
    },
    {
        "SW_MUX_CTL_PAD_NAND_DATA02",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000188, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_data02
    },
    {
        "SW_MUX_CTL_PAD_NAND_DATA03",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000018c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_data03
    },
    {
        "SW_MUX_CTL_PAD_NAND_DATA04",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_data04
    },
    {
        "SW_MUX_CTL_PAD_NAND_DATA05",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000194, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_data05
    },
    {
        "SW_MUX_CTL_PAD_NAND_DATA06",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000198, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_data06
    },
    {
        "SW_MUX_CTL_PAD_NAND_DATA07",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x0000019c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_data07
    },
    {
        "SW_MUX_CTL_PAD_NAND_ALE",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_ale
    },
    {
        "SW_MUX_CTL_PAD_NAND_WP_B",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_wp_b
    },
    {
        "SW_MUX_CTL_PAD_NAND_READY_B",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_ready_b
    },
    {
        "SW_MUX_CTL_PAD_NAND_CE0_B",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_ce0_b
    },
    {
        "SW_MUX_CTL_PAD_NAND_CE1_B",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_ce1_b
    },
    {
        "SW_MUX_CTL_PAD_NAND_CLE",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_cle
    },
    {
        "SW_MUX_CTL_PAD_NAND_DQS",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001b8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_nand_dqs
    },
    {
        "SW_MUX_CTL_PAD_SD1_CMD",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_cmd
    },
    {
        "SW_MUX_CTL_PAD_SD1_CLK",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_clk
    },
    {
        "SW_MUX_CTL_PAD_SD1_DATA0",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001c4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_data0
    },
    {
        "SW_MUX_CTL_PAD_SD1_DATA1",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001c8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_data1
    },
    {
        "SW_MUX_CTL_PAD_SD1_DATA2",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001cc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_data2
    },
    {
        "SW_MUX_CTL_PAD_SD1_DATA3",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_sd1_data3
    },
    {
        "SW_MUX_CTL_PAD_CSI_MCLK",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001d4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_mclk
    },
    {
        "SW_MUX_CTL_PAD_CSI_PIXCLK",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001d8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_pixclk
    },
    {
        "SW_MUX_CTL_PAD_CSI_VSYNC",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001dc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_vsync
    },
    {
        "SW_MUX_CTL_PAD_CSI_HSYNC",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001e0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_hsync
    },
    {
        "SW_MUX_CTL_PAD_CSI_DATA00",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001e4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_data00
    },
    {
        "SW_MUX_CTL_PAD_CSI_DATA01",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001e8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_data01
    },
    {
        "SW_MUX_CTL_PAD_CSI_DATA02",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001ec, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_data02
    },
    {
        "SW_MUX_CTL_PAD_CSI_DATA03",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_data03
    },
    {
        "SW_MUX_CTL_PAD_CSI_DATA04",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_data04
    },
    {
        "SW_MUX_CTL_PAD_CSI_DATA05",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001f8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_data05
    },
    {
        "SW_MUX_CTL_PAD_CSI_DATA06",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x000001fc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_data06
    },
    {
        "SW_MUX_CTL_PAD_CSI_DATA07",
        "SW_MUX_CTL Register",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_iomuxc_sw_mux_ctl_pad_csi_data07
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR00",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr00
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR01",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr01
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR02",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr02
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR03",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr03
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR04",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr04
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR05",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr05
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR06",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr06
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR07",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr07
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR08",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr08
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR09",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr09
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR10",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr10
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR11",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr11
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR12",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr12
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR13",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr13
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR14",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr14
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ADDR15",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_addr15
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM0",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_DQM1",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_dqm1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_RAS_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_ras_b
    },
    {
        "SW_PAD_CTL_PAD_DRAM_CAS_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_cas_b
    },
    {
        "SW_PAD_CTL_PAD_DRAM_CS0_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_cs0_b
    },
    {
        "SW_PAD_CTL_PAD_DRAM_CS1_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_cs1_b
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDWE_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdwe_b
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ODT0",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_odt0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_ODT1",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_odt1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDBA0",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdba0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDBA1",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdba1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDBA2",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdba2
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDCKE0",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdcke0
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDCKE1",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdcke1
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDCLK0_P",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000027c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdclk0_p
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS0_P",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs0_p
    },
    {
        "SW_PAD_CTL_PAD_DRAM_SDQS1_P",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_sdqs1_p
    },
    {
        "SW_PAD_CTL_PAD_DRAM_RESET",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_dram_reset
    },
    {
        "SW_PAD_CTL_PAD_TEST_MODE",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_test_mode
    },
    {
        "SW_PAD_CTL_PAD_POR_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_por_b
    },
    {
        "SW_PAD_CTL_PAD_ONOFF",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000294, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_onoff
    },
    {
        "SW_PAD_CTL_PAD_SNVS_PMIC_ON_REQ",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000298, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_snvs_pmic_on_req
    },
    {
        "SW_PAD_CTL_PAD_CCM_PMIC_STBY_REQ",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000029c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_ccm_pmic_stby_req
    },
    {
        "SW_PAD_CTL_PAD_BOOT_MODE0",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_boot_mode0
    },
    {
        "SW_PAD_CTL_PAD_BOOT_MODE1",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002a4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_boot_mode1
    },
    {
        "SW_PAD_CTL_PAD_SNVS_TAMPER0",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002a8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_snvs_tamper0
    },
    {
        "SW_PAD_CTL_PAD_SNVS_TAMPER1",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002ac, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_snvs_tamper1
    },
    {
        "SW_PAD_CTL_PAD_SNVS_TAMPER2",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_snvs_tamper2
    },
    {
        "SW_PAD_CTL_PAD_SNVS_TAMPER3",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002b4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_snvs_tamper3
    },
    {
        "SW_PAD_CTL_PAD_SNVS_TAMPER4",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002b8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_snvs_tamper4
    },
    {
        "SW_PAD_CTL_PAD_SNVS_TAMPER5",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002bc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_snvs_tamper5
    },
    {
        "SW_PAD_CTL_PAD_SNVS_TAMPER6",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002c0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_snvs_tamper6
    },
    {
        "SW_PAD_CTL_PAD_SNVS_TAMPER7",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002c4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_snvs_tamper7
    },
    {
        "SW_PAD_CTL_PAD_SNVS_TAMPER8",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002c8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_snvs_tamper8
    },
    {
        "SW_PAD_CTL_PAD_SNVS_TAMPER9",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002cc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_snvs_tamper9
    },
    {
        "SW_PAD_CTL_PAD_JTAG_MOD",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002d0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_mod
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TMS",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002d4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_tms
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TDO",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002d8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_tdo
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TDI",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002dc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_tdi
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TCK",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002e0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_tck
    },
    {
        "SW_PAD_CTL_PAD_JTAG_TRST_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002e4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_jtag_trst_b
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO00",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002e8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io00
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO01",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002ec, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io01
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO02",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002f0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io02
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO03",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002f4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io03
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO04",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002f8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io04
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO05",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000002fc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io05
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO06",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io06
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO07",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000304, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io07
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO08",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000308, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io08
    },
    {
        "SW_PAD_CTL_PAD_GPIO1_IO09",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000030c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_gpio1_io09
    },
    {
        "SW_PAD_CTL_PAD_UART1_TX_DATA",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000310, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart1_tx_data
    },
    {
        "SW_PAD_CTL_PAD_UART1_RX_DATA",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000314, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart1_rx_data
    },
    {
        "SW_PAD_CTL_PAD_UART1_CTS_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000318, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart1_cts_b
    },
    {
        "SW_PAD_CTL_PAD_UART1_RTS_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000031c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart1_rts_b
    },
    {
        "SW_PAD_CTL_PAD_UART2_TX_DATA",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart2_tx_data
    },
    {
        "SW_PAD_CTL_PAD_UART2_RX_DATA",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000324, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart2_rx_data
    },
    {
        "SW_PAD_CTL_PAD_UART2_CTS_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000328, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart2_cts_b
    },
    {
        "SW_PAD_CTL_PAD_UART2_RTS_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000032c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart2_rts_b
    },
    {
        "SW_PAD_CTL_PAD_UART3_TX_DATA",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000330, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart3_tx_data
    },
    {
        "SW_PAD_CTL_PAD_UART3_RX_DATA",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000334, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart3_rx_data
    },
    {
        "SW_PAD_CTL_PAD_UART3_CTS_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000338, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart3_cts_b
    },
    {
        "SW_PAD_CTL_PAD_UART3_RTS_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000033c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart3_rts_b
    },
    {
        "SW_PAD_CTL_PAD_UART4_TX_DATA",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000340, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart4_tx_data
    },
    {
        "SW_PAD_CTL_PAD_UART4_RX_DATA",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000344, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart4_rx_data
    },
    {
        "SW_PAD_CTL_PAD_UART5_TX_DATA",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000348, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart5_tx_data
    },
    {
        "SW_PAD_CTL_PAD_UART5_RX_DATA",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000034c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_uart5_rx_data
    },
    {
        "SW_PAD_CTL_PAD_ENET1_RX_DATA0",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000350, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet1_rx_data0
    },
    {
        "SW_PAD_CTL_PAD_ENET1_RX_DATA1",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000354, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet1_rx_data1
    },
    {
        "SW_PAD_CTL_PAD_ENET1_RX_EN",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000358, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet1_rx_en
    },
    {
        "SW_PAD_CTL_PAD_ENET1_TX_DATA0",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000035c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet1_tx_data0
    },
    {
        "SW_PAD_CTL_PAD_ENET1_TX_DATA1",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000360, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet1_tx_data1
    },
    {
        "SW_PAD_CTL_PAD_ENET1_TX_EN",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000364, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet1_tx_en
    },
    {
        "SW_PAD_CTL_PAD_ENET1_TX_CLK",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000368, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet1_tx_clk
    },
    {
        "SW_PAD_CTL_PAD_ENET1_RX_ER",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000036c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet1_rx_er
    },
    {
        "SW_PAD_CTL_PAD_ENET2_RX_DATA0",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000370, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet2_rx_data0
    },
    {
        "SW_PAD_CTL_PAD_ENET2_RX_DATA1",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000374, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet2_rx_data1
    },
    {
        "SW_PAD_CTL_PAD_ENET2_RX_EN",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000378, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet2_rx_en
    },
    {
        "SW_PAD_CTL_PAD_ENET2_TX_DATA0",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000037c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet2_tx_data0
    },
    {
        "SW_PAD_CTL_PAD_ENET2_TX_DATA1",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000380, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet2_tx_data1
    },
    {
        "SW_PAD_CTL_PAD_ENET2_TX_EN",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000384, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet2_tx_en
    },
    {
        "SW_PAD_CTL_PAD_ENET2_TX_CLK",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000388, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet2_tx_clk
    },
    {
        "SW_PAD_CTL_PAD_ENET2_RX_ER",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000038c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_enet2_rx_er
    },
    {
        "SW_PAD_CTL_PAD_LCD_CLK",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000390, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_clk
    },
    {
        "SW_PAD_CTL_PAD_LCD_ENABLE",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000394, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_enable
    },
    {
        "SW_PAD_CTL_PAD_LCD_HSYNC",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000398, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_hsync
    },
    {
        "SW_PAD_CTL_PAD_LCD_VSYNC",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000039c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_vsync
    },
    {
        "SW_PAD_CTL_PAD_LCD_RESET",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_reset
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA00",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003a4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data00
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA01",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003a8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data01
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA02",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003ac, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data02
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA03",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003b0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data03
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA04",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003b4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data04
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA05",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003b8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data05
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA06",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003bc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data06
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA07",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003c0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data07
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA08",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003c4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data08
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA09",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003c8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data09
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA10",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003cc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data10
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA11",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003d0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data11
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA12",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003d4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data12
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA13",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003d8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data13
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA14",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003dc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data14
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA15",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003e0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data15
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA16",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003e4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data16
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA17",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003e8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data17
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA18",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003ec, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data18
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA19",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003f0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data19
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA20",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003f4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data20
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA21",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003f8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data21
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA22",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x000003fc, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data22
    },
    {
        "SW_PAD_CTL_PAD_LCD_DATA23",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_lcd_data23
    },
    {
        "SW_PAD_CTL_PAD_NAND_RE_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_re_b
    },
    {
        "SW_PAD_CTL_PAD_NAND_WE_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_we_b
    },
    {
        "SW_PAD_CTL_PAD_NAND_DATA00",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_data00
    },
    {
        "SW_PAD_CTL_PAD_NAND_DATA01",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_data01
    },
    {
        "SW_PAD_CTL_PAD_NAND_DATA02",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_data02
    },
    {
        "SW_PAD_CTL_PAD_NAND_DATA03",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000418, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_data03
    },
    {
        "SW_PAD_CTL_PAD_NAND_DATA04",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000041c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_data04
    },
    {
        "SW_PAD_CTL_PAD_NAND_DATA05",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_data05
    },
    {
        "SW_PAD_CTL_PAD_NAND_DATA06",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000424, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_data06
    },
    {
        "SW_PAD_CTL_PAD_NAND_DATA07",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000428, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_data07
    },
    {
        "SW_PAD_CTL_PAD_NAND_ALE",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000042c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_ale
    },
    {
        "SW_PAD_CTL_PAD_NAND_WP_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_wp_b
    },
    {
        "SW_PAD_CTL_PAD_NAND_READY_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000434, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_ready_b
    },
    {
        "SW_PAD_CTL_PAD_NAND_CE0_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000438, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_ce0_b
    },
    {
        "SW_PAD_CTL_PAD_NAND_CE1_B",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000043c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_ce1_b
    },
    {
        "SW_PAD_CTL_PAD_NAND_CLE",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_cle
    },
    {
        "SW_PAD_CTL_PAD_NAND_DQS",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000444, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_nand_dqs
    },
    {
        "SW_PAD_CTL_PAD_SD1_CMD",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000448, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_cmd
    },
    {
        "SW_PAD_CTL_PAD_SD1_CLK",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000044c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_clk
    },
    {
        "SW_PAD_CTL_PAD_SD1_DATA0",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000450, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_data0
    },
    {
        "SW_PAD_CTL_PAD_SD1_DATA1",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000454, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_data1
    },
    {
        "SW_PAD_CTL_PAD_SD1_DATA2",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000458, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_data2
    },
    {
        "SW_PAD_CTL_PAD_SD1_DATA3",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000045c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_sd1_data3
    },
    {
        "SW_PAD_CTL_PAD_CSI_MCLK",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000460, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_mclk
    },
    {
        "SW_PAD_CTL_PAD_CSI_PIXCLK",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000464, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_pixclk
    },
    {
        "SW_PAD_CTL_PAD_CSI_VSYNC",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000468, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_vsync
    },
    {
        "SW_PAD_CTL_PAD_CSI_HSYNC",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000046c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_hsync
    },
    {
        "SW_PAD_CTL_PAD_CSI_DATA00",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000470, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_data00
    },
    {
        "SW_PAD_CTL_PAD_CSI_DATA01",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000474, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_data01
    },
    {
        "SW_PAD_CTL_PAD_CSI_DATA02",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000478, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_data02
    },
    {
        "SW_PAD_CTL_PAD_CSI_DATA03",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000047c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_data03
    },
    {
        "SW_PAD_CTL_PAD_CSI_DATA04",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000480, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_data04
    },
    {
        "SW_PAD_CTL_PAD_CSI_DATA05",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000484, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_data05
    },
    {
        "SW_PAD_CTL_PAD_CSI_DATA06",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x00000488, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_data06
    },
    {
        "SW_PAD_CTL_PAD_CSI_DATA07",
        "SW_PAD_CTL Register",
        4, // Width in bytes
        0x0000048c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_pad_csi_data07
    },
    {
        "SW_PAD_CTL_GRP_ADDDS",
        "SW_GRP Register",
        4, // Width in bytes
        0x00000490, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_addds
    },
    {
        "SW_PAD_CTL_GRP_DDRMODE_CTL",
        "SW_GRP Register",
        4, // Width in bytes
        0x00000494, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrmode_ctl
    },
    {
        "SW_PAD_CTL_GRP_B0DS",
        "SW_GRP Register",
        4, // Width in bytes
        0x00000498, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b0ds
    },
    {
        "SW_PAD_CTL_GRP_DDRPK",
        "SW_GRP Register",
        4, // Width in bytes
        0x0000049c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrpk
    },
    {
        "SW_PAD_CTL_GRP_CTLDS",
        "SW_GRP Register",
        4, // Width in bytes
        0x000004a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ctlds
    },
    {
        "SW_PAD_CTL_GRP_B1DS",
        "SW_GRP Register",
        4, // Width in bytes
        0x000004a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_b1ds
    },
    {
        "SW_PAD_CTL_GRP_DDRHYS",
        "SW_GRP Register",
        4, // Width in bytes
        0x000004a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrhys
    },
    {
        "SW_PAD_CTL_GRP_DDRPKE",
        "SW_GRP Register",
        4, // Width in bytes
        0x000004ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrpke
    },
    {
        "SW_PAD_CTL_GRP_DDRMODE",
        "SW_GRP Register",
        4, // Width in bytes
        0x000004b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddrmode
    },
    {
        "SW_PAD_CTL_GRP_DDR_TYPE",
        "SW_GRP Register",
        4, // Width in bytes
        0x000004b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sw_pad_ctl_grp_ddr_type
    },
    {
        "USB_OTG1_ID_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usb_otg1_id_select_input
    },
    {
        "USB_OTG2_ID_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004bc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usb_otg2_id_select_input
    },
    {
        "CCM_PMIC_READY_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ccm_pmic_ready_select_input
    },
    {
        "CSI_DATA02_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data02_select_input
    },
    {
        "CSI_DATA03_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data03_select_input
    },
    {
        "CSI_DATA05_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data05_select_input
    },
    {
        "CSI_DATA00_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data00_select_input
    },
    {
        "CSI_DATA01_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data01_select_input
    },
    {
        "CSI_DATA04_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data04_select_input
    },
    {
        "CSI_DATA06_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data06_select_input
    },
    {
        "CSI_DATA07_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data07_select_input
    },
    {
        "CSI_DATA08_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data08_select_input
    },
    {
        "CSI_DATA09_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data09_select_input
    },
    {
        "CSI_DATA10_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data10_select_input
    },
    {
        "CSI_DATA11_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data11_select_input
    },
    {
        "CSI_DATA12_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data12_select_input
    },
    {
        "CSI_DATA13_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data13_select_input
    },
    {
        "CSI_DATA14_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000004fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data14_select_input
    },
    {
        "CSI_DATA15_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000500, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data15_select_input
    },
    {
        "CSI_DATA16_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000504, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data16_select_input
    },
    {
        "CSI_DATA17_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000508, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data17_select_input
    },
    {
        "CSI_DATA18_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000050c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data18_select_input
    },
    {
        "CSI_DATA19_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000510, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data19_select_input
    },
    {
        "CSI_DATA20_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000514, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data20_select_input
    },
    {
        "CSI_DATA21_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000518, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data21_select_input
    },
    {
        "CSI_DATA22_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000051c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data22_select_input
    },
    {
        "CSI_DATA23_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000520, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_data23_select_input
    },
    {
        "CSI_HSYNC_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000524, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_hsync_select_input
    },
    {
        "CSI_PIXCLK_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000528, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_pixclk_select_input
    },
    {
        "CSI_VSYNC_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000052c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_vsync_select_input
    },
    {
        "CSI_FIELD_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000530, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_csi_field_select_input
    },
    {
        "ECSPI1_SCLK_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000534, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_sclk_select_input
    },
    {
        "ECSPI1_MISO_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000538, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_miso_select_input
    },
    {
        "ECSPI1_MOSI_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000053c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_mosi_select_input
    },
    {
        "ECSPI1_SS0_B_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000540, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi1_ss0_b_select_input
    },
    {
        "ECSPI2_SCLK_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000544, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_sclk_select_input
    },
    {
        "ECSPI2_MISO_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000548, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_miso_select_input
    },
    {
        "ECSPI2_MOSI_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000054c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_mosi_select_input
    },
    {
        "ECSPI2_SS0_B_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000550, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi2_ss0_b_select_input
    },
    {
        "ECSPI3_SCLK_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000554, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi3_sclk_select_input
    },
    {
        "ECSPI3_MISO_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000558, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi3_miso_select_input
    },
    {
        "ECSPI3_MOSI_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000055c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi3_mosi_select_input
    },
    {
        "ECSPI3_SS0_B_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000560, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi3_ss0_b_select_input
    },
    {
        "ECSPI4_SCLK_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000564, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi4_sclk_select_input
    },
    {
        "ECSPI4_MISO_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000568, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi4_miso_select_input
    },
    {
        "ECSPI4_MOSI_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000056c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi4_mosi_select_input
    },
    {
        "ECSPI4_SS0_B_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000570, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_ecspi4_ss0_b_select_input
    },
    {
        "ENET1_REF_CLK1_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000574, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet1_ref_clk1_select_input
    },
    {
        "ENET1_MAC0_MDIO_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000578, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet1_mac0_mdio_select_input
    },
    {
        "ENET2_REF_CLK2_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000057c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet2_ref_clk2_select_input
    },
    {
        "ENET2_MAC0_MDIO_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000580, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_enet2_mac0_mdio_select_input
    },
    {
        "FLEXCAN1_RX_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000584, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_flexcan1_rx_select_input
    },
    {
        "FLEXCAN2_RX_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000588, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_flexcan2_rx_select_input
    },
    {
        "GPT1_CAPTURE1_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000058c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_gpt1_capture1_select_input
    },
    {
        "GPT1_CAPTURE2_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000590, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_gpt1_capture2_select_input
    },
    {
        "GPT1_CLK_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000594, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_gpt1_clk_select_input
    },
    {
        "GPT2_CAPTURE1_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000598, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_gpt2_capture1_select_input
    },
    {
        "GPT2_CAPTURE2_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000059c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_gpt2_capture2_select_input
    },
    {
        "GPT2_CLK_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_gpt2_clk_select_input
    },
    {
        "I2C1_SCL_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c1_scl_select_input
    },
    {
        "I2C1_SDA_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c1_sda_select_input
    },
    {
        "I2C2_SCL_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c2_scl_select_input
    },
    {
        "I2C2_SDA_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c2_sda_select_input
    },
    {
        "I2C3_SCL_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c3_scl_select_input
    },
    {
        "I2C3_SDA_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c3_sda_select_input
    },
    {
        "I2C4_SCL_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005bc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c4_scl_select_input
    },
    {
        "I2C4_SDA_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_i2c4_sda_select_input
    },
    {
        "KPP_COL0_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005c4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_col0_select_input
    },
    {
        "KPP_COL1_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005c8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_col1_select_input
    },
    {
        "KPP_COL2_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005cc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_col2_select_input
    },
    {
        "KPP_ROW0_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_row0_select_input
    },
    {
        "KPP_ROW1_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_row1_select_input
    },
    {
        "KPP_ROW2_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_kpp_row2_select_input
    },
    {
        "LCD_BUSY_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_lcd_busy_select_input
    },
    {
        "SAI1_MCLK_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai1_mclk_select_input
    },
    {
        "SAI1_RX_DATA_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai1_rx_data_select_input
    },
    {
        "SAI1_TX_BCLK_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai1_tx_bclk_select_input
    },
    {
        "SAI1_TX_SYNC_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai1_tx_sync_select_input
    },
    {
        "SAI2_MCLK_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai2_mclk_select_input
    },
    {
        "SAI2_RX_DATA_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005f4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai2_rx_data_select_input
    },
    {
        "SAI2_TX_BCLK_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005f8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai2_tx_bclk_select_input
    },
    {
        "SAI2_TX_SYNC_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x000005fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai2_tx_sync_select_input
    },
    {
        "SAI3_MCLK_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000600, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai3_mclk_select_input
    },
    {
        "SAI3_RX_DATA_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000604, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai3_rx_data_select_input
    },
    {
        "SAI3_TX_BCLK_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000608, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai3_tx_bclk_select_input
    },
    {
        "SAI3_TX_SYNC_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000060c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sai3_tx_sync_select_input
    },
    {
        "SDMA_EVENTS0_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000610, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sdma_events0_select_input
    },
    {
        "SDMA_EVENTS1_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000614, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_sdma_events1_select_input
    },
    {
        "SPDIF_IN_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000618, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_spdif_in_select_input
    },
    {
        "SPDIF_EXT_CLK_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000061c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_spdif_ext_clk_select_input
    },
    {
        "UART1_RTS_B_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000620, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart1_rts_b_select_input
    },
    {
        "UART1_RX_DATA_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000624, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart1_rx_data_select_input
    },
    {
        "UART2_RTS_B_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000628, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart2_rts_b_select_input
    },
    {
        "UART2_RX_DATA_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000062c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart2_rx_data_select_input
    },
    {
        "UART3_RTS_B_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000630, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart3_rts_b_select_input
    },
    {
        "UART3_RX_DATA_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000634, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart3_rx_data_select_input
    },
    {
        "UART4_RTS_B_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000638, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart4_rts_b_select_input
    },
    {
        "UART4_RX_DATA_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000063c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart4_rx_data_select_input
    },
    {
        "UART5_RTS_B_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000640, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart5_rts_b_select_input
    },
    {
        "UART5_RX_DATA_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000644, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart5_rx_data_select_input
    },
    {
        "UART6_RTS_B_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000648, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart6_rts_b_select_input
    },
    {
        "UART6_RX_DATA_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000064c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart6_rx_data_select_input
    },
    {
        "UART7_RTS_B_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000650, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart7_rts_b_select_input
    },
    {
        "UART7_RX_DATA_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000654, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart7_rx_data_select_input
    },
    {
        "UART8_RTS_B_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000658, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart8_rts_b_select_input
    },
    {
        "UART8_RX_DATA_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000065c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_uart8_rx_data_select_input
    },
    {
        "USB_OTG2_OC_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000660, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usb_otg2_oc_select_input
    },
    {
        "USB_OTG_OC_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000664, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usb_otg_oc_select_input
    },
    {
        "USDHC1_CD_B_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000668, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc1_cd_b_select_input
    },
    {
        "USDHC1_WP_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000066c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc1_wp_select_input
    },
    {
        "USDHC2_CLK_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000670, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc2_clk_select_input
    },
    {
        "USDHC2_CD_B_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000674, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc2_cd_b_select_input
    },
    {
        "USDHC2_CMD_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000678, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc2_cmd_select_input
    },
    {
        "USDHC2_DATA0_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000067c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc2_data0_select_input
    },
    {
        "USDHC2_DATA1_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000680, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc2_data1_select_input
    },
    {
        "USDHC2_DATA2_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000684, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc2_data2_select_input
    },
    {
        "USDHC2_DATA3_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000688, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc2_data3_select_input
    },
    {
        "USDHC2_DATA4_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000068c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc2_data4_select_input
    },
    {
        "USDHC2_DATA5_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000690, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc2_data5_select_input
    },
    {
        "USDHC2_DATA6_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000694, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc2_data6_select_input
    },
    {
        "USDHC2_DATA7_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x00000698, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc2_data7_select_input
    },
    {
        "USDHC2_WP_SELECT_INPUT",
        "DAISY Register",
        4, // Width in bytes
        0x0000069c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_iomuxc_usdhc2_wp_select_input
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark IOMUXC_GPR
#endif

// Bitfields in register IOMUXC_GPR_GPR_GPR0.
static const field_t hw_iomuxc_gpr_gpr_gpr0[] =
{
    {
        "DMAREQ_MUX_SEL0",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL1",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL2",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL3",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL4",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL5",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL6",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL7",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL8",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL9",
        "",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL10",
        "",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL11",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL12",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL13",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL14",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL15",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL16",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL17",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL18",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL19",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL20",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL21",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAREQ_MUX_SEL22",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR1.
static const field_t hw_iomuxc_gpr_gpr_gpr1[] =
{
    {
        "ACT_CS0",
        "See description for ADDRS3[10]",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRS0",
        "See description for ADDRS3[10]",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACT_CS1",
        "See description for ADDRS3[10]",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRS1",
        "See description for ADDRS3[10]",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACT_CS2",
        "See description for ADDRS3[10]",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRS2",
        "See description for ADDRS3[10]",
        7, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACT_CS3",
        "See description for ADDRS3[10]",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRS3",
        "Active Chip Select and Address Space.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GINT",
        "Global interrupt \"0\" bit (connected to ARM A7 IRQ#0 and GPC)",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_CLK_SEL",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET2_CLK_SEL",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USB_EXP_MODE",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADD_DS",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_TX_CLK_DIR",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET2_TX_CLK_DIR",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SAI1_MCLK_DIR",
        "LCD_DATA00 data direction control when sai1.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SAI2_MCLK_DIR",
        "SD1_CLK data direction control when sai2.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SAI3_MCLK_DIR",
        "LCD_CLK data direction control when sai3.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXC_MON",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZASC1_BOOT_LOCK",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARMA7_CLK_APB_DBG_EN",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARMA7_CLK_ATB_EN",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARMA7_CLK_AHB_EN",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR2.
static const field_t hw_iomuxc_gpr_gpr_gpr2[] =
{
    {
        "PXP_MEM_EN_POWERSAVING",
        "enable power saving features on PXP memory",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_MEM_SHUTDOWN",
        "set to bring memory to shutdown state (most power saving state, Shut D"
        "own periphery and core, no memory retention)",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_MEM_DEEPSLEEP",
        "control how memory enter Deep Sleep mode (shutdown periphery power, bu"
        "t maintain memory contents, outputs of memory are pulled low)",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PXP_MEM_LIGHTSLEEP",
        "set to bring memory to light sleep state (Low leakage mode, maintain m"
        "emory contents, no change to memory output)",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_MEM_EN_POWERSAVING",
        "enable power saving features on LCDIF memory",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_MEM_SHUTDOWN",
        "set to bring memory to shutdown state (most power saving state, Shut D"
        "own periphery and core, no memory retention)",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_MEM_DEEPSLEEP",
        "control how memory enter Deep Sleep mode (shutdown periphery power, bu"
        "t maintain memory contents, outputs of memory are pulled low)",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF1_MEM_LIGHTSLEEP",
        "set to bring memory to light sleep state (Low leakage mode, maintain m"
        "emory contents, no change to memory output)",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF2_MEM_EN_POWERSAVING",
        "enable power saving features on LCDIF memory",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF2_MEM_SHUTDOWN",
        "set to bring memory to shutdown state (most power saving state, Shut D"
        "own periphery and core, no memory retention)",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF2_MEM_DEEPSLEEP",
        "control how memory enter Deep Sleep mode (shutdown periphery power, bu"
        "t maintain memory contents, outputs of memory are pulled low)",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCDIF2_MEM_LIGHTSLEEP",
        "set to bring memory to light sleep state (Low leakage mode, maintain m"
        "emory contents, no change to memory output)",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_MEM_EN_POWERSAVING",
        "enable power saving features on L2 memory",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_MEM_SHUTDOWN",
        "set to bring memory to shutdown state (most power saving state, Shut D"
        "own periphery and core, no memory retention)",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_MEM_DEEPSLEEP",
        "control how memory enter Deep Sleep mode (shutdown periphery power, bu"
        "t maintain memory contents, outputs of memory are pulled low)",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_MEM_LIGHTSLEEP",
        "set to bring memory to light sleep state (Low leakage mode, maintain m"
        "emory contents, no change to memory output)",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MQS_CLK_DIV",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MQS_SW_RST",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MQS_EN",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MQS_OVERSAMPLE",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRAM_RESET_BYPASS",
        "",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRAM_RESET",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRAM_CKE0",
        "",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRAM_CKE1",
        "",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DRAM_CKE_BYPASS",
        "",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR3.
static const field_t hw_iomuxc_gpr_gpr_gpr3[] =
{
    {
        "OCRAM_CTL",
        "OCRAM_CTL[24] write address pipeline control bit.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE_DBG_ACK_EN",
        "Mask control of Core debug acknowledge to global debug acknowledge",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_STATUS",
        "This field shows the OCRAM pipeline settings status, controlled by OCR"
        "AM_CTL[24:21] bits respectively.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR4.
static const field_t hw_iomuxc_gpr_gpr_gpr4[] =
{
    {
        "SDMA_STOP_REQ",
        "SDMA stop request.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CAN1_STOP_REQ",
        "CAN1 stop request.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CAN2_STOP_REQ",
        "CAN2 stop request.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENET1_STOP_REQ",
        "ENET1 stop request.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENET2_STOP_REQ",
        "ENET2 stop request.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SAI1_STOP_REQ",
        "SAI1 stop request.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SAI2_STOP_REQ",
        "SAI2 stop request.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SAI3_STOP_REQ",
        "SAI3 stop request.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENET_IPG_CLK_S_EN",
        "ENET ipg_clk_s clock gating enable",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDMA_STOP_ACK",
        "SDMA stop acknowledge.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CAN1_STOP_ACK",
        "CAN1 stop acknowledge.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CAN2_STOP_ACK",
        "CAN2 stop acknowledge.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENET1_STOP_ACK",
        "ENET1 stop acknowledge.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENET2_STOP_ACK",
        "ENET2 stop acknowledge.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SAI1_STOP_ACK",
        "SAI1 stop acknowledge.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SAI2_STOP_ACK",
        "SAI2 stop acknowledge.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SAI3_STOP_ACK",
        "SAI3 stop acknowledge.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ARM_WFI",
        "ARM A7 WFI event out indicating on WFI state of the cores (these are s"
        "tatus, read only bits)",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ARM_WFE",
        "ARM A7 WFE event out indication on WFE state of the cores (these are s"
        "tatus, read only bits)",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR5.
static const field_t hw_iomuxc_gpr_gpr_gpr5[] =
{
    {
        "WDOG1_MASK",
        "WDOG1 Timeout Mask",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG2_MASK",
        "WDOG2 Timeout Mask",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG3_MASK",
        "WDOG3 Timeout Mask",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPT2_CAPIN1_SEL",
        "GPT2 input capture channel 1 source select",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPT2_CAPIN2_SEL",
        "GPT2 input capture channel 2 source select",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET1_EVENT3IN_SEL",
        "ENET1 input timer event3 source select",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENET2_EVENT3IN_SEL",
        "ENET2 input timer event3 source select",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VREF_1M_CLK_GPT1",
        "GPT1 1MHz clock source select",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VREF_1M_CLK_GPT2",
        "GPT2 1MHz clock source select",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_1M_CLK_EPIT1",
        "EPIT1 1MHz clock source select",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_1M_CLK_EPIT2",
        "EPIT2 1MHz clock source select",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR9.
static const field_t hw_iomuxc_gpr_gpr_gpr9[] =
{
    {
        "TZASC1_BYP",
        "TZASC-1 BYPASS MUX control",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR10.
static const field_t hw_iomuxc_gpr_gpr_gpr10[] =
{
    {
        "DBG_EN",
        "ARM non secure (non-invasive) debug enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBG_CLK_EN",
        "ARM Debug clock enable",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEC_ERR_RESP",
        "Security error response enable for all security gaskets (on both AHB a"
        "nd AXI busses)",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_TZ_EN",
        "OCRAM TrustZone (TZ) enable.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCRAM_TZ_ADDR",
        "OCRAM TrustZone (TZ) start address.",
        11, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register IOMUXC_GPR_GPR_GPR14.
static const field_t hw_iomuxc_gpr_gpr_gpr14[] =
{
    {
        "SIM1_SIMV2_EMV_SEL",
        "SIM1 emv/simv2 select",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SIM2_SIMV2_EMV_SEL",
        "SIM2 emv/simv2 select",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPR",
        "General purpose bits to be used by SoC integration.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a IOMUXC_GPR module.
static const reg_t hw_iomuxc_gpr[] =
{
    {
        "GPR_GPR0",
        "GPR Register",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        23, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr0
    },
    {
        "GPR_GPR1",
        "GPR Register",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        23, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr1
    },
    {
        "GPR_GPR2",
        "GPR Register",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr2
    },
    {
        "GPR_GPR3",
        "GPR Register",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr3
    },
    {
        "GPR_GPR4",
        "GPR Register",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        19, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr4
    },
    {
        "GPR_GPR5",
        "GPR Register",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr5
    },
    {
        "GPR_GPR9",
        "GPR Register",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr9
    },
    {
        "GPR_GPR10",
        "GPR Register",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr10
    },
    {
        "GPR_GPR14",
        "GPR Register",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_iomuxc_gpr_gpr_gpr14
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark KPP
#endif

// Bitfields in register KPP_KPCR.
static const field_t hw_kpp_kpcr[] =
{
    {
        "KRE",
        "Keypad Row Enable.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KCO",
        "Keypad Column Strobe Open-Drain Enable.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register KPP_KPSR.
static const field_t hw_kpp_kpsr[] =
{
    {
        "KPKD",
        "Keypad Key Depress.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KPKR",
        "Keypad Key Release.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KDSC",
        "Key Depress Synchronizer Clear.",
        2, // LSB
        2, // MSB
        false, // Readable
        false // Writable
    },
    {
        "KRSS",
        "Key Release Synchronizer Set.",
        3, // LSB
        3, // MSB
        false, // Readable
        false // Writable
    },
    {
        "KDIE",
        "Keypad Key Depress Interrupt Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KRIE",
        "Keypad Release Interrupt Enable.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register KPP_KDDR.
static const field_t hw_kpp_kddr[] =
{
    {
        "KRDD",
        "Keypad Row Data Direction.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KCDD",
        "Keypad Column Data Direction Register.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register KPP_KPDR.
static const field_t hw_kpp_kpdr[] =
{
    {
        "KRD",
        "Keypad Row Data.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "KCD",
        "Keypad Column Data.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a KPP module.
static const reg_t hw_kpp[] =
{
    {
        "KPCR",
        "The Keypad Control Register determines which of the eight possible col"
        "umn strobes are to be open drain when configured as outputs, and which"
        " of the eight row sense lines are considered in generating an interrup"
        "t to the core.",
        2, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_kpp_kpcr
    },
    {
        "KPSR",
        "The Keypad Status Register reflects the state of the key press detect "
        "circuit.",
        2, // Width in bytes
        0x00000002, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_kpp_kpsr
    },
    {
        "KDDR",
        "The bits in the KPP_KDDR control the direction of the keypad port pins"
        ".",
        2, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_kpp_kddr
    },
    {
        "KPDR",
        "This 16-bit register is used to access the column and row data.",
        2, // Width in bytes
        0x00000006, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_kpp_kpdr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark LCDIF
#endif

// Bitfields in register LCDIF_RL.
static const field_t hw_lcdif_rl[] =
{
    {
        "RUN",
        "When this bit is set by software, the eLCDIF will begin transferring d"
        "ata between the SoC and the display.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_24_BIT",
        "Used only when WORD_LENGTH = 3, i.e.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_18_BIT",
        "Used only when WORD_LENGTH = 2, i.e.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_16_BIT",
        "When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit dat"
        "a is in ARGB555 format.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "MASTER",
        "Set this bit to make the eLCDIF act as a bus master.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PXP_HANDSHAKE",
        "If this bit is set and LCDIF_MASTER bit is set, the eLCDIF will act as"
        " bus master and the handshake mechanism between eLCDIF and ePXP will b"
        "e turned on.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RGB_TO_YCBCR422_CSC",
        "Set this bit to 1 to enable conversion from RGB to YCbCr colorspace.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "Input data format.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCD_DATABUS_WIDTH",
        "LCD Data bus transfer width.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSC_DATA_SWIZZLE",
        "This field specifies how to swap the bytes after the data has been con"
        "verted into an internal representation of 24 bits per pixel and before"
        " it is transmitted over the LCD interface bus.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INPUT_DATA_SWIZZLE",
        "This field specifies how to swap the bytes fetched by the bus master i"
        "nterface.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SELECT",
        "Command Mode polarity bit.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_MODE",
        "Set this bit to 1 to make the hardware go into the DOTCLK mode, i.e.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_MODE",
        "Setting this bit to 1 will make the eLCDIF hardware go into VSYNC mode"
        ".",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_COUNT",
        "When this bit is 0, it means that eLCDIF will stop the block operation"
        " and turn off the RUN bit after the amount of data indicated by the LC"
        "DIF_TRANSFER_COUNT register has been transferred out.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVI_MODE",
        "Set this bit to 1 to get into the ITU-R BT.656 digital video interface"
        " mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHIFT_NUM_BITS",
        "The data to be transmitted is shifted left or right by this number of "
        "bits.",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SHIFT_DIR",
        "Use this bit to determine the direction of shift of transmit data.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT_FOR_VSYNC_EDGE",
        "Setting this bit to 1 will make the hardware wait for the triggering V"
        "SYNC edge before starting write transfers to the LCD.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_WRITEB",
        "By default, eLCDIF is in the write mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCBCR422_INPUT",
        "Zero implies input data is in RGB color space.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "This bit must be set to zero to enable normal operation of the eLCDIF.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_RL_SET.
static const field_t hw_lcdif_rl_set[] =
{
    {
        "RUN",
        "When this bit is set by software, the eLCDIF will begin transferring d"
        "ata between the SoC and the display.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_24_BIT",
        "Used only when WORD_LENGTH = 3, i.e.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_18_BIT",
        "Used only when WORD_LENGTH = 2, i.e.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_16_BIT",
        "When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit dat"
        "a is in ARGB555 format.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "MASTER",
        "Set this bit to make the eLCDIF act as a bus master.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PXP_HANDSHAKE",
        "If this bit is set and LCDIF_MASTER bit is set, the eLCDIF will act as"
        " bus master and the handshake mechanism between eLCDIF and ePXP will b"
        "e turned on.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RGB_TO_YCBCR422_CSC",
        "Set this bit to 1 to enable conversion from RGB to YCbCr colorspace.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "Input data format.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCD_DATABUS_WIDTH",
        "LCD Data bus transfer width.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSC_DATA_SWIZZLE",
        "This field specifies how to swap the bytes after the data has been con"
        "verted into an internal representation of 24 bits per pixel and before"
        " it is transmitted over the LCD interface bus.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INPUT_DATA_SWIZZLE",
        "This field specifies how to swap the bytes fetched by the bus master i"
        "nterface.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SELECT",
        "Command Mode polarity bit.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_MODE",
        "Set this bit to 1 to make the hardware go into the DOTCLK mode, i.e.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_MODE",
        "Setting this bit to 1 will make the eLCDIF hardware go into VSYNC mode"
        ".",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_COUNT",
        "When this bit is 0, it means that eLCDIF will stop the block operation"
        " and turn off the RUN bit after the amount of data indicated by the LC"
        "DIF_TRANSFER_COUNT register has been transferred out.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVI_MODE",
        "Set this bit to 1 to get into the ITU-R BT.656 digital video interface"
        " mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHIFT_NUM_BITS",
        "The data to be transmitted is shifted left or right by this number of "
        "bits.",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SHIFT_DIR",
        "Use this bit to determine the direction of shift of transmit data.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT_FOR_VSYNC_EDGE",
        "Setting this bit to 1 will make the hardware wait for the triggering V"
        "SYNC edge before starting write transfers to the LCD.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_WRITEB",
        "By default, eLCDIF is in the write mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCBCR422_INPUT",
        "Zero implies input data is in RGB color space.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "This bit must be set to zero to enable normal operation of the eLCDIF.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_RL_CLR.
static const field_t hw_lcdif_rl_clr[] =
{
    {
        "RUN",
        "When this bit is set by software, the eLCDIF will begin transferring d"
        "ata between the SoC and the display.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_24_BIT",
        "Used only when WORD_LENGTH = 3, i.e.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_18_BIT",
        "Used only when WORD_LENGTH = 2, i.e.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_16_BIT",
        "When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit dat"
        "a is in ARGB555 format.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "MASTER",
        "Set this bit to make the eLCDIF act as a bus master.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PXP_HANDSHAKE",
        "If this bit is set and LCDIF_MASTER bit is set, the eLCDIF will act as"
        " bus master and the handshake mechanism between eLCDIF and ePXP will b"
        "e turned on.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RGB_TO_YCBCR422_CSC",
        "Set this bit to 1 to enable conversion from RGB to YCbCr colorspace.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "Input data format.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCD_DATABUS_WIDTH",
        "LCD Data bus transfer width.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSC_DATA_SWIZZLE",
        "This field specifies how to swap the bytes after the data has been con"
        "verted into an internal representation of 24 bits per pixel and before"
        " it is transmitted over the LCD interface bus.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INPUT_DATA_SWIZZLE",
        "This field specifies how to swap the bytes fetched by the bus master i"
        "nterface.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SELECT",
        "Command Mode polarity bit.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_MODE",
        "Set this bit to 1 to make the hardware go into the DOTCLK mode, i.e.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_MODE",
        "Setting this bit to 1 will make the eLCDIF hardware go into VSYNC mode"
        ".",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_COUNT",
        "When this bit is 0, it means that eLCDIF will stop the block operation"
        " and turn off the RUN bit after the amount of data indicated by the LC"
        "DIF_TRANSFER_COUNT register has been transferred out.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVI_MODE",
        "Set this bit to 1 to get into the ITU-R BT.656 digital video interface"
        " mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHIFT_NUM_BITS",
        "The data to be transmitted is shifted left or right by this number of "
        "bits.",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SHIFT_DIR",
        "Use this bit to determine the direction of shift of transmit data.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT_FOR_VSYNC_EDGE",
        "Setting this bit to 1 will make the hardware wait for the triggering V"
        "SYNC edge before starting write transfers to the LCD.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_WRITEB",
        "By default, eLCDIF is in the write mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCBCR422_INPUT",
        "Zero implies input data is in RGB color space.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "This bit must be set to zero to enable normal operation of the eLCDIF.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_RL_TOG.
static const field_t hw_lcdif_rl_tog[] =
{
    {
        "RUN",
        "When this bit is set by software, the eLCDIF will begin transferring d"
        "ata between the SoC and the display.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_24_BIT",
        "Used only when WORD_LENGTH = 3, i.e.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_18_BIT",
        "Used only when WORD_LENGTH = 2, i.e.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_FORMAT_16_BIT",
        "When this bit is 1 and WORD_LENGTH = 0, it implies that the 16-bit dat"
        "a is in ARGB555 format.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "MASTER",
        "Set this bit to make the eLCDIF act as a bus master.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PXP_HANDSHAKE",
        "If this bit is set and LCDIF_MASTER bit is set, the eLCDIF will act as"
        " bus master and the handshake mechanism between eLCDIF and ePXP will b"
        "e turned on.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RGB_TO_YCBCR422_CSC",
        "Set this bit to 1 to enable conversion from RGB to YCbCr colorspace.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WORD_LENGTH",
        "Input data format.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LCD_DATABUS_WIDTH",
        "LCD Data bus transfer width.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSC_DATA_SWIZZLE",
        "This field specifies how to swap the bytes after the data has been con"
        "verted into an internal representation of 24 bits per pixel and before"
        " it is transmitted over the LCD interface bus.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INPUT_DATA_SWIZZLE",
        "This field specifies how to swap the bytes fetched by the bus master i"
        "nterface.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SELECT",
        "Command Mode polarity bit.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_MODE",
        "Set this bit to 1 to make the hardware go into the DOTCLK mode, i.e.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_MODE",
        "Setting this bit to 1 will make the eLCDIF hardware go into VSYNC mode"
        ".",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS_COUNT",
        "When this bit is 0, it means that eLCDIF will stop the block operation"
        " and turn off the RUN bit after the amount of data indicated by the LC"
        "DIF_TRANSFER_COUNT register has been transferred out.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVI_MODE",
        "Set this bit to 1 to get into the ITU-R BT.656 digital video interface"
        " mode.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SHIFT_NUM_BITS",
        "The data to be transmitted is shifted left or right by this number of "
        "bits.",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_SHIFT_DIR",
        "Use this bit to determine the direction of shift of transmit data.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT_FOR_VSYNC_EDGE",
        "Setting this bit to 1 will make the hardware wait for the triggering V"
        "SYNC edge before starting write transfers to the LCD.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_WRITEB",
        "By default, eLCDIF is in the write mode.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCBCR422_INPUT",
        "Zero implies input data is in RGB color space.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "This bit must be set to zero to enable normal operation of the eLCDIF.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL1.
static const field_t hw_lcdif_ctrl1[] =
{
    {
        "RESET",
        "Reset bit for the external LCD controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE86",
        "This bit is used to select between the 8080 and 6800 series of micropr"
        "ocessor modes.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY_ENABLE",
        "This bit enables the use of the interface's busy signal input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        3, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "VSYNC_EDGE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_EDGE_IRQ_EN",
        "This bit is set to enable an interrupt every time the hardware encount"
        "ers the leading VSYNC edge in the VSYNC and DOTCLK modes, or the begin"
        "ning of every field in DVI mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ_EN",
        "This bit is set to 1 enable an interrupt every time the hardware enter"
        "s in the vertical blanking state.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ_EN",
        "This bit is set to enable an underflow interrupt in the TXFIFO in the "
        "write mode.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ_EN",
        "This bit is set to enable an overflow interrupt in the TXFIFO in the w"
        "rite mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYTE_PACKING_FORMAT",
        "This bitfield is used to show which data bytes in a 32-bit word are va"
        "lid.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ON_ALTERNATE_FIELDS",
        "If this bit is set, the eLCDIF block will assert the cur_frame_done in"
        "terrupt only on alternate fields, otherwise it will issue the interrup"
        "t on both odd and even field.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_CLEAR",
        "Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO"
        " and the RXFIFO.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_INTERLACE_FROM_SECOND_FIELD",
        "The default is to grab the odd lines first and then the even lines.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTERLACE_FIELDS",
        "Set this bit if it is required that the eLCDIF block fetches odd lines"
        " in one field and even lines in the other field.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECOVER_ON_UNDERFLOW",
        "Set this bit to enable the eLCDIF block to recover in the next field/f"
        "rame if there was an underflow in the current field/frame.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ_EN",
        "This bit is set to enable bus master error interrupt in the eLCDIF mas"
        "ter mode.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMBINE_MPU_WR_STRB",
        "If this bit is not set, the write strobe will be driven on LCD_WR_RWn "
        "pin in the 8080 mode and on the LCD_RD_E pin in the 6800 mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        28, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL1_SET.
static const field_t hw_lcdif_ctrl1_set[] =
{
    {
        "RESET",
        "Reset bit for the external LCD controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE86",
        "This bit is used to select between the 8080 and 6800 series of micropr"
        "ocessor modes.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY_ENABLE",
        "This bit enables the use of the interface's busy signal input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        3, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "VSYNC_EDGE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_EDGE_IRQ_EN",
        "This bit is set to enable an interrupt every time the hardware encount"
        "ers the leading VSYNC edge in the VSYNC and DOTCLK modes, or the begin"
        "ning of every field in DVI mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ_EN",
        "This bit is set to 1 enable an interrupt every time the hardware enter"
        "s in the vertical blanking state.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ_EN",
        "This bit is set to enable an underflow interrupt in the TXFIFO in the "
        "write mode.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ_EN",
        "This bit is set to enable an overflow interrupt in the TXFIFO in the w"
        "rite mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYTE_PACKING_FORMAT",
        "This bitfield is used to show which data bytes in a 32-bit word are va"
        "lid.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ON_ALTERNATE_FIELDS",
        "If this bit is set, the eLCDIF block will assert the cur_frame_done in"
        "terrupt only on alternate fields, otherwise it will issue the interrup"
        "t on both odd and even field.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_CLEAR",
        "Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO"
        " and the RXFIFO.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_INTERLACE_FROM_SECOND_FIELD",
        "The default is to grab the odd lines first and then the even lines.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTERLACE_FIELDS",
        "Set this bit if it is required that the eLCDIF block fetches odd lines"
        " in one field and even lines in the other field.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECOVER_ON_UNDERFLOW",
        "Set this bit to enable the eLCDIF block to recover in the next field/f"
        "rame if there was an underflow in the current field/frame.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ_EN",
        "This bit is set to enable bus master error interrupt in the eLCDIF mas"
        "ter mode.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMBINE_MPU_WR_STRB",
        "If this bit is not set, the write strobe will be driven on LCD_WR_RWn "
        "pin in the 8080 mode and on the LCD_RD_E pin in the 6800 mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        28, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL1_CLR.
static const field_t hw_lcdif_ctrl1_clr[] =
{
    {
        "RESET",
        "Reset bit for the external LCD controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE86",
        "This bit is used to select between the 8080 and 6800 series of micropr"
        "ocessor modes.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY_ENABLE",
        "This bit enables the use of the interface's busy signal input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        3, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "VSYNC_EDGE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_EDGE_IRQ_EN",
        "This bit is set to enable an interrupt every time the hardware encount"
        "ers the leading VSYNC edge in the VSYNC and DOTCLK modes, or the begin"
        "ning of every field in DVI mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ_EN",
        "This bit is set to 1 enable an interrupt every time the hardware enter"
        "s in the vertical blanking state.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ_EN",
        "This bit is set to enable an underflow interrupt in the TXFIFO in the "
        "write mode.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ_EN",
        "This bit is set to enable an overflow interrupt in the TXFIFO in the w"
        "rite mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYTE_PACKING_FORMAT",
        "This bitfield is used to show which data bytes in a 32-bit word are va"
        "lid.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ON_ALTERNATE_FIELDS",
        "If this bit is set, the eLCDIF block will assert the cur_frame_done in"
        "terrupt only on alternate fields, otherwise it will issue the interrup"
        "t on both odd and even field.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_CLEAR",
        "Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO"
        " and the RXFIFO.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_INTERLACE_FROM_SECOND_FIELD",
        "The default is to grab the odd lines first and then the even lines.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTERLACE_FIELDS",
        "Set this bit if it is required that the eLCDIF block fetches odd lines"
        " in one field and even lines in the other field.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECOVER_ON_UNDERFLOW",
        "Set this bit to enable the eLCDIF block to recover in the next field/f"
        "rame if there was an underflow in the current field/frame.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ_EN",
        "This bit is set to enable bus master error interrupt in the eLCDIF mas"
        "ter mode.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMBINE_MPU_WR_STRB",
        "If this bit is not set, the write strobe will be driven on LCD_WR_RWn "
        "pin in the 8080 mode and on the LCD_RD_E pin in the 6800 mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        28, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL1_TOG.
static const field_t hw_lcdif_ctrl1_tog[] =
{
    {
        "RESET",
        "Reset bit for the external LCD controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MODE86",
        "This bit is used to select between the 8080 and 6800 series of micropr"
        "ocessor modes.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BUSY_ENABLE",
        "This bit enables the use of the interface's busy signal input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        3, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "VSYNC_EDGE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_EDGE_IRQ_EN",
        "This bit is set to enable an interrupt every time the hardware encount"
        "ers the leading VSYNC edge in the VSYNC and DOTCLK modes, or the begin"
        "ning of every field in DVI mode.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CUR_FRAME_DONE_IRQ_EN",
        "This bit is set to 1 enable an interrupt every time the hardware enter"
        "s in the vertical blanking state.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNDERFLOW_IRQ_EN",
        "This bit is set to enable an underflow interrupt in the TXFIFO in the "
        "write mode.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVERFLOW_IRQ_EN",
        "This bit is set to enable an overflow interrupt in the TXFIFO in the w"
        "rite mode.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYTE_PACKING_FORMAT",
        "This bitfield is used to show which data bytes in a 32-bit word are va"
        "lid.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ON_ALTERNATE_FIELDS",
        "If this bit is set, the eLCDIF block will assert the cur_frame_done in"
        "terrupt only on alternate fields, otherwise it will issue the interrup"
        "t on both odd and even field.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIFO_CLEAR",
        "Set this bit to clear all the data in the latency FIFO (LFIFO), TXFIFO"
        " and the RXFIFO.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_INTERLACE_FROM_SECOND_FIELD",
        "The default is to grab the odd lines first and then the even lines.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INTERLACE_FIELDS",
        "Set this bit if it is required that the eLCDIF block fetches odd lines"
        " in one field and even lines in the other field.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RECOVER_ON_UNDERFLOW",
        "Set this bit to enable the eLCDIF block to recover in the next field/f"
        "rame if there was an underflow in the current field/frame.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ",
        "This bit is set to indicate that an interrupt is requested by the eLCD"
        "IF block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BM_ERROR_IRQ_EN",
        "This bit is set to enable bus master error interrupt in the eLCDIF mas"
        "ter mode.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COMBINE_MPU_WR_STRB",
        "If this bit is not set, the write strobe will be driven on LCD_WR_RWn "
        "pin in the 8080 mode and on the LCD_RD_E pin in the 6800 mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        28, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL2.
static const field_t hw_lcdif_ctrl2[] =
{
    {
        "RSRVD0",
        "Reserved bits.",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "INITIAL_DUMMY_READ",
        "The value in this field determines the number of dummy 8/16/18/24-bit "
        "subwords that have to be read back from the LCD panel/controller.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_NUM_PACKED_SUBWORDS",
        "Indicates the number of valid 8/16/18/24-bit subwords that will be pac"
        "ked into the 32-bit word in read mode.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READ_MODE_6_BIT_INPUT",
        "Setting this bit to 1 indicates to eLCDIF that even though LCD_DATABUS"
        "_WIDTH is set to 8 bits, the input data is actually only 6 bits wide a"
        "nd exists on D5-D0.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_OUTPUT_IN_RGB_FORMAT",
        "Setting this bit will enable the eLCDIF to convert the incoming data t"
        "o the RGB format given by WORD_LENGTH bitfield.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_PACK_DIR",
        "The default value of 0 indicates data is stored in the little endian f"
        "ormat.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        11, // LSB
        11, // MSB
        false, // Readable
        false // Writable
    },
    {
        "EVEN_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " EVEN lines (line numbers 2,4,6,..).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD3",
        "Reserved bits.",
        15, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ODD_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " ODD lines (line numbers 1,3,5,..).",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD4",
        "Reserved bits.",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BURST_LEN_8",
        "By default, when the eLCDIF is in the bus master mode, it will issue A"
        "XI bursts of length 16 (except when in packed 24 bpp mode, it will iss"
        "ue bursts of length 15).",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTSTANDING_REQS",
        "This bitfield indicates the maximum number of outstanding transactions"
        " that eLCDIF should request when it is acting as a bus master.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD5",
        "Reserved bits.",
        24, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL2_SET.
static const field_t hw_lcdif_ctrl2_set[] =
{
    {
        "RSRVD0",
        "Reserved bits.",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "INITIAL_DUMMY_READ",
        "The value in this field determines the number of dummy 8/16/18/24-bit "
        "subwords that have to be read back from the LCD panel/controller.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_NUM_PACKED_SUBWORDS",
        "Indicates the number of valid 8/16/18/24-bit subwords that will be pac"
        "ked into the 32-bit word in read mode.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READ_MODE_6_BIT_INPUT",
        "Setting this bit to 1 indicates to eLCDIF that even though LCD_DATABUS"
        "_WIDTH is set to 8 bits, the input data is actually only 6 bits wide a"
        "nd exists on D5-D0.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_OUTPUT_IN_RGB_FORMAT",
        "Setting this bit will enable the eLCDIF to convert the incoming data t"
        "o the RGB format given by WORD_LENGTH bitfield.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_PACK_DIR",
        "The default value of 0 indicates data is stored in the little endian f"
        "ormat.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        11, // LSB
        11, // MSB
        false, // Readable
        false // Writable
    },
    {
        "EVEN_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " EVEN lines (line numbers 2,4,6,..).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD3",
        "Reserved bits.",
        15, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ODD_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " ODD lines (line numbers 1,3,5,..).",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD4",
        "Reserved bits.",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BURST_LEN_8",
        "By default, when the eLCDIF is in the bus master mode, it will issue A"
        "XI bursts of length 16 (except when in packed 24 bpp mode, it will iss"
        "ue bursts of length 15).",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTSTANDING_REQS",
        "This bitfield indicates the maximum number of outstanding transactions"
        " that eLCDIF should request when it is acting as a bus master.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD5",
        "Reserved bits.",
        24, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL2_CLR.
static const field_t hw_lcdif_ctrl2_clr[] =
{
    {
        "RSRVD0",
        "Reserved bits.",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "INITIAL_DUMMY_READ",
        "The value in this field determines the number of dummy 8/16/18/24-bit "
        "subwords that have to be read back from the LCD panel/controller.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_NUM_PACKED_SUBWORDS",
        "Indicates the number of valid 8/16/18/24-bit subwords that will be pac"
        "ked into the 32-bit word in read mode.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READ_MODE_6_BIT_INPUT",
        "Setting this bit to 1 indicates to eLCDIF that even though LCD_DATABUS"
        "_WIDTH is set to 8 bits, the input data is actually only 6 bits wide a"
        "nd exists on D5-D0.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_OUTPUT_IN_RGB_FORMAT",
        "Setting this bit will enable the eLCDIF to convert the incoming data t"
        "o the RGB format given by WORD_LENGTH bitfield.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_PACK_DIR",
        "The default value of 0 indicates data is stored in the little endian f"
        "ormat.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        11, // LSB
        11, // MSB
        false, // Readable
        false // Writable
    },
    {
        "EVEN_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " EVEN lines (line numbers 2,4,6,..).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD3",
        "Reserved bits.",
        15, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ODD_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " ODD lines (line numbers 1,3,5,..).",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD4",
        "Reserved bits.",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BURST_LEN_8",
        "By default, when the eLCDIF is in the bus master mode, it will issue A"
        "XI bursts of length 16 (except when in packed 24 bpp mode, it will iss"
        "ue bursts of length 15).",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTSTANDING_REQS",
        "This bitfield indicates the maximum number of outstanding transactions"
        " that eLCDIF should request when it is acting as a bus master.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD5",
        "Reserved bits.",
        24, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CTRL2_TOG.
static const field_t hw_lcdif_ctrl2_tog[] =
{
    {
        "RSRVD0",
        "Reserved bits.",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "INITIAL_DUMMY_READ",
        "The value in this field determines the number of dummy 8/16/18/24-bit "
        "subwords that have to be read back from the LCD panel/controller.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_NUM_PACKED_SUBWORDS",
        "Indicates the number of valid 8/16/18/24-bit subwords that will be pac"
        "ked into the 32-bit word in read mode.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "READ_MODE_6_BIT_INPUT",
        "Setting this bit to 1 indicates to eLCDIF that even though LCD_DATABUS"
        "_WIDTH is set to 8 bits, the input data is actually only 6 bits wide a"
        "nd exists on D5-D0.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_MODE_OUTPUT_IN_RGB_FORMAT",
        "Setting this bit will enable the eLCDIF to convert the incoming data t"
        "o the RGB format given by WORD_LENGTH bitfield.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_PACK_DIR",
        "The default value of 0 indicates data is stored in the little endian f"
        "ormat.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        11, // LSB
        11, // MSB
        false, // Readable
        false // Writable
    },
    {
        "EVEN_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " EVEN lines (line numbers 2,4,6,..).",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD3",
        "Reserved bits.",
        15, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ODD_LINE_PATTERN",
        "This field determines the order of the RGB components of each pixel in"
        " ODD lines (line numbers 1,3,5,..).",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD4",
        "Reserved bits.",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BURST_LEN_8",
        "By default, when the eLCDIF is in the bus master mode, it will issue A"
        "XI bursts of length 16 (except when in packed 24 bpp mode, it will iss"
        "ue bursts of length 15).",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTSTANDING_REQS",
        "This bitfield indicates the maximum number of outstanding transactions"
        " that eLCDIF should request when it is acting as a bus master.",
        21, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD5",
        "Reserved bits.",
        24, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_TRANSFER_COUNT.
static const field_t hw_lcdif_transfer_count[] =
{
    {
        "H_COUNT",
        "Total valid data (pixels) in each horizontal line.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "V_COUNT",
        "Number of horizontal lines per frame which contain valid data.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CUR_BUF.
static const field_t hw_lcdif_cur_buf[] =
{
    {
        "ADDR",
        "Address of the current frame being transmitted by eLCDIF.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_NEXT_BUF.
static const field_t hw_lcdif_next_buf[] =
{
    {
        "ADDR",
        "Address of the next frame that will be transmitted by eLCDIF.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_TIMING.
static const field_t hw_lcdif_timing[] =
{
    {
        "DATA_SETUP",
        "Data bus setup time in CLK_DIS_LCDIFn cycles.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_HOLD",
        "Data bus hold time in CLK_DIS_LCDIFn cycles.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_SETUP",
        "Number of CLK_DIS_LCDIFn cycles that the DCn signal is active before C"
        "En is asserted.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_HOLD",
        "Number of CLK_DIS_LCDIFn cycles that the DCn signal is active after CE"
        "n is deasserted.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL0.
static const field_t hw_lcdif_vdctrl0[] =
{
    {
        "VSYNC_PULSE_WIDTH",
        "Number of units for which VSYNC signal is active.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE_MODE",
        "When this bit is 0, the first field (VSYNC period) will end in half a "
        "horizontal line and the second field will begin with half a horizontal"
        " line.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE",
        "Setting this bit to 1 will make the total VSYNC period equal to the VS"
        "YNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i.e.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PULSE_WIDTH_UNIT",
        "Default 0 for counting VSYNC_PULSE_WIDTH in terms of CLK_DIS_LCDIFn cy"
        "cles.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PERIOD_UNIT",
        "Default 0 for counting VSYNC_PERIOD in terms of CLK_DIS_LCDIFn cycles.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        22, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ENABLE_POL",
        "Default 0 active low during valid data transfer on each horizontal lin"
        "e.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_POL",
        "Default is data launched at negative edge of DOTCLK and captured at po"
        "sitive edge.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "Default 0 active low during HSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the HSYNC period.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_POL",
        "Default 0 active low during VSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the VSYNC period.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PRESENT",
        "Setting this bit to 1 will make the hardware generate the ENABLE signa"
        "l in the DOTCLK mode, thereby making it the true RGB interface along w"
        "ith the remaining three signals VSYNC, HSYNC and DOTCLK.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_OEB",
        "0 means the VSYNC signal is an output, 1 means it is an input.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL0_SET.
static const field_t hw_lcdif_vdctrl0_set[] =
{
    {
        "VSYNC_PULSE_WIDTH",
        "Number of units for which VSYNC signal is active.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE_MODE",
        "When this bit is 0, the first field (VSYNC period) will end in half a "
        "horizontal line and the second field will begin with half a horizontal"
        " line.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE",
        "Setting this bit to 1 will make the total VSYNC period equal to the VS"
        "YNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i.e.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PULSE_WIDTH_UNIT",
        "Default 0 for counting VSYNC_PULSE_WIDTH in terms of CLK_DIS_LCDIFn cy"
        "cles.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PERIOD_UNIT",
        "Default 0 for counting VSYNC_PERIOD in terms of CLK_DIS_LCDIFn cycles.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        22, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ENABLE_POL",
        "Default 0 active low during valid data transfer on each horizontal lin"
        "e.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_POL",
        "Default is data launched at negative edge of DOTCLK and captured at po"
        "sitive edge.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "Default 0 active low during HSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the HSYNC period.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_POL",
        "Default 0 active low during VSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the VSYNC period.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PRESENT",
        "Setting this bit to 1 will make the hardware generate the ENABLE signa"
        "l in the DOTCLK mode, thereby making it the true RGB interface along w"
        "ith the remaining three signals VSYNC, HSYNC and DOTCLK.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_OEB",
        "0 means the VSYNC signal is an output, 1 means it is an input.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL0_CLR.
static const field_t hw_lcdif_vdctrl0_clr[] =
{
    {
        "VSYNC_PULSE_WIDTH",
        "Number of units for which VSYNC signal is active.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE_MODE",
        "When this bit is 0, the first field (VSYNC period) will end in half a "
        "horizontal line and the second field will begin with half a horizontal"
        " line.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE",
        "Setting this bit to 1 will make the total VSYNC period equal to the VS"
        "YNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i.e.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PULSE_WIDTH_UNIT",
        "Default 0 for counting VSYNC_PULSE_WIDTH in terms of CLK_DIS_LCDIFn cy"
        "cles.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PERIOD_UNIT",
        "Default 0 for counting VSYNC_PERIOD in terms of CLK_DIS_LCDIFn cycles.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        22, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ENABLE_POL",
        "Default 0 active low during valid data transfer on each horizontal lin"
        "e.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_POL",
        "Default is data launched at negative edge of DOTCLK and captured at po"
        "sitive edge.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "Default 0 active low during HSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the HSYNC period.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_POL",
        "Default 0 active low during VSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the VSYNC period.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PRESENT",
        "Setting this bit to 1 will make the hardware generate the ENABLE signa"
        "l in the DOTCLK mode, thereby making it the true RGB interface along w"
        "ith the remaining three signals VSYNC, HSYNC and DOTCLK.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_OEB",
        "0 means the VSYNC signal is an output, 1 means it is an input.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL0_TOG.
static const field_t hw_lcdif_vdctrl0_tog[] =
{
    {
        "VSYNC_PULSE_WIDTH",
        "Number of units for which VSYNC signal is active.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE_MODE",
        "When this bit is 0, the first field (VSYNC period) will end in half a "
        "horizontal line and the second field will begin with half a horizontal"
        " line.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HALF_LINE",
        "Setting this bit to 1 will make the total VSYNC period equal to the VS"
        "YNC_PERIOD field plus half the HORIZONTAL_PERIOD field (i.e.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PULSE_WIDTH_UNIT",
        "Default 0 for counting VSYNC_PULSE_WIDTH in terms of CLK_DIS_LCDIFn cy"
        "cles.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_PERIOD_UNIT",
        "Default 0 for counting VSYNC_PERIOD in terms of CLK_DIS_LCDIFn cycles.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        22, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ENABLE_POL",
        "Default 0 active low during valid data transfer on each horizontal lin"
        "e.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOTCLK_POL",
        "Default is data launched at negative edge of DOTCLK and captured at po"
        "sitive edge.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_POL",
        "Default 0 active low during HSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the HSYNC period.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_POL",
        "Default 0 active low during VSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the VSYNC period.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PRESENT",
        "Setting this bit to 1 will make the hardware generate the ENABLE signa"
        "l in the DOTCLK mode, thereby making it the true RGB interface along w"
        "ith the remaining three signals VSYNC, HSYNC and DOTCLK.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_OEB",
        "0 means the VSYNC signal is an output, 1 means it is an input.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL1.
static const field_t hw_lcdif_vdctrl1[] =
{
    {
        "VSYNC_PERIOD",
        "Total number of units between two positive or two negative edges of th"
        "e VSYNC signal.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL2.
static const field_t hw_lcdif_vdctrl2[] =
{
    {
        "HSYNC_PERIOD",
        "Total number of CLK_DIS_LCDIFn cycles between two positive or two nega"
        "tive edges of the HSYNC signal.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSYNC_PULSE_WIDTH",
        "Number of CLK_DIS_LCDIFn cycles for which HSYNC signal is active.",
        18, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL3.
static const field_t hw_lcdif_vdctrl3[] =
{
    {
        "VERTICAL_WAIT_CNT",
        "In the VSYNC interface mode, wait for this number of CLK_DIS_LCDIFn cy"
        "cles from the falling VSYNC edge (or rising if VSYNC_POL is 1) before "
        "starting LCD transactions and is applicable only if WAIT_FOR_VSYNC_EDG"
        "E is set.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HORIZONTAL_WAIT_CNT",
        "In the DOTCLK mode, wait for this number of clocks from falling edge ("
        "or rising if HSYNC_POL is 1) of HSYNC signal to account for horizontal"
        " back porch plus the number of DOTCLKs before the moving picture infor"
        "mation begins.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSYNC_ONLY",
        "This bit must be set to 1 in the VSYNC mode of operation, and 0 in the"
        " DOTCLK mode of operation.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_SYNC_SIGNALS",
        "When this bit is set, the eLCDIF block will internally mux HSYNC with "
        "LCD_D14, DOTCLK with LCD_D13 and ENABLE with LCD_D12, otherwise these "
        "signals will go out on separate pins.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VDCTRL4.
static const field_t hw_lcdif_vdctrl4[] =
{
    {
        "DOTCLK_H_VALID_DATA_CNT",
        "Total number of CLK_DIS_LCDIFn cycles on each horizontal line that car"
        "ry valid data in DOTCLK mode.",
        0, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYNC_SIGNALS_ON",
        "Set this field to 1 if the LCD controller requires that the VSYNC or V"
        "SYNC/HSYNC/DOTCLK control signals should be active at least one frame "
        "before the data transfers actually start and remain active at least on"
        "e frame after the data transfers end.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        19, // LSB
        28, // MSB
        false, // Readable
        false // Writable
    },
    {
        "DOTCLK_DLY_SEL",
        "This bitfield selects the amount of time by which the DOTCLK signal sh"
        "ould be delayed before coming out of the LCD_DOTCK pin.",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DVICTRL0.
static const field_t hw_lcdif_dvictrl0[] =
{
    {
        "H_BLANKING_CNT",
        "Number of blanking samples to be inserted between EAV and SAV during h"
        "orizontal blanking interval.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        12, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "H_ACTIVE_CNT",
        "Number of active video samples to be transmitted.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits, write as 0.",
        28, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DVICTRL1.
static const field_t hw_lcdif_dvictrl1[] =
{
    {
        "F2_START_LINE",
        "Vertical line number from which Field 2 begins.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F1_END_LINE",
        "Vertical line number at which Field1 ends.",
        10, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F1_START_LINE",
        "Vertical line number from which Field 1 begins.",
        20, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DVICTRL2.
static const field_t hw_lcdif_dvictrl2[] =
{
    {
        "V1_BLANK_END_LINE",
        "Vertical line number in the beginning part of Field2 where first Verti"
        "cal Blanking interval ends.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "V1_BLANK_START_LINE",
        "Vertical line number towards the end of Field1 where first Vertical Bl"
        "anking interval starts.",
        10, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "F2_END_LINE",
        "Vertical line number at which Field 2 ends.",
        20, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DVICTRL3.
static const field_t hw_lcdif_dvictrl3[] =
{
    {
        "V_LINES_CNT",
        "Total number of vertical lines per frame (generally 525 or 625)",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "V2_BLANK_END_LINE",
        "Vertical line number in the beginning part of Field1 where second Vert"
        "ical Blanking interval ends.",
        10, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "V2_BLANK_START_LINE",
        "Vertical line number towards the end of Field2 where second Vertical B"
        "lanking interval starts.",
        20, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        30, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DVICTRL4.
static const field_t hw_lcdif_dvictrl4[] =
{
    {
        "H_FILL_CNT",
        "Number of active video samples that have to be filled with the filler "
        "data in the front and back portions of the active horizontal interval.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CR_FILL_VALUE",
        "Value of CR component of filler data.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CB_FILL_VALUE",
        "Value of CB component of filler data",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "Y_FILL_VALUE",
        "Value of Y component of filler data",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_COEFF0.
static const field_t hw_lcdif_csc_coeff0[] =
{
    {
        "CSC_SUBSAMPLE_FILTER",
        "This register describes the filtering and subsampling scheme to be per"
        "formed on the chroma components in order to convert from YCbCr 4:4:4 t"
        "o YCbCr 4:2:2 space.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        2, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "C0",
        "Two's complement red multiplier coefficient for Y",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits, write as 0.",
        26, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_COEFF1.
static const field_t hw_lcdif_csc_coeff1[] =
{
    {
        "C1",
        "Two's complement green multiplier coefficient for Y",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        10, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "C2",
        "Two's complement blue multiplier coefficient for Y",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits, write as 0.",
        26, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_COEFF2.
static const field_t hw_lcdif_csc_coeff2[] =
{
    {
        "C3",
        "Two's complement red multiplier coefficient for Cb",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        10, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "C4",
        "Two's complement green multiplier coefficient for Cb",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits, write as 0.",
        26, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_COEFF3.
static const field_t hw_lcdif_csc_coeff3[] =
{
    {
        "C5",
        "Two's complement blue multiplier coefficient for Cb",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        10, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "C6",
        "Two's complement red multiplier coefficient for Cr",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits, write as 0.",
        26, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_COEFF4.
static const field_t hw_lcdif_csc_coeff4[] =
{
    {
        "C7",
        "Two's complement green multiplier coefficient for Cr",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        10, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "C8",
        "Two's complement blue multiplier coefficient for Cr",
        16, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits, write as 0.",
        26, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_OFFSET.
static const field_t hw_lcdif_csc_offset[] =
{
    {
        "Y_OFFSET",
        "Two's complement offset for the Y component",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "Reserved bits, write as 0.",
        9, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CBCR_OFFSET",
        "Two's complement offset for the Cb and Cr components",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits, write as 0.",
        25, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CSC_LIMIT.
static const field_t hw_lcdif_csc_limit[] =
{
    {
        "Y_MAX",
        "Upper limit of Y after RGB to 4:2:2 YCbCr conversion",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "Y_MIN",
        "Lower limit of Y after RGB to 4:2:2 YCbCr conversion",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CBCR_MAX",
        "Upper limit of Cb and Cr after RGB to 4:2:2 YCbCr conversion",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CBCR_MIN",
        "Lower limit of Cb and Cr after RGB to 4:2:2 YCbCr conversion",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DATA.
static const field_t hw_lcdif_data[] =
{
    {
        "DATA_ZERO",
        "Byte 0 (least significant byte) of data written to eLCDIF.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_ONE",
        "Byte 1 of data written to eLCDIF.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_TWO",
        "Byte 2 of data written to eLCDIF.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_THREE",
        "Byte 3 (most significant byte) of data written to LCDIF.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_BM_ERROR_STAT.
static const field_t hw_lcdif_bm_error_stat[] =
{
    {
        "ADDR",
        "Virtual address at which bus master error occurred.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_CRC_STAT.
static const field_t hw_lcdif_crc_stat[] =
{
    {
        "CRC_VALUE",
        "Calculated CRC value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_STAT.
static const field_t hw_lcdif_stat[] =
{
    {
        "LFIFO_COUNT",
        "Read only view of the current count in Latency buffer (LFIFO).",
        0, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSRVD0",
        "Reserved bits.",
        9, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    {
        "DVI_CURRENT_FIELD",
        "Read only view of the current field being transmitted.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUSY",
        "Read only view of the input busy signal from the external LCD controll"
        "er.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXFIFO_EMPTY",
        "Read only view of the signal that indicates that LCD write dapatath FI"
        "FO is empty, will be generally used in the read mode of the LCD interf"
        "ace.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXFIFO_FULL",
        "Read only view of the signal that indicates that LCD write datapath FI"
        "FO is full, will be generally used in the write mode of the LCD interf"
        "ace.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LFIFO_EMPTY",
        "Read only view of the signal that indicates that LCD read dapatath FIF"
        "O is empty, will be generally used in the read mode of the LCD interfa"
        "ce.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LFIFO_FULL",
        "Read only view of the signal that indicates that LCD read datapath FIF"
        "O is full, will be generally used in the write mode of the LCD interfa"
        "ce.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRESENT",
        "0: eLCDIF not present on this product 1: eLCDIF is present.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_VERSION.
static const field_t hw_lcdif_version[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DEBUG0.
static const field_t hw_lcdif_debug0[] =
{
    {
        "MST_WORDS",
        "Read only view of the current bursts issued by the AXI bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST_OUTSTANDING_REQS",
        "Read only view of the current outstanding requests issued by the AXI b"
        "us master.",
        4, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST_AVALID",
        "Read only view of the mst_avalid signal issued by the AXI bus master.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CUR_REQ_STATE",
        "Read only view of the request state machine.",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PXP_B1_DONE",
        "Buffer1 done signal issued by eLCDIF.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PXP_LCDIF_B1_READY",
        "Buffer1 ready signal issued by ePXP.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PXP_B0_DONE",
        "Buffer0 done signal issued by eLCDIF.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PXP_LCDIF_B0_READY",
        "Buffer0 ready signal issued by ePXP.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CUR_STATE",
        "Read only view of the current state machine state in the current mode "
        "of operation.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EMPTY_WORD",
        "Indicates that the current word is empty.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CUR_FRAME_TX",
        "This bit is 1 for the time the current frame is being transmitted in t"
        "he VSYNC mode.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VSYNC",
        "Read only view of VSYNC signal.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HSYNC",
        "Read only view of HSYNC signal.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENABLE",
        "Read only view of ENABLE signal.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYNC_SIGNALS_ON_REG",
        "Read only view of internal sync_signals_on_reg signal.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WAIT_FOR_VSYNC_EDGE_OUT",
        "Read only view of WAIT_FOR_VSYNC_EDGE bit in the VSYNC mode after it c"
        "omes out of the TXFIFO.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STREAMING_END_DETECTED",
        "Read only view of the DOTCLK_MODE or DVI_MODE bit going from 1 to 0.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DEBUG1.
static const field_t hw_lcdif_debug1[] =
{
    {
        "V_DATA_COUNT",
        "Read only view of the current state of the vertical data counter.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "H_DATA_COUNT",
        "Read only view of the current state of the horizontal data counter.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DEBUG2.
static const field_t hw_lcdif_debug2[] =
{
    {
        "MST_ADDRESS",
        "Read only view of the current address issued by the AXI bus master.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_THRES.
static const field_t hw_lcdif_thres[] =
{
    {
        "PANIC",
        "",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD1",
        "Reserved bits.",
        9, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FASTCLOCK",
        "This value should be set to a value of pixels, from 0 to 511.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD2",
        "Reserved bits.",
        25, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_AS_CTRL.
static const field_t hw_lcdif_as_ctrl[] =
{
    {
        "AS_ENABLE",
        "When this bit is set by software, the LCDIF will start fetching AS buf"
        "fer data in bus master mode and combine it with another buffer.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA_CTRL",
        "Determines how the alpha value is constructed for this alpha surface.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_COLORKEY",
        "Indicates that colorkey functionality is enabled for this alpha surfac"
        "e.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FORMAT",
        "Indicates the input buffer format for AS.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA",
        "Alpha modifier used when the ALPHA_MULTIPLY or ALPHA_OVERRIDE values a"
        "re programmed in REG_AS_CTRL[ALPHA_CTRL].",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROP",
        "Indicates a raster operation to perform when enabled.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA_INVERT",
        "Setting this bit to logic 0 will not alter the alpha value.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INPUT_DATA_SWIZZLE",
        "This field specifies how to swap the bytes either in the HW_LCDIF_DATA"
        " register or those fetched by the AXI master part of LCDIF.",
        21, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS_DISABLE",
        "When this bit is set by software, the LCDIF will disable PS buffer dat"
        "a.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RVDS1",
        "Reserved, always set to zero.",
        24, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSI_SYNC_ON_IRQ",
        "this bit is set by software to decide which vsync generate mode.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_SYNC_ON_IRQ_EN",
        "This bit is set to enable an interrupt when LCDIF lock with CSI vsync "
        "input.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_VSYNC_MODE",
        "this bit is set by software to decide which vsync generate mode.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_VSYNC_POL",
        "Default 0 active low during VSYNC_PULSE_WIDTH time and will be high du"
        "ring the rest of the VSYNC period.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSI_VSYNC_ENABLE",
        "When this bit is set by software, the LCDIF work as sync mode with CSI"
        " input.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_AS_BUF.
static const field_t hw_lcdif_as_buf[] =
{
    {
        "ADDR",
        "Address pointer for the alpha surface 0 buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_AS_NEXT_BUF.
static const field_t hw_lcdif_as_next_buf[] =
{
    {
        "ADDR",
        "Address of the next frame that will be transmitted by eLCDIF.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_AS_CLRKEYLOW.
static const field_t hw_lcdif_as_clrkeylow[] =
{
    {
        "PIXEL",
        "Low range of RGB color key applied to AS buffer",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_AS_CLRKEYHIGH.
static const field_t hw_lcdif_as_clrkeyhigh[] =
{
    {
        "PIXEL",
        "High range of RGB color key applied to AS buffer",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_SYNC_DELAY.
static const field_t hw_lcdif_sync_delay[] =
{
    {
        "H_COUNT_DELAY",
        "LCDIF VSYNC delayed counter for CSI_VSYNC.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "V_COUNT_DELAY",
        "LCDIF VSYNC delayed counter for CSI_VSYNC.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DEBUG3.
static const field_t hw_lcdif_debug3[] =
{
    {
        "MST_WORDS",
        "Read only view of the current bursts issued by the AXI bus master.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST_OUTSTANDING_REQS",
        "Read only view of the current outstanding requests issued by the AXI b"
        "us master",
        4, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST_AVALID",
        "Read only view of the mst_avalid signal issued by the AXI bus master",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CUR_REQ_STATE",
        "Read only view of the request state machine",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD0",
        "Reserved bits, write as 0.",
        12, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DEBUG4.
static const field_t hw_lcdif_debug4[] =
{
    {
        "V_DATA_COUNT",
        "Read only view of the current AS state of the vertical data counter.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "H_DATA_COUNT",
        "Read only view of the current AS state of the horizontal data counter.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register LCDIF_DEBUG5.
static const field_t hw_lcdif_debug5[] =
{
    {
        "MST_ADDRESS",
        "Read only view of the AS channel address issued by the AXI bus master.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a LCDIF module.
static const reg_t hw_lcdif[] =
{
    {
        "RL",
        "The LCD Interface Control Register provides overall control of the eLC"
        "DIF block.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        24, // Number of bitfields
        hw_lcdif_rl
    },
    {
        "RL_SET",
        "The LCD Interface Control Register provides overall control of the eLC"
        "DIF block.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        24, // Number of bitfields
        hw_lcdif_rl_set
    },
    {
        "RL_CLR",
        "The LCD Interface Control Register provides overall control of the eLC"
        "DIF block.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        24, // Number of bitfields
        hw_lcdif_rl_clr
    },
    {
        "RL_TOG",
        "The LCD Interface Control Register provides overall control of the eLC"
        "DIF block.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        24, // Number of bitfields
        hw_lcdif_rl_tog
    },
    {
        "CTRL1",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        22, // Number of bitfields
        hw_lcdif_ctrl1
    },
    {
        "CTRL1_SET",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        22, // Number of bitfields
        hw_lcdif_ctrl1_set
    },
    {
        "CTRL1_CLR",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        22, // Number of bitfields
        hw_lcdif_ctrl1_clr
    },
    {
        "CTRL1_TOG",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        22, // Number of bitfields
        hw_lcdif_ctrl1_tog
    },
    {
        "CTRL2",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_lcdif_ctrl2
    },
    {
        "CTRL2_SET",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_lcdif_ctrl2_set
    },
    {
        "CTRL2_CLR",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_lcdif_ctrl2_clr
    },
    {
        "CTRL2_TOG",
        "The eLCDIF Control Register provides overall control of the eLCDIF blo"
        "ck.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_lcdif_ctrl2_tog
    },
    {
        "TRANSFER_COUNT",
        "This register tells the eLCDIF how much data will be sent for this fra"
        "me, or transaction.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_transfer_count
    },
    {
        "CUR_BUF",
        "This register indicates the address of the current frame being transmi"
        "tted by eLCDIF.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_cur_buf
    },
    {
        "NEXT_BUF",
        "This register indicates the address of next frame that will be transmi"
        "tted by eLCDIF.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_next_buf
    },
    {
        "TIMING",
        "The LCD interface timing register controls the various setup and hold "
        "times enforced by the LCD interface in the 6800/8080 MPU and VSYNC mod"
        "es of operation.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_timing
    },
    {
        "VDCTRL0",
        "This register is used to control the VSYNC and DOTCLK modes of the LCD"
        "IF so as to work with different types of LCDs like moving picture disp"
        "lays and delta pixel displays.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_lcdif_vdctrl0
    },
    {
        "VDCTRL0_SET",
        "This register is used to control the VSYNC and DOTCLK modes of the LCD"
        "IF so as to work with different types of LCDs like moving picture disp"
        "lays and delta pixel displays.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_lcdif_vdctrl0_set
    },
    {
        "VDCTRL0_CLR",
        "This register is used to control the VSYNC and DOTCLK modes of the LCD"
        "IF so as to work with different types of LCDs like moving picture disp"
        "lays and delta pixel displays.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_lcdif_vdctrl0_clr
    },
    {
        "VDCTRL0_TOG",
        "This register is used to control the VSYNC and DOTCLK modes of the LCD"
        "IF so as to work with different types of LCDs like moving picture disp"
        "lays and delta pixel displays.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_lcdif_vdctrl0_tog
    },
    {
        "VDCTRL1",
        "This register is used to control the VSYNC signal in the VSYNC and DOT"
        "CLK modes of the block.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_vdctrl1
    },
    {
        "VDCTRL2",
        "This register is used to control the HSYNC signal in the DOTCLK mode o"
        "f the block.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_vdctrl2
    },
    {
        "VDCTRL3",
        "This register is used to determine the vertical and horizontal wait co"
        "unts.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_lcdif_vdctrl3
    },
    {
        "VDCTRL4",
        "This register is used to control the DOTCLK mode of the block.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_vdctrl4
    },
    {
        "DVICTRL0",
        "The Digital Video interface Control0 register provides the overall con"
        "trol of the Digital Video interface.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_dvictrl0
    },
    {
        "DVICTRL1",
        "The Digital Video interface Control1 register provides the overall con"
        "trol of the Digital Video interface.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_dvictrl1
    },
    {
        "DVICTRL2",
        "The Digital Video interface Control2 register provides the overall con"
        "trol of the Digital Video interface.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_dvictrl2
    },
    {
        "DVICTRL3",
        "The Digital Video interface Control3 register provides the overall con"
        "trol of the Digital Video interface.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_dvictrl3
    },
    {
        "DVICTRL4",
        "The Digital Video interface Control4 register provides the overall con"
        "trol of the Digital Video interface.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_dvictrl4
    },
    {
        "CSC_COEFF0",
        "LCDIF_CSC_COEFF0 register provides overall control over color space co"
        "nversion from RGB to 4:2:2 YCbCr.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_csc_coeff0
    },
    {
        "CSC_COEFF1",
        "LCDIF_CSC_COEFF1 register provides overall control over color space co"
        "nversion from RGB to 4:2:2 YCbCr.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_csc_coeff1
    },
    {
        "CSC_COEFF2",
        "LCDIF_CSC_COEFF2 register provides overall control over color space co"
        "nversion from RGB to 4:2:2 YCbCr.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_csc_coeff2
    },
    {
        "CSC_COEFF3",
        "LCDIF_CSC_COEFF3 register provides overall control over color space co"
        "nversion from RGB to 4:2:2 YCbCr.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_csc_coeff3
    },
    {
        "CSC_COEFF4",
        "LCDIF_CSC_COEFF4 register provides overall control over color space co"
        "nversion from RGB to 4:2:2 YCbCr.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_csc_coeff4
    },
    {
        "CSC_OFFSET",
        "LCDIF_CSC_ register provides overall control over color space conversi"
        "on from RGB to 4:2:2 YCbCr.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_csc_offset
    },
    {
        "CSC_LIMIT",
        "LCDIF_CSC_CTRL0 register provides overall control over color space con"
        "version from RGB to 4:2:2 YCbCr.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_csc_limit
    },
    {
        "DATA",
        "This register is used to transfer data using the PIO interface mode of"
        " operation.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_data
    },
    {
        "BM_ERROR_STAT",
        "This register reflects the virtual address at which the AXI master rec"
        "eived an error response from the slave.",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_bm_error_stat
    },
    {
        "CRC_STAT",
        "This register reflects the CRC value of each frame sent out by eLCDIF.",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_crc_stat
    },
    {
        "STAT",
        "The LCD interface status register can be used to check the current sta"
        "tus of the eLCDIF block.",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        false, // Writable
        9, // Number of bitfields
        hw_lcdif_stat
    },
    {
        "VERSION",
        "The LCD interface version register can be used to read the version of "
        "the eLCDIF IP being used in this SoC.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_lcdif_version
    },
    {
        "DEBUG0",
        "The LCD interface debug0 register provides a diagnostic view of the st"
        "ate machine and other useful internal signals.",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        false, // Writable
        17, // Number of bitfields
        hw_lcdif_debug0
    },
    {
        "DEBUG1",
        "The LCD interface debug1 register provides a diagnostic view of the st"
        "ate machine and other useful internal signals.",
        4, // Width in bytes
        0x000001e0, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lcdif_debug1
    },
    {
        "DEBUG2",
        "The LCD interface debug2 register provides a diagnostic view of the st"
        "ate machine and other useful internal signals.",
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_lcdif_debug2
    },
    {
        "THRES",
        "This register is used to activate control signals when the number of p"
        "ixels reaches the programmed threshold.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_lcdif_thres
    },
    {
        "AS_CTRL",
        "The Alpha Surface Parameter register provides additional controls for "
        "AS.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_lcdif_as_ctrl
    },
    {
        "AS_BUF",
        "This register is used to indicate the base address of the AS buffer.",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_as_buf
    },
    {
        "AS_NEXT_BUF",
        "When the LCDIF is behaving as a master, this address points to the add"
        "ress of the next frame of data that will be sent out via the LCDIF.",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_lcdif_as_next_buf
    },
    {
        "AS_CLRKEYLOW",
        "If a pixel in the current overlay image with a color that falls in the"
        " range from the ASCOLORKEYLOW to ASCOLORKEYHIGH range, it will use the"
        " PS pixel value for that location.",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_as_clrkeylow
    },
    {
        "AS_CLRKEYHIGH",
        "If a pixel in the current overlay image with a color that falls in the"
        " range from the ASCOLORKEYLOW to ASCOLORKEYHIGH range, it will use the"
        " PS pixel value for that location.",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_as_clrkeyhigh
    },
    {
        "SYNC_DELAY",
        "The LCDIF DOTCLK mode VSYNC will delay from CSI_VSYNC as ( V_COUNT_DEL"
        "AY * HSYNC_PERIOD + H_COUNT_DELAY) PIXCLK cycles",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_lcdif_sync_delay
    },
    {
        "DEBUG3",
        "The LCD interface debug register is for diagnostic use only.",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_lcdif_debug3
    },
    {
        "DEBUG4",
        "The LCD interface debug register is for diagnostic use only.",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_lcdif_debug4
    },
    {
        "DEBUG5",
        "The LCD interface debug register is for diagnostic use only.",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_lcdif_debug5
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark MMDC
#endif

// Bitfields in register MMDC_MDCTL.
static const field_t hw_mmdc_mdctl[] =
{
    {
        "DSIZ",
        "DDR data bus size.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BL",
        "Burst Length.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COL",
        "Column Address Width.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROW",
        "Row Address Width.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDE_1",
        "MMDC Enable CS1.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDE_0",
        "MMDC Enable CS0.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDPDC.
static const field_t hw_mmdc_mdpdc[] =
{
    {
        "TCKSRE",
        "Valid clock cycles after self-refresh entry.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCKSRX",
        "Valid clock cycles before self-refresh exit.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOTH_CS_PD",
        "Parallel power down entry to both chip selects.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOW_PD",
        "Slow/fast power down.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWDT_0",
        "Power Down Timer - Chip Select 0.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWDT_1",
        "Power Down Timer - Chip Select 1.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCKE",
        "CKE minimum pulse width.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRCT_0",
        "Precharge Timer - Chip Select 0.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRCT_1",
        "Precharge Timer - Chip Select 1.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDOTC.
static const field_t hw_mmdc_mdotc[] =
{
    {
        "TODT_IDLE_OFF",
        "ODT turn off latency.",
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TODTLON",
        "ODT turn on latency.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAXPD",
        "Asynchronous ODT to power down exit delay.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TANPD",
        "Asynchronous ODT to power down entry delay.",
        20, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAONPD",
        "Asynchronous RTT turn-on delay (power down with DLL frozen).",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TAOFPD",
        "Asynchronous RTT turn-off delay (power down with DLL frozen).",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG0.
static const field_t hw_mmdc_mdcfg0[] =
{
    {
        "TCL",
        "CAS Read Latency.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TFAW",
        "Four Active Window (all banks).",
        4, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPDLL",
        "Exit precharge power down with DLL frozen to commands requiring DLL.",
        9, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXP",
        "Exit power down with DLL-on to any valid command.",
        13, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "Exit self refresh to non READ command.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRFC",
        "Refresh command to Active or Refresh command time.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG1.
static const field_t hw_mmdc_mdcfg1[] =
{
    {
        "TCWL",
        "CAS Write Latency.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TMRD",
        "Mode Register Set command cycle (all banks).",
        5, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWR",
        "WRITE recovery time (same bank).",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRPA",
        "Precharge-all command period.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRAS",
        "Active to Precharge command period (same bank).",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRC",
        "Active to Active or Refresh command period (same bank).",
        21, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRP",
        "Precharge command period (same bank).",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRCD",
        "Active command to internal read or write delay time (same bank).",
        29, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG2.
static const field_t hw_mmdc_mdcfg2[] =
{
    {
        "TRRD",
        "Active to Active command period (all banks).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TWTR",
        "Internal WRITE to READ command delay (same bank).",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRTP",
        "Internal READ command to Precharge command delay (same bank).",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDLLK",
        "DLL locking time.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDMISC.
static const field_t hw_mmdc_mdmisc[] =
{
    {
        "RST",
        "Software Reset.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_TYPE",
        "DDR TYPE.",
        3, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_4_BANK",
        "Number of banks per DDR device.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RALAT",
        "Read Additional Latency.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MIF3_MODE",
        "Command prediction working mode.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPDDR2_S2",
        "LPDDR2 S2 device type indication.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BI_ON",
        "Bank Interleaving On.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WALAT",
        "Write Additional latency.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LHD",
        "Latency hiding disable.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDR_MIRROR",
        "Address mirroring.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CALIB_PER_CS",
        "Number of chip-select for calibration process.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CK1_GATING",
        "Gating the secondary DDR clock.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CS1_RDY",
        "External status device on CS1.",
        30, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CS0_RDY",
        "External status device on CS0.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDSCR.
static const field_t hw_mmdc_mdscr[] =
{
    {
        "CMD_BA",
        "Bank Address.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_CS",
        "Chip Select.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD",
        "Command.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_EN",
        "DQS pads direction.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MRR_READ_DATA_VALID",
        "MRR read data valid.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CON_ACK",
        "Configuration acknowledge.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CON_REQ",
        "Configuration request.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_ADDR_LSB_MR_ADDR",
        "Command/Address LSB.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMD_ADDR_MSB_MR_OP",
        "Command/Address MSB.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDREF.
static const field_t hw_mmdc_mdref[] =
{
    {
        "START_REF",
        "Manual start of refresh cycle.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFR",
        "Refresh Rate.",
        11, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_SEL",
        "Refresh Selector.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REF_CNT",
        "Refresh Counter at DDR clock period If REF_SEL equals '2' a refresh cy"
        "cle will begin every amount of DDR cycles configured in this field.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDRWD.
static const field_t hw_mmdc_mdrwd[] =
{
    {
        "RTR_DIFF",
        "Read to read delay for different chip-select.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTW_DIFF",
        "Read to write delay for different chip-select.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WTW_DIFF",
        "Write to write delay for different chip-select.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WTR_DIFF",
        "Write to read delay for different chip-select.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTW_SAME",
        "Read to write delay for the same chip-select.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TDAI",
        "Device auto initialization period.",
        16, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDOR.
static const field_t hw_mmdc_mdor[] =
{
    {
        "RST_TO_CKE",
        "DDR3: Time from SDE enable to CKE rise.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDE_TO_RST",
        "DDR3: Time from SDE enable until DDR reset# is high.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPR",
        "DDR3: CKE HIGH to a valid command.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDMRR.
static const field_t hw_mmdc_mdmrr[] =
{
    {
        "MRR_READ_DATA0",
        "MRR DATA that arrived on DQ[7:0]",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MRR_READ_DATA1",
        "MRR DATA that arrived on DQ[15:8]",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDCFG3LP.
static const field_t hw_mmdc_mdcfg3lp[] =
{
    {
        "TRPAB_LP",
        "Precharge (all banks) command period.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRPPB_LP",
        "Precharge (per bank) command period (same bank).",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRCD_LP",
        "Active command to internal read or write delay time (same bank).",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_LP",
        "Active to Active or Refresh command period (same bank).",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDMR4.
static const field_t hw_mmdc_mdmr4[] =
{
    {
        "UPDATE_DE_REQ",
        "Update Derated Values Request.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPDATE_DE_ACK",
        "Update Derated Values Acknowledge.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRCD_DE",
        "tRCD derating value.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRC_DE",
        "tRC derating value.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRAS_DE",
        "tRAS derating value.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRP_DE",
        "tRP derating value.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRRD_DE",
        "tRRD derating value.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MDASP.
static const field_t hw_mmdc_mdasp[] =
{
    {
        "CS0_END",
        "CS0_END.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAARCR.
static const field_t hw_mmdc_maarcr[] =
{
    {
        "ARCR_GUARD",
        "ARCR Guard.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_DYN_MAX",
        "ARCR Dynamic Maximum.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_DYN_JMP",
        "ARCR Dynamic Jump.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_ACC_HIT",
        "ARCR Access Hit Rate.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_PAG_HIT",
        "ARCR Page Hit Rate.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_RCH_EN",
        "This bit defines whether Real time channel is activated and bypassed a"
        "ll other pending accesses, So accesses with QoS=='F' will be granted t"
        "he highest priority in the optimization/reordering mechanism Default v"
        "alue is 0x1 - encoding 1 (Enabled)",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_EXC_ERR_EN",
        "This bit defines whether exclusive read/write access violation of AXI "
        "6.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_SEC_ERR_EN",
        "This bit defines whether security read/write access violation result i"
        "n SLV Error response or in OKAY response Default value is 0x1 - encodi"
        "ng 1(response is SLV Error, rresp/bresp=2'b10)",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ARCR_SEC_ERR_LOCK",
        "Once set, this bit locks ARCR_SEC_ERR_EN and prevents from its updatin"
        "g.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAPSR.
static const field_t hw_mmdc_mapsr[] =
{
    {
        "PSD",
        "Automatic Power Saving Disable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSS",
        "Power Saving Status.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RIS",
        "Read Idle Status.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WIS",
        "Write Idle Status.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PST",
        "Automatic Power saving timer.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPMD",
        "General LPMD request.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DVFS",
        "General DVFS request.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPACK",
        "General low-power acknowledge.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DVACK",
        "General DVFS acknowledge.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAEXIDR0.
static const field_t hw_mmdc_maexidr0[] =
{
    {
        "EXC_ID_MONITOR0",
        "This field defines ID for Exclusive monitor#0.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXC_ID_MONITOR1",
        "This field defines ID for Exclusive monitor#1.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAEXIDR1.
static const field_t hw_mmdc_maexidr1[] =
{
    {
        "EXC_ID_MONITOR2",
        "This field defines ID for Exclusive monitor#2.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXC_ID_MONITOR3",
        "This field defines ID for Exclusive monitor#3.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPCR0.
static const field_t hw_mmdc_madpcr0[] =
{
    {
        "DBG_EN",
        "Debug and Profiling Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBG_RST",
        "Debug and Profiling Reset.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRF_FRZ",
        "Profiling freeze.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CYC_OVF",
        "Total Profiling Cycles Count Overflow.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBS_EN",
        "Step By Step debug Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SBS",
        "Step By Step trigger.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPCR1.
static const field_t hw_mmdc_madpcr1[] =
{
    {
        "PRF_AXI_ID",
        "Profiling AXI ID.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRF_AXI_ID_MASK",
        "Profiling AXI ID Mask.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR0.
static const field_t hw_mmdc_madpsr0[] =
{
    {
        "CYC_COUNT",
        "Total Profiling cycle Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR1.
static const field_t hw_mmdc_madpsr1[] =
{
    {
        "BUSY_COUNT",
        "Profiling Busy Cycles Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR2.
static const field_t hw_mmdc_madpsr2[] =
{
    {
        "RD_ACC_COUNT",
        "Profiling Read Access Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR3.
static const field_t hw_mmdc_madpsr3[] =
{
    {
        "WR_ACC_COUNT",
        "Profiling Write Access Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR4.
static const field_t hw_mmdc_madpsr4[] =
{
    {
        "RD_BYTES_COUNT",
        "Profiling Read Bytes Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MADPSR5.
static const field_t hw_mmdc_madpsr5[] =
{
    {
        "WR_BYTES_COUNT",
        "Profiling Write Bytes Count.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MASBS0.
static const field_t hw_mmdc_masbs0[] =
{
    {
        "SBS_ADDR",
        "Step By Step Address.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MASBS1.
static const field_t hw_mmdc_masbs1[] =
{
    {
        "SBS_VLD",
        "Step By Step Valid.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_TYPE",
        "Step By Step Request Type.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_LOCK",
        "Step By Step Lock.",
        2, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_PROT",
        "Step By Step Protection.",
        4, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_SIZE",
        "Step By Step Size.",
        7, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_BURST",
        "Step By Step Burst.",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_BUFF",
        "Step By Step Buffered.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_LEN",
        "Step By Step Length.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SBS_AXI_ID",
        "Step By Step AXI ID.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MAGENP.
static const field_t hw_mmdc_magenp[] =
{
    {
        "GP31_GP0",
        "General purpose read/write bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPZQHWCTRL.
static const field_t hw_mmdc_mpzqhwctrl[] =
{
    {
        "ZQ_MODE",
        "ZQ calibration mode:",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_HW_PER",
        "ZQ periodic calibration time.",
        2, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_HW_PU_RES",
        "ZQ automatic calibration pull-up result.",
        6, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZQ_HW_PD_RES",
        "ZQ HW calibration pull-down result.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZQ_HW_FOR",
        "Force ZQ automatic calibration process with the i.MX ZQ calibration pa"
        "d.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZQ_INIT",
        "Device ZQ long/init time.",
        17, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZQ_OPER",
        "Device ZQ long/oper time.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TZQ_CS",
        "Device ZQ short time.",
        23, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_EARLY_COMPARATOR_EN_TIMER",
        "ZQ early comparator enable timer.",
        27, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPZQSWCTRL.
static const field_t hw_mmdc_mpzqswctrl[] =
{
    {
        "ZQ_SW_FOR",
        "ZQ SW calibration enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_SW_RES",
        "ZQ software calibration result.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ZQ_SW_PU_VAL",
        "ZQ software pull-up resistence.",
        2, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_SW_PD_VAL",
        "ZQ software pull-down resistence.",
        7, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_SW_PD",
        "ZQ software PU/PD calibration.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USE_ZQ_SW_VAL",
        "Use SW ZQ configured value for I/O pads resistor controls.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_CMP_OUT_SMP",
        "Defines the amount of cycles between driving the ZQ signals to the ZQ "
        "pad and till sampling the comparator enable output while performing ZQ"
        " calibration process with the i.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLGCR.
static const field_t hw_mmdc_mpwlgcr[] =
{
    {
        "HW_WL_EN",
        "Write-Leveling HW (automatic) enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_WL_EN",
        "Write-Leveling SW enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_WL_CNT_EN",
        "SW write-leveling count down enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_SW_RES0",
        "Byte0 write-leveling software result.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_SW_RES1",
        "Byte1 write-leveling software result.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_HW_ERR0",
        "Byte0 write-leveling HW calibration error.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_HW_ERR1",
        "Byte1 write-leveling HW calibration error.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLDECTRL0.
static const field_t hw_mmdc_mpwldectrl0[] =
{
    {
        "WL_DL_ABS_OFFSET0",
        "Absolute write-leveling delay offset for Byte 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_HC_DEL0",
        "Write leveling half cycle delay for Byte 0.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_CYC_DEL0",
        "Write leveling cycle delay for Byte 0.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_DL_ABS_OFFSET1",
        "Absolute write-leveling delay offset for Byte 1.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_HC_DEL1",
        "Write leveling half cycle delay for Byte 1.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WL_CYC_DEL1",
        "Write leveling cycle delay for Byte 1.",
        25, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLDLST.
static const field_t hw_mmdc_mpwldlst[] =
{
    {
        "WL_DL_UNIT_NUM0",
        "This field reflects the number of delay units that are actually used b"
        "y write leveling delay-line 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WL_DL_UNIT_NUM1",
        "This field reflects the number of delay units that are actually used b"
        "y write leveling delay-line 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPODTCTRL.
static const field_t hw_mmdc_mpodtctrl[] =
{
    {
        "ODT_WR_PAS_EN",
        "Inactive write CS ODT enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT_WR_ACT_EN",
        "Active write CS ODT enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT_RD_PAS_EN",
        "Inactive read CS ODT enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT_RD_ACT_EN",
        "Active read CS ODT enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT0_INT_RES",
        "On chip ODT byte0 resistor - This field determines the Rtt_Nom of the "
        "on chip ODT byte0 resistor during read accesses.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ODT1_INT_RES",
        "On chip ODT byte1 resistor - This field determines the Rtt_Nom of the "
        "on chip ODT byte1 resistor during read accesses.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY0DL.
static const field_t hw_mmdc_mprddqby0dl[] =
{
    {
        "RD_DQ0_DEL",
        "Read dqs0 to dq0 delay fine-tuning.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ1_DEL",
        "Read dqs0 to dq1 delay fine-tuning.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ2_DEL",
        "Read dqs0 to dq2 delay fine-tuning.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ3_DEL",
        "Read dqs0 to dq3 delay fine-tuning.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ4_DEL",
        "Read dqs0 to dq4 delay fine-tuning.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ5_DEL",
        "Read dqs0 to dq5 delay fine-tuning.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ6_DEL",
        "Read dqs0 to dq6 delay fine-tuning.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ7_DEL",
        "Read dqs0 to dq7 delay fine-tuning.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDQBY1DL.
static const field_t hw_mmdc_mprddqby1dl[] =
{
    {
        "RD_DQ8_DEL",
        "Read dqs1 to dq8 delay fine-tuning.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ9_DEL",
        "Read dqs1 to dq9 delay fine-tuning.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ10_DEL",
        "Read dqs1 to dq10 delay fine-tuning.",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ11_DEL",
        "Read dqs1 to dq11 delay fine-tuning.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ12_DEL",
        "Read dqs1 to dq12 delay fine-tuning.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ13_DEL",
        "Read dqs1 to dq13 delay fine-tuning.",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ14_DEL",
        "Read dqs1 to dq14 delay fine-tuning.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQ15_DEL",
        "Read dqs1 to dq15 delay fine-tuning.",
        28, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDQBY0DL.
static const field_t hw_mmdc_mpwrdqby0dl[] =
{
    {
        "WR_DQ0_DEL",
        "Write dq0 delay fine-tuning.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ1_DEL",
        "Write dq1 delay fine-tuning.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ2_DEL",
        "Write dq2 delay fine-tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ3_DEL",
        "Write dq3 delay fine-tuning.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ4_DEL",
        "Write dq4 delay fine-tuning.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ5_DEL",
        "Write dq5 delay fine-tuning.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ6_DEL",
        "Write dq6 delay fine-tuning.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ7_DEL",
        "Write dq7 delay fine-tuning.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DM0_DEL",
        "Write dm0 delay fine-tuning.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDQBY1DL.
static const field_t hw_mmdc_mpwrdqby1dl[] =
{
    {
        "WR_DQ8_DEL",
        "Write dq8 delay fine-tuning.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ9_DEL",
        "Write dq9 delay fine-tuning.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ10_DEL",
        "Write dq10 delay fine-tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ11_DEL",
        "Write dq11 delay fine-tuning.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ12_DEL",
        "Write dq12 delay fine-tuning.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ13_DEL",
        "Write dq13 delay fine-tuning.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ14_DEL",
        "Write dq14 delay fine-tuning.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQ15_DEL",
        "Write dq15 delay fine-tuning.",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DM1_DEL",
        "Write dm1 delay fine-tuning.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGCTRL0.
static const field_t hw_mmdc_mpdgctrl0[] =
{
    {
        "DG_DL_ABS_OFFSET0",
        "Absolute read DQS gating delay offset for Byte0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL0",
        "Read DQS gating half cycles delay for Byte0 .",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_DG_ERR",
        "HW DQS gating error.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_ABS_OFFSET1",
        "Absolute read DQS gating delay offset for Byte1.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_EXT_UP",
        "DG extend upper boundary.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_HC_DEL1",
        "Read DQS gating half cycles delay for Byte1 .",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_DG_EN",
        "Enable automatic read DQS gating calibration.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_DIS",
        "Read DQS gating disable.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DG_CMP_CYC",
        "Read DQS gating sample cycle.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST_RD_FIFO",
        "Reset Read Data FIFO and associated pointers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGDLST0.
static const field_t hw_mmdc_mpdgdlst0[] =
{
    {
        "DG_DL_UNIT_NUM0",
        "This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DG_DL_UNIT_NUM1",
        "This field reflects the number of delay units that are actually used b"
        "y read DQS gating delay-line 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLCTL.
static const field_t hw_mmdc_mprddlctl[] =
{
    {
        "RD_DL_ABS_OFFSET0",
        "Absolute read delay offset for Byte0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DL_ABS_OFFSET1",
        "Absolute read delay offset for Byte1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLST.
static const field_t hw_mmdc_mprddlst[] =
{
    {
        "RD_DL_UNIT_NUM0",
        "This field reflects the number of delay units that are actually used b"
        "y read delay-line 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RD_DL_UNIT_NUM1",
        "This field reflects the number of delay units that are actually used b"
        "y read delay-line 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLCTL.
static const field_t hw_mmdc_mpwrdlctl[] =
{
    {
        "WR_DL_ABS_OFFSET0",
        "Absolute write delay offset for Byte0.",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DL_ABS_OFFSET1",
        "Absolute write delay offset for Byte1.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLST.
static const field_t hw_mmdc_mpwrdlst[] =
{
    {
        "WR_DL_UNIT_NUM0",
        "This field reflects the number of delay units that are actually used b"
        "y write delay-line 0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_DL_UNIT_NUM1",
        "This field reflects the number of delay units that are actually used b"
        "y write delay-line 1.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSDCTRL.
static const field_t hw_mmdc_mpsdctrl[] =
{
    {
        "SDCLK0_DEL",
        "DDR clock0 delay fine tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDCLK1_DEL",
        "DDR clock1 delay fine tuning.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPZQLP2CTL.
static const field_t hw_mmdc_mpzqlp2ctl[] =
{
    {
        "ZQ_LP2_HW_ZQINIT",
        "This register defines the period in cycles that it takes the memory de"
        "vice to perform a Init ZQ calibration.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_LP2_HW_ZQCL",
        "This register defines the period in cycles that it takes the memory de"
        "vice to perform a short ZQ calibration.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ZQ_LP2_HW_ZQCS",
        "This register defines the period in cycles that it takes the memory de"
        "vice to perform a long ZQ calibration.",
        24, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLHWCTL.
static const field_t hw_mmdc_mprddlhwctl[] =
{
    {
        "HW_RD_DL_ERR0",
        "Automatic (HW) read calibration error of Byte0.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_ERR1",
        "Automatic (HW) read calibration error of Byte1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_EN",
        "Enable automatic (HW) read calibration.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_RD_DL_CMP_CYC",
        "Automatic (HW) read sample cycle.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLHWCTL.
static const field_t hw_mmdc_mpwrdlhwctl[] =
{
    {
        "HW_WR_DL_ERR0",
        "Automatic (HW) write calibration error of Byte0.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_ERR1",
        "Automatic (HW) write calibration error of Byte1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_EN",
        "Enable automatic (HW) write calibration.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HW_WR_DL_CMP_CYC",
        "Write sample cycle.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPRDDLHWST0.
static const field_t hw_mmdc_mprddlhwst0[] =
{
    {
        "HW_RD_DL_LOW0",
        "Automatic (HW) read calibration result of the lower boundary of Byte0.",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP0",
        "Automatic (HW) read calibration result of the upper boundary of Byte0.",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_LOW1",
        "Automatic (HW) read calibration result of the lower boundary of Byte1.",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_RD_DL_UP1",
        "Automatic (HW) read calibration result of the upper boundary of Byte1.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRDLHWST0.
static const field_t hw_mmdc_mpwrdlhwst0[] =
{
    {
        "HW_WR_DL_LOW0",
        "Automatic (HW) write calibration result of the lower boundary of Byte0"
        ".",
        0, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP0",
        "Automatic (HW) write calibration result of the upper boundary of Byte0"
        ".",
        8, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_LOW1",
        "Automatic (HW) write calibration result of the lower boundary of Byte1"
        ".",
        16, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WR_DL_UP1",
        "Automatic (HW) write automatic (HW) write calibration result of the up"
        "per boundary of Byte1.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWLHWERR.
static const field_t hw_mmdc_mpwlhwerr[] =
{
    {
        "HW_WL0_DQ",
        "HW write-leveling calibration result of Byte0.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_WL1_DQ",
        "HW write-leveling calibration result of Byte1.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST0.
static const field_t hw_mmdc_mpdghwst0[] =
{
    {
        "HW_DG_LOW0",
        "HW DQS gating calibration result of the lower boundary of Byte0.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP0",
        "HW DQS gating calibration result of the upper boundary of Byte0.",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDGHWST1.
static const field_t hw_mmdc_mpdghwst1[] =
{
    {
        "HW_DG_LOW1",
        "HW DQS gating calibration result of the lower boundary of Byte1.",
        0, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HW_DG_UP1",
        "HW DQS gating calibration result of the upper boundary of Byte1.",
        16, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPPDCMPR1.
static const field_t hw_mmdc_mppdcmpr1[] =
{
    {
        "PDV1",
        "MMDC Pre defined compare value2.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PDV2",
        "MMDC Pre defined compare value2.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPPDCMPR2.
static const field_t hw_mmdc_mppdcmpr2[] =
{
    {
        "MPR_CMP",
        "MPR(DDR3)/DQ calibration (LPDDR2) compare enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MPR_FULL_CMP",
        "MPR(DDR3)/DQ calibration (LPDDR2) full compare enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "READ_LEVEL_PATTERN",
        "MPR(DDR3)/DQ calibration(LPDDR2) read compare pattern.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CA_DL_ABS_OFFSET",
        "Absolute CA (Command/Address of LPDDRR2) offset.",
        16, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHY_CA_DL_UNIT",
        "This field reflects the number of delay units that are actually used b"
        "y CA (Command/Address of LPDDR2) delay-line",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDAR0.
static const field_t hw_mmdc_mpswdar0[] =
{
    {
        "SW_DUMMY_WR",
        "SW dummy write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_DUMMY_RD",
        "SW dummy read.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SW_DUM_CMP0",
        "SW dummy read byte0 compare results.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW_DUM_CMP1",
        "SW dummy read byte1 compare results.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR0.
static const field_t hw_mmdc_mpswdrdr0[] =
{
    {
        "DUM_RD0",
        "Dummy read data0.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR1.
static const field_t hw_mmdc_mpswdrdr1[] =
{
    {
        "DUM_RD1",
        "Dummy read data1.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR2.
static const field_t hw_mmdc_mpswdrdr2[] =
{
    {
        "DUM_RD2",
        "Dummy read data2.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR3.
static const field_t hw_mmdc_mpswdrdr3[] =
{
    {
        "DUM_RD3",
        "Dummy read data3.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR4.
static const field_t hw_mmdc_mpswdrdr4[] =
{
    {
        "DUM_RD4",
        "Dummy read data4.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR5.
static const field_t hw_mmdc_mpswdrdr5[] =
{
    {
        "DUM_RD5",
        "Dummy read data5.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR6.
static const field_t hw_mmdc_mpswdrdr6[] =
{
    {
        "DUM_RD6",
        "Dummy read data6.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPSWDRDR7.
static const field_t hw_mmdc_mpswdrdr7[] =
{
    {
        "DUM_RD7",
        "Dummy read data7.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPMUR0.
static const field_t hw_mmdc_mpmur0[] =
{
    {
        "MU_BYP_VAL",
        "Number of delay units for measurement bypass.",
        0, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MU_BYP_EN",
        "Measure unit bypass enable.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRC_MSR",
        "Force measurement on delay-lines.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MU_UNIT_DEL_NUM",
        "Number of delay units measured per cycle.",
        16, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPWRCADL.
static const field_t hw_mmdc_mpwrcadl[] =
{
    {
        "WR_CA0_DEL",
        "CA (Command/Address LPDDR2 bus) bit 0 delay fine tuning.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA1_DEL",
        "CA (Command/Address LPDDR2 bus) bit 1 delay fine tuning.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA2_DEL",
        "CA (Command/Address LPDDR2 bus) bit 2 delay fine tuning.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA3_DEL",
        "CA (Command/Address LPDDR2 bus) bit 3 delay fine tuning.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA4_DEL",
        "CA (Command/Address LPDDR2 bus) bit 4 delay fine tuning.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA5_DEL",
        "CA (Command/Address LPDDR2 bus) bit 5 delay fine tuning.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA6_DEL",
        "CA (Command/Address LPDDR2 bus) bit 6 delay fine tuning.",
        12, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA7_DEL",
        "CA (Command/Address LPDDR2 bus) bit 7 delay fine tuning.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA8_DEL",
        "CA (Command/Address LPDDR2 bus) bit 8 delay fine tuning.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_CA9_DEL",
        "CA (Command/Address LPDDR2 bus) bit 9 delay fine tuning.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register MMDC_MPDCCR.
static const field_t hw_mmdc_mpdccr[] =
{
    {
        "WR_DQS0_FT_DCC",
        "Write DQS duty cycle fine tuning control of Byte0.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_DQS1_FT_DCC",
        "Write DQS duty cycle fine tuning control of Byte1.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CK_FT0_DCC",
        "Primary duty cycle fine tuning control of DDR clock.",
        12, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CK_FT1_DCC",
        "Secondary duty cycle fine tuning control of DDR clock.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQS0_FT_DCC",
        "Read DQS duty cycle fine tuning control of Byte0.",
        19, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DQS1_FT_DCC",
        "Read DQS duty cycle fine tuning control of Byte1.",
        22, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a MMDC module.
static const reg_t hw_mmdc[] =
{
    {
        "MDCTL",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdctl
    },
    {
        "MDPDC",
        "PRCT field encoding PRCT[2:0] Precharge Timer 000 Disabled (Bit field "
        "reset value) 001 2 clocks 010 4 clocks 011 8 clocks 100 16 clocks 101 "
        "32 clocks 110 64 clocks 111 128 clocks PWDT field encoding PWDT[3:0] P"
        "ower Down Time-out 0000 Disabled (bit field reset value) 0001 16 cycle"
        "s 0010 32 cycles 0011 64 cycles 0100 128 cycles 0101 256 cycles 0110 5"
        "12 cycles 0111 1024 cycles 1000 2048 cycles 1001 4096 cycles 1010 8196"
        " cycles 1011 16384 cycles 1100 32768 cycles 1101-1111 Reserved",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mdpdc
    },
    {
        "MDOTC",
        "For further information see ODT ConfigurationThe MMDC supports one DRA"
        "M_ODT signal (DRAM_ODT for each DRAM_CS) in DDR3 mode in order to allo"
        "w the DDR device to turn on/off its termination resistors.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdotc
    },
    {
        "MDCFG0",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdcfg0
    },
    {
        "MDCFG1",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mdcfg1
    },
    {
        "MDCFG2",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mdcfg2
    },
    {
        "MDMISC",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_mmdc_mdmisc
    },
    {
        "MDSCR",
        "This register is used to issue special commands manually toward the ex"
        "ternal DDR device (such as load mode register, manual self refresh, ma"
        "nual precharge and so on).",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mdscr
    },
    {
        "MDREF",
        "This register determines the refresh scheme that will be executed towa"
        "rd the DDR device.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mdref
    },
    {
        "MDRWD",
        "This register determines the delay between back to back read and write"
        " accesses.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mdrwd
    },
    {
        "MDOR",
        "This register defines delays that must be kept when MMDC exits reset.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mmdc_mdor
    },
    {
        "MDMRR",
        "This register contains data that was collected after issuing MRR comma"
        "nd.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mdmrr
    },
    {
        "MDCFG3LP",
        "This register is relevant only for LPDDR2 mode.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mdcfg3lp
    },
    {
        "MDMR4",
        "This register is relevant only for LPDDR2 mode.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_mmdc_mdmr4
    },
    {
        "MDASP",
        "This register defines the partitioning between chip select 0 and chip "
        "select 1.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmdc_mdasp
    },
    {
        "MAARCR",
        "This register determines the values of the weights used for the re-ord"
        "ering arbitration engine.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_maarcr
    },
    {
        "MAPSR",
        "The MAPSR determines the power saving features of MMDC.",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mapsr
    },
    {
        "MAEXIDR0",
        "This register defines the ID to be monitored for exclusive accesses of"
        " monitor0 and monitor1.",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_maexidr0
    },
    {
        "MAEXIDR1",
        "This register defines the ID to be monitored for exclusive accesses of"
        " monitor2 and monitor3.",
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_maexidr1
    },
    {
        "MADPCR0",
        "",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_madpcr0
    },
    {
        "MADPCR1",
        "",
        4, // Width in bytes
        0x00000414, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_madpcr1
    },
    {
        "MADPSR0",
        "",
        4, // Width in bytes
        0x00000418, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr0
    },
    {
        "MADPSR1",
        "The register reflects the total cycles during which the MMDC state mac"
        "hines were busy (both writes and reads).",
        4, // Width in bytes
        0x0000041c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr1
    },
    {
        "MADPSR2",
        "This register reflects the total number of read accesses (per AXI ID) "
        "toward MMDC.",
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr2
    },
    {
        "MADPSR3",
        "This register reflects the total number of write accesses (per AXI ID)"
        " toward MMDC.",
        4, // Width in bytes
        0x00000424, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr3
    },
    {
        "MADPSR4",
        "This register reflects the total number of bytes that were transferred"
        " during read access (per AXI ID) toward MMDC.",
        4, // Width in bytes
        0x00000428, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr4
    },
    {
        "MADPSR5",
        "This register reflects the total number of bytes that were transferred"
        " during write access (per AXI ID) toward MMDC.",
        4, // Width in bytes
        0x0000042c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_madpsr5
    },
    {
        "MASBS0",
        "",
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_masbs0
    },
    {
        "MASBS1",
        "",
        4, // Width in bytes
        0x00000434, // Base address offset
        true, // Readable
        false, // Writable
        9, // Number of bitfields
        hw_mmdc_masbs1
    },
    {
        "MAGENP",
        "This register is a general 32 bit read/write register.",
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_mmdc_magenp
    },
    {
        "MPZQHWCTRL",
        "",
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpzqhwctrl
    },
    {
        "MPZQSWCTRL",
        "",
        4, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_mmdc_mpzqswctrl
    },
    {
        "MPWLGCR",
        "",
        4, // Width in bytes
        0x00000808, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_mmdc_mpwlgcr
    },
    {
        "MPWLDECTRL0",
        "",
        4, // Width in bytes
        0x0000080c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpwldectrl0
    },
    {
        "MPWLDLST",
        "This register holds the status of the four write leveling delay-lines.",
        4, // Width in bytes
        0x00000814, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpwldlst
    },
    {
        "MPODTCTRL",
        "In LPDDR2 mode this register should be cleared, so no termination will"
        " be activated",
        4, // Width in bytes
        0x00000818, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpodtctrl
    },
    {
        "MPRDDQBY0DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte0 relative to the read DQS.",
        4, // Width in bytes
        0x0000081c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby0dl
    },
    {
        "MPRDDQBY1DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e read DQ byte1 relative to the read DQS",
        4, // Width in bytes
        0x00000820, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_mmdc_mprddqby1dl
    },
    {
        "MPWRDQBY0DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e write DQ byte0 relative to the write DQS",
        4, // Width in bytes
        0x0000082c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpwrdqby0dl
    },
    {
        "MPWRDQBY1DL",
        "This register is used to add fine-tuning adjustment to every bit in th"
        "e write DQ byte1 relative to the write DQS",
        4, // Width in bytes
        0x00000830, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_mmdc_mpwrdqby1dl
    },
    {
        "MPDGCTRL0",
        "",
        4, // Width in bytes
        0x0000083c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_mmdc_mpdgctrl0
    },
    {
        "MPDGDLST0",
        "This register holds the status of the 4 dqs gating delay-lines.",
        4, // Width in bytes
        0x00000844, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdgdlst0
    },
    {
        "MPRDDLCTL",
        "This register controls read delay-lines functionality; it determines D"
        "QS delay relative to the associated DQ read access.",
        4, // Width in bytes
        0x00000848, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_mprddlctl
    },
    {
        "MPRDDLST",
        "This register holds the status of the 4 read delay-lines.",
        4, // Width in bytes
        0x0000084c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mprddlst
    },
    {
        "MPWRDLCTL",
        "This register controls write delay-lines functionality, it determines "
        "DQ/DM delay relative to the associated DQS in write access.",
        4, // Width in bytes
        0x00000850, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_mpwrdlctl
    },
    {
        "MPWRDLST",
        "This register holds the status of the 4 write delay-line.",
        4, // Width in bytes
        0x00000854, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpwrdlst
    },
    {
        "MPSDCTRL",
        "This register controls the fine tuning of the primary clock (CK0).",
        4, // Width in bytes
        0x00000858, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_mpsdctrl
    },
    {
        "MPZQLP2CTL",
        "This register controls the idle time that takes the LPDDR2 device to p"
        "erform ZQ calibration",
        4, // Width in bytes
        0x0000085c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_mmdc_mpzqlp2ctl
    },
    {
        "MPRDDLHWCTL",
        "",
        4, // Width in bytes
        0x00000860, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlhwctl
    },
    {
        "MPWRDLHWCTL",
        "",
        4, // Width in bytes
        0x00000864, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlhwctl
    },
    {
        "MPRDDLHWST0",
        "",
        4, // Width in bytes
        0x00000868, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mprddlhwst0
    },
    {
        "MPWRDLHWST0",
        "",
        4, // Width in bytes
        0x00000870, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_mmdc_mpwrdlhwst0
    },
    {
        "MPWLHWERR",
        "",
        4, // Width in bytes
        0x00000878, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpwlhwerr
    },
    {
        "MPDGHWST0",
        "",
        4, // Width in bytes
        0x0000087c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst0
    },
    {
        "MPDGHWST1",
        "",
        4, // Width in bytes
        0x00000880, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_mmdc_mpdghwst1
    },
    {
        "MPPDCMPR1",
        "This register holds the MMDC pre-defined compare value that will be us"
        "ed during automatic read, read DQS gating and write calibration proces"
        "s.",
        4, // Width in bytes
        0x0000088c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_mmdc_mppdcmpr1
    },
    {
        "MPPDCMPR2",
        "",
        4, // Width in bytes
        0x00000890, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_mmdc_mppdcmpr2
    },
    {
        "MPSWDAR0",
        "",
        4, // Width in bytes
        0x00000894, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpswdar0
    },
    {
        "MPSWDRDR0",
        "",
        4, // Width in bytes
        0x00000898, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr0
    },
    {
        "MPSWDRDR1",
        "",
        4, // Width in bytes
        0x0000089c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr1
    },
    {
        "MPSWDRDR2",
        "",
        4, // Width in bytes
        0x000008a0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr2
    },
    {
        "MPSWDRDR3",
        "",
        4, // Width in bytes
        0x000008a4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr3
    },
    {
        "MPSWDRDR4",
        "",
        4, // Width in bytes
        0x000008a8, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr4
    },
    {
        "MPSWDRDR5",
        "",
        4, // Width in bytes
        0x000008ac, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr5
    },
    {
        "MPSWDRDR6",
        "",
        4, // Width in bytes
        0x000008b0, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr6
    },
    {
        "MPSWDRDR7",
        "",
        4, // Width in bytes
        0x000008b4, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_mmdc_mpswdrdr7
    },
    {
        "MPMUR0",
        "",
        4, // Width in bytes
        0x000008b8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_mmdc_mpmur0
    },
    {
        "MPWRCADL",
        "This register is used to add fine-tuning adjustment to the CA (command"
        "/Address of LPDDR2 bus) relative to the DDR clock",
        4, // Width in bytes
        0x000008bc, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_mmdc_mpwrcadl
    },
    {
        "MPDCCR",
        "This register is used to control the duty cycle of the DQS and the pri"
        "mary clock (CK0) .",
        4, // Width in bytes
        0x000008c0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_mmdc_mpdccr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark OCOTP
#endif

// Bitfields in register OCOTP_CTRL.
static const field_t hw_ocotp_ctrl[] =
{
    {
        "ADDR",
        "OTP write and read access address register.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUSY",
        "OTP controller status bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR",
        "Set by the controller when an access to a locked region(OTP or shadow "
        "register) is requested.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELOAD_SHADOWS",
        "Set to force re-loading the shadow registers (HW/SW capability and LOC"
        "K).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_TEST",
        "Set to calculate CRC according to start address and end address in CRC"
        "_ADDR register.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_FAIL",
        "Set by controller when calculated CRC value is not equal to appointed "
        "CRC fuse word",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_UNLOCK",
        "Write 0x3E77 to enable OTP write accesses.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_SET.
static const field_t hw_ocotp_ctrl_set[] =
{
    {
        "ADDR",
        "OTP write and read access address register.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUSY",
        "OTP controller status bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR",
        "Set by the controller when an access to a locked region(OTP or shadow "
        "register) is requested.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELOAD_SHADOWS",
        "Set to force re-loading the shadow registers (HW/SW capability and LOC"
        "K).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_TEST",
        "Set to calculate CRC according to start address and end address in CRC"
        "_ADDR register.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_FAIL",
        "Set by controller when calculated CRC value is not equal to appointed "
        "CRC fuse word",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_UNLOCK",
        "Write 0x3E77 to enable OTP write accesses.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_CLR.
static const field_t hw_ocotp_ctrl_clr[] =
{
    {
        "ADDR",
        "OTP write and read access address register.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUSY",
        "OTP controller status bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR",
        "Set by the controller when an access to a locked region(OTP or shadow "
        "register) is requested.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELOAD_SHADOWS",
        "Set to force re-loading the shadow registers (HW/SW capability and LOC"
        "K).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_TEST",
        "Set to calculate CRC according to start address and end address in CRC"
        "_ADDR register.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_FAIL",
        "Set by controller when calculated CRC value is not equal to appointed "
        "CRC fuse word",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_UNLOCK",
        "Write 0x3E77 to enable OTP write accesses.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CTRL_TOG.
static const field_t hw_ocotp_ctrl_tog[] =
{
    {
        "ADDR",
        "OTP write and read access address register.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BUSY",
        "OTP controller status bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERROR",
        "Set by the controller when an access to a locked region(OTP or shadow "
        "register) is requested.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELOAD_SHADOWS",
        "Set to force re-loading the shadow registers (HW/SW capability and LOC"
        "K).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_TEST",
        "Set to calculate CRC according to start address and end address in CRC"
        "_ADDR register.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_FAIL",
        "Set by controller when calculated CRC value is not equal to appointed "
        "CRC fuse word",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WR_UNLOCK",
        "Write 0x3E77 to enable OTP write accesses.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_TIMING.
static const field_t hw_ocotp_timing[] =
{
    {
        "STROBE_PROG",
        "This count value specifies the strobe period in one time write OTP.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RELAX",
        "This count value specifies the time to add to all default timing param"
        "eters other than the Tpgm and Trd.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STROBE_READ",
        "This count value specifies the strobe period in one time read OTP.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAIT",
        "This count value specifies time interval between auto read and write a"
        "ccess in one time program.",
        22, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSRVD0",
        "These bits always read back zero.",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_DATA.
static const field_t hw_ocotp_data[] =
{
    {
        "DATA",
        "Used to initiate a write to OTP.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_READ_CTRL.
static const field_t hw_ocotp_read_ctrl[] =
{
    {
        "READ_FUSE",
        "Used to initiate a read to OTP.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved",
        1, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_READ_FUSE_DATA.
static const field_t hw_ocotp_read_fuse_data[] =
{
    {
        "DATA",
        "The data read from OTP",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SW_STICKY.
static const field_t hw_ocotp_sw_sticky[] =
{
    {
        "SRK_REVOKE_LOCK",
        "Shadow register write and OTP write lock for SRK_REVOKE region.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FIELD_RETURN_LOCK",
        "Shadow register write and OTP write lock for FIELD_RETURN region.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved",
        5, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SCS.
static const field_t hw_ocotp_scs[] =
{
    {
        "HAB_JDE",
        "HAB JTAG Debug Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPARE",
        "Unallocated read/write bits for implementation specific software use.",
        1, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "When set, all of the bits in this register are locked and can not be c"
        "hanged through SW programming.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SCS_SET.
static const field_t hw_ocotp_scs_set[] =
{
    {
        "HAB_JDE",
        "HAB JTAG Debug Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPARE",
        "Unallocated read/write bits for implementation specific software use.",
        1, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "When set, all of the bits in this register are locked and can not be c"
        "hanged through SW programming.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SCS_CLR.
static const field_t hw_ocotp_scs_clr[] =
{
    {
        "HAB_JDE",
        "HAB JTAG Debug Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPARE",
        "Unallocated read/write bits for implementation specific software use.",
        1, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "When set, all of the bits in this register are locked and can not be c"
        "hanged through SW programming.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SCS_TOG.
static const field_t hw_ocotp_scs_tog[] =
{
    {
        "HAB_JDE",
        "HAB JTAG Debug Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPARE",
        "Unallocated read/write bits for implementation specific software use.",
        1, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "When set, all of the bits in this register are locked and can not be c"
        "hanged through SW programming.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CRC_ADDR.
static const field_t hw_ocotp_crc_addr[] =
{
    {
        "DATA_START_ADDR",
        "End address of fuse location for CRC calculation",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_END_ADDR",
        "Start address of fuse location for CRC calculation",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_ADDR",
        "Address of 32-bit CRC result for comparing",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTPMK_CRC",
        "Enable bit for CRC32 calculation address When OTPMK_CRC_ADDR_OTPMK_CRC"
        " bit sets to 1, calculation address sets to OTPMK_CRC (recommend).",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved",
        20, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CRC_VALUE.
static const field_t hw_ocotp_crc_value[] =
{
    {
        "DATA",
        "The crc32 value based on CRC_ADDR",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_VERSION.
static const field_t hw_ocotp_version[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_LOCK.
static const field_t hw_ocotp_lock[] =
{
    {
        "TESTER",
        "Status of shadow register and OTP write lock for tester region.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOT_CFG",
        "Status of shadow register and OTP write lock for boot_cfg region.",
        2, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MEM_TRIM",
        "Status of shadow register and OTP write lock for mem_trim region.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SJC_RESP",
        "Status of shadow register read and write, OTP read and write lock for "
        "sjc_resp region.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD0",
        "Reserved",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAC_ADDR",
        "Status of shadow register and OTP write lock for mac_addr region.",
        8, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP1",
        "Status of shadow register and OTP write lock for gp2 region.",
        10, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP2",
        "Status of shadow register and OTP write lock for gp2 region.",
        12, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SRK",
        "Status of shadow register and OTP write lock for srk region.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP3",
        "Status of shadow register and OTP write lock for GP3 region.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW_GP",
        "Status of shadow register and OTP write lock for SW_GP region.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTPMK",
        "Status of shadow register and OTP write lock for OTPMK region.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ANALOG",
        "Status of shadow register and OTP write lock for analog region.",
        18, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTPMK_CRC",
        "Status of shadow register and OTP write lock for otpmk crc region.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ROM_PATCH",
        "Status of shadow register and OTP write lock for rom_patch region.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MISC_CONF",
        "Status of shadow register and OTP write lock for misc_conf region.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP4",
        "Status of shadow register and OTP write lock for GP4 region.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP5",
        "Status of shadow register and OTP write lock for GP5 region.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PIN",
        "Status of Pin access lock bit.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP7",
        "Status of shadow register and OTP write lock for GP7 region.",
        26, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP8",
        "Status of shadow register and OTP write lock for gp8 region.",
        28, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "GP6",
        "Status of shadow register and OTP write lock for GP6 region.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG0.
static const field_t hw_ocotp_cfg0[] =
{
    {
        "BITS",
        "This register contains 32 bits of the Unique ID and SJC_CHALLENGE fiel"
        "d.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG1.
static const field_t hw_ocotp_cfg1[] =
{
    {
        "BITS",
        "This register contains 32 bits of the Unique ID and SJC_CHALLENGE fiel"
        "d.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG2.
static const field_t hw_ocotp_cfg2[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 0, word 3 (ADDR = 0x03).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG3.
static const field_t hw_ocotp_cfg3[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 0, word 4 (ADDR = 0x04).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG4.
static const field_t hw_ocotp_cfg4[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 0, word 5 (ADDR = 0x05).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG5.
static const field_t hw_ocotp_cfg5[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 0, word 6 (ADDR = 0x06).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CFG6.
static const field_t hw_ocotp_cfg6[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 0, word 7 (ADDR = 0x07).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM0.
static const field_t hw_ocotp_mem0[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 0 (ADDR = 0x08).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM1.
static const field_t hw_ocotp_mem1[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 1 (ADDR = 0x09).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM2.
static const field_t hw_ocotp_mem2[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 2 (ADDR = 0x0A).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM3.
static const field_t hw_ocotp_mem3[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 3 (ADDR = 0x0B).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MEM4.
static const field_t hw_ocotp_mem4[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 4 (ADDR = 0x0C).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ANA0.
static const field_t hw_ocotp_ana0[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 5 (ADDR = 0x0D).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ANA1.
static const field_t hw_ocotp_ana1[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 6 (ADDR = 0x0E).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ANA2.
static const field_t hw_ocotp_ana2[] =
{
    {
        "BITS",
        "Reflects value of OTP bank 1, word 7 (ADDR = 0x0F).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_OTPMK0.
static const field_t hw_ocotp_otpmk0[] =
{
    {
        "BITS",
        "Shadow register for the OTPMK Key word0 (Copy of OTP Bank 2, word 0 (A"
        "DDR = 0x10)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_OTPMK1.
static const field_t hw_ocotp_otpmk1[] =
{
    {
        "BITS",
        "Shadow register for the OTPMK Key word0 (Copy of OTP Bank 2, word 1 (A"
        "DDR = 0x11)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_OTPMK2.
static const field_t hw_ocotp_otpmk2[] =
{
    {
        "BITS",
        "Shadow register for the OTPMK Key word0 (Copy of OTP Bank 2, word 2 (A"
        "DDR = 0x12)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_OTPMK3.
static const field_t hw_ocotp_otpmk3[] =
{
    {
        "BITS",
        "Shadow register for the OTPMK Key word0 (Copy of OTP Bank 2, word 3 (A"
        "DDR = 0x13)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_OTPMK4.
static const field_t hw_ocotp_otpmk4[] =
{
    {
        "BITS",
        "Shadow register for the OTPMK Key word0 (Copy of OTP Bank 2, word 4 (A"
        "DDR = 0x14)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_OTPMK5.
static const field_t hw_ocotp_otpmk5[] =
{
    {
        "BITS",
        "Shadow register for the OTPMK Key word0 (Copy of OTP Bank 2, word 4 (A"
        "DDR = 0x14)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_OTPMK6.
static const field_t hw_ocotp_otpmk6[] =
{
    {
        "BITS",
        "Shadow register for the OTPMK Key word0 (Copy of OTP Bank 2, word 6 (A"
        "DDR = 0x16)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_OTPMK7.
static const field_t hw_ocotp_otpmk7[] =
{
    {
        "BITS",
        "Shadow register for the OTPMK Key word0 (Copy of OTP Bank 2, word 7 (A"
        "DDR = 0x17)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK0.
static const field_t hw_ocotp_srk0[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word0 (Copy of OTP "
        "Bank 3, word 0 (ADDR = 0x18)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK1.
static const field_t hw_ocotp_srk1[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word1 (Copy of OTP "
        "Bank 3, word 1 (ADDR = 0x19)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK2.
static const field_t hw_ocotp_srk2[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word2 (Copy of OTP "
        "Bank 3, word 2 (ADDR = 0x1A)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK3.
static const field_t hw_ocotp_srk3[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word3 (Copy of OTP "
        "Bank 3, word 3 (ADDR = 0x1B)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK4.
static const field_t hw_ocotp_srk4[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word4 (Copy of OTP "
        "Bank 3, word 4 (ADDR = 0x1C)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK5.
static const field_t hw_ocotp_srk5[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word5 (Copy of OTP "
        "Bank 3, word 5 (ADDR = 0x1D)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK6.
static const field_t hw_ocotp_srk6[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word6 (Copy of OTP "
        "Bank 3, word 6 (ADDR = 0x1E)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK7.
static const field_t hw_ocotp_srk7[] =
{
    {
        "BITS",
        "Shadow register for the hash of the Super Root Key word7 (Copy of OTP "
        "Bank 3, word 7 (ADDR = 0x1F)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SJC_RESP0.
static const field_t hw_ocotp_sjc_resp0[] =
{
    {
        "BITS",
        "Shadow register for the SJC_RESP Key word0 (Copy of OTP Bank 4, word 0"
        " (ADDR = 0x20)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SJC_RESP1.
static const field_t hw_ocotp_sjc_resp1[] =
{
    {
        "BITS",
        "Shadow register for the SJC_RESP Key word1 (Copy of OTP Bank 4, word 1"
        " (ADDR = 0x21)).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MAC0.
static const field_t hw_ocotp_mac0[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 4, word 2 (ADDR = 0x22).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MAC1.
static const field_t hw_ocotp_mac1[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 4, word 3 (ADDR = 0x23).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MAC.
static const field_t hw_ocotp_mac[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 4, word 4 (ADDR = 0x24).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_CRC.
static const field_t hw_ocotp_crc[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 4, word 5 (ADDR = 0x25).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP1.
static const field_t hw_ocotp_gp1[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 4, word 6 (ADDR = 0x26).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP2.
static const field_t hw_ocotp_gp2[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 4, word 7 (ADDR = 0x27).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SW_GP0.
static const field_t hw_ocotp_sw_gp0[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 5, word 0 (ADDR = 0x28).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SW_GP1.
static const field_t hw_ocotp_sw_gp1[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 5, word 1 (ADDR = 0x29).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SW_GP2.
static const field_t hw_ocotp_sw_gp2[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 5, word 2 (ADDR = 0x2a).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SW_GP3.
static const field_t hw_ocotp_sw_gp3[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 5, word 3 (ADDR = 0x2b).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SW_GP4.
static const field_t hw_ocotp_sw_gp4[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 5, word 4 (ADDR = 0x2c).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_MISC_CONF.
static const field_t hw_ocotp_misc_conf[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 5, word 5 (ADDR = 0x2d).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_FIELD_RETURN.
static const field_t hw_ocotp_field_return[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 5, word 6 (ADDR = 0x2e).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_SRK_REVOKE.
static const field_t hw_ocotp_srk_revoke[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 5, word 7 (ADDR = 0x2f).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ROM_PATCH0.
static const field_t hw_ocotp_rom_patch0[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 6, word 0 (ADDR = 0x30).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ROM_PATCH1.
static const field_t hw_ocotp_rom_patch1[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 6, word 1 (ADDR = 0x31).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ROM_PATCH2.
static const field_t hw_ocotp_rom_patch2[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 6, word 2 (ADDR = 0x32).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ROM_PATCH3.
static const field_t hw_ocotp_rom_patch3[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 6, word 3 (ADDR = 0x33).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ROM_PATCH4.
static const field_t hw_ocotp_rom_patch4[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 6, word 4 (ADDR = 0x34).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ROM_PATCH5.
static const field_t hw_ocotp_rom_patch5[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 6, word 5 (ADDR = 0x35).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ROM_PATCH6.
static const field_t hw_ocotp_rom_patch6[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 6, word 6 (ADDR = 0x36).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ROM_PATCH7.
static const field_t hw_ocotp_rom_patch7[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 6, word 7 (ADDR = 0x37).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ROM_PATCH8.
static const field_t hw_ocotp_rom_patch8[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 7, word 0 (ADDR = 0x38).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ROM_PATCH9.
static const field_t hw_ocotp_rom_patch9[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 7, word 1 (ADDR = 0x39).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ROM_PATCH10.
static const field_t hw_ocotp_rom_patch10[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 7, word 2 (ADDR = 0x3a).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ROM_PATCH11.
static const field_t hw_ocotp_rom_patch11[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 7, word 3 (ADDR = 0x3b).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ROM_PATCH12.
static const field_t hw_ocotp_rom_patch12[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 7, word 4 (ADDR = 0x3c).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ROM_PATCH13.
static const field_t hw_ocotp_rom_patch13[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 7, word 5 (ADDR = 0x3d).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ROM_PATCH14.
static const field_t hw_ocotp_rom_patch14[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 7, word 6 (ADDR = 0x3e).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_ROM_PATCH15.
static const field_t hw_ocotp_rom_patch15[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 7, word 7 (ADDR = 0x3f).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP30.
static const field_t hw_ocotp_gp30[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 8, word 0 (ADDR = 0x40).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP31.
static const field_t hw_ocotp_gp31[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 8, word 1 (ADDR = 0x41).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP32.
static const field_t hw_ocotp_gp32[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 8, word 2 (ADDR = 0x42).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP33.
static const field_t hw_ocotp_gp33[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 8, word 3 (ADDR = 0x43).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP34.
static const field_t hw_ocotp_gp34[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 8, word 4 (ADDR = 0x44).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP35.
static const field_t hw_ocotp_gp35[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 8, word 5 (ADDR = 0x45).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP36.
static const field_t hw_ocotp_gp36[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 8, word 6 (ADDR = 0x46).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP37.
static const field_t hw_ocotp_gp37[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 8, word 7 (ADDR = 0x47).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP38.
static const field_t hw_ocotp_gp38[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 9, word 0 (ADDR = 0x48).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP39.
static const field_t hw_ocotp_gp39[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 9, word 1 (ADDR = 0x49).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP310.
static const field_t hw_ocotp_gp310[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 9, word 2 (ADDR = 0x4a).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP311.
static const field_t hw_ocotp_gp311[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 9, word 3 (ADDR = 0x4b).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP312.
static const field_t hw_ocotp_gp312[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 9, word 4 (ADDR = 0x4c).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP313.
static const field_t hw_ocotp_gp313[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 9, word 5 (ADDR = 0x4d).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP314.
static const field_t hw_ocotp_gp314[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 9, word 6 (ADDR = 0x4e).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP315.
static const field_t hw_ocotp_gp315[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 9, word 7 (ADDR = 0x4f).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP40.
static const field_t hw_ocotp_gp40[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 10, word 0 (ADDR = 0x50).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP41.
static const field_t hw_ocotp_gp41[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 10, word 1 (ADDR = 0x51).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP42.
static const field_t hw_ocotp_gp42[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 10, word 2 (ADDR = 0x52).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP43.
static const field_t hw_ocotp_gp43[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 10, word 3 (ADDR = 0x53).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP44.
static const field_t hw_ocotp_gp44[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 10, word 4 (ADDR = 0x54).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP45.
static const field_t hw_ocotp_gp45[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 10, word 5 (ADDR = 0x55).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP46.
static const field_t hw_ocotp_gp46[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 10, word 6 (ADDR = 0x56).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP47.
static const field_t hw_ocotp_gp47[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 10, word 7 (ADDR = 0x57).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP48.
static const field_t hw_ocotp_gp48[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 11, word 0 (ADDR = 0x58).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP49.
static const field_t hw_ocotp_gp49[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 11, word 1 (ADDR = 0x59).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP410.
static const field_t hw_ocotp_gp410[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 11, word 2 (ADDR = 0x5A).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP411.
static const field_t hw_ocotp_gp411[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 11, word 3 (ADDR = 0x5B).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP412.
static const field_t hw_ocotp_gp412[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 11, word 4 (ADDR = 0x5C).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP413.
static const field_t hw_ocotp_gp413[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 11, word 5 (ADDR = 0x5D).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP414.
static const field_t hw_ocotp_gp414[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 11, word 6 (ADDR = 0x5E).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP415.
static const field_t hw_ocotp_gp415[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 11, word 7 (ADDR = 0x5F).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP50.
static const field_t hw_ocotp_gp50[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 12, word 0 (ADDR = 0x60).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP51.
static const field_t hw_ocotp_gp51[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 12, word 1 (ADDR = 0x61).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP52.
static const field_t hw_ocotp_gp52[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 12, word 2 (ADDR = 0x62).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP53.
static const field_t hw_ocotp_gp53[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 12, word 3 (ADDR = 0x63).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP54.
static const field_t hw_ocotp_gp54[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 12, word 4 (ADDR = 0x64).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP55.
static const field_t hw_ocotp_gp55[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 12, word 5 (ADDR = 0x65).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP56.
static const field_t hw_ocotp_gp56[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 12, word 6 (ADDR = 0x66).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP57.
static const field_t hw_ocotp_gp57[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 12, word 7 (ADDR = 0x67).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP58.
static const field_t hw_ocotp_gp58[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 13, word 0 (ADDR = 0x68).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP59.
static const field_t hw_ocotp_gp59[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 13, word 1 (ADDR = 0x69).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP510.
static const field_t hw_ocotp_gp510[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 13, word 2 (ADDR = 0x6A).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP511.
static const field_t hw_ocotp_gp511[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 13, word 3 (ADDR = 0x6B).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP512.
static const field_t hw_ocotp_gp512[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 13, word 4 (ADDR = 0x6C).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP513.
static const field_t hw_ocotp_gp513[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 13, word 5 (ADDR = 0x6D).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP514.
static const field_t hw_ocotp_gp514[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 13, word 6 (ADDR = 0x6E).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP515.
static const field_t hw_ocotp_gp515[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 13, word 7 (ADDR = 0x6F).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP60.
static const field_t hw_ocotp_gp60[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 14, word 0 (ADDR = 0x70).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP61.
static const field_t hw_ocotp_gp61[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 14, word 1 (ADDR = 0x71).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP62.
static const field_t hw_ocotp_gp62[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 14, word 2 (ADDR = 0x72).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP63.
static const field_t hw_ocotp_gp63[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 14, word 3 (ADDR = 0x73).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP64.
static const field_t hw_ocotp_gp64[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 14, word 4 (ADDR = 0x74).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP65.
static const field_t hw_ocotp_gp65[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 14, word 5 (ADDR = 0x75).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP66.
static const field_t hw_ocotp_gp66[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 14, word 6 (ADDR = 0x76).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP67.
static const field_t hw_ocotp_gp67[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 14, word 7 (ADDR = 0x77).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP70.
static const field_t hw_ocotp_gp70[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 15, word 0 (ADDR = 0x78).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP71.
static const field_t hw_ocotp_gp71[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 15, word 1 (ADDR = 0x79).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP72.
static const field_t hw_ocotp_gp72[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 15, word 2 (ADDR = 0x7A).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP73.
static const field_t hw_ocotp_gp73[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 15, word 3 (ADDR = 0x7B).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP80.
static const field_t hw_ocotp_gp80[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 15, word 4 (ADDR = 0x7C).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP81.
static const field_t hw_ocotp_gp81[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 15, word 5 (ADDR = 0x7D).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP82.
static const field_t hw_ocotp_gp82[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 15, word 6 (ADDR = 0x7E).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register OCOTP_GP83.
static const field_t hw_ocotp_gp83[] =
{
    {
        "BITS",
        "Reflects value of OTP Bank 15, word 7 (ADDR = 0x7F).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a OCOTP module.
static const reg_t hw_ocotp[] =
{
    {
        "CTRL",
        "The OCOTP Control and Status Register specifies the copy state, as wel"
        "l as the control required for random access of the OTP memory OCOTP_CT"
        "RL: 0x000 OCOTP_CTRL_SET: 0x004 OCOTP_CTRL_CLR: 0x008 OCOTP_CTRL_TOG: "
        "0x00C The OCOTP Control and Status Register provides the necessary sof"
        "tware interface for performing read and write operations to the On-Chi"
        "p OTP (One-Time Programmable ROM).",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ocotp_ctrl
    },
    {
        "CTRL_SET",
        "The OCOTP Control and Status Register specifies the copy state, as wel"
        "l as the control required for random access of the OTP memory OCOTP_CT"
        "RL: 0x000 OCOTP_CTRL_SET: 0x004 OCOTP_CTRL_CLR: 0x008 OCOTP_CTRL_TOG: "
        "0x00C The OCOTP Control and Status Register provides the necessary sof"
        "tware interface for performing read and write operations to the On-Chi"
        "p OTP (One-Time Programmable ROM).",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ocotp_ctrl_set
    },
    {
        "CTRL_CLR",
        "The OCOTP Control and Status Register specifies the copy state, as wel"
        "l as the control required for random access of the OTP memory OCOTP_CT"
        "RL: 0x000 OCOTP_CTRL_SET: 0x004 OCOTP_CTRL_CLR: 0x008 OCOTP_CTRL_TOG: "
        "0x00C The OCOTP Control and Status Register provides the necessary sof"
        "tware interface for performing read and write operations to the On-Chi"
        "p OTP (One-Time Programmable ROM).",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ocotp_ctrl_clr
    },
    {
        "CTRL_TOG",
        "The OCOTP Control and Status Register specifies the copy state, as wel"
        "l as the control required for random access of the OTP memory OCOTP_CT"
        "RL: 0x000 OCOTP_CTRL_SET: 0x004 OCOTP_CTRL_CLR: 0x008 OCOTP_CTRL_TOG: "
        "0x00C The OCOTP Control and Status Register provides the necessary sof"
        "tware interface for performing read and write operations to the On-Chi"
        "p OTP (One-Time Programmable ROM).",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_ocotp_ctrl_tog
    },
    {
        "TIMING",
        "The OCOTP Data Register is used for OTP Programming This register spec"
        "ifies timing parameters for programming and reading the OCOTP fuse arr"
        "ay.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ocotp_timing
    },
    {
        "DATA",
        "The OCOTP Data Register is used for OTP Programming This register is u"
        "sed in conjuction with OCOTP_CTRL to perform one-time writes to the OT"
        "P.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_data
    },
    {
        "READ_CTRL",
        "The OCOTP Register is used for OTP Read This register is used in conju"
        "ction with OCOTP_CTRL to perform one time read to the OTP.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_ocotp_read_ctrl
    },
    {
        "READ_FUSE_DATA",
        "The OCOTP Data Register is used for OTP Read The data read from OTP",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_read_fuse_data
    },
    {
        "SW_STICKY",
        "Some SW sticky bits .",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_sw_sticky
    },
    {
        "SCS",
        "OCOTP_SCS: 0x060 OCOTP_SCS_SET: 0x064 OCOTP_SCS_CLR: 0x068 OCOTP_SCS_T"
        "OG: 0x06C This register holds volatile configuration values that can b"
        "e set and locked by trusted software.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_scs
    },
    {
        "SCS_SET",
        "OCOTP_SCS: 0x060 OCOTP_SCS_SET: 0x064 OCOTP_SCS_CLR: 0x068 OCOTP_SCS_T"
        "OG: 0x06C This register holds volatile configuration values that can b"
        "e set and locked by trusted software.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_scs_set
    },
    {
        "SCS_CLR",
        "OCOTP_SCS: 0x060 OCOTP_SCS_SET: 0x064 OCOTP_SCS_CLR: 0x068 OCOTP_SCS_T"
        "OG: 0x06C This register holds volatile configuration values that can b"
        "e set and locked by trusted software.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_scs_clr
    },
    {
        "SCS_TOG",
        "OCOTP_SCS: 0x060 OCOTP_SCS_SET: 0x064 OCOTP_SCS_CLR: 0x068 OCOTP_SCS_T"
        "OG: 0x06C This register holds volatile configuration values that can b"
        "e set and locked by trusted software.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_ocotp_scs_tog
    },
    {
        "CRC_ADDR",
        "The OCOTP Data Register is used for OTP Read The address for CRC calcu"
        "lation",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_ocotp_crc_addr
    },
    {
        "CRC_VALUE",
        "The OCOTP Data Register is used for OTP Read The CRC32 value is based "
        "on CRC_ADDR.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_crc_value
    },
    {
        "VERSION",
        "This register always returns a known read value for debug purposes it "
        "indicates the version of the block.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_ocotp_version
    },
    {
        "LOCK",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        false, // Writable
        22, // Number of bitfields
        hw_ocotp_lock
    },
    {
        "CFG0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000410, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg0
    },
    {
        "CFG1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000420, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg1
    },
    {
        "CFG2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000430, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg2
    },
    {
        "CFG3",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000440, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg3
    },
    {
        "CFG4",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000450, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg4
    },
    {
        "CFG5",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000460, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg5
    },
    {
        "CFG6",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000470, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_cfg6
    },
    {
        "MEM0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000480, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem0
    },
    {
        "MEM1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000490, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem1
    },
    {
        "MEM2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem2
    },
    {
        "MEM3",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem3
    },
    {
        "MEM4",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mem4
    },
    {
        "ANA0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ana0
    },
    {
        "ANA1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ana1
    },
    {
        "ANA2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000004f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_ana2
    },
    {
        "OTPMK0",
        "Shadow register for the OTPMK Key word0 (Copy of OTP Bank 2, word 0 (A"
        "DDR = 0x10)).",
        4, // Width in bytes
        0x00000500, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_otpmk0
    },
    {
        "OTPMK1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000510, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_otpmk1
    },
    {
        "OTPMK2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000520, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_otpmk2
    },
    {
        "OTPMK3",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000530, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_otpmk3
    },
    {
        "OTPMK4",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000540, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_otpmk4
    },
    {
        "OTPMK5",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000550, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_otpmk5
    },
    {
        "OTPMK6",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000560, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_otpmk6
    },
    {
        "OTPMK7",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000570, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_otpmk7
    },
    {
        "SRK0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000580, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk0
    },
    {
        "SRK1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000590, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk1
    },
    {
        "SRK2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk2
    },
    {
        "SRK3",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk3
    },
    {
        "SRK4",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk4
    },
    {
        "SRK5",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk5
    },
    {
        "SRK6",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk6
    },
    {
        "SRK7",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000005f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk7
    },
    {
        "SJC_RESP0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000600, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_sjc_resp0
    },
    {
        "SJC_RESP1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000610, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_sjc_resp1
    },
    {
        "MAC0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000620, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mac0
    },
    {
        "MAC1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000630, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mac1
    },
    {
        "MAC",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000640, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_mac
    },
    {
        "CRC",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000650, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_crc
    },
    {
        "GP1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000660, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp1
    },
    {
        "GP2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000670, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp2
    },
    {
        "SW_GP0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000680, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_sw_gp0
    },
    {
        "SW_GP1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000690, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_sw_gp1
    },
    {
        "SW_GP2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000006a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_sw_gp2
    },
    {
        "SW_GP3",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000006b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_sw_gp3
    },
    {
        "SW_GP4",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000006c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_sw_gp4
    },
    {
        "MISC_CONF",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000006d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_misc_conf
    },
    {
        "FIELD_RETURN",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000006e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_field_return
    },
    {
        "SRK_REVOKE",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000006f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_srk_revoke
    },
    {
        "ROM_PATCH0",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_rom_patch0
    },
    {
        "ROM_PATCH1",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000810, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_rom_patch1
    },
    {
        "ROM_PATCH2",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000820, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_rom_patch2
    },
    {
        "ROM_PATCH3",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000830, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_rom_patch3
    },
    {
        "ROM_PATCH4",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000840, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_rom_patch4
    },
    {
        "ROM_PATCH5",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000850, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_rom_patch5
    },
    {
        "ROM_PATCH6",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000860, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_rom_patch6
    },
    {
        "ROM_PATCH7",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000870, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_rom_patch7
    },
    {
        "ROM_PATCH8",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000880, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_rom_patch8
    },
    {
        "ROM_PATCH9",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000890, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_rom_patch9
    },
    {
        "ROM_PATCH10",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000008a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_rom_patch10
    },
    {
        "ROM_PATCH11",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000008b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_rom_patch11
    },
    {
        "ROM_PATCH12",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000008c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_rom_patch12
    },
    {
        "ROM_PATCH13",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000008d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_rom_patch13
    },
    {
        "ROM_PATCH14",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000008e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_rom_patch14
    },
    {
        "ROM_PATCH15",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000008f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_rom_patch15
    },
    {
        "GP30",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000900, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp30
    },
    {
        "GP31",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000910, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp31
    },
    {
        "GP32",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000920, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp32
    },
    {
        "GP33",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000930, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp33
    },
    {
        "GP34",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000940, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp34
    },
    {
        "GP35",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000950, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp35
    },
    {
        "GP36",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000960, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp36
    },
    {
        "GP37",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000970, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp37
    },
    {
        "GP38",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000980, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp38
    },
    {
        "GP39",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000990, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp39
    },
    {
        "GP310",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000009a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp310
    },
    {
        "GP311",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000009b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp311
    },
    {
        "GP312",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000009c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp312
    },
    {
        "GP313",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000009d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp313
    },
    {
        "GP314",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000009e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp314
    },
    {
        "GP315",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x000009f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp315
    },
    {
        "GP40",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a00, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp40
    },
    {
        "GP41",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a10, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp41
    },
    {
        "GP42",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a20, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp42
    },
    {
        "GP43",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a30, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp43
    },
    {
        "GP44",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a40, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp44
    },
    {
        "GP45",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a50, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp45
    },
    {
        "GP46",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a60, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp46
    },
    {
        "GP47",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a70, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp47
    },
    {
        "GP48",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a80, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp48
    },
    {
        "GP49",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000a90, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp49
    },
    {
        "GP410",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000aa0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp410
    },
    {
        "GP411",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000ab0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp411
    },
    {
        "GP412",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000ac0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp412
    },
    {
        "GP413",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000ad0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp413
    },
    {
        "GP414",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000ae0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp414
    },
    {
        "GP415",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000af0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp415
    },
    {
        "GP50",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000b00, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp50
    },
    {
        "GP51",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000b10, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp51
    },
    {
        "GP52",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000b20, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp52
    },
    {
        "GP53",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000b30, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp53
    },
    {
        "GP54",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000b40, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp54
    },
    {
        "GP55",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000b50, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp55
    },
    {
        "GP56",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000b60, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp56
    },
    {
        "GP57",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000b70, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp57
    },
    {
        "GP58",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000b80, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp58
    },
    {
        "GP59",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000b90, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp59
    },
    {
        "GP510",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000ba0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp510
    },
    {
        "GP511",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000bb0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp511
    },
    {
        "GP512",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000bc0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp512
    },
    {
        "GP513",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000bd0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp513
    },
    {
        "GP514",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000be0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp514
    },
    {
        "GP515",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000bf0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp515
    },
    {
        "GP60",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000c00, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp60
    },
    {
        "GP61",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000c10, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp61
    },
    {
        "GP62",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000c20, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp62
    },
    {
        "GP63",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000c30, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp63
    },
    {
        "GP64",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000c40, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp64
    },
    {
        "GP65",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000c50, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp65
    },
    {
        "GP66",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000c60, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp66
    },
    {
        "GP67",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000c70, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp67
    },
    {
        "GP70",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000c80, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp70
    },
    {
        "GP71",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000c90, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp71
    },
    {
        "GP72",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000ca0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp72
    },
    {
        "GP73",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000cb0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp73
    },
    {
        "GP80",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000cc0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp80
    },
    {
        "GP81",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000cd0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp81
    },
    {
        "GP82",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000ce0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp82
    },
    {
        "GP83",
        "Copied from the OTP automatically after reset.",
        4, // Width in bytes
        0x00000cf0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_ocotp_gp83
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PMU
#endif

// Bitfields in register PMU_REG_1P1.
static const field_t hw_pmu_reg_1p1[] =
{
    {
        "ENABLE_LINREG",
        "Control bit to enable the regulator output.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_BO",
        "Control bit to enable the brownout circuitry in the regulator.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ILIMIT",
        "Control bit to enable the current-limit circuitry in the regulator.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PULLDOWN",
        "Control bit to enable the pull-down circuitry in the regulator",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_OFFSET",
        "Control bits to adjust the regulator brownout offset voltage in 25mV s"
        "teps.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTPUT_TRG",
        "Control bits to adjust the regulator output voltage.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_VDD1P1",
        "Status bit that signals when a brownout is detected on the regulator o"
        "utput.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OK_VDD1P1",
        "Status bit that signals when the regulator output is ok.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENABLE_WEAK_LINREG",
        "Enables the weak 1p1 regulator.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SELREF_WEAK_LINREG",
        "Selects the source for the reference voltage of the weak 1p1 regulator"
        ".",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_REG_3P0.
static const field_t hw_pmu_reg_3p0[] =
{
    {
        "ENABLE_LINREG",
        "Control bit to enable the regulator output to be set by the programmed"
        " target voltage setting and internal bandgap reference.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_BO",
        "Control bit to enable the brownout circuitry in the regulator.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ILIMIT",
        "Control bit to enable the current-limit circuitry in the regulator.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_OFFSET",
        "Control bits to adjust the regulator brownout offset voltage in 25mV s"
        "teps.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VBUS_SEL",
        "Select input voltage source for LDO_3P0 from either USB_OTG1_VBUS or U"
        "SB_OTG2_VBUS.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTPUT_TRG",
        "Control bits to adjust the regulator output voltage.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_VDD3P0",
        "Status bit that signals when a brownout is detected on the regulator o"
        "utput.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OK_VDD3P0",
        "Status bit that signals when the regulator output is ok.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_REG_2P5.
static const field_t hw_pmu_reg_2p5[] =
{
    {
        "ENABLE_LINREG",
        "Control bit to enable the regulator output.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_BO",
        "Control bit to enable the brownout circuitry in the regulator.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_ILIMIT",
        "Control bit to enable the current-limit circuitry in the regulator.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_PULLDOWN",
        "Control bit to enable the pull-down circuitry in the regulator",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_OFFSET",
        "Control bits to adjust the regulator brownout offset voltage in 25mV s"
        "teps.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OUTPUT_TRG",
        "Control bits to adjust the regulator output voltage.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BO_VDD2P5",
        "Status bit that signals when a brownout is detected on the regulator o"
        "utput.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OK_VDD2P5",
        "Status bit that signals when the regulator output is ok.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENABLE_WEAK_LINREG",
        "Enables the weak 2p5 regulator.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_REG_CORE.
static const field_t hw_pmu_reg_core[] =
{
    {
        "REG0_TARG",
        "This field defines the target voltage for the ARM core power domain.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_TARG",
        "This field defines the target voltage for the SOC power domain.",
        18, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RAMP_RATE",
        "Regulator voltage ramp rate.",
        27, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FET_ODRIVE",
        "If set, increases the gate drive on power gating FETs to reduce leakag"
        "e in the off state.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC0.
static const field_t hw_pmu_misc0[] =
{
    {
        "REFTOP_PWD",
        "Control bit to power-down the analog bandgap reference circuitry.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_SELFBIASOFF",
        "Control bit to disable the self-bias circuit in the analog bandgap.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGADJ",
        "",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGUP",
        "Status bit that signals the analog bandgap voltage is up and stable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_MODE_CONFIG",
        "Configure the analog behavior in stop mode.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCON_HIGH_SNVS",
        "This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_I",
        "This field determines the bias current in the 24MHz oscillator.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_XTALOK",
        "Status bit that signals that the output of the 24-MHz crystal oscillat"
        "or is stable.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSC_XTALOK_EN",
        "This bit enables the detector that signals when the 24MHz crystal osci"
        "llator is stable.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_CTRL",
        "This bit allows disabling the clock gate (always ungated) for the xtal"
        " 24MHz clock that clocks the digital logic in the analog block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_DELAY",
        "This field specifies the delay between powering up the XTAL 24MHz cloc"
        "k and releasing the clock to the digital logic inside the analog block"
        ".",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_XTAL_SOURCE",
        "This field indicates which chip source is being used for the rtc clock"
        ".",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTAL_24M_PWD",
        "This field powers down the 24M crystal oscillator if set true.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_PLL_PREDIV",
        "Predivider for the source clock of the PLL's.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC1.
static const field_t hw_pmu_misc1[] =
{
    {
        "PFD_480_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_480 clocks an"
        "ytime the USB1_PLL_480 is unlocked or powered off.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_528_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_528 clocks an"
        "ytime the PLL_528 is unlocked or powered off.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPPANIC",
        "This status bit is set to one when the temperature sensor panic interr"
        "upt asserts for a panic high temperature.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPLOW",
        "This status bit is set to one when the temperature sensor low interrup"
        "t asserts for low temperature.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPHIGH",
        "This status bit is set to one when the temperature sensor high interru"
        "pt asserts for high temperature.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC1_SET.
static const field_t hw_pmu_misc1_set[] =
{
    {
        "PFD_480_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_480 clocks an"
        "ytime the USB1_PLL_480 is unlocked or powered off.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_528_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_528 clocks an"
        "ytime the PLL_528 is unlocked or powered off.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPPANIC",
        "This status bit is set to one when the temperature sensor panic interr"
        "upt asserts for a panic high temperature.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPLOW",
        "This status bit is set to one when the temperature sensor low interrup"
        "t asserts for low temperature.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPHIGH",
        "This status bit is set to one when the temperature sensor high interru"
        "pt asserts for high temperature.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC1_CLR.
static const field_t hw_pmu_misc1_clr[] =
{
    {
        "PFD_480_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_480 clocks an"
        "ytime the USB1_PLL_480 is unlocked or powered off.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_528_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_528 clocks an"
        "ytime the PLL_528 is unlocked or powered off.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPPANIC",
        "This status bit is set to one when the temperature sensor panic interr"
        "upt asserts for a panic high temperature.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPLOW",
        "This status bit is set to one when the temperature sensor low interrup"
        "t asserts for low temperature.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPHIGH",
        "This status bit is set to one when the temperature sensor high interru"
        "pt asserts for high temperature.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC1_TOG.
static const field_t hw_pmu_misc1_tog[] =
{
    {
        "PFD_480_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_480 clocks an"
        "ytime the USB1_PLL_480 is unlocked or powered off.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFD_528_AUTOGATE_EN",
        "This enables a feature that will clkgate (reset) all PFD_528 clocks an"
        "ytime the PLL_528 is unlocked or powered off.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPPANIC",
        "This status bit is set to one when the temperature sensor panic interr"
        "upt asserts for a panic high temperature.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPLOW",
        "This status bit is set to one when the temperature sensor low interrup"
        "t asserts for low temperature.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_TEMPHIGH",
        "This status bit is set to one when the temperature sensor high interru"
        "pt asserts for high temperature.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ANA_BO",
        "This status bit is set to one when when any of the analog regulator br"
        "ownout interrupts assert.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_DIG_BO",
        "This status bit is set to one when when any of the digital regulator b"
        "rownout interrupts assert.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC2.
static const field_t hw_pmu_misc2[] =
{
    {
        "REG0_BO_OFFSET",
        "This field defines the brown out voltage offset for the CORE power dom"
        "ain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "Default value of \"0\".",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC2_SET.
static const field_t hw_pmu_misc2_set[] =
{
    {
        "REG0_BO_OFFSET",
        "This field defines the brown out voltage offset for the CORE power dom"
        "ain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "Default value of \"0\".",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC2_CLR.
static const field_t hw_pmu_misc2_clr[] =
{
    {
        "REG0_BO_OFFSET",
        "This field defines the brown out voltage offset for the CORE power dom"
        "ain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "Default value of \"0\".",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_MISC2_TOG.
static const field_t hw_pmu_misc2_tog[] =
{
    {
        "REG0_BO_OFFSET",
        "This field defines the brown out voltage offset for the CORE power dom"
        "ain.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_BO_STATUS",
        "Reg0 brownout status bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG0_ENABLE_BO",
        "Enables the brownout detection.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PLL3_DISABLE",
        "Default value of \"0\".",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUDIO_DIV_LSB",
        "LSB of Post-divider for Audio PLL.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_BO_OFFSET",
        "This field defines the brown out voltage offset for the xPU power doma"
        "in.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_BO_STATUS",
        "Reg2 brownout status bit.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REG2_ENABLE_BO",
        "Enables the brownout detection.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_OK",
        "Signals that the voltage is above the brownout level for the SOC suppl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AUDIO_DIV_MSB",
        "MSB of Post-divider for Audio PLL.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG0_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REG2_STEP_TIME",
        "Number of clock periods (24MHz clock).",
        28, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VIDEO_DIV",
        "Post-divider for video.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_LOWPWR_CTRL_SET.
static const field_t hw_pmu_lowpwr_ctrl_set[] =
{
    {
        "RC_OSC_EN",
        "RC Osc.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_SEL",
        "Select the source for the 24MHz clock.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_SEL",
        "Bandgap select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_TEST",
        "Low power bandgap test bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_IBIAS_OFF",
        "Low power reftop ibias disable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1_PWRGATE",
        "L1 power gate control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PWRGATE",
        "L2 power gate control.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPU_PWRGATE",
        "CPU power gate control.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PWRGATE",
        "Display logic power gate control.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCOSC_CG_OVERRIDE",
        "For debug purposes only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_DELAY",
        "Specifies the time delay between when the 24MHz xtal is powered up unt"
        "il it is stable and ready to use.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_STAT",
        "Status of the 24MHz xtal oscillator.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIX_PWRGATE",
        "Display power gate control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_PWRGATE",
        "GPU power gate control.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_LOWPWR_CTRL_CLR.
static const field_t hw_pmu_lowpwr_ctrl_clr[] =
{
    {
        "RC_OSC_EN",
        "RC Osc.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_SEL",
        "Select the source for the 24MHz clock.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_SEL",
        "Bandgap select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_TEST",
        "Low power bandgap test bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_IBIAS_OFF",
        "Low power reftop ibias disable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1_PWRGATE",
        "L1 power gate control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PWRGATE",
        "L2 power gate control.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPU_PWRGATE",
        "CPU power gate control.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PWRGATE",
        "Display logic power gate control.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCOSC_CG_OVERRIDE",
        "For debug purposes only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_DELAY",
        "Specifies the time delay between when the 24MHz xtal is powered up unt"
        "il it is stable and ready to use.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_STAT",
        "Status of the 24MHz xtal oscillator.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIX_PWRGATE",
        "Display power gate control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_PWRGATE",
        "GPU power gate control.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PMU_LOWPWR_CTRL_TOG.
static const field_t hw_pmu_lowpwr_ctrl_tog[] =
{
    {
        "RC_OSC_EN",
        "RC Osc.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_SEL",
        "Select the source for the 24MHz clock.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_SEL",
        "Bandgap select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_TEST",
        "Low power bandgap test bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_IBIAS_OFF",
        "Low power reftop ibias disable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1_PWRGATE",
        "L1 power gate control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PWRGATE",
        "L2 power gate control.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPU_PWRGATE",
        "CPU power gate control.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PWRGATE",
        "Display logic power gate control.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCOSC_CG_OVERRIDE",
        "For debug purposes only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_DELAY",
        "Specifies the time delay between when the 24MHz xtal is powered up unt"
        "il it is stable and ready to use.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_STAT",
        "Status of the 24MHz xtal oscillator.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIX_PWRGATE",
        "Display power gate control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_PWRGATE",
        "GPU power gate control.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a PMU module.
static const reg_t hw_pmu[] =
{
    {
        "REG_1P1",
        "This register defines the control and status bits for the 1.1V regulat"
        "or.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_pmu_reg_1p1
    },
    {
        "REG_3P0",
        "This register defines the control and status bits for the 3.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pmu_reg_3p0
    },
    {
        "REG_2P5",
        "This register defines the control and status bits for the 2.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_pmu_reg_2p5
    },
    {
        "REG_CORE",
        "This register defines the function of the digital regulators",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pmu_reg_core
    },
    {
        "MISC0",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_pmu_misc0
    },
    {
        "MISC1",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_pmu_misc1
    },
    {
        "MISC1_SET",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_pmu_misc1_set
    },
    {
        "MISC1_CLR",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_pmu_misc1_clr
    },
    {
        "MISC1_TOG",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_pmu_misc1_tog
    },
    {
        "MISC2",
        "This register defines the control for miscellaneous PMU Analog blocks.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_pmu_misc2
    },
    {
        "MISC2_SET",
        "This register defines the control for miscellaneous PMU Analog blocks.",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_pmu_misc2_set
    },
    {
        "MISC2_CLR",
        "This register defines the control for miscellaneous PMU Analog blocks.",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_pmu_misc2_clr
    },
    {
        "MISC2_TOG",
        "This register defines the control for miscellaneous PMU Analog blocks.",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_pmu_misc2_tog
    },
    {
        "LOWPWR_CTRL_SET",
        "This register defines the low power configuration bits.",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_pmu_lowpwr_ctrl_set
    },
    {
        "LOWPWR_CTRL_CLR",
        "This register defines the low power configuration bits.",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_pmu_lowpwr_ctrl_clr
    },
    {
        "LOWPWR_CTRL_TOG",
        "This register defines the low power configuration bits.",
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_pmu_lowpwr_ctrl_tog
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PWM
#endif

// Bitfields in register PWM_PWMCR.
static const field_t hw_pwm_pwmcr[] =
{
    {
        "EN",
        "PWM Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REPEAT",
        "Sample Repeat.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWR",
        "Software Reset.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PRESCALER",
        "Counter Clock Prescaler Value.",
        4, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKSRC",
        "Select Clock Source.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "POUTC",
        "PWM Output Configuration.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCTR",
        "Half-word Data Swap Control.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCTR",
        "Byte Data Swap Control.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "Debug Mode Enable.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAITEN",
        "Wait Mode Enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZEN",
        "Doze Mode Enable.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOPEN",
        "Stop Mode Enable.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWM",
        "FIFO Water Mark.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMSR.
static const field_t hw_pwm_pwmsr[] =
{
    {
        "FIFOAV",
        "FIFO Available.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FE",
        "FIFO Empty Status Bit.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROV",
        "Roll-over Status.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMP",
        "Compare Status.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FWE",
        "FIFO Write Error Status.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMIR.
static const field_t hw_pwm_pwmir[] =
{
    {
        "FIE",
        "FIFO Empty Interrupt Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIE",
        "Roll-over Interrupt Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIE",
        "Compare Interrupt Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMSAR.
static const field_t hw_pwm_pwmsar[] =
{
    {
        "SAMPLE",
        "Sample Value.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMPR.
static const field_t hw_pwm_pwmpr[] =
{
    {
        "PERIOD",
        "Period Value.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PWM_PWMCNR.
static const field_t hw_pwm_pwmcnr[] =
{
    {
        "COUNT",
        "Counter Value.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a PWM module.
static const reg_t hw_pwm[] =
{
    {
        "PWMCR",
        "The PWM control register (PWM_PWMCR) is used to configure the operatin"
        "g settings of the PWM.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_pwm_pwmcr
    },
    {
        "PWMSR",
        "The PWM status register (PWM_PWMSR) contains seven bits which display "
        "the state of the FIFO and the occurrence of rollover and compare event"
        "s.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pwm_pwmsr
    },
    {
        "PWMIR",
        "The PWM Interrupt register (PWM_PWMIR) contains three bits which contr"
        "ol the generation of the compare, rollover and FIFO empty interrupts.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pwm_pwmir
    },
    {
        "PWMSAR",
        "The PWM sample register (PWM_PWMSAR) is the input to the FIFO.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pwm_pwmsar
    },
    {
        "PWMPR",
        "The PWM period register (PWM_PWMPR) determines the period of the PWM o"
        "utput signal.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pwm_pwmpr
    },
    {
        "PWMCNR",
        "The read-only pulse-width modulator counter register (PWM_PWMCNR) cont"
        "ains the current count value and can be read at any time without distu"
        "rbing the counter.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_pwm_pwmcnr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark PXP
#endif

// Bitfields in register PXP_CTRL.
static const field_t hw_pxp_ctrl[] =
{
    {
        "ENABLE",
        "Enables PXP operation with specified parameters.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRQ_ENABLE",
        "Interrupt enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT_IRQ_ENABLE",
        "Next command interrupt enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LUT_DMA_IRQ_ENABLE",
        "LUT DMA interrupt enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_LCD_HANDSHAKE",
        "Enable handshake with LCD controller.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "ROTATE",
        "Indicates the clockwise rotation to be applied at the output buffer.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HFLIP",
        "Indicates that the output buffer should be flipped horizontally (effec"
        "t applied before rotation).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VFLIP",
        "Indicates that the output buffer should be flipped vertically (effect "
        "applied before rotation).",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        12, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ROT_POS",
        "This bit controls where rotation will occur in the PXP datapath.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BLOCK_SIZE",
        "Select the block size to process.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved, always set to zero.",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EN_REPEAT",
        "Enable the PXP to run continuously.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD4",
        "Reserved, always set to zero.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "This bit must be set to zero for normal operation.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Set this bit to zero to enable normal PXP operation.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_STAT.
static const field_t hw_pxp_stat[] =
{
    {
        "IRQ",
        "Indicates current PXP interrupt status.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_WRITE_ERROR",
        "Indicates PXP encountered an AXI write error and processing has been t"
        "erminated.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_READ_ERROR",
        "Indicates PXP encountered an AXI read error and processing has been te"
        "rminated.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NEXT_IRQ",
        "Indicates that a command issued with the \"Next Command\" functionalit"
        "y has been issued and that a new command may be initiated with a write"
        " to the PXP_NEXT register.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AXI_ERROR_ID",
        "Indicates the AXI ID of the failing bus operation.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LUT_DMA_LOAD_DONE_IRQ",
        "Indicates that the LUT DMA transfer has completed.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set to zero.",
        9, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BLOCKY",
        "Indicates the X coordinate of the block currently being rendered.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BLOCKX",
        "Indicates the X coordinate of the block currently being rendered.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_CTRL.
static const field_t hw_pxp_out_ctrl[] =
{
    {
        "FORMAT",
        "Output framebuffer format.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INTERLACED_OUTPUT",
        "Determines how the PXP writes it's output data.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        10, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALPHA_OUTPUT",
        "Indicates that alpha component in output buffer pixels should be overw"
        "ritten by PXP_OUT_CTRL[ALPHA].",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA",
        "When generating an output buffer with an alpha component, the value in"
        " this field will be used when enabled to override the alpha passed thr"
        "ough the pixel data pipeline.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_BUF.
static const field_t hw_pxp_out_buf[] =
{
    {
        "ADDR",
        "Current address pointer for the output frame buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_BUF2.
static const field_t hw_pxp_out_buf2[] =
{
    {
        "ADDR",
        "Current address pointer for the output frame buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_PITCH.
static const field_t hw_pxp_out_pitch[] =
{
    {
        "PITCH",
        "Indicates the number of bytes in memory between two vertically adjacen"
        "t pixels.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "Reserved, always set to zero.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_LRC.
static const field_t hw_pxp_out_lrc[] =
{
    {
        "Y",
        "Indicates the number of vertical PIXELS in the output surface (non-rot"
        "ated).",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "X",
        "Indicates number of horizontal PIXELS in the output surface (non-rotat"
        "ed).",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_PS_ULC.
static const field_t hw_pxp_out_ps_ulc[] =
{
    {
        "Y",
        "This field indicates the upper left Y-coordinate (in pixels) of the pr"
        "ocessed surface in the output buffer.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "X",
        "This field indicates the upper left X-coordinate (in pixels) of the pr"
        "ocessed surface (PS) in the output buffer.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_PS_LRC.
static const field_t hw_pxp_out_ps_lrc[] =
{
    {
        "Y",
        "This field indicates the lower right Y-coordinate (in pixels) of the p"
        "rocessed surface in the output frame buffer.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "X",
        "This field indicates the lower right X-coordinate (in pixels) of the p"
        "rocessed surface (PS) in the output frame buffer.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_AS_ULC.
static const field_t hw_pxp_out_as_ulc[] =
{
    {
        "Y",
        "This field indicates the upper left Y-coordinate (in pixels) of the al"
        "pha surface in the output frame buffer.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "X",
        "This field indicates the upper left X-coordinate (in pixels) of the al"
        "pha surface (AS) in the output frame buffer.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_OUT_AS_LRC.
static const field_t hw_pxp_out_as_lrc[] =
{
    {
        "Y",
        "This field indicates the lower right Y-coordinate (in pixels) of the a"
        "lpha surface in the output frame buffer.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "X",
        "This field indicates the lower right X-coordinate (in pixels) of the a"
        "lpha surface (AS) in the output frame buffer.",
        16, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_CTRL.
static const field_t hw_pxp_ps_ctrl[] =
{
    {
        "FORMAT",
        "PS buffer format.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WB_SWAP",
        "Swap bytes in words.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DECY",
        "Verticle pre decimation filter control.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DECX",
        "Horizontal pre decimation filter control.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        12, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_BUF.
static const field_t hw_pxp_ps_buf[] =
{
    {
        "ADDR",
        "Address pointer for the PS RGB or Y (luma) input buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_UBUF.
static const field_t hw_pxp_ps_ubuf[] =
{
    {
        "ADDR",
        "Address pointer for the PS U/Cb or 2 plane UV Chroma input buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_VBUF.
static const field_t hw_pxp_ps_vbuf[] =
{
    {
        "ADDR",
        "Address pointer for the PS V/Cr Chroma input buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_PITCH.
static const field_t hw_pxp_ps_pitch[] =
{
    {
        "PITCH",
        "Indicates the number of bytes in memory between two vertically adjacen"
        "t pixels.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "Reserved, always set to zero.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_BACKGROUND.
static const field_t hw_pxp_ps_background[] =
{
    {
        "COLOR",
        "Background color (in 24bpp format) for any pixels not within the buffe"
        "r range specified by the PS ULC/LRC.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_SCALE.
static const field_t hw_pxp_ps_scale[] =
{
    {
        "XSCALE",
        "This is a two bit integer and 12 bit fractional representation (##.###"
        "#_####_####) of the X scaling factor for the PS source buffer.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YSCALE",
        "This is a two bit integer and 12 bit fractional representation (##.###"
        "#_####_####) of the Y scaling factor for the PS source buffer.",
        16, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set to zero.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_OFFSET.
static const field_t hw_pxp_ps_offset[] =
{
    {
        "XOFFSET",
        "This is a 12 bit fractional representation (0.####_####_####) of the X"
        " scaling offset.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "YOFFSET",
        "This is a 12 bit fractional representation (0.####_####_####) of the Y"
        " scaling offset.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set to zero.",
        28, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_CLRKEYLOW.
static const field_t hw_pxp_ps_clrkeylow[] =
{
    {
        "PIXEL",
        "Low range of color key applied to PS buffer.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_PS_CLRKEYHIGH.
static const field_t hw_pxp_ps_clrkeyhigh[] =
{
    {
        "PIXEL",
        "High range of color key applied to PS buffer.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_AS_CTRL.
static const field_t hw_pxp_as_ctrl[] =
{
    {
        "RSVD0",
        "Reserved, always set to zero.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALPHA_CTRL",
        "Determines how the alpha value is constructed for this alpha surface.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_COLORKEY",
        "Indicates that colorkey functionality is enabled for this alpha surfac"
        "e.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FORMAT",
        "Indicates the input buffer format for AS.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA",
        "Alpha modifier used when the ALPHA_MULTIPLY or ALPHA_OVERRIDE values a"
        "re programmed in PXP_AS_CTRL[ALPHA_CTRL].",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROP",
        "Indicates a raster operation to perform when enabled.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALPHA_INVERT",
        "Setting this bit to logic 0 will not alter the alpha value.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        21, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_AS_BUF.
static const field_t hw_pxp_as_buf[] =
{
    {
        "ADDR",
        "Address pointer for the alpha surface 0 buffer.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_AS_PITCH.
static const field_t hw_pxp_as_pitch[] =
{
    {
        "PITCH",
        "Indicates the number of bytes in memory between two vertically adjacen"
        "t pixels.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "Reserved, always set to zero.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_AS_CLRKEYLOW.
static const field_t hw_pxp_as_clrkeylow[] =
{
    {
        "PIXEL",
        "Low range of RGB color key applied to AS buffer.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_AS_CLRKEYHIGH.
static const field_t hw_pxp_as_clrkeyhigh[] =
{
    {
        "PIXEL",
        "High range of RGB color key applied to AS buffer.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC1_COEF0.
static const field_t hw_pxp_csc1_coef0[] =
{
    {
        "Y_OFFSET",
        "Two's compliment amplitude offset implicit in the Y data.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UV_OFFSET",
        "Two's compliment phase offset implicit for CbCr data.",
        9, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "C0",
        "Two's compliment Y multiplier coefficient.",
        18, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BYPASS",
        "Bypass the CSC unit in the scaling engine.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YCBCR_MODE",
        "Set to 1 when performing YCbCr conversion to RGB.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC1_COEF1.
static const field_t hw_pxp_csc1_coef1[] =
{
    {
        "C4",
        "Two's compliment Blue U/Cb multiplier coefficient.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "C1",
        "Two's compliment Red V/Cr multiplier coefficient.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        27, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC1_COEF2.
static const field_t hw_pxp_csc1_coef2[] =
{
    {
        "C3",
        "Two's complement Green U/Cb multiplier coefficient.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "C2",
        "Two's complement Green V/Cr multiplier coefficient.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        27, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_CTRL.
static const field_t hw_pxp_csc2_ctrl[] =
{
    {
        "BYPASS",
        "This bit controls whether the pixels entering the CSC2 unit get conver"
        "ted or not.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSC_MODE",
        "This field controls how the CSC unit operates on pixels when the CSC i"
        "s not bypassed.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "Reserved, always set to zero.",
        3, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF0.
static const field_t hw_pxp_csc2_coef0[] =
{
    {
        "A1",
        "Two's complement coefficient offset.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "A2",
        "Two's complement coefficient offset.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        27, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF1.
static const field_t hw_pxp_csc2_coef1[] =
{
    {
        "A3",
        "Two's complement coefficient offset.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "B1",
        "Two's complement coefficient offset.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        27, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF2.
static const field_t hw_pxp_csc2_coef2[] =
{
    {
        "B2",
        "Two's complement coefficient offset.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "B3",
        "Two's complement coefficient offset.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        27, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF3.
static const field_t hw_pxp_csc2_coef3[] =
{
    {
        "C1",
        "Two's complement coefficient offset.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "C2",
        "Two's complement coefficient offset.",
        16, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        27, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF4.
static const field_t hw_pxp_csc2_coef4[] =
{
    {
        "C3",
        "Two's complement coefficient offset.",
        0, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "D1",
        "Two's complement coefficient integer offset to be added.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        25, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CSC2_COEF5.
static const field_t hw_pxp_csc2_coef5[] =
{
    {
        "D2",
        "Two's complement D1 coefficient integer offset to be added.",
        0, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        9, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "D3",
        "Two's complement coefficient integer offset to be added.",
        16, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        25, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_LUT_CTRL.
static const field_t hw_pxp_lut_ctrl[] =
{
    {
        "DMA_START",
        "Setting this bit will result in the DMA operation to load the PXP LUT "
        "memory based on PXP_LUT_ADDR_NUM_BYTES, PXP_LUT_ADDR_ADDR, and PXP_LUT"
        "_MEM_ADDR.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        1, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INVALID",
        "Invalidate the cache LRU and valid bits.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LRU_UPD",
        "Least Recently Used Policy Update Control: 1=> block LRU update for hi"
        "t after miss.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEL_8KB",
        "Selects which 8KB bank of memory to use for direct 12bpp lookup modes.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        11, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OUT_MODE",
        "Select the output mode of operation for the LUT resource.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set to zero.",
        18, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOOKUP_MODE",
        "Configure the input address for the 16KB LUT memory.",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved, always set to zero.",
        26, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BYPASS",
        "Setting this bit will bypass the LUT memory resource completely.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_LUT_ADDR.
static const field_t hw_pxp_lut_addr[] =
{
    {
        "ADDR",
        "LUT indexed address pointer.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NUM_BYTES",
        "Indicates the number of bytes to load via a DMA operation.",
        16, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set to zero.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_LUT_DATA.
static const field_t hw_pxp_lut_data[] =
{
    {
        "DATA",
        "Writing this field will load 4 bytes, aligned to four byte boundaries,"
        " of data indexed by the ADDR field of the PXP_LUT_CTRL register.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_LUT_EXTMEM.
static const field_t hw_pxp_lut_extmem[] =
{
    {
        "ADDR",
        "This register contains the external memory address used for LUT memory"
        " operation.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_CFA.
static const field_t hw_pxp_cfa[] =
{
    {
        "DATA",
        "This register contains the Color Filter Array pattern for decimation o"
        "f RGBW4444 16 bit pixels to individual R, G, B, W values.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST_CTRL.
static const field_t hw_pxp_hist_ctrl[] =
{
    {
        "STATUS",
        "Indicates which histogram matched the processed bitmap.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PANEL_MODE",
        "This value is used to specify the number of bits used in comparisons w"
        "hen matching pixels to histogram bins.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD",
        "Reserved, always set to zero.",
        6, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST2_PARAM.
static const field_t hw_pxp_hist2_param[] =
{
    {
        "VALUE0",
        "Black value for 2-level histogram",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE1",
        "White value for 2-level histogram",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD",
        "Reserved, always set to zero.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST4_PARAM.
static const field_t hw_pxp_hist4_param[] =
{
    {
        "VALUE0",
        "GRAY0 (Black) value for 4-level histogram",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE1",
        "GRAY1 value for 4-level histogram",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE2",
        "GRAY2 value for 4-level histogram",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set to zero.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE3",
        "GRAY3 (White) value for 4-level histogram",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved, always set to zero.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST8_PARAM0.
static const field_t hw_pxp_hist8_param0[] =
{
    {
        "VALUE0",
        "GRAY0 (Black) value for 8-level histogram",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE1",
        "GRAY1 value for 8-level histogram",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE2",
        "GRAY2 value for 8-level histogram",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set to zero.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE3",
        "GRAY3 value for 8-level histogram",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved, always set to zero.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST8_PARAM1.
static const field_t hw_pxp_hist8_param1[] =
{
    {
        "VALUE4",
        "GRAY4 value for 8-level histogram",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD4",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE5",
        "GRAY5 value for 8-level histogram",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "Reserved, always set to zero.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE6",
        "GRAY6 value for 8-level histogram",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD6",
        "Reserved, always set to zero.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE7",
        "GRAY7 (White) value for 8-level histogram",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD7",
        "Reserved, always set to zero.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST16_PARAM0.
static const field_t hw_pxp_hist16_param0[] =
{
    {
        "VALUE0",
        "GRAY0 (Black) value for 16-level histogram",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE1",
        "GRAY1 value for 16-level histogram",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved, always set to zero.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE2",
        "GRAY2 value for 16-level histogram",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved, always set to zero.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE3",
        "GRAY3 value for 16-level histogram",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved, always set to zero.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST16_PARAM1.
static const field_t hw_pxp_hist16_param1[] =
{
    {
        "VALUE4",
        "GRAY4 value for 16-level histogram",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD4",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE5",
        "GRAY5 value for 16-level histogram",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "Reserved, always set to zero.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE6",
        "GRAY6 value for 16-level histogram",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD6",
        "Reserved, always set to zero.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE7",
        "GRAY7 value for 16-level histogram",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD7",
        "Reserved, always set to zero.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST16_PARAM2.
static const field_t hw_pxp_hist16_param2[] =
{
    {
        "VALUE8",
        "GRAY8 value for 16-level histogram",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD8",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE9",
        "GRAY9 value for 16-level histogram",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD9",
        "Reserved, always set to zero.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE10",
        "GRAY10 value for 16-level histogram",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD10",
        "Reserved, always set to zero.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE11",
        "GRAY11 value for 16-level histogram",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD11",
        "Reserved, always set to zero.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_HIST16_PARAM3.
static const field_t hw_pxp_hist16_param3[] =
{
    {
        "VALUE12",
        "GRAY12 value for 16-level histogram",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD12",
        "Reserved, always set to zero.",
        5, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE13",
        "GRAY13 value for 16-level histogram",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD13",
        "Reserved, always set to zero.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE14",
        "GRAY14 value for 16-level histogram",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD14",
        "Reserved, always set to zero.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALUE15",
        "GRAY15 (White) value for 16-level histogram",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD15",
        "Reserved, always set to zero.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_POWER.
static const field_t hw_pxp_power[] =
{
    {
        "LUT_LP_STATE_WAY0_BANK0",
        "Select the low power state of the LUT's WAY0-BANK0 memory.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LUT_LP_STATE_WAY0_BANKN",
        "Select the low power state of the LUT's WAY0-BANK1,2,3 memory.",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LUT_LP_STATE_WAY1_BANKN",
        "Select the low power state of the LUT's WAY0-BANK0,1,2,3 memory.",
        6, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROT_MEM_LP_STATE",
        "Select the low power state of the ROT memory.",
        9, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTRL",
        "This register contains power control for the PXP.",
        12, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register PXP_NEXT.
static const field_t hw_pxp_next[] =
{
    {
        "ENABLED",
        "Indicates that the \"next frame\" functionality has been enabled.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD",
        "Reserved, always set to zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "POINTER",
        "A pointer to a data structure containing register values to be used wh"
        "en processing the next frame.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a PXP module.
static const reg_t hw_pxp[] =
{
    {
        "CTRL",
        "The CTRL register contains controls for the PXP module.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_pxp_ctrl
    },
    {
        "STAT",
        "The PXP Interrupt Status register provides interrupt status informatio"
        "n.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_pxp_stat
    },
    {
        "OUT_CTRL",
        "The OUT_CTRL register contains controls for the Output Buffer.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pxp_out_ctrl
    },
    {
        "OUT_BUF",
        "Output Framebuffer Pointer.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_out_buf
    },
    {
        "OUT_BUF2",
        "Output Framebuffer Pointer #2.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_out_buf2
    },
    {
        "OUT_PITCH",
        "This register contains the output buffer pitch in bytes.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_out_pitch
    },
    {
        "OUT_LRC",
        "This register contains the size, or lower right coordinate, of the out"
        "put buffer NOT rotated.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_out_lrc
    },
    {
        "OUT_PS_ULC",
        "This register contains the upper left pixel coordinate for the Process"
        "ed Surface in the OUTPUT buffer.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_out_ps_ulc
    },
    {
        "OUT_PS_LRC",
        "This register contains the lower right extent for the Processed Surfac"
        "e in the OUTPUT buffer.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_out_ps_lrc
    },
    {
        "OUT_AS_ULC",
        "This register contains the upper left location for the Alpha Surface i"
        "n the output buffer.",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_out_as_ulc
    },
    {
        "OUT_AS_LRC",
        "This register contains the lower right extent for Alpha Surface in the"
        " output buffer.",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_out_as_lrc
    },
    {
        "PS_CTRL",
        "The PS_CTRL register contains controls for the Processed Surface Buffe"
        "r.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pxp_ps_ctrl
    },
    {
        "PS_BUF",
        "PS Input Buffer Address.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_ps_buf
    },
    {
        "PS_UBUF",
        "PS Chroma (U/Cb/UV) Input Buffer Address.",
        4, // Width in bytes
        0x000000d0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_ps_ubuf
    },
    {
        "PS_VBUF",
        "PS Chroma (V/Cr) Input Buffer Address.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_ps_vbuf
    },
    {
        "PS_PITCH",
        "This register contains the processed surface pitch in bytes.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_ps_pitch
    },
    {
        "PS_BACKGROUND",
        "PS Background Pixel Color.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_ps_background
    },
    {
        "PS_SCALE",
        "PS Scale Factor.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_ps_scale
    },
    {
        "PS_OFFSET",
        "PS Scale Offset.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_ps_offset
    },
    {
        "PS_CLRKEYLOW",
        "This register contains the color key low value for the PS buffer.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_ps_clrkeylow
    },
    {
        "PS_CLRKEYHIGH",
        "This register contains the color key high value for the PS buffer.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_ps_clrkeyhigh
    },
    {
        "AS_CTRL",
        "This register contains buffer control for the Alpha Surface 0 input bu"
        "ffer.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_as_ctrl
    },
    {
        "AS_BUF",
        "Alpha Surface 0 Buffer Address Pointer.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_as_buf
    },
    {
        "AS_PITCH",
        "This register contains the alpha surface pitch in bytes.",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_as_pitch
    },
    {
        "AS_CLRKEYLOW",
        "This register contains the color key low value for the AS buffer.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_as_clrkeylow
    },
    {
        "AS_CLRKEYHIGH",
        "This register contains the color key high value for the AS buffer.",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_pxp_as_clrkeyhigh
    },
    {
        "CSC1_COEF0",
        "This register contains color space conversion coefficients in two's co"
        "mpliment notation.",
        4, // Width in bytes
        0x000001a0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_pxp_csc1_coef0
    },
    {
        "CSC1_COEF1",
        "This register contains color space conversion coefficients in two's co"
        "mpliment notation.",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_csc1_coef1
    },
    {
        "CSC1_COEF2",
        "This register contains color space conversion coefficients in two's co"
        "mpliment notation.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_csc1_coef2
    },
    {
        "CSC2_CTRL",
        "This register contains the control registers to configure the CSC modu"
        "le.",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pxp_csc2_ctrl
    },
    {
        "CSC2_COEF0",
        "This register contains color space conversion coefficients in two's co"
        "mplement notation.",
        4, // Width in bytes
        0x000001e0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_csc2_coef0
    },
    {
        "CSC2_COEF1",
        "This register contains color space conversion coefficients in two's co"
        "mplement notation.",
        4, // Width in bytes
        0x000001f0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_csc2_coef1
    },
    {
        "CSC2_COEF2",
        "This register contains color space conversion coefficients in two's co"
        "mplement notation.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_csc2_coef2
    },
    {
        "CSC2_COEF3",
        "This register contains color space conversion coefficients in two's co"
        "mplement notation.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_csc2_coef3
    },
    {
        "CSC2_COEF4",
        "This register contains color space conversion coefficients in two's co"
        "mplement notation.",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_csc2_coef4
    },
    {
        "CSC2_COEF5",
        "This register contains color space conversion coefficients in two's co"
        "mplement notation.",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_csc2_coef5
    },
    {
        "LUT_CTRL",
        "This register is used to access/control the Monochrome Lookup table.",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_pxp_lut_ctrl
    },
    {
        "LUT_ADDR",
        "This register is used to access/control the Monochrome Lookup table.",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_pxp_lut_addr
    },
    {
        "LUT_DATA",
        "This register is used to load data into the lookup table.",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_lut_data
    },
    {
        "LUT_EXTMEM",
        "For DMA LUT memory loads, this is the base address from which data wil"
        "l be sourced to store into the LUT memory array.",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_lut_extmem
    },
    {
        "CFA",
        "There are sixteen 2 bit values in this register each mapping a selecte"
        "d component to the output pixel.",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_pxp_cfa
    },
    {
        "HIST_CTRL",
        "Provides control and status registers for the PXP's histogram classifi"
        "cation algorithm.",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pxp_hist_ctrl
    },
    {
        "HIST2_PARAM",
        "This register specifies the valid values for a 2-level histogram.",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pxp_hist2_param
    },
    {
        "HIST4_PARAM",
        "This register specifies the valid values for a 4-level histogram.",
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_hist4_param
    },
    {
        "HIST8_PARAM0",
        "This register specifies four of the valid values for an 8-level histog"
        "ram.",
        4, // Width in bytes
        0x000002c0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_hist8_param0
    },
    {
        "HIST8_PARAM1",
        "This register specifies four of the valid values for an 8-level histog"
        "ram.",
        4, // Width in bytes
        0x000002d0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_hist8_param1
    },
    {
        "HIST16_PARAM0",
        "This register specifies four of the valid values for a 16-level histog"
        "ram.",
        4, // Width in bytes
        0x000002e0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_hist16_param0
    },
    {
        "HIST16_PARAM1",
        "This register specifies four of the valid values for a 16-level histog"
        "ram.",
        4, // Width in bytes
        0x000002f0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_hist16_param1
    },
    {
        "HIST16_PARAM2",
        "This register specifies four of the valid values for a 16-level histog"
        "ram.",
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_hist16_param2
    },
    {
        "HIST16_PARAM3",
        "This register specifies four of the valid values for a 16-level histog"
        "ram.",
        4, // Width in bytes
        0x00000310, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_pxp_hist16_param3
    },
    {
        "POWER",
        "",
        4, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_pxp_power
    },
    {
        "NEXT",
        "This register contains a pointer to a data structure used to reload th"
        "e PXP registers at the end of the current frame.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_pxp_next
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark QuadSPI
#endif

// Bitfields in register QuadSPI_MCR.
static const field_t hw_quadspi_mcr[] =
{
    {
        "SWRSTSD",
        "Software reset for serial flash domain",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SWRSTHD",
        "Software reset for AHB domain",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "END_CFG",
        "Defines the endianness of the QuadSPI module.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DQS_EN",
        "DQS enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_EN",
        "DDR mode enable",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLR_RXF",
        "Clear RX FIFO.",
        10, // LSB
        10, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CLR_TXF",
        "Clear TX FIFO/Buffer.",
        11, // LSB
        11, // MSB
        false, // Readable
        false // Writable
    },
    {
        "MDIS",
        "Module Disable.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SCLKCFG",
        "Serial Clock Configuration.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_IPCR.
static const field_t hw_quadspi_ipcr[] =
{
    {
        "IDATSZ",
        "IP data transfer size.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAR_EN",
        "When set, a transaction to two serial flash devices is triggered in pa"
        "rallel mode.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEQID",
        "Points to a sequence in the Look-up table.",
        24, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_FLSHCR.
static const field_t hw_quadspi_flshcr[] =
{
    {
        "TCSS",
        "Serial flash CS setup time in terms of serial flash clock cycles.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSH",
        "Serial flash CS hold time in terms of serial flash clock cycles.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_BUF0CR.
static const field_t hw_quadspi_buf0cr[] =
{
    {
        "MSTRID",
        "Master ID.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADATSZ",
        "Defines the data transfer size in 8 bytes of an AHB triggered access t"
        "o serial flash.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HP_EN",
        "High Priority Enable.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_BUF1CR.
static const field_t hw_quadspi_buf1cr[] =
{
    {
        "MSTRID",
        "Master ID.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADATSZ",
        "Defines the data transfer size in 8 bytes of an AHB triggered access t"
        "o serial flash.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_BUF2CR.
static const field_t hw_quadspi_buf2cr[] =
{
    {
        "MSTRID",
        "Master ID.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADATSZ",
        "Defines the data transfer size in 8 bytes of an AHB triggered access t"
        "o serial flash.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_BUF3CR.
static const field_t hw_quadspi_buf3cr[] =
{
    {
        "MSTRID",
        "Master ID.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADATSZ",
        "Defines the data transfer size in 8 Bytes of an AHB triggered access t"
        "o serial flash.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ALLMST",
        "All master enable.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_BFGENCR.
static const field_t hw_quadspi_bfgencr[] =
{
    {
        "SEQID",
        "Points to a sequence in the Look-up-table.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAR_EN",
        "When set, a transaction to two serial flash devices is triggered in pa"
        "rallel mode.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_BUF0IND.
static const field_t hw_quadspi_buf0ind[] =
{
    {
        "TPINDX0",
        "Top index of buffer 0.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_BUF1IND.
static const field_t hw_quadspi_buf1ind[] =
{
    {
        "TPINDX1",
        "Top index of buffer 1.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_BUF2IND.
static const field_t hw_quadspi_buf2ind[] =
{
    {
        "TPINDX2",
        "Top index of buffer 2.",
        3, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SFAR.
static const field_t hw_quadspi_sfar[] =
{
    {
        "SFADR",
        "Serial Flash Address.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SMPR.
static const field_t hw_quadspi_smpr[] =
{
    {
        "HSENA",
        "This bit enables the divide by 2 of the clock to the external serial f"
        "lash device for all commands, only in SDR.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSPHS",
        "Only relevant when HSENA bit is set.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSDLY",
        "Only relevant when HSENA bit is set.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSPHS",
        "Select the edge of the sampling clock valid for full speed commands.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLY",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDRSMP",
        "Select the sampling point for incoming data when serial flash is execu"
        "ting a DDR instruction.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBSR.
static const field_t hw_quadspi_rbsr[] =
{
    {
        "RDBFL",
        "RX Buffer Fill Level.",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RDCTR",
        "Read Counter.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBCT.
static const field_t hw_quadspi_rbct[] =
{
    {
        "WMRK",
        "RX Buffer Watermark.",
        0, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXBRD",
        "RX Buffer Readout.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_TBSR.
static const field_t hw_quadspi_tbsr[] =
{
    {
        "TRBFL",
        "TX Buffer Fill Level.",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TRCTR",
        "Transmit Counter.",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_TBDR.
static const field_t hw_quadspi_tbdr[] =
{
    {
        "TXDATA",
        "TX Data On write access the data is written into the next available en"
        "try of the TX Buffer and the QPSI_TBSR[TRBFL] field is updated accordi"
        "ngly.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SR.
static const field_t hw_quadspi_sr[] =
{
    {
        "BUSY",
        "Module Busy.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IP_ACC",
        "IP Access.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB_ACC",
        "AHB Access.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHBGNT",
        "AHB Command priority Granted: Asserted when another module has been gr"
        "anted priority of AHB Commands against IP Commands.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHBTRN",
        "AHB Access Transaction pending.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB0NE",
        "AHB 0 Buffer Not Empty.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB1NE",
        "AHB 1 Buffer Not Empty.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB2NE",
        "AHB 2 Buffer Not Empty.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB3NE",
        "AHB 3 Buffer Not Empty.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB0FUL",
        "AHB 0 Buffer Full.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB1FUL",
        "AHB 1 Buffer Full.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB2FUL",
        "AHB 2 Buffer Full.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AHB3FUL",
        "AHB 3 Buffer Full.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXWE",
        "RX Buffer Watermark Exceeded.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFULL",
        "RX Buffer Full.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXDMA",
        "RX Buffer DMA.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXEDA",
        "Asserted when TX Buffer contains enough data for any pop operation to "
        "take place.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXFULL",
        "TX Buffer Full.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLPSMP",
        "Data learning pattern sampling point.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_FR.
static const field_t hw_quadspi_fr[] =
{
    {
        "TFF",
        "IP Command Transaction Finished Flag.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPGEF",
        "IP Command Trigger during AHB Grant Error Flag.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPIEF",
        "IP Command Trigger could not be executed Error Flag.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPAEF",
        "IP Command Trigger during AHB Access Error Flag.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IUEF",
        "IP Command Usage Error Flag.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABOF",
        "AHB Buffer Overflow Flag.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEF",
        "AHB Sequence Error Flag.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBDF",
        "RX Buffer Drain Flag.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBOF",
        "RX Buffer Overflow Flag.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ILLINE",
        "Illegal Instruction Error Flag.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TBUF",
        "TX Buffer Underrun Flag.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TBFF",
        "TX Buffer Fill Flag.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLPFF",
        "Data Learning Pattern Failure Flag.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RSER.
static const field_t hw_quadspi_rser[] =
{
    {
        "TFIE",
        "Transaction Finished Interrupt Enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPGEIE",
        "IP Command Trigger during AHB Grant Error Interrupt Enable",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPIEIE",
        "IP Command Trigger during IP Access Error Interrupt Enable",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPAEIE",
        "IP Command Trigger during AHB Access Error Interrupt Enable",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IUEIE",
        "IP Command Usage Error Interrupt Enable",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABOIE",
        "AHB Buffer Overflow Interrupt Enable",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABSEIE",
        "AHB Sequence Error Interrupt Enable: Triggered by ABSEF flags of QSPI_"
        "FR",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBDIE",
        "RX Buffer Drain Interrupt Enable: Enables generation of IRQ requests f"
        "or RX Buffer Drain.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBOIE",
        "RX Buffer Overflow Interrupt Enable",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RBDDE",
        "RX Buffer Drain DMA Enable: Enables generation of DMA requests for RX "
        "Buffer Drain.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ILLINIE",
        "Illegal Instruction Error Interrupt Enable.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TBUIE",
        "TX Buffer Underrun Interrupt Enable",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TBFIE",
        "TX Buffer Fill Interrupt Enable",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLPFIE",
        "Data Learning Pattern Failure Interrupt enable .",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SPNDST.
static const field_t hw_quadspi_spndst[] =
{
    {
        "SUSPND",
        "When set, it signifies that a sequence is in suspended state",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SPDBUF",
        "Suspended Buffer: Provides the suspended buffer number.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DATLFT",
        "Data left: Provides information about the amount of data left to be re"
        "ad in the suspended sequence.",
        9, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SPTRCLR.
static const field_t hw_quadspi_sptrclr[] =
{
    {
        "BFPTRC",
        "Buffer Pointer Clear: 1: Clears the sequence pointer for AHB accesses "
        "as defined in QuadSPI_BFGENCR.",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "IPPTRC",
        "IP Pointer Clear: 1: Clears the sequence pointer for IP accesses as de"
        "fined in QuadSPI_IPCR This is a self-clearing field.",
        8, // LSB
        8, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SFA1AD.
static const field_t hw_quadspi_sfa1ad[] =
{
    {
        "TPADA1",
        "Top address for Serial Flash A1.",
        10, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SFA2AD.
static const field_t hw_quadspi_sfa2ad[] =
{
    {
        "TPADA2",
        "Top address for Serial Flash A2.",
        10, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SFB1AD.
static const field_t hw_quadspi_sfb1ad[] =
{
    {
        "TPADB1",
        "Top address for Serial Flash B1.",
        10, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_SFB2AD.
static const field_t hw_quadspi_sfb2ad[] =
{
    {
        "TPADB2",
        "Top address for Serial Flash B2.",
        10, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR0.
static const field_t hw_quadspi_rbdr0[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR1.
static const field_t hw_quadspi_rbdr1[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR2.
static const field_t hw_quadspi_rbdr2[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR3.
static const field_t hw_quadspi_rbdr3[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR4.
static const field_t hw_quadspi_rbdr4[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR5.
static const field_t hw_quadspi_rbdr5[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR6.
static const field_t hw_quadspi_rbdr6[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR7.
static const field_t hw_quadspi_rbdr7[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR8.
static const field_t hw_quadspi_rbdr8[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR9.
static const field_t hw_quadspi_rbdr9[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR10.
static const field_t hw_quadspi_rbdr10[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR11.
static const field_t hw_quadspi_rbdr11[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR12.
static const field_t hw_quadspi_rbdr12[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR13.
static const field_t hw_quadspi_rbdr13[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR14.
static const field_t hw_quadspi_rbdr14[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR15.
static const field_t hw_quadspi_rbdr15[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR16.
static const field_t hw_quadspi_rbdr16[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR17.
static const field_t hw_quadspi_rbdr17[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR18.
static const field_t hw_quadspi_rbdr18[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR19.
static const field_t hw_quadspi_rbdr19[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR20.
static const field_t hw_quadspi_rbdr20[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR21.
static const field_t hw_quadspi_rbdr21[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR22.
static const field_t hw_quadspi_rbdr22[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR23.
static const field_t hw_quadspi_rbdr23[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR24.
static const field_t hw_quadspi_rbdr24[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR25.
static const field_t hw_quadspi_rbdr25[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR26.
static const field_t hw_quadspi_rbdr26[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR27.
static const field_t hw_quadspi_rbdr27[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR28.
static const field_t hw_quadspi_rbdr28[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR29.
static const field_t hw_quadspi_rbdr29[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR30.
static const field_t hw_quadspi_rbdr30[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_RBDR31.
static const field_t hw_quadspi_rbdr31[] =
{
    {
        "RXDATA",
        "RX Data.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUTKEY.
static const field_t hw_quadspi_lutkey[] =
{
    {
        "KEY",
        "The key to lock or unlock the LUT.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LCKCR.
static const field_t hw_quadspi_lckcr[] =
{
    {
        "LOCK",
        "Locks the LUT when the following condition is met: This register is wr"
        "itten just after the LUTKEYLUT Key Register The LUT key register was w"
        "ritten with 0x5AF05AF0 key",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UNLOCK",
        "Unlocks the LUT when the following two conditions are met: 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT0.
static const field_t hw_quadspi_lut0[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT1.
static const field_t hw_quadspi_lut1[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT2.
static const field_t hw_quadspi_lut2[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT3.
static const field_t hw_quadspi_lut3[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT4.
static const field_t hw_quadspi_lut4[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT5.
static const field_t hw_quadspi_lut5[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT6.
static const field_t hw_quadspi_lut6[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT7.
static const field_t hw_quadspi_lut7[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT8.
static const field_t hw_quadspi_lut8[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT9.
static const field_t hw_quadspi_lut9[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT10.
static const field_t hw_quadspi_lut10[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT11.
static const field_t hw_quadspi_lut11[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT12.
static const field_t hw_quadspi_lut12[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT13.
static const field_t hw_quadspi_lut13[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT14.
static const field_t hw_quadspi_lut14[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT15.
static const field_t hw_quadspi_lut15[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT16.
static const field_t hw_quadspi_lut16[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT17.
static const field_t hw_quadspi_lut17[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT18.
static const field_t hw_quadspi_lut18[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT19.
static const field_t hw_quadspi_lut19[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT20.
static const field_t hw_quadspi_lut20[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT21.
static const field_t hw_quadspi_lut21[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT22.
static const field_t hw_quadspi_lut22[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT23.
static const field_t hw_quadspi_lut23[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT24.
static const field_t hw_quadspi_lut24[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT25.
static const field_t hw_quadspi_lut25[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT26.
static const field_t hw_quadspi_lut26[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT27.
static const field_t hw_quadspi_lut27[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT28.
static const field_t hw_quadspi_lut28[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT29.
static const field_t hw_quadspi_lut29[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT30.
static const field_t hw_quadspi_lut30[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT31.
static const field_t hw_quadspi_lut31[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT32.
static const field_t hw_quadspi_lut32[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT33.
static const field_t hw_quadspi_lut33[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT34.
static const field_t hw_quadspi_lut34[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT35.
static const field_t hw_quadspi_lut35[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT36.
static const field_t hw_quadspi_lut36[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT37.
static const field_t hw_quadspi_lut37[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT38.
static const field_t hw_quadspi_lut38[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT39.
static const field_t hw_quadspi_lut39[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT40.
static const field_t hw_quadspi_lut40[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT41.
static const field_t hw_quadspi_lut41[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT42.
static const field_t hw_quadspi_lut42[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT43.
static const field_t hw_quadspi_lut43[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT44.
static const field_t hw_quadspi_lut44[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT45.
static const field_t hw_quadspi_lut45[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT46.
static const field_t hw_quadspi_lut46[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT47.
static const field_t hw_quadspi_lut47[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT48.
static const field_t hw_quadspi_lut48[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT49.
static const field_t hw_quadspi_lut49[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT50.
static const field_t hw_quadspi_lut50[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT51.
static const field_t hw_quadspi_lut51[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT52.
static const field_t hw_quadspi_lut52[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT53.
static const field_t hw_quadspi_lut53[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT54.
static const field_t hw_quadspi_lut54[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT55.
static const field_t hw_quadspi_lut55[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT56.
static const field_t hw_quadspi_lut56[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT57.
static const field_t hw_quadspi_lut57[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT58.
static const field_t hw_quadspi_lut58[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT59.
static const field_t hw_quadspi_lut59[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT60.
static const field_t hw_quadspi_lut60[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT61.
static const field_t hw_quadspi_lut61[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT62.
static const field_t hw_quadspi_lut62[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register QuadSPI_LUT63.
static const field_t hw_quadspi_lut63[] =
{
    {
        "OPRND0",
        "",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD0",
        "",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR0",
        "",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OPRND1",
        "",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PAD1",
        "",
        24, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INSTR1",
        "",
        26, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a QUADSPI module.
static const reg_t hw_quadspi[] =
{
    {
        "MCR",
        "The QuadSPI_MCR holds configuration data associated with QuadSPI opera"
        "tion.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_quadspi_mcr
    },
    {
        "IPCR",
        "The IP configuration register provides all the configuration required "
        "for an IP initiated command.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_quadspi_ipcr
    },
    {
        "FLSHCR",
        "The Flash configuration register contains the flash device specific ti"
        "mings that must be met by the QuadSPI controller for the device to fun"
        "ction correctly.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_flshcr
    },
    {
        "BUF0CR",
        "This register provides the configuration for any access to buffer0.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_quadspi_buf0cr
    },
    {
        "BUF1CR",
        "This register provides the configuration for any access to buffer1.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_buf1cr
    },
    {
        "BUF2CR",
        "This register provides the configuration for any access to buffer2.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_buf2cr
    },
    {
        "BUF3CR",
        "This register provides the configuration for any access to buffer3.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_quadspi_buf3cr
    },
    {
        "BFGENCR",
        "This register provides the generic configuration to any of the buffer "
        "accesses.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_bfgencr
    },
    {
        "BUF0IND",
        "This register specifies the top index of buffer0, which defines its si"
        "ze.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_buf0ind
    },
    {
        "BUF1IND",
        "This register specifies the top index of buffer1, which defines its si"
        "ze.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_buf1ind
    },
    {
        "BUF2IND",
        "This register specifies the top index of buffer2, which defines its si"
        "ze.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_buf2ind
    },
    {
        "SFAR",
        "The module automatically translates this address on the memory map to "
        "the address on the flash itself.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_sfar
    },
    {
        "SMPR",
        "The Sampling Register allows configuration of how the incoming data fr"
        "om the external serial flash devices are sampled in the QuadSPI module"
        ".",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_smpr
    },
    {
        "RBSR",
        "This register contains information related to the receive data buffer.",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_quadspi_rbsr
    },
    {
        "RBCT",
        "This register contains control data related to the receive data buffer"
        ".",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_rbct
    },
    {
        "TBSR",
        "This register contains information related to the transmit data buffer"
        ".",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_quadspi_tbsr
    },
    {
        "TBDR",
        "The QSPI_TBDR register provides access to the circular TX Buffer of de"
        "pth 128 bytes.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_tbdr
    },
    {
        "SR",
        "The QSPI_SR register provides all available status information about S"
        "FM command execution and arbitration, the RX Buffer, TX Buffer, and th"
        "e AHB Buffer.",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        false, // Writable
        19, // Number of bitfields
        hw_quadspi_sr
    },
    {
        "FR",
        "The QSPI_FR register provides all available flags about SFM command ex"
        "ecution and arbitration which may serve as source for the generation o"
        "f interrupt service requests.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_quadspi_fr
    },
    {
        "RSER",
        "The QuadSPI_RSER register provides enables and selectors for the inter"
        "rupts in the QuadSPI module.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_quadspi_rser
    },
    {
        "SPNDST",
        "The sequence suspend status register provides information specific to "
        "any suspended sequence.",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_quadspi_spndst
    },
    {
        "SPTRCLR",
        "The sequence pointer clear register provides bits to reset the IP and "
        "Buffer sequence pointers.",
        4, // Width in bytes
        0x0000016c, // Base address offset
        false, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_sptrclr
    },
    {
        "SFA1AD",
        "The QSPI_SFA1AD register provides the address mapping for the serial f"
        "lash A1.The difference between QSPI_SFA1AD[TPADA1] and QSPI_AMBA_BASE "
        "defines the size of the memory map for serial flash A1.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_sfa1ad
    },
    {
        "SFA2AD",
        "The QSPI_SFA2AD register provides the address mapping for the serial f"
        "lash A2.The difference between QSPI_SFA2AD[TPADA2] and QSPI_SFA1AD[TPA"
        "DA1] defines the size of the memory map for serial flash A2.",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_sfa2ad
    },
    {
        "SFB1AD",
        "The QSPI_SFB1AD register provides the address mapping for the serial f"
        "lash B1.The difference between QSPI_SFB1AD[TPADB1] and QSPI_SFA2AD[TPA"
        "DA2] defines the size of the memory map for serial flash B1.",
        4, // Width in bytes
        0x00000188, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_sfb1ad
    },
    {
        "SFB2AD",
        "The QSPI_SFB2AD register provides the address mapping for the serial f"
        "lash B2.The difference between QSPI_SFB2AD[TPADB2] and QSPI_SFB1AD[TPA"
        "DB1] defines the size of the memory map for serial flash B2.",
        4, // Width in bytes
        0x0000018c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_sfb2ad
    },
    {
        "RBDR0",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr0
    },
    {
        "RBDR1",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr1
    },
    {
        "RBDR2",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr2
    },
    {
        "RBDR3",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr3
    },
    {
        "RBDR4",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr4
    },
    {
        "RBDR5",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr5
    },
    {
        "RBDR6",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr6
    },
    {
        "RBDR7",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr7
    },
    {
        "RBDR8",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr8
    },
    {
        "RBDR9",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr9
    },
    {
        "RBDR10",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr10
    },
    {
        "RBDR11",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr11
    },
    {
        "RBDR12",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr12
    },
    {
        "RBDR13",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr13
    },
    {
        "RBDR14",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr14
    },
    {
        "RBDR15",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr15
    },
    {
        "RBDR16",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr16
    },
    {
        "RBDR17",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr17
    },
    {
        "RBDR18",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr18
    },
    {
        "RBDR19",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr19
    },
    {
        "RBDR20",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr20
    },
    {
        "RBDR21",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr21
    },
    {
        "RBDR22",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr22
    },
    {
        "RBDR23",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr23
    },
    {
        "RBDR24",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr24
    },
    {
        "RBDR25",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr25
    },
    {
        "RBDR26",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr26
    },
    {
        "RBDR27",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr27
    },
    {
        "RBDR28",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr28
    },
    {
        "RBDR29",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr29
    },
    {
        "RBDR30",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr30
    },
    {
        "RBDR31",
        "The QuadSPI_RBDR registers provide access to the individual entries in"
        " the RX Buffer.",
        4, // Width in bytes
        0x0000027c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_quadspi_rbdr31
    },
    {
        "LUTKEY",
        "The LUT Key register contains the key to lock and unlock the Look-up-t"
        "able.",
        4, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_quadspi_lutkey
    },
    {
        "LCKCR",
        "The LUT lock configuration register is used along with QSPI_LUTKEY reg"
        "ister to lock or unlock the LUT.",
        4, // Width in bytes
        0x00000304, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_quadspi_lckcr
    },
    {
        "LUT0",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000310, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut0
    },
    {
        "LUT1",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000314, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut1
    },
    {
        "LUT2",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000318, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut2
    },
    {
        "LUT3",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000031c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut3
    },
    {
        "LUT4",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut4
    },
    {
        "LUT5",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000324, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut5
    },
    {
        "LUT6",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000328, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut6
    },
    {
        "LUT7",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000032c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut7
    },
    {
        "LUT8",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000330, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut8
    },
    {
        "LUT9",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000334, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut9
    },
    {
        "LUT10",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000338, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut10
    },
    {
        "LUT11",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000033c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut11
    },
    {
        "LUT12",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000340, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut12
    },
    {
        "LUT13",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000344, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut13
    },
    {
        "LUT14",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000348, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut14
    },
    {
        "LUT15",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000034c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut15
    },
    {
        "LUT16",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000350, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut16
    },
    {
        "LUT17",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000354, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut17
    },
    {
        "LUT18",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000358, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut18
    },
    {
        "LUT19",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000035c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut19
    },
    {
        "LUT20",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000360, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut20
    },
    {
        "LUT21",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000364, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut21
    },
    {
        "LUT22",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000368, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut22
    },
    {
        "LUT23",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000036c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut23
    },
    {
        "LUT24",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000370, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut24
    },
    {
        "LUT25",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000374, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut25
    },
    {
        "LUT26",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000378, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut26
    },
    {
        "LUT27",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000037c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut27
    },
    {
        "LUT28",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000380, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut28
    },
    {
        "LUT29",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000384, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut29
    },
    {
        "LUT30",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000388, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut30
    },
    {
        "LUT31",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000038c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut31
    },
    {
        "LUT32",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000390, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut32
    },
    {
        "LUT33",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000394, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut33
    },
    {
        "LUT34",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000398, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut34
    },
    {
        "LUT35",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000039c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut35
    },
    {
        "LUT36",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003a0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut36
    },
    {
        "LUT37",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003a4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut37
    },
    {
        "LUT38",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003a8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut38
    },
    {
        "LUT39",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003ac, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut39
    },
    {
        "LUT40",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003b0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut40
    },
    {
        "LUT41",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003b4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut41
    },
    {
        "LUT42",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003b8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut42
    },
    {
        "LUT43",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003bc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut43
    },
    {
        "LUT44",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003c0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut44
    },
    {
        "LUT45",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003c4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut45
    },
    {
        "LUT46",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003c8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut46
    },
    {
        "LUT47",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003cc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut47
    },
    {
        "LUT48",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003d0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut48
    },
    {
        "LUT49",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003d4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut49
    },
    {
        "LUT50",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003d8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut50
    },
    {
        "LUT51",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003dc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut51
    },
    {
        "LUT52",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003e0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut52
    },
    {
        "LUT53",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003e4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut53
    },
    {
        "LUT54",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003e8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut54
    },
    {
        "LUT55",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003ec, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut55
    },
    {
        "LUT56",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003f0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut56
    },
    {
        "LUT57",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003f4, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut57
    },
    {
        "LUT58",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003f8, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut58
    },
    {
        "LUT59",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x000003fc, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut59
    },
    {
        "LUT60",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000400, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut60
    },
    {
        "LUT61",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000404, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut61
    },
    {
        "LUT62",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x00000408, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut62
    },
    {
        "LUT63",
        "The LUT registers are a look-up-table for sequences of instructions.",
        4, // Width in bytes
        0x0000040c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_quadspi_lut63
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark ROMC
#endif

// Bitfields in register ROMC_ROMPATCH0D.
static const field_t hw_romc_rompatch0d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH1D.
static const field_t hw_romc_rompatch1d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH2D.
static const field_t hw_romc_rompatch2d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH3D.
static const field_t hw_romc_rompatch3d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH4D.
static const field_t hw_romc_rompatch4d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH5D.
static const field_t hw_romc_rompatch5d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH6D.
static const field_t hw_romc_rompatch6d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH7D.
static const field_t hw_romc_rompatch7d[] =
{
    {
        "DATAX",
        "Data Fix Registers - Stores the data used for 1-word data fix operatio"
        "ns.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHCNTL.
static const field_t hw_romc_rompatchcntl[] =
{
    {
        "DATAFIX",
        "Data Fix Enable - Controls the use of the first 8 address comparators "
        "for 1-word data fix or for code patch routine.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIS",
        "ROMC Disable -- This bit, when set, disables all ROMC operations.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHENH.
static const field_t hw_romc_rompatchenh[] =
{
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHENL.
static const field_t hw_romc_rompatchenl[] =
{
    {
        "ENABLE",
        "Enable Address Comparator - This bit enables the corresponding address"
        " comparator to trigger an event.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH0A.
static const field_t hw_romc_rompatch0a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH1A.
static const field_t hw_romc_rompatch1a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH2A.
static const field_t hw_romc_rompatch2a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH3A.
static const field_t hw_romc_rompatch3a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH4A.
static const field_t hw_romc_rompatch4a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH5A.
static const field_t hw_romc_rompatch5a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH6A.
static const field_t hw_romc_rompatch6a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH7A.
static const field_t hw_romc_rompatch7a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH8A.
static const field_t hw_romc_rompatch8a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH9A.
static const field_t hw_romc_rompatch9a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH10A.
static const field_t hw_romc_rompatch10a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH11A.
static const field_t hw_romc_rompatch11a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH12A.
static const field_t hw_romc_rompatch12a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH13A.
static const field_t hw_romc_rompatch13a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH14A.
static const field_t hw_romc_rompatch14a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCH15A.
static const field_t hw_romc_rompatch15a[] =
{
    {
        "THUMBX",
        "THUMB Comparator Select - Indicates that this address will trigger a T"
        "HUMB opcode patch or an ARM opcode patch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADDRX",
        "Address Comparator Registers - Indicates the memory address to be watc"
        "hed.",
        1, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register ROMC_ROMPATCHSR.
static const field_t hw_romc_rompatchsr[] =
{
    {
        "SOURCE",
        "ROMC Source Number - Binary encoding of the number of the address comp"
        "arator which has an address match in the most recent patch event on RO"
        "MC AHB.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SW",
        "ROMC AHB Multiple Address Comparator matches Indicator - Indicates tha"
        "t multiple address comparator matches occurred.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a ROMC module.
static const reg_t hw_romc[] =
{
    {
        "ROMPATCH0D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000d4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch0d
    },
    {
        "ROMPATCH1D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000d8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch1d
    },
    {
        "ROMPATCH2D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000dc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch2d
    },
    {
        "ROMPATCH3D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000e0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch3d
    },
    {
        "ROMPATCH4D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000e4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch4d
    },
    {
        "ROMPATCH5D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000e8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch5d
    },
    {
        "ROMPATCH6D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000ec, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch6d
    },
    {
        "ROMPATCH7D",
        "The ROMC data registers (ROMC_ROMPATCH7D through ROMC_ROMPATCH0D) stor"
        "e the data to use for the 8 1-word data fix events.",
        4, // Width in bytes
        0x000000f0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatch7d
    },
    {
        "ROMPATCHCNTL",
        "The ROMC control register (ROMC_ROMPATCHCNTL) contains the block disab"
        "le bit and the data fix enable bits.",
        4, // Width in bytes
        0x000000f4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatchcntl
    },
    {
        "ROMPATCHENH",
        "The ROMC enable register high (ROMC_ROMPATCHENH) and ROMC enable regis"
        "ter low (ROMC_ROMPATCHENL) control whether or not the associated addre"
        "ss comparator can trigger a opcode patch or data fix event.",
        4, // Width in bytes
        0x000000f8, // Base address offset
        false, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_romc_rompatchenh
    },
    {
        "ROMPATCHENL",
        "The ROMC enable register high (ROMC_ROMPATCHENH) and ROMC enable regis"
        "ter low (ROMC_ROMPATCHENL) control whether or not the associated addre"
        "ss comparator can trigger a opcode patch or data fix event.",
        4, // Width in bytes
        0x000000fc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_romc_rompatchenl
    },
    {
        "ROMPATCH0A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch0a
    },
    {
        "ROMPATCH1A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch1a
    },
    {
        "ROMPATCH2A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch2a
    },
    {
        "ROMPATCH3A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch3a
    },
    {
        "ROMPATCH4A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch4a
    },
    {
        "ROMPATCH5A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch5a
    },
    {
        "ROMPATCH6A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch6a
    },
    {
        "ROMPATCH7A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch7a
    },
    {
        "ROMPATCH8A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch8a
    },
    {
        "ROMPATCH9A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch9a
    },
    {
        "ROMPATCH10A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch10a
    },
    {
        "ROMPATCH11A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch11a
    },
    {
        "ROMPATCH12A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch12a
    },
    {
        "ROMPATCH13A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch13a
    },
    {
        "ROMPATCH14A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch14a
    },
    {
        "ROMPATCH15A",
        "The ROMC address registers (ROMC_ROMPATCHA0 through ROMC_ROMPATCHA15) "
        "store the memory addresses where opcode patching begins and data fixin"
        "g occurs.",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatch15a
    },
    {
        "ROMPATCHSR",
        "The ROMC status register (ROMC_ROMPATCHSR) indicates the current state"
        " of the ROMC and the source number of the most recent address comparat"
        "or event.",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_romc_rompatchsr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SDMAARM
#endif

// Bitfields in register SDMAARM_MC0PTR.
static const field_t hw_sdmaarm_mc0ptr[] =
{
    {
        "MC0PTR",
        "Channel 0 Pointer contains the 32-bit address, in ARM platform memory,"
        " of channel 0 control block (the boot channel).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_INTR.
static const field_t hw_sdmaarm_intr[] =
{
    {
        "HI",
        "The ARM platform Interrupts register contains the 32 HI[i] bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_STOP_STAT.
static const field_t hw_sdmaarm_stop_stat[] =
{
    {
        "HE",
        "This 32-bit register gives access to the ARM platform Enable bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_HSTART.
static const field_t hw_sdmaarm_hstart[] =
{
    {
        "HSTART_HE",
        "The HSTART_HE registers are 32 bits wide with one bit for every channe"
        "l.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVTOVR.
static const field_t hw_sdmaarm_evtovr[] =
{
    {
        "EO",
        "The Channel Event Override register contains the 32 EO[i] bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_DSPOVR.
static const field_t hw_sdmaarm_dspovr[] =
{
    {
        "DO",
        "This register is reserved.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_HOSTOVR.
static const field_t hw_sdmaarm_hostovr[] =
{
    {
        "HO",
        "The Channel ARM platform Override register contains the 32 HO[i] bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVTPEND.
static const field_t hw_sdmaarm_evtpend[] =
{
    {
        "EP",
        "The Channel Event Pending register contains the 32 EP[i] bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_RESET.
static const field_t hw_sdmaarm_reset[] =
{
    {
        "RESET",
        "When set, this bit causes the SDMA to be held in a software reset.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RESCHED",
        "When set, this bit forces the SDMA to reschedule as if a script had ex"
        "ecuted a done instruction.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVTERR.
static const field_t hw_sdmaarm_evterr[] =
{
    {
        "CHNERR",
        "This register is used by the SDMA to warn the ARM platform when an inc"
        "oming DMA request was detected and it triggers a channel that is alrea"
        "dy pending or being serviced.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_INTRMASK.
static const field_t hw_sdmaarm_intrmask[] =
{
    {
        "HIMASK",
        "The Interrupt Mask Register contains 32 interrupt generation mask bits"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_PSW.
static const field_t hw_sdmaarm_psw[] =
{
    {
        "CCR",
        "The Current Channel Register indicates the number of the channel that "
        "is being executed by the SDMA.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CCP",
        "The Current Channel Priority indicates the priority of the current act"
        "ive channel.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCR",
        "The Next Channel Register indicates the number of the next scheduled p"
        "ending channel with the highest priority.",
        8, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NCP",
        "The Next Channel Priority gives the next pending channel priority.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVTERRDBG.
static const field_t hw_sdmaarm_evterrdbg[] =
{
    {
        "CHNERR",
        "This register is the same as EVTERR, except reading it does not clear "
        "its contents.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CONFIG.
static const field_t hw_sdmaarm_config[] =
{
    {
        "CSM",
        "Selects the Context Switch Mode.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACR",
        "ARM platform DMA / SDMA Core Clock Ratio.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTDOBS",
        "Indicates if Real-Time Debug pins are used: They do not toggle by defa"
        "ult in order to reduce power consumption.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSPDMA",
        "This bit's function is reserved and should be configured as zero.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_LOCK.
static const field_t hw_sdmaarm_sdma_lock[] =
{
    {
        "LOCK",
        "The LOCK bit is used to restrict access to update SDMA script memory t"
        "hrough ROM channel zero scripts and through the OnCE interface under A"
        "RM platform control.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRESET_LOCK_CLR",
        "The SRESET_LOCK_CLR bit determine if the LOCK bit is cleared on a soft"
        "ware reset triggered by writing to the RESET register.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_ENB.
static const field_t hw_sdmaarm_once_enb[] =
{
    {
        "ENB",
        "The OnCE Enable register selects the OnCE control source: When cleared"
        " (0), the OnCE registers are accessed through the JTAG interface; when"
        " set (1), the OnCE registers may be accessed by the ARM platform throu"
        "gh the addresses described, as follows.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_DATA.
static const field_t hw_sdmaarm_once_data[] =
{
    {
        "DATA",
        "Data register of the OnCE JTAG controller.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_INSTR.
static const field_t hw_sdmaarm_once_instr[] =
{
    {
        "INSTR",
        "Instruction register of the OnCE JTAG controller.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_STAT.
static const field_t hw_sdmaarm_once_stat[] =
{
    {
        "ECDR",
        "Event Cell Debug Request.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST",
        "This flag is raised when the OnCE is controlled from the ARM platform "
        "peripheral interface.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWB",
        "This flag is raised when the SDMA has entered debug mode after a softw"
        "are breakpoint.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODR",
        "This flag is raised when the SDMA has entered debug mode after a OnCE "
        "debug request.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EDR",
        "This flag is raised when the SDMA has entered debug mode after an exte"
        "rnal debug request.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RCV",
        "After each write access to the real time buffer (RTB), the RCV bit is "
        "set.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PST",
        "The Processor Status bits reflect the state of the SDMA RISC engine.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ONCE_CMD.
static const field_t hw_sdmaarm_once_cmd[] =
{
    {
        "CMD",
        "Writing to this register will cause the OnCE to execute the command th"
        "at is written.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_ILLINSTADDR.
static const field_t hw_sdmaarm_illinstaddr[] =
{
    {
        "ILLINSTADDR",
        "The Illegal Instruction Trap Address is the address where the SDMA jum"
        "ps when an illegal instruction is executed.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHN0ADDR.
static const field_t hw_sdmaarm_chn0addr[] =
{
    {
        "CHN0ADDR",
        "This 14-bit register is used by the boot code of the SDMA.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMSZ",
        "The bit 14 (Scratch Memory Size) determines if scratch memory must be "
        "available after every channel context.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVT_MIRROR.
static const field_t hw_sdmaarm_evt_mirror[] =
{
    {
        "EVENTS",
        "This register reflects the DMA requests received by the SDMA for event"
        "s 31-0.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_EVT_MIRROR2.
static const field_t hw_sdmaarm_evt_mirror2[] =
{
    {
        "EVENTS",
        "This register reflects the DMA requests received by the SDMA for event"
        "s 47-32.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_XTRIG_CONF1.
static const field_t hw_sdmaarm_xtrig_conf1[] =
{
    {
        "NUM0",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF0",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM1",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF1",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM2",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF2",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM3",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF3",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_XTRIG_CONF2.
static const field_t hw_sdmaarm_xtrig_conf2[] =
{
    {
        "NUM4",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF4",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM5",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i.",
        8, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF5",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM6",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF6",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NUM7",
        "Contains the number of the DMA request or channel that triggers the pu"
        "lse on the cross-trigger event line number i.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNF7",
        "Configuration of the SDMA event line number i that is connected to the"
        " cross-trigger.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI0.
static const field_t hw_sdmaarm_sdma_chnpri0[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI1.
static const field_t hw_sdmaarm_sdma_chnpri1[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI2.
static const field_t hw_sdmaarm_sdma_chnpri2[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI3.
static const field_t hw_sdmaarm_sdma_chnpri3[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI4.
static const field_t hw_sdmaarm_sdma_chnpri4[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI5.
static const field_t hw_sdmaarm_sdma_chnpri5[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI6.
static const field_t hw_sdmaarm_sdma_chnpri6[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI7.
static const field_t hw_sdmaarm_sdma_chnpri7[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI8.
static const field_t hw_sdmaarm_sdma_chnpri8[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI9.
static const field_t hw_sdmaarm_sdma_chnpri9[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI10.
static const field_t hw_sdmaarm_sdma_chnpri10[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI11.
static const field_t hw_sdmaarm_sdma_chnpri11[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI12.
static const field_t hw_sdmaarm_sdma_chnpri12[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI13.
static const field_t hw_sdmaarm_sdma_chnpri13[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI14.
static const field_t hw_sdmaarm_sdma_chnpri14[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI15.
static const field_t hw_sdmaarm_sdma_chnpri15[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI16.
static const field_t hw_sdmaarm_sdma_chnpri16[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI17.
static const field_t hw_sdmaarm_sdma_chnpri17[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI18.
static const field_t hw_sdmaarm_sdma_chnpri18[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI19.
static const field_t hw_sdmaarm_sdma_chnpri19[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI20.
static const field_t hw_sdmaarm_sdma_chnpri20[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI21.
static const field_t hw_sdmaarm_sdma_chnpri21[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI22.
static const field_t hw_sdmaarm_sdma_chnpri22[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI23.
static const field_t hw_sdmaarm_sdma_chnpri23[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI24.
static const field_t hw_sdmaarm_sdma_chnpri24[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI25.
static const field_t hw_sdmaarm_sdma_chnpri25[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI26.
static const field_t hw_sdmaarm_sdma_chnpri26[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI27.
static const field_t hw_sdmaarm_sdma_chnpri27[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI28.
static const field_t hw_sdmaarm_sdma_chnpri28[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI29.
static const field_t hw_sdmaarm_sdma_chnpri29[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI30.
static const field_t hw_sdmaarm_sdma_chnpri30[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_SDMA_CHNPRI31.
static const field_t hw_sdmaarm_sdma_chnpri31[] =
{
    {
        "CHNPRIN",
        "This contains the priority of channel number n.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL0.
static const field_t hw_sdmaarm_chnenbl0[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL1.
static const field_t hw_sdmaarm_chnenbl1[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL2.
static const field_t hw_sdmaarm_chnenbl2[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL3.
static const field_t hw_sdmaarm_chnenbl3[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL4.
static const field_t hw_sdmaarm_chnenbl4[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL5.
static const field_t hw_sdmaarm_chnenbl5[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL6.
static const field_t hw_sdmaarm_chnenbl6[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL7.
static const field_t hw_sdmaarm_chnenbl7[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL8.
static const field_t hw_sdmaarm_chnenbl8[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL9.
static const field_t hw_sdmaarm_chnenbl9[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL10.
static const field_t hw_sdmaarm_chnenbl10[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL11.
static const field_t hw_sdmaarm_chnenbl11[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL12.
static const field_t hw_sdmaarm_chnenbl12[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL13.
static const field_t hw_sdmaarm_chnenbl13[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL14.
static const field_t hw_sdmaarm_chnenbl14[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL15.
static const field_t hw_sdmaarm_chnenbl15[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL16.
static const field_t hw_sdmaarm_chnenbl16[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL17.
static const field_t hw_sdmaarm_chnenbl17[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL18.
static const field_t hw_sdmaarm_chnenbl18[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL19.
static const field_t hw_sdmaarm_chnenbl19[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL20.
static const field_t hw_sdmaarm_chnenbl20[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL21.
static const field_t hw_sdmaarm_chnenbl21[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL22.
static const field_t hw_sdmaarm_chnenbl22[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL23.
static const field_t hw_sdmaarm_chnenbl23[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL24.
static const field_t hw_sdmaarm_chnenbl24[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL25.
static const field_t hw_sdmaarm_chnenbl25[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL26.
static const field_t hw_sdmaarm_chnenbl26[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL27.
static const field_t hw_sdmaarm_chnenbl27[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL28.
static const field_t hw_sdmaarm_chnenbl28[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL29.
static const field_t hw_sdmaarm_chnenbl29[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL30.
static const field_t hw_sdmaarm_chnenbl30[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL31.
static const field_t hw_sdmaarm_chnenbl31[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL32.
static const field_t hw_sdmaarm_chnenbl32[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL33.
static const field_t hw_sdmaarm_chnenbl33[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL34.
static const field_t hw_sdmaarm_chnenbl34[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL35.
static const field_t hw_sdmaarm_chnenbl35[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL36.
static const field_t hw_sdmaarm_chnenbl36[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL37.
static const field_t hw_sdmaarm_chnenbl37[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL38.
static const field_t hw_sdmaarm_chnenbl38[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL39.
static const field_t hw_sdmaarm_chnenbl39[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL40.
static const field_t hw_sdmaarm_chnenbl40[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL41.
static const field_t hw_sdmaarm_chnenbl41[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL42.
static const field_t hw_sdmaarm_chnenbl42[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL43.
static const field_t hw_sdmaarm_chnenbl43[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL44.
static const field_t hw_sdmaarm_chnenbl44[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL45.
static const field_t hw_sdmaarm_chnenbl45[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL46.
static const field_t hw_sdmaarm_chnenbl46[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMAARM_CHNENBL47.
static const field_t hw_sdmaarm_chnenbl47[] =
{
    {
        "ENBLN",
        "This 32-bit value selects the channels that are triggered by the DMA r"
        "equest number n.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SDMAARM module.
static const reg_t hw_sdmaarm[] =
{
    {
        "MC0PTR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_mc0ptr
    },
    {
        "INTR",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_intr
    },
    {
        "STOP_STAT",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_stop_stat
    },
    {
        "HSTART",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_hstart
    },
    {
        "EVTOVR",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evtovr
    },
    {
        "DSPOVR",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_dspovr
    },
    {
        "HOSTOVR",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_hostovr
    },
    {
        "EVTPEND",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evtpend
    },
    {
        "RESET",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_sdmaarm_reset
    },
    {
        "EVTERR",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evterr
    },
    {
        "INTRMASK",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_intrmask
    },
    {
        "PSW",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_sdmaarm_psw
    },
    {
        "EVTERRDBG",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evterrdbg
    },
    {
        "CONFIG",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_sdmaarm_config
    },
    {
        "SDMA_LOCK",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sdmaarm_sdma_lock
    },
    {
        "ONCE_ENB",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_once_enb
    },
    {
        "ONCE_DATA",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_once_data
    },
    {
        "ONCE_INSTR",
        "",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_once_instr
    },
    {
        "ONCE_STAT",
        "",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_sdmaarm_once_stat
    },
    {
        "ONCE_CMD",
        "",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_once_cmd
    },
    {
        "ILLINSTADDR",
        "",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_illinstaddr
    },
    {
        "CHN0ADDR",
        "",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sdmaarm_chn0addr
    },
    {
        "EVT_MIRROR",
        "",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evt_mirror
    },
    {
        "EVT_MIRROR2",
        "",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmaarm_evt_mirror2
    },
    {
        "XTRIG_CONF1",
        "",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_sdmaarm_xtrig_conf1
    },
    {
        "XTRIG_CONF2",
        "",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_sdmaarm_xtrig_conf2
    },
    {
        "SDMA_CHNPRI0",
        "",
        4, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri0
    },
    {
        "SDMA_CHNPRI1",
        "",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri1
    },
    {
        "SDMA_CHNPRI2",
        "",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri2
    },
    {
        "SDMA_CHNPRI3",
        "",
        4, // Width in bytes
        0x0000010c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri3
    },
    {
        "SDMA_CHNPRI4",
        "",
        4, // Width in bytes
        0x00000110, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri4
    },
    {
        "SDMA_CHNPRI5",
        "",
        4, // Width in bytes
        0x00000114, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri5
    },
    {
        "SDMA_CHNPRI6",
        "",
        4, // Width in bytes
        0x00000118, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri6
    },
    {
        "SDMA_CHNPRI7",
        "",
        4, // Width in bytes
        0x0000011c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri7
    },
    {
        "SDMA_CHNPRI8",
        "",
        4, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri8
    },
    {
        "SDMA_CHNPRI9",
        "",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri9
    },
    {
        "SDMA_CHNPRI10",
        "",
        4, // Width in bytes
        0x00000128, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri10
    },
    {
        "SDMA_CHNPRI11",
        "",
        4, // Width in bytes
        0x0000012c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri11
    },
    {
        "SDMA_CHNPRI12",
        "",
        4, // Width in bytes
        0x00000130, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri12
    },
    {
        "SDMA_CHNPRI13",
        "",
        4, // Width in bytes
        0x00000134, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri13
    },
    {
        "SDMA_CHNPRI14",
        "",
        4, // Width in bytes
        0x00000138, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri14
    },
    {
        "SDMA_CHNPRI15",
        "",
        4, // Width in bytes
        0x0000013c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri15
    },
    {
        "SDMA_CHNPRI16",
        "",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri16
    },
    {
        "SDMA_CHNPRI17",
        "",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri17
    },
    {
        "SDMA_CHNPRI18",
        "",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri18
    },
    {
        "SDMA_CHNPRI19",
        "",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri19
    },
    {
        "SDMA_CHNPRI20",
        "",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri20
    },
    {
        "SDMA_CHNPRI21",
        "",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri21
    },
    {
        "SDMA_CHNPRI22",
        "",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri22
    },
    {
        "SDMA_CHNPRI23",
        "",
        4, // Width in bytes
        0x0000015c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri23
    },
    {
        "SDMA_CHNPRI24",
        "",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri24
    },
    {
        "SDMA_CHNPRI25",
        "",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri25
    },
    {
        "SDMA_CHNPRI26",
        "",
        4, // Width in bytes
        0x00000168, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri26
    },
    {
        "SDMA_CHNPRI27",
        "",
        4, // Width in bytes
        0x0000016c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri27
    },
    {
        "SDMA_CHNPRI28",
        "",
        4, // Width in bytes
        0x00000170, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri28
    },
    {
        "SDMA_CHNPRI29",
        "",
        4, // Width in bytes
        0x00000174, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri29
    },
    {
        "SDMA_CHNPRI30",
        "",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri30
    },
    {
        "SDMA_CHNPRI31",
        "",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_sdma_chnpri31
    },
    {
        "CHNENBL0",
        "",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl0
    },
    {
        "CHNENBL1",
        "",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl1
    },
    {
        "CHNENBL2",
        "",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl2
    },
    {
        "CHNENBL3",
        "",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl3
    },
    {
        "CHNENBL4",
        "",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl4
    },
    {
        "CHNENBL5",
        "",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl5
    },
    {
        "CHNENBL6",
        "",
        4, // Width in bytes
        0x00000218, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl6
    },
    {
        "CHNENBL7",
        "",
        4, // Width in bytes
        0x0000021c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl7
    },
    {
        "CHNENBL8",
        "",
        4, // Width in bytes
        0x00000220, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl8
    },
    {
        "CHNENBL9",
        "",
        4, // Width in bytes
        0x00000224, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl9
    },
    {
        "CHNENBL10",
        "",
        4, // Width in bytes
        0x00000228, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl10
    },
    {
        "CHNENBL11",
        "",
        4, // Width in bytes
        0x0000022c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl11
    },
    {
        "CHNENBL12",
        "",
        4, // Width in bytes
        0x00000230, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl12
    },
    {
        "CHNENBL13",
        "",
        4, // Width in bytes
        0x00000234, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl13
    },
    {
        "CHNENBL14",
        "",
        4, // Width in bytes
        0x00000238, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl14
    },
    {
        "CHNENBL15",
        "",
        4, // Width in bytes
        0x0000023c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl15
    },
    {
        "CHNENBL16",
        "",
        4, // Width in bytes
        0x00000240, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl16
    },
    {
        "CHNENBL17",
        "",
        4, // Width in bytes
        0x00000244, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl17
    },
    {
        "CHNENBL18",
        "",
        4, // Width in bytes
        0x00000248, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl18
    },
    {
        "CHNENBL19",
        "",
        4, // Width in bytes
        0x0000024c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl19
    },
    {
        "CHNENBL20",
        "",
        4, // Width in bytes
        0x00000250, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl20
    },
    {
        "CHNENBL21",
        "",
        4, // Width in bytes
        0x00000254, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl21
    },
    {
        "CHNENBL22",
        "",
        4, // Width in bytes
        0x00000258, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl22
    },
    {
        "CHNENBL23",
        "",
        4, // Width in bytes
        0x0000025c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl23
    },
    {
        "CHNENBL24",
        "",
        4, // Width in bytes
        0x00000260, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl24
    },
    {
        "CHNENBL25",
        "",
        4, // Width in bytes
        0x00000264, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl25
    },
    {
        "CHNENBL26",
        "",
        4, // Width in bytes
        0x00000268, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl26
    },
    {
        "CHNENBL27",
        "",
        4, // Width in bytes
        0x0000026c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl27
    },
    {
        "CHNENBL28",
        "",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl28
    },
    {
        "CHNENBL29",
        "",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl29
    },
    {
        "CHNENBL30",
        "",
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl30
    },
    {
        "CHNENBL31",
        "",
        4, // Width in bytes
        0x0000027c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl31
    },
    {
        "CHNENBL32",
        "",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl32
    },
    {
        "CHNENBL33",
        "",
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl33
    },
    {
        "CHNENBL34",
        "",
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl34
    },
    {
        "CHNENBL35",
        "",
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl35
    },
    {
        "CHNENBL36",
        "",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl36
    },
    {
        "CHNENBL37",
        "",
        4, // Width in bytes
        0x00000294, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl37
    },
    {
        "CHNENBL38",
        "",
        4, // Width in bytes
        0x00000298, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl38
    },
    {
        "CHNENBL39",
        "",
        4, // Width in bytes
        0x0000029c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl39
    },
    {
        "CHNENBL40",
        "",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl40
    },
    {
        "CHNENBL41",
        "",
        4, // Width in bytes
        0x000002a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl41
    },
    {
        "CHNENBL42",
        "",
        4, // Width in bytes
        0x000002a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl42
    },
    {
        "CHNENBL43",
        "",
        4, // Width in bytes
        0x000002ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl43
    },
    {
        "CHNENBL44",
        "",
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl44
    },
    {
        "CHNENBL45",
        "",
        4, // Width in bytes
        0x000002b4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl45
    },
    {
        "CHNENBL46",
        "",
        4, // Width in bytes
        0x000002b8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl46
    },
    {
        "CHNENBL47",
        "",
        4, // Width in bytes
        0x000002bc, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmaarm_chnenbl47
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SDMABP
#endif

// Bitfields in register SDMABP_DC0PTR.
static const field_t hw_sdmabp_dc0ptr[] =
{
    {
        "DC0PTR",
        "Channel 0 Pointer contains the 32-bit address, in BP memory, of the ar"
        "ray of channel control blocks starting with the one for channel 0 (the"
        " control channel).",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_INTR.
static const field_t hw_sdmabp_intr[] =
{
    {
        "DI",
        "The BP Interrupts register contains the 32 DI[i] bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_STOP_STAT.
static const field_t hw_sdmabp_stop_stat[] =
{
    {
        "DE",
        "This 32-bit register gives access to the BP (DSP) Enable bits, DE.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_DSTART.
static const field_t hw_sdmabp_dstart[] =
{
    {
        "DSTART_DE",
        "The DSTART_DE registers are 32 bits wide with one bit for every channe"
        "l.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_EVTERR.
static const field_t hw_sdmabp_evterr[] =
{
    {
        "CHNERR",
        "This register is used by the SDMA to warn the BP when an incoming DMA "
        "request was detected; it then triggers a channel that is already pendi"
        "ng or being serviced, which may mean there is an overflow of data for "
        "that channel.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_INTRMASK.
static const field_t hw_sdmabp_intrmask[] =
{
    {
        "DIMASK",
        "The Interrupt Mask Register contains 32 interrupt generation mask bits"
        ".",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMABP_EVTERRDBG.
static const field_t hw_sdmabp_evterrdbg[] =
{
    {
        "CHNERR",
        "This register is the same as EVTERR except reading it does not clear i"
        "ts contents.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SDMABP module.
static const reg_t hw_sdmabp[] =
{
    {
        "DC0PTR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmabp_dc0ptr
    },
    {
        "INTR",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmabp_intr
    },
    {
        "STOP_STAT",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmabp_stop_stat
    },
    {
        "DSTART",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmabp_dstart
    },
    {
        "EVTERR",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmabp_evterr
    },
    {
        "INTRMASK",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmabp_intrmask
    },
    {
        "EVTERRDBG",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmabp_evterrdbg
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SDMACORE
#endif

// Bitfields in register SDMACORE_MC0PTR.
static const field_t hw_sdmacore_mc0ptr[] =
{
    {
        "MC0PTR",
        "Contains the address-in the ARM platform memory space-of the initial S"
        "DMA context and scripts that are loaded by the SDMA boot script runnin"
        "g on channel 0.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_CCPTR.
static const field_t hw_sdmacore_ccptr[] =
{
    {
        "CCPTR",
        "Contains the start address of the context data for the current channel"
        ": Its value is CONTEXT_BASE + 24* CCR or CONTEXT_BASE + 32* CCR where "
        "CONTEXT_BASE = 0x0800.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_CCR.
static const field_t hw_sdmacore_ccr[] =
{
    {
        "CCR",
        "Contains the number of the current running channel whose context is in"
        "stalled.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_NCR.
static const field_t hw_sdmacore_ncr[] =
{
    {
        "NCR",
        "Contains the number of the pending channel that the scheduler has sele"
        "cted to run next.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EVENTS.
static const field_t hw_sdmacore_events[] =
{
    {
        "EVENTS",
        "Reflects the status of the SDMA's external DMA requests.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_CCPRI.
static const field_t hw_sdmacore_ccpri[] =
{
    {
        "CCPRI",
        "Contains the 3-bit priority of the channel whose context is installed.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_NCPRI.
static const field_t hw_sdmacore_ncpri[] =
{
    {
        "NCPRI",
        "Contains the 3-bit priority of the channel the scheduler has selected "
        "to run next.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_ECOUNT.
static const field_t hw_sdmacore_ecount[] =
{
    {
        "ECOUNT",
        "The event cell counter contains the number of times minus one that an "
        "event detection must occur before generating a debug request.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_ECTL.
static const field_t hw_sdmacore_ectl[] =
{
    {
        "ATS",
        "The access type select bits define the memory access type required on "
        "the SDMA memory bus.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AATC",
        "The Address A Trigger Condition (AATC) controls the operations perform"
        "ed by address comparator A.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ABTC",
        "The Address B Trigger Condition (ABTC) controls the operations perform"
        "ed by address comparator B.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATC",
        "The address trigger condition bits select how the two address conditio"
        "ns (addressA and addressB) are combined to define the global address m"
        "atching condition.",
        6, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTC",
        "The data trigger condition bits define when data is considered matchin"
        "g after comparison with the data register of the event detection unit.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ECTC",
        "The event cell trigger condition bits select the combination of addres"
        "s and data matching conditions that generate the final address/data co"
        "ndition.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNT",
        "Event Counter Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN",
        "Event Cell Enable.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EAA.
static const field_t hw_sdmacore_eaa[] =
{
    {
        "EAA",
        "Event Cell Address Register A computes an address A condition.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EAB.
static const field_t hw_sdmacore_eab[] =
{
    {
        "EAB",
        "Event Cell Address Register B computes an address B condition.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EAM.
static const field_t hw_sdmacore_eam[] =
{
    {
        "EAM",
        "The Event Cell Address Mask contains a user-defined address mask value"
        ".",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_ED.
static const field_t hw_sdmacore_ed[] =
{
    {
        "ED",
        "The event cell data register contains a user defined data value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EDM.
static const field_t hw_sdmacore_edm[] =
{
    {
        "EDM",
        "The event cell data mask register contains the user-defined data mask "
        "value.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_RTB.
static const field_t hw_sdmacore_rtb[] =
{
    {
        "RTB",
        "The Real Time Buffer register stores and retrieves run time informatio"
        "n without putting the SDMA in debug mode.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_TB.
static const field_t hw_sdmacore_tb[] =
{
    {
        "CHFADDR",
        "The change of flow address is the address where the change of flow is "
        "taken when executing a change of flow instruction.",
        0, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TADDR",
        "The target address is the address taken after the execution of the cha"
        "nge of flow instruction.",
        14, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TBF",
        "The Trace Buffer Flag is set when the buffer contains the addresses of"
        " a valid change of flow.",
        28, // LSB
        28, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_OSTAT.
static const field_t hw_sdmacore_ostat[] =
{
    {
        "ECDR",
        "Event Cell Debug Request.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MST",
        "This flag is raised when the OnCE is controlled from the ARM platform "
        "peripheral interface.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWB",
        "This flag is raised when the SDMA has entered debug mode after a softw"
        "are breakpoint.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ODR",
        "This flag is raised when the SDMA has entered debug mode after a OnCE "
        "debug request.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EDR",
        "This flag is raised when the SDMA has entered debug mode after an exte"
        "rnal debug request.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RCV",
        "After each write access to the real time buffer (RTB), the RCV bit is "
        "set.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PST",
        "The Processor Status bits reflect the state of the SDMA RISC engine.",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_MCHN0ADDR.
static const field_t hw_sdmacore_mchn0addr[] =
{
    {
        "CHN0ADDR",
        "Contains the address of the channel 0 routine programmed by the ARM pl"
        "atform; it is loaded into a general register at the very start of the "
        "boot and the SDMA jumps to the address it contains.",
        0, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SMSZ",
        "The bit 14 (Scratch Memory Size) determines if scratch memory must be "
        "available after every channel context.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_ENDIANNESS.
static const field_t hw_sdmacore_endianness[] =
{
    {
        "APEND",
        "APEND indicates the endian mode of the Peripheral and Burst DMA interf"
        "aces.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_SDMA_LOCK.
static const field_t hw_sdmacore_sdma_lock[] =
{
    {
        "LOCK",
        "The LOCK bit reports the value of the LOCK bit in the SDMA_LOCK status"
        " register.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SDMACORE_EVENTS2.
static const field_t hw_sdmacore_events2[] =
{
    {
        "EVENTS",
        "Reflects the status of the SDMA's external DMA requests.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SDMACORE module.
static const reg_t hw_sdmacore[] =
{
    {
        "MC0PTR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_mc0ptr
    },
    {
        "CCPTR",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ccptr
    },
    {
        "CCR",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ccr
    },
    {
        "NCR",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ncr
    },
    {
        "EVENTS",
        "This register is very useful in the case of DMA requests that are acti"
        "ve when a peripheral FIFO level is above the programmed watermark.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_events
    },
    {
        "CCPRI",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ccpri
    },
    {
        "NCPRI",
        "",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_ncpri
    },
    {
        "ECOUNT",
        "",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_ecount
    },
    {
        "ECTL",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_sdmacore_ectl
    },
    {
        "EAA",
        "",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_eaa
    },
    {
        "EAB",
        "",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_eab
    },
    {
        "EAM",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_eam
    },
    {
        "ED",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_ed
    },
    {
        "EDM",
        "",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_edm
    },
    {
        "RTB",
        "",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_sdmacore_rtb
    },
    {
        "TB",
        "",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sdmacore_tb
    },
    {
        "OSTAT",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_sdmacore_ostat
    },
    {
        "MCHN0ADDR",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_sdmacore_mchn0addr
    },
    {
        "ENDIANNESS",
        "",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_endianness
    },
    {
        "SDMA_LOCK",
        "",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_sdma_lock
    },
    {
        "EVENTS2",
        "",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sdmacore_events2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SJC
#endif

// Bitfields in register SJC_GPUSR1.
static const field_t hw_sjc_gpusr1[] =
{
    {
        "A_DBG",
        "ARM core debug status bit Bit 0 is the ARM core DBGACK (debug acknowle"
        "dge) DBGACK can be overwritten in the ARM core DCR to force a particul"
        "ar DBGACK value.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "A_WFI",
        "ARM core wait-for interrupt bit Bit 1 is the ARM core standbywfi (stan"
        "d by wait-for interrupt).",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "S_STAT",
        "3 LSBits of SDMA core statusH.",
        2, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PLL_LOCK",
        "PLL_LOCK A Combined PLL-Lock flag indicator, for all the PLL's.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_GPUSR2.
static const field_t hw_sjc_gpusr2[] =
{
    {
        "STBYWFI",
        "STBYWFI[3:0] These bits provide status of \"Standby Wait-For-Interrupt"
        "\" state of all ARM cores.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "S_STAT",
        "S_STAT[3:0] SDMA debug status bits: debug_core_state[3:0]",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STBYWFE",
        "STBYWFE[3:0] Reflecting the \"Standby Wait For Event\" signals of all "
        "cores.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_GPUSR3.
static const field_t hw_sjc_gpusr3[] =
{
    {
        "IPG_WAIT",
        "IPG_WAIT CCM's \"ipg_wait\" signal indication",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IPG_STOP",
        "IPG_STOP CCM's \"ipg_stop\" signal indication",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYS_WAIT",
        "System In wait Indication on System in wait mode (from CCM).",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_GPSSR.
static const field_t hw_sjc_gpssr[] =
{
    {
        "GPSSR",
        "General Purpose Secured Status Register Register is used for testing a"
        "nd debug.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_DCR.
static const field_t hw_sjc_dcr[] =
{
    {
        "DE_TO_ARM",
        "ARM platform debug request input propagation This bit controls the pro"
        "pagation of debug request to ARM platform (\"dbgreq\"), when the JTAG "
        "state machine is put in \"ENTER_DEBUG\" IR instruction.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DE_TO_SDMA",
        "SDMA debug request input propagation This bit controls the propagation"
        " of debug request to SDMA, when the JTAG state machine is put in \"ENT"
        "ER_DEBUG\" IR instruction.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_OBS",
        "Debug observability This bit controls the propagation of the \"system "
        "debug\" input to SJC For i.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIRECT_SDMA_REQ_EN",
        "Debug enable of the sdma debug request This bit controls the propagati"
        "on of debug request DE_B to the sdma.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DIRECT_ARM_REQ_EN",
        "Pass Debug Enable event from DE_B pin to ARM platform debug request si"
        "gnal(s).",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_SSR.
static const field_t hw_sjc_ssr[] =
{
    {
        "KTF",
        "Kill Trace Enable fuse value",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "KTA",
        "Kill Trace is active",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWF",
        "Software JTAG enable fuse Status of the no SW disable JTAG fuse",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SWE",
        "SW enable SW JTAG enable status",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EBF",
        "External Boot fuse Status of the external boot disable fuse",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EBG",
        "External boot granted External boot enabled, requested and granted",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FT",
        "Fuse type Fuse type bit - e-fuse or laser fuse",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SJM",
        "SJC Secure mode Secure JTAG mode, as set by external fuses.",
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSSTAT",
        "Response status Response status bits",
        11, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOTIND",
        "Boot Indication Inverted Internal Boot indication, i.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SJC_GPCCR.
static const field_t hw_sjc_gpccr[] =
{
    {
        "SCLKR",
        "SDMA Clock ON Register - This bit forces the clock on of the SDMA",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACLKOFFDIS",
        "Disable/prevent ARM platform clock/power shutdown",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SJC module.
static const reg_t hw_sjc[] =
{
    {
        "GPUSR1",
        "The General Purpose Unsecured Status Register 1 is a read only registe"
        "rs used to check the status of the different Cores and of the PLL.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_sjc_gpusr1
    },
    {
        "GPUSR2",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sjc_gpusr2
    },
    {
        "GPUSR3",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_sjc_gpusr3
    },
    {
        "GPSSR",
        "The General Purpose Secured Status Register is a read-only register us"
        "ed to check the status of the different critical information in the So"
        "C.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_sjc_gpssr
    },
    {
        "DCR",
        "This register is used to control propagation of debug request from DE_"
        "B pad to the cores and debug signals from internal logic to the DE_B p"
        "ad.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_sjc_dcr
    },
    {
        "SSR",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        10, // Number of bitfields
        hw_sjc_ssr
    },
    {
        "GPCCR",
        "This register is used to configure clock related modes in SOC, see Sys"
        "tem Configuration chapter for more information.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_sjc_gpccr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SNVS
#endif

// Bitfields in register SNVS_HPLR.
static const field_t hw_snvs_hplr[] =
{
    {
        "MC_SL",
        "Monotonic Counter Soft Lock When set, prevents any writes (increments)"
        " to the MC Registers and MC_ENV bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPR_SL",
        "General Purpose Register Soft Lock When set, prevents any writes to th"
        "e GPR.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPCOMR.
static const field_t hw_snvs_hpcomr[] =
{
    {
        "LP_SWR",
        "LP Software Reset When set, it resets the SNVS_LP section.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LP_SWR_DIS",
        "LP Software Reset Disable When set, disables the LP software reset.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NPSWA_EN",
        "Non-Privileged Software Access Enable When set, allows non-privileged "
        "software to access all SNVS registers, including those that are privil"
        "eged software read/write access only.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPCR.
static const field_t hw_snvs_hpcr[] =
{
    {
        "RTC_EN",
        "HP Real Time Counter Enable",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPTA_EN",
        "HP Time Alarm Enable When set, the time alarm interrupt is generated i"
        "f the value in the HP Time Alarm Registers is equal to the value of th"
        "e HP Real Time Counter.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PI_EN",
        "HP Periodic Interrupt Enable The periodic interrupt can be generated o"
        "nly if the HP Real Time Counter is enabled.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PI_FREQ",
        "Periodic Interrupt Frequency Defines frequency of the periodic interru"
        "pt.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPCALB_EN",
        "HP Real Time Counter Calibration Enabled Indicates that the time calib"
        "ration mechanism is enabled.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HPCALB_VAL",
        "HP Calibration Value Defines signed calibration value for the HP Real "
        "Time Counter.",
        10, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BTN_CONFIG",
        "Button Configuration.",
        24, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BTN_MASK",
        "Button interrupt mask.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPSR.
static const field_t hw_snvs_hpsr[] =
{
    {
        "BTN",
        "Value of the BTN input.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BI",
        "Button Interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPRTCMR.
static const field_t hw_snvs_hprtcmr[] =
{
    {
        "RTC",
        "HP Real Time Counter Most significant 32 bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPRTCLR.
static const field_t hw_snvs_hprtclr[] =
{
    {
        "RTC",
        "HP Real Time Counter Least significant 32 bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPTAMR.
static const field_t hw_snvs_hptamr[] =
{
    {
        "HPTA",
        "HP Time Alarm Most significant 15 bits.",
        0, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPTALR.
static const field_t hw_snvs_hptalr[] =
{
    {
        "HPTA",
        "HP Time Alarm Least significant bits.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPLR.
static const field_t hw_snvs_lplr[] =
{
    {
        "MC_HL",
        "Monotonic Counter Hard Lock When set, prevents any writes (increments)"
        " to the MC Registers and MC_ENV bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPR_HL",
        "General Purpose Register Hard Lock When set, prevents any writes to th"
        "e GPR.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPCR.
static const field_t hw_snvs_lpcr[] =
{
    {
        "MC_ENV",
        "Monotonic Counter Enable and Valid When set, the MC can be incremented"
        " (by write transaction to the LPSMCMR or LPSMCLR).",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP_EN",
        "Dumb PMIC Enabled When set, software can control the system power.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TOP",
        "Turn off System Power Asserting this bit causes a signal to be sent to"
        " the Power Management IC to turn off the system power.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWR_GLITCH_EN",
        "By default the detection of a power glitch does not cause the pmic_en_"
        "b signal to be asserted.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BTN_PRESS_TIME",
        "Button press time out values for PMIC Logic.",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBOUNCE",
        "This field configures the amount of debounce time for the BTN input si"
        "gnal.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ON_TIME",
        "The ON_TIME field is used to configure the period of time after BTN is"
        " asserted before pmic_en_b is asserted to turn on the SoCpower.",
        20, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PK_EN",
        "PMIC On Request Enable.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PK_OVERRIDE",
        "PMIC On Request Override.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPSR.
static const field_t hw_snvs_lpsr[] =
{
    {
        "MCR",
        "Monotonic Counter Rollover.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EO",
        "Emergency Off This bit is set when a power off is requested.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SPO",
        "Set Power Off The SPO bit is set when the set_pwr_off_irq interrupt is"
        " triggered, which happens when software writes a 1 to the TOP bit in t"
        "he LPCR or when the power button is pressed longer than the configured"
        " debounce time.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPSMCMR.
static const field_t hw_snvs_lpsmcmr[] =
{
    {
        "MON_COUNTER",
        "Monotonic Counter Most Significant 16 Bits The MC is incremented by on"
        "e when: A write transaction to the LPSMCMR or LPSMCLR register is dete"
        "cted.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MC_ERA_BITS",
        "Monotonic Counter Era Bits These bits are inputs to the module and typ"
        "ically connect to fuses.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPSMCLR.
static const field_t hw_snvs_lpsmclr[] =
{
    {
        "MON_COUNTER",
        "Monotonic Counter bits The MC is incremented by one when: A write tran"
        "saction to the LPSMCMR or LPSMCLR Register is detected.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_LPGPR.
static const field_t hw_snvs_lpgpr[] =
{
    {
        "GPR",
        "General Purpose Register When GPR_SL or GPR_HL bit is set, the registe"
        "r cannot be programmed.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPVIDR1.
static const field_t hw_snvs_hpvidr1[] =
{
    {
        "MINOR_REV",
        "SNVS block minor version number",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR_REV",
        "SNVS block major version number",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IP_ID",
        "SNVS block ID",
        16, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SNVS_HPVIDR2.
static const field_t hw_snvs_hpvidr2[] =
{
    {
        "CONFIG_OPT",
        "SNVS Configuration Option",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ECO_REV",
        "SNVS ECO Revision",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INTG_OPT",
        "SNVS Integration Option",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IP_ERA",
        "00h - Era 1 or 2 03h - Era 3 04h - Era 4 05h - Era 5",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SNVS module.
static const reg_t hw_snvs[] =
{
    {
        "HPLR",
        "The SNVS_HP Lock Register contains lock bits for the SNVS registers.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_snvs_hplr
    },
    {
        "HPCOMR",
        "The SNVS_HP Command Register contains the command, configuration, and "
        "control bits for the SNVS block.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_snvs_hpcomr
    },
    {
        "HPCR",
        "The SNVS_HP Control Register contains various control bits of the HP s"
        "ection of SNVS .",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_snvs_hpcr
    },
    {
        "HPSR",
        "The HP Status Register reflects the internal state of the SNVS.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_snvs_hpsr
    },
    {
        "HPRTCMR",
        "The SNVS_HP Real Time Counter MSB register contains the most significa"
        "nt bits of the HP Real Time Counter.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_hprtcmr
    },
    {
        "HPRTCLR",
        "The SNVS_HP Real Time Counter LSB register contains the 32 least signi"
        "ficant bits of the HP real time counter.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_hprtclr
    },
    {
        "HPTAMR",
        "The SNVS_HP Time Alarm MSB register contains the most significant bits"
        " of the SNVS_HP Time Alarm value.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_hptamr
    },
    {
        "HPTALR",
        "The SNVS_HP Time Alarm LSB register contains the 32 least significant "
        "bits of the SNVS_HP Time Alarm value.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_hptalr
    },
    {
        "LPLR",
        "The SNVS_LP Lock Register contains lock bits for the SNVS_LP registers"
        ".",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_snvs_lplr
    },
    {
        "LPCR",
        "The SNVS_LP Control Register contains various control bits of the LP s"
        "ection of SNVS.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_snvs_lpcr
    },
    {
        "LPSR",
        "The SNVS_LP Status Register reflects the internal state and behavior o"
        "f the SNVS_LP.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_snvs_lpsr
    },
    {
        "LPSMCMR",
        "The SNVS_LP Secure Monotonic Counter MSB Register contains the monoton"
        "ic counter era bits and the most significant 16 bits of the monotonic "
        "counter.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_snvs_lpsmcmr
    },
    {
        "LPSMCLR",
        "The SNVS_LP Secure Monotonic Counter LSB Register contains the 32 leas"
        "t significant bits of the monotonic counter.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpsmclr
    },
    {
        "LPGPR",
        "The SNVS_LP General Purpose Register is a 32-bit read/write register l"
        "ocated in the low power domain.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_snvs_lpgpr
    },
    {
        "HPVIDR1",
        "The SNVS_HP Version ID Register 1 is a read-only register that contain"
        "s the current version of the SNVS .",
        4, // Width in bytes
        0x00000bf8, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_snvs_hpvidr1
    },
    {
        "HPVIDR2",
        "The SNVS_HP Version ID Register 2 is a read-only register that indicat"
        "es the current version of the SNVS.",
        4, // Width in bytes
        0x00000bfc, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_snvs_hpvidr2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SPBA
#endif

// Bitfields in register SPBA_PRR0.
static const field_t hw_spba_prr0[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR1.
static const field_t hw_spba_prr1[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR2.
static const field_t hw_spba_prr2[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR3.
static const field_t hw_spba_prr3[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR4.
static const field_t hw_spba_prr4[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR5.
static const field_t hw_spba_prr5[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR6.
static const field_t hw_spba_prr6[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR7.
static const field_t hw_spba_prr7[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR8.
static const field_t hw_spba_prr8[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR9.
static const field_t hw_spba_prr9[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR10.
static const field_t hw_spba_prr10[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR11.
static const field_t hw_spba_prr11[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR12.
static const field_t hw_spba_prr12[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR13.
static const field_t hw_spba_prr13[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR14.
static const field_t hw_spba_prr14[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR15.
static const field_t hw_spba_prr15[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR16.
static const field_t hw_spba_prr16[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR17.
static const field_t hw_spba_prr17[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR18.
static const field_t hw_spba_prr18[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR19.
static const field_t hw_spba_prr19[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR20.
static const field_t hw_spba_prr20[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR21.
static const field_t hw_spba_prr21[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR22.
static const field_t hw_spba_prr22[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR23.
static const field_t hw_spba_prr23[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR24.
static const field_t hw_spba_prr24[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR25.
static const field_t hw_spba_prr25[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR26.
static const field_t hw_spba_prr26[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR27.
static const field_t hw_spba_prr27[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR28.
static const field_t hw_spba_prr28[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR29.
static const field_t hw_spba_prr29[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR30.
static const field_t hw_spba_prr30[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPBA_PRR31.
static const field_t hw_spba_prr31[] =
{
    {
        "RARA",
        "Resource Access Right.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARB",
        "Resource Access Right.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RARC",
        "Resource Access Right.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ROI",
        "Resource Owner ID.",
        16, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RMO",
        "Requesting Master Owner.",
        30, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a SPBA module.
static const reg_t hw_spba[] =
{
    {
        "PRR0",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr0
    },
    {
        "PRR1",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr1
    },
    {
        "PRR2",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr2
    },
    {
        "PRR3",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr3
    },
    {
        "PRR4",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr4
    },
    {
        "PRR5",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr5
    },
    {
        "PRR6",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr6
    },
    {
        "PRR7",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr7
    },
    {
        "PRR8",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr8
    },
    {
        "PRR9",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr9
    },
    {
        "PRR10",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr10
    },
    {
        "PRR11",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr11
    },
    {
        "PRR12",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr12
    },
    {
        "PRR13",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr13
    },
    {
        "PRR14",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr14
    },
    {
        "PRR15",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr15
    },
    {
        "PRR16",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr16
    },
    {
        "PRR17",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr17
    },
    {
        "PRR18",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr18
    },
    {
        "PRR19",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000004c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr19
    },
    {
        "PRR20",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr20
    },
    {
        "PRR21",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr21
    },
    {
        "PRR22",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr22
    },
    {
        "PRR23",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr23
    },
    {
        "PRR24",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr24
    },
    {
        "PRR25",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr25
    },
    {
        "PRR26",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr26
    },
    {
        "PRR27",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000006c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr27
    },
    {
        "PRR28",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr28
    },
    {
        "PRR29",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr29
    },
    {
        "PRR30",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr30
    },
    {
        "PRR31",
        "This register controls master ownership and access for a peripheral.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_spba_prr31
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SPDIF
#endif

// Bitfields in register SPDIF_SCR.
static const field_t hw_spdif_scr[] =
{
    {
        "USRC_SEL",
        "",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSEL",
        "",
        2, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALCTRL",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_TX_EN",
        "DMA Transmit Request Enable (Tx FIFO empty)",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMA_RX_EN",
        "DMA Receive Request Enable (RX FIFO full)",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFO_CTRL",
        "",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SOFT_RESET",
        "When write 1 to this bit, it will cause SPDIF software reset.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOW_POWER",
        "When write 1 to this bit, it will cause SPDIF enter low-power mode.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOEMPTY_SEL",
        "",
        15, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXAUTOSYNC",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXAUTOSYNC",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFOFULL_SEL",
        "",
        19, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFO_RST",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFO_OFF_ON",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFO_CTRL",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRCD.
static const field_t hw_spdif_srcd[] =
{
    {
        "USYNCMODE",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRPC.
static const field_t hw_spdif_srpc[] =
{
    {
        "GAINSEL",
        "Gain selection:",
        3, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "LOCK bit to show that the internal DPLL is locked, read only",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKSRC_SEL",
        "Clock source selection, all other settings not shown are reserved:",
        7, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SIE.
static const field_t hw_spdif_sie[] =
{
    {
        "RXFIFOFUL",
        "SPDIF Rx FIFO full, can't be cleared with reg.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXEM",
        "SPDIF Tx FIFO empty, can't be cleared with reg.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCKLOSS",
        "SPDIF receiver loss of lock",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFORESYN",
        "Rx FIFO resync",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFIFOUNOV",
        "Rx FIFO underrun/overrun",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UQERR",
        "U/Q Channel framing error",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UQSYNC",
        "U/Q Channel sync found",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QRXOV",
        "Q Channel receive register overrun",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "QRXFUL",
        "Q Channel receive register full, can't be cleared with reg.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URXOV",
        "U Channel receive register overrun",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URXFUL",
        "U Channel receive register full, can't be cleared with reg.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BITERR",
        "SPDIF receiver found parity bit error",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYMERR",
        "SPDIF receiver found illegal symbol",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALNOGOOD",
        "SPDIF validity flag no good",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CNEW",
        "SPDIF receive change in value of control channel",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXRESYN",
        "SPDIF Tx FIFO resync",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXUNOV",
        "SPDIF Tx FIFO under/overrun",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOCK",
        "SPDIF receiver's DPLL is locked",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SIS.
static const field_t hw_spdif_sis[] =
{
    {
        "RXFIFOFUL",
        "SPDIF Rx FIFO full, can't be cleared with reg.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXEM",
        "SPDIF Tx FIFO empty, can't be cleared with reg.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCKLOSS",
        "SPDIF receiver loss of lock",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFIFORESYN",
        "Rx FIFO resync",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXFIFOUNOV",
        "Rx FIFO underrun/overrun",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UQERR",
        "U/Q Channel framing error",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UQSYNC",
        "U/Q Channel sync found",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "QRXOV",
        "Q Channel receive register overrun",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "QRXFUL",
        "Q Channel receive register full, can't be cleared with reg.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "URXOV",
        "U Channel receive register overrun",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "URXFUL",
        "U Channel receive register full, can't be cleared with reg.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BITERR",
        "SPDIF receiver found parity bit error",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SYMERR",
        "SPDIF receiver found illegal symbol",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VALNOGOOD",
        "SPDIF validity flag no good",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CNEW",
        "SPDIF receive change in value of control channel",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXRESYN",
        "SPDIF Tx FIFO resync",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXUNOV",
        "SPDIF Tx FIFO under/overrun",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LOCK",
        "SPDIF receiver's DPLL is locked",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SIC.
static const field_t hw_spdif_sic[] =
{
    {
        "LOCKLOSS",
        "SPDIF receiver loss of lock",
        2, // LSB
        2, // MSB
        false, // Readable
        false // Writable
    },
    {
        "RXFIFORESYN",
        "Rx FIFO resync",
        3, // LSB
        3, // MSB
        false, // Readable
        false // Writable
    },
    {
        "RXFIFOUNOV",
        "Rx FIFO underrun/overrun",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "UQERR",
        "U/Q Channel framing error",
        5, // LSB
        5, // MSB
        false, // Readable
        false // Writable
    },
    {
        "UQSYNC",
        "U/Q Channel sync found",
        6, // LSB
        6, // MSB
        false, // Readable
        false // Writable
    },
    {
        "QRXOV",
        "Q Channel receive register overrun",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "URXOV",
        "U Channel receive register overrun",
        9, // LSB
        9, // MSB
        false, // Readable
        false // Writable
    },
    {
        "BITERR",
        "SPDIF receiver found parity bit error",
        14, // LSB
        14, // MSB
        false, // Readable
        false // Writable
    },
    {
        "SYMERR",
        "SPDIF receiver found illegal symbol",
        15, // LSB
        15, // MSB
        false, // Readable
        false // Writable
    },
    {
        "VALNOGOOD",
        "SPDIF validity flag no good",
        16, // LSB
        16, // MSB
        false, // Readable
        false // Writable
    },
    {
        "CNEW",
        "SPDIF receive change in value of control channel",
        17, // LSB
        17, // MSB
        false, // Readable
        false // Writable
    },
    {
        "TXRESYN",
        "SPDIF Tx FIFO resync",
        18, // LSB
        18, // MSB
        false, // Readable
        false // Writable
    },
    {
        "TXUNOV",
        "SPDIF Tx FIFO under/overrun",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "LOCK",
        "SPDIF receiver's DPLL is locked",
        20, // LSB
        20, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRL.
static const field_t hw_spdif_srl[] =
{
    {
        "RXDATALEFT",
        "Processor receive SPDIF data left",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRR.
static const field_t hw_spdif_srr[] =
{
    {
        "RXDATARIGHT",
        "Processor receive SPDIF data right",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRCSH.
static const field_t hw_spdif_srcsh[] =
{
    {
        "RXCCHANNEL_H",
        "SPDIF receive C channel register, contains first 24 bits of C channel "
        "without interpretation",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRCSL.
static const field_t hw_spdif_srcsl[] =
{
    {
        "RXCCHANNEL_L",
        "SPDIF receive C channel register, contains next 24 bits of C channel w"
        "ithout interpretation",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRU.
static const field_t hw_spdif_sru[] =
{
    {
        "RXUCHANNEL",
        "SPDIF receive U channel register, contains next 3 U channel bytes",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRQ.
static const field_t hw_spdif_srq[] =
{
    {
        "RXQCHANNEL",
        "SPDIF receive Q channel register, contains next 3 Q channel bytes",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STL.
static const field_t hw_spdif_stl[] =
{
    {
        "TXDATALEFT",
        "SPDIF transmit left channel data.",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STR.
static const field_t hw_spdif_str[] =
{
    {
        "TXDATARIGHT",
        "SPDIF transmit right channel data.",
        0, // LSB
        23, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STCSCH.
static const field_t hw_spdif_stcsch[] =
{
    {
        "TXCCHANNELCONS_H",
        "SPDIF transmit Cons.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STCSCL.
static const field_t hw_spdif_stcscl[] =
{
    {
        "TXCCHANNELCONS_L",
        "SPDIF transmit Cons.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_SRFM.
static const field_t hw_spdif_srfm[] =
{
    {
        "FREQMEAS",
        "Frequency measurement data",
        0, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SPDIF_STC.
static const field_t hw_spdif_stc[] =
{
    {
        "TXCLK_DF",
        "Divider factor (1-128)",
        0, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TX_ALL_CLK_EN",
        "Spdif transfer clock enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCLK_SOURCE",
        "",
        8, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SYSCLK_DF",
        "system clock divider factor, 2~512.",
        11, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a SPDIF module.
static const reg_t hw_spdif[] =
{
    {
        "SCR",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_spdif_scr
    },
    {
        "SRCD",
        "",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_spdif_srcd
    },
    {
        "SRPC",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_spdif_srpc
    },
    {
        "SIE",
        "The InterruptEn register (SPDIF_SIE) provides control over the enablin"
        "g of interrupts.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        18, // Number of bitfields
        hw_spdif_sie
    },
    {
        "SIS",
        "The InterruptStat (SPDIF_SIS) register is a read only register that pr"
        "ovides the status on interrupt operations.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        18, // Number of bitfields
        hw_spdif_sis
    },
    {
        "SIC",
        "The InterruptClear (SPDIF_SIC) register is a write only register and i"
        "s used to clear interrupts.",
        4, // Width in bytes
        0x00000010, // Base address offset
        false, // Readable
        false, // Writable
        14, // Number of bitfields
        hw_spdif_sic
    },
    {
        "SRL",
        "SPDIFRxLeft register is an audio data reception register.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_srl
    },
    {
        "SRR",
        "SPDIFRxRight register is an audio data reception register.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_srr
    },
    {
        "SRCSH",
        "SPDIFRxCChannel_h register is a channel status reception register.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_srcsh
    },
    {
        "SRCSL",
        "SPDIFRxCChannel_l register is a channel status reception register.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_srcsl
    },
    {
        "SRU",
        "UChannelRx register is a user bits reception register.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_sru
    },
    {
        "SRQ",
        "QChannelRx register is a user bits reception register.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_srq
    },
    {
        "STL",
        "SPDIFTxLeft register is an audio data transmission register.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_stl
    },
    {
        "STR",
        "SPDIFTxRight register is an audio data transmission register.",
        4, // Width in bytes
        0x00000030, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_str
    },
    {
        "STCSCH",
        "SPDIFTxCChannelCons_h register is a channel status transmission regist"
        "er.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_spdif_stcsch
    },
    {
        "STCSCL",
        "SPDIFTxCChannelCons_l register is a channel status transmission regist"
        "er.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_spdif_stcscl
    },
    {
        "SRFM",
        "",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_spdif_srfm
    },
    {
        "STC",
        "The SPDIFTxClk Control register includes the means to select the trans"
        "mit clock and frequency division.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_spdif_stc
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark SRC
#endif

// Bitfields in register SRC_SCR.
static const field_t hw_src_scr[] =
{
    {
        "WARM_RESET_ENABLE",
        "WARM reset enable bit.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WARM_RST_BYPASS_COUNT",
        "Defines the XTALI cycles to count before bypassing the MMDC acknowledg"
        "e for WARM reset.",
        5, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_WDOG_RST",
        "Mask wdog_rst_b source.",
        7, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EIM_RST",
        "EIM reset is needed in order to reconfigure the eim chip select.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE0_RST",
        "Software reset for core0 only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORE0_DBG_RST",
        "Software reset for core0 debug only.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CORES_DBG_RST",
        "Software reset for debug of arm platform only.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG3_RST_OPTN",
        "Wdog3_rst_b option",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBG_RST_MSK_PG",
        "Do not assert debug resets after power gating event of core",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MIX_RST_STRCH",
        "SoC mix (Audio, ENET, uSDHC, EIM, QSPI, OCRAM, MMDC, etc) power up res"
        "et stretch mix reset width = (mix_rst_strtch +1)* 88 ipg_clk cycles",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MASK_WDOG3_RST",
        "Mask wdog3_rst_b source.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SBMR1.
static const field_t hw_src_sbmr1[] =
{
    {
        "BOOT_CFG1",
        "Refer to fusemap.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOT_CFG2",
        "Refer to fusemap.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOT_CFG3",
        "Refer to fusemap.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BOOT_CFG4",
        "Refer to fusemap.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SRSR.
static const field_t hw_src_srsr[] =
{
    {
        "IPP_RESET_B",
        "Indicates whether reset was the result of ipp_reset_b pin (Power-up se"
        "quence)",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CSU_RESET_B",
        "Indicates whether the reset was the result of the csu_reset_b input.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPP_USER_RESET_B",
        "Indicates whether the reset was the result of the ipp_user_reset_b qua"
        "lified reset.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG_RST_B",
        "IC Watchdog Time-out reset.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "JTAG_RST_B",
        "HIGH - Z JTAG reset.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "JTAG_SW_RST",
        "JTAG software reset.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDOG3_RST_B",
        "IC Watchdog3 Time-out reset.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TEMPSENSE_RST_B",
        "Temper Sensor software reset.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WARM_BOOT",
        "WARM boot indication shows that WARM boot was initiated by software.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SISR.
static const field_t hw_src_sisr[] =
{
    {
        "CORE0_WDOG_RST_REQ",
        "WDOG reset request from core0.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_SBMR2.
static const field_t hw_src_sbmr2[] =
{
    {
        "SEC_CONFIG",
        "SECONFIG[1] shows the state of the SECONFIG[1] fuse.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DIR_BT_DIS",
        "DIR_BT_DIS shows the state of the DIR_BT_DIS fuse.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BT_FUSE_SEL",
        "BT_FUSE_SEL (connected to gpio bt_fuse_sel) shows the state of the BT_"
        "FUSE_SEL fuse.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BMOD",
        "BMOD[1:0] shows the latched state of the BOOT_MODE1 and BOOT_MODE0 sig"
        "nals on the rising edge of POR_B.",
        24, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR1.
static const field_t hw_src_gpr1[] =
{
    {
        "PERSISTENT_ENTRY0",
        "Holds entry function for core0 for waking-up from low power mode.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR2.
static const field_t hw_src_gpr2[] =
{
    {
        "PERSISTENT_ARG0",
        "Holds argument of entry function for core0 for waking-up from low powe"
        "r mode.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR3.
static const field_t hw_src_gpr3[] =
{
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR4.
static const field_t hw_src_gpr4[] =
{
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR5.
static const field_t hw_src_gpr5[] =
{
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR6.
static const field_t hw_src_gpr6[] =
{
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR7.
static const field_t hw_src_gpr7[] =
{
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR8.
static const field_t hw_src_gpr8[] =
{
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR9.
static const field_t hw_src_gpr9[] =
{
    { 0 } // Terminator
};

// Bitfields in register SRC_GPR10.
static const field_t hw_src_gpr10[] =
{
    { 0 } // Terminator
};

// Registers in a SRC module.
static const reg_t hw_src[] =
{
    {
        "SCR",
        "The Reset control register (SCR), contains bits that control operation"
        " of the reset controller.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_src_scr
    },
    {
        "SBMR1",
        "The Boot Mode register (SBMR) contains bits that reflect the status of"
        " Boot Mode Pins of the chip.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_src_sbmr1
    },
    {
        "SRSR",
        "The SRSR is a write to one clear register which records the source of "
        "the reset events for the chip.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_src_srsr
    },
    {
        "SISR",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_src_sisr
    },
    {
        "SBMR2",
        "The Boot Mode register (SBMR), contains bits that reflect the status o"
        "f Boot Mode Pins of the chip.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_src_sbmr2
    },
    {
        "GPR1",
        "This register is used by the ROM code and should not be used by applic"
        "ation software.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_src_gpr1
    },
    {
        "GPR2",
        "This register is used by the ROM code and should not be used by applic"
        "ation software.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_src_gpr2
    },
    {
        "GPR3",
        "This register is used by the ROM code and should not be used by applic"
        "ation software.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_src_gpr3
    },
    {
        "GPR4",
        "This register is used by the ROM code and should not be used by applic"
        "ation software.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_src_gpr4
    },
    {
        "GPR5",
        "This register is used by the ROM code and should not be used by applic"
        "ation software.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_src_gpr5
    },
    {
        "GPR6",
        "This register is used by the ROM code and should not be used by applic"
        "ation software.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_src_gpr6
    },
    {
        "GPR7",
        "This register is used by the ROM code and should not be used by applic"
        "ation software.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_src_gpr7
    },
    {
        "GPR8",
        "This register is used by the ROM code and should not be used by applic"
        "ation software.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_src_gpr8
    },
    {
        "GPR9",
        "This register is used by the ROM code and should not be used by applic"
        "ation software.",
        4, // Width in bytes
        0x00000040, // Base address offset
        false, // Readable
        false, // Writable
        0, // Number of bitfields
        hw_src_gpr9
    },
    {
        "GPR10",
        "This register is used by the ROM code and should not be used by applic"
        "ation software.",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        0, // Number of bitfields
        hw_src_gpr10
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark TEMPMON
#endif

// Bitfields in register TEMPMON_TEMPSENSE0.
static const field_t hw_tempmon_tempsense0[] =
{
    {
        "POWER_DOWN",
        "This bit powers down the temperature sensor.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEASURE_TEMP",
        "Starts the measurement process.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FINISHED",
        "Indicates that the latest temp is valid.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEMP_CNT",
        "This bit field contains the last measured temperature count.",
        8, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALARM_VALUE",
        "This bit field contains the temperature count (raw sensor output) that"
        " will generate an alarm interrupt.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE0_SET.
static const field_t hw_tempmon_tempsense0_set[] =
{
    {
        "POWER_DOWN",
        "This bit powers down the temperature sensor.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEASURE_TEMP",
        "Starts the measurement process.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FINISHED",
        "Indicates that the latest temp is valid.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEMP_CNT",
        "This bit field contains the last measured temperature count.",
        8, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALARM_VALUE",
        "This bit field contains the temperature count (raw sensor output) that"
        " will generate an alarm interrupt.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE0_CLR.
static const field_t hw_tempmon_tempsense0_clr[] =
{
    {
        "POWER_DOWN",
        "This bit powers down the temperature sensor.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEASURE_TEMP",
        "Starts the measurement process.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FINISHED",
        "Indicates that the latest temp is valid.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEMP_CNT",
        "This bit field contains the last measured temperature count.",
        8, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALARM_VALUE",
        "This bit field contains the temperature count (raw sensor output) that"
        " will generate an alarm interrupt.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE0_TOG.
static const field_t hw_tempmon_tempsense0_tog[] =
{
    {
        "POWER_DOWN",
        "This bit powers down the temperature sensor.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEASURE_TEMP",
        "Starts the measurement process.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FINISHED",
        "Indicates that the latest temp is valid.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TEMP_CNT",
        "This bit field contains the last measured temperature count.",
        8, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ALARM_VALUE",
        "This bit field contains the temperature count (raw sensor output) that"
        " will generate an alarm interrupt.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE1.
static const field_t hw_tempmon_tempsense1[] =
{
    {
        "MEASURE_FREQ",
        "This bits determines how many RTC clocks to wait before automatically "
        "repeating a temperature measurement.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE1_SET.
static const field_t hw_tempmon_tempsense1_set[] =
{
    {
        "MEASURE_FREQ",
        "This bits determines how many RTC clocks to wait before automatically "
        "repeating a temperature measurement.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE1_CLR.
static const field_t hw_tempmon_tempsense1_clr[] =
{
    {
        "MEASURE_FREQ",
        "This bits determines how many RTC clocks to wait before automatically "
        "repeating a temperature measurement.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE1_TOG.
static const field_t hw_tempmon_tempsense1_tog[] =
{
    {
        "MEASURE_FREQ",
        "This bits determines how many RTC clocks to wait before automatically "
        "repeating a temperature measurement.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE2.
static const field_t hw_tempmon_tempsense2[] =
{
    {
        "LOW_ALARM_VALUE",
        "This bit field contains the temperature that will generate a low alarm"
        " interrupt when the field is greater than the temperature measurement.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PANIC_ALARM_VALUE",
        "This bit field contains the temperature that will generate a panic int"
        "errupt when exceeded by the temperature measurement.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE2_SET.
static const field_t hw_tempmon_tempsense2_set[] =
{
    {
        "LOW_ALARM_VALUE",
        "This bit field contains the temperature that will generate a low alarm"
        " interrupt when the field is greater than the temperature measurement.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PANIC_ALARM_VALUE",
        "This bit field contains the temperature that will generate a panic int"
        "errupt when exceeded by the temperature measurement.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE2_CLR.
static const field_t hw_tempmon_tempsense2_clr[] =
{
    {
        "LOW_ALARM_VALUE",
        "This bit field contains the temperature that will generate a low alarm"
        " interrupt when the field is greater than the temperature measurement.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PANIC_ALARM_VALUE",
        "This bit field contains the temperature that will generate a panic int"
        "errupt when exceeded by the temperature measurement.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TEMPMON_TEMPSENSE2_TOG.
static const field_t hw_tempmon_tempsense2_tog[] =
{
    {
        "LOW_ALARM_VALUE",
        "This bit field contains the temperature that will generate a low alarm"
        " interrupt when the field is greater than the temperature measurement.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PANIC_ALARM_VALUE",
        "This bit field contains the temperature that will generate a panic int"
        "errupt when exceeded by the temperature measurement.",
        16, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a TEMPMON module.
static const reg_t hw_tempmon[] =
{
    {
        "TEMPSENSE0",
        "This register defines the basic controls for the temperature sensor mi"
        "nus the frequency of automatic sampling which is defined in the tempse"
        "nsor.",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_tempmon_tempsense0
    },
    {
        "TEMPSENSE0_SET",
        "This register defines the basic controls for the temperature sensor mi"
        "nus the frequency of automatic sampling which is defined in the tempse"
        "nsor.",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_tempmon_tempsense0_set
    },
    {
        "TEMPSENSE0_CLR",
        "This register defines the basic controls for the temperature sensor mi"
        "nus the frequency of automatic sampling which is defined in the tempse"
        "nsor.",
        4, // Width in bytes
        0x00000188, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_tempmon_tempsense0_clr
    },
    {
        "TEMPSENSE0_TOG",
        "This register defines the basic controls for the temperature sensor mi"
        "nus the frequency of automatic sampling which is defined in the tempse"
        "nsor.",
        4, // Width in bytes
        0x0000018c, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_tempmon_tempsense0_tog
    },
    {
        "TEMPSENSE1",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x00000190, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_tempmon_tempsense1
    },
    {
        "TEMPSENSE1_SET",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x00000194, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_tempmon_tempsense1_set
    },
    {
        "TEMPSENSE1_CLR",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x00000198, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_tempmon_tempsense1_clr
    },
    {
        "TEMPSENSE1_TOG",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x0000019c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_tempmon_tempsense1_tog
    },
    {
        "TEMPSENSE2",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_tempmon_tempsense2
    },
    {
        "TEMPSENSE2_SET",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x00000294, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_tempmon_tempsense2_set
    },
    {
        "TEMPSENSE2_CLR",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x00000298, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_tempmon_tempsense2_clr
    },
    {
        "TEMPSENSE2_TOG",
        "This register defines the automatic repeat time of the temperature sen"
        "sor.",
        4, // Width in bytes
        0x0000029c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_tempmon_tempsense2_tog
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark TSC
#endif

// Bitfields in register TSC_BASIC_SETTING.
static const field_t hw_tsc_basic_setting[] =
{
    {
        "AUTO_MEASURE",
        "This field indicates after detect touch, whether automatic start measu"
        "rement.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "4_5_WIRE",
        "4-Wire Detection Mode or 5-Wire Detection Mode",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MEASURE_DELAY_TIME",
        "Before X-axis or Y-axis measurement, the screen need some time before "
        "even potential distribution ready.",
        8, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TSC_PS_INPUT_BUFFER_ADDR.
static const field_t hw_tsc_ps_input_buffer_addr[] =
{
    {
        "PRE_CHARGE_TIME",
        "This field indicates after detect touch, whether automatic start measu"
        "rement.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TSC_FLOW_CONTROL.
static const field_t hw_tsc_flow_control[] =
{
    {
        "SW_RST",
        "This is a synchronization reset, which reset all HW registers.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_MEASURE",
        "This field indicates whether start measure X/Y coordinate value after "
        "detect a touch It's a self-clean bit.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DROP_MEASURE",
        "This field indicates whether start measure X/Y coordinate value after "
        "detect a touch It's a HW self-clean bit.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "START_SENSE",
        "It's a HW self-clean bit.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE",
        "This bit is for SW disable registers.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TSC_MEASEURE_VALUE.
static const field_t hw_tsc_measeure_value[] =
{
    {
        "Y_VALUE",
        "Y coordinate value, note, it is an ADC conversion value, SW need to co"
        "nvert it to fit screen size",
        0, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "X_VALUE",
        "Coordinate valueIt is an ADC conversion value, SW need to convert it t"
        "o fit screen size.",
        16, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TSC_INT_EN.
static const field_t hw_tsc_int_en[] =
{
    {
        "MEASURE_INT_EN",
        "This field indicates whether enable the measure interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DETECT_INT_EN",
        "This field indicates whether enable the detect interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE_SW_INT_EN",
        "This field indicates whether enable the software return to idle status"
        " interrupt.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TSC_INT_SIG_EN.
static const field_t hw_tsc_int_sig_en[] =
{
    {
        "MEASURE_SIG_EN",
        "This field indicates whether enable the measure signal.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DETECT_SIG_EN",
        "This field indicates whether enable the detect signal.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALID_SIG_EN",
        "This field indicates whether enable the valid signal.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE_SW_SIG_EN",
        "This field indicates whether enable the software return to idle status"
        ".",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TSC_INT_STATUS.
static const field_t hw_tsc_int_status[] =
{
    {
        "MEASURE",
        "This field indicates whether there is a measure signal.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DETECT",
        "This field indicates whether there is a detect signal.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VALID",
        "This field indicats whether the measure value is valid.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE_SW",
        "This field indicates whether the state machine return to idle status.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TSC_DEBUG_MODE.
static const field_t hw_tsc_debug_mode[] =
{
    {
        "ADC_CONV_VALUE",
        "This signal is generated by ADC.",
        0, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADC_COCO",
        "This signal is generated by ADC.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EXT_HWTS",
        "Hardware trigger select signal, select which channel to start conversi"
        "on.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRIGGER",
        "Hardware trigger signal to ADC",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADC_COCO_CLEAR",
        "Original ADC coco only clear is system read conv result from IPS bus.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADC_COCO_CLEAR_DISABLE",
        "This bit could prevent TSC HW generates an ADC COCO clear signal.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_EN",
        "The RO registers in debug_mode and debug_mode2 always reflect the late"
        "st value and is not controlled by this bit.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register TSC_DEBUG_MODE2.
static const field_t hw_tsc_debug_mode2[] =
{
    {
        "XPUL_PULL_DOWN",
        "This is a control signal of this XPUL wire pull down switch.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XPUL_PULL_UP",
        "This is a control signal of this XPUL Wire Pull Up Switch.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XPUL_200K_PULL_UP",
        "This is a control signal of this XPUL Wire 200K Pull Up Switch.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XNUR_PULL_DOWN",
        "This is a control signal of this XNUR Wire Pull Down Switch.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XNUR_PULL_UP",
        "This is a control signal of this XNUR Wire Pull Up Switch.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XNUR_200K_PULL_UP",
        "This is a control signal of this XNUR wire 200K pull up switch.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YPLL_PULL_DOWN",
        "This is a control signal of this YPLL wire pull down switch.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YPLL_PULL_UP",
        "This is a control signal of this YPLL wire pull up switch.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YPLL_200K_PULL_UP",
        "This is a control signal of this YPLL wire 200k pull up switch.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YNLR_PULL_DOWN",
        "This is a control signal of this YNLR wire pull down switch.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YNLR_PULL_UP",
        "This is a control signal of this YNLR wire pull up switch.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "YNLR_200K_PULL_UP",
        "This is a control signal of this YNLR wire 200K pull up switch.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIPER_PULL_DOWN",
        "This is a control signal of this wiper wire pull down switch.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIPER_PULL_UP",
        "This is a control signal of this switch.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIPER_200K_PULL_UP",
        "This is a control signal of this wiper wire 200k pull up switch.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DETECT_FOUR_WIRE",
        "This field in only valid when the touch controller is under detect mod"
        "e.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DETECT_FIVE_WIRE",
        "This field in only valid when the touch controller is under detect mod"
        "e.",
        17, // LSB
        17, // MSB
        true, // Readable
        false // Writable
    },
    {
        "STATE_MACHINE",
        "",
        20, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "INTERMEDIATE",
        "It's an intermediate state, between two state machine states, in order"
        " to provide better timing for analogue.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DETECT_ENABLE_FOUR_WIRE",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DETECT_ENABLE_FIVE_WIRE",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DE_GLITCH",
        "This field indicates glitch threshold.",
        29, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a TSC module.
static const reg_t hw_tsc[] =
{
    {
        "BASIC_SETTING",
        "",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_tsc_basic_setting
    },
    {
        "PS_INPUT_BUFFER_ADDR",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_tsc_ps_input_buffer_addr
    },
    {
        "FLOW_CONTROL",
        "",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_tsc_flow_control
    },
    {
        "MEASEURE_VALUE",
        "",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_tsc_measeure_value
    },
    {
        "INT_EN",
        "",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_tsc_int_en
    },
    {
        "INT_SIG_EN",
        "",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_tsc_int_sig_en
    },
    {
        "INT_STATUS",
        "",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_tsc_int_status
    },
    {
        "DEBUG_MODE",
        "",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_tsc_debug_mode
    },
    {
        "DEBUG_MODE2",
        "",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        22, // Number of bitfields
        hw_tsc_debug_mode2
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark UART
#endif

// Bitfields in register UART_URXD.
static const field_t hw_uart_urxd[] =
{
    {
        "RX_DATA",
        "Received Data.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRERR",
        "In RS-485 mode, it holds the ninth data bit (bit [8]) of received 9-bi"
        "t RS-485 data In RS232/IrDA mode, it is the Parity Error flag.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BRK",
        "BREAK Detect.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FRMERR",
        "Frame Error.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OVRRUN",
        "Receiver Overrun.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ERR",
        "Error Detect.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CHARRDY",
        "Character Ready.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UTXD.
static const field_t hw_uart_utxd[] =
{
    {
        "TX_DATA",
        "Transmit Data.",
        0, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UCR1.
static const field_t hw_uart_ucr1[] =
{
    {
        "UARTEN",
        "UART Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DOZE",
        "DOZE.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDMAEN",
        "Aging DMA Timer Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXDMAEN",
        "Transmitter Ready DMA Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SNDBRK",
        "Send BREAK.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTSDEN",
        "RTS Delta Interrupt Enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXMPTYEN",
        "Transmitter Empty Interrupt Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IREN",
        "Infrared Interface Enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDMAEN",
        "Receive Ready DMA Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RRDYEN",
        "Receiver Ready Interrupt Enable.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ICD",
        "Idle Condition Detect.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDEN",
        "Idle Condition Detected Interrupt Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRDYEN",
        "Transmitter Ready Interrupt Enable.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADBR",
        "Automatic Detection of Baud Rate.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADEN",
        "Automatic Baud Rate Detection Interrupt Enable.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UCR2.
static const field_t hw_uart_ucr2[] =
{
    {
        "SRST",
        "Software Reset.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEN",
        "Receiver Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXEN",
        "Transmitter Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATEN",
        "Aging Timer Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTSEN",
        "Request to Send Interrupt Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WS",
        "Word Size.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STPB",
        "Stop.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PROE",
        "Parity Odd/Even.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PREN",
        "Parity Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTEC",
        "Request to Send Edge Control.",
        9, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESCEN",
        "Escape Enable.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTS",
        "Clear to Send.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTSC",
        "CTS Pin Control.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRTS",
        "Ignore RTS Pin.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESCI",
        "Escape Sequence Interrupt Enable.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UCR3.
static const field_t hw_uart_ucr3[] =
{
    {
        "ACIEN",
        "Autobaud Counter Interrupt Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVT",
        "Invert TXD output in RS-232/RS-485 mode, set TXD active level in IrDA "
        "mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDMUXSEL",
        "RXD Muxed Input Selected.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTRDEN",
        "Data Terminal Ready Delta Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AWAKEN",
        "Asynchronous WAKE Interrupt Enable.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AIRINTEN",
        "Asynchronous IR WAKE Interrupt Enable.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDSEN",
        "Receive Status Interrupt Enable.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ADNIMP",
        "Autobaud Detection Not Improved-.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RI",
        "Ring Indicator.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCD",
        "Data Carrier Detect.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DSR",
        "Data Set Ready.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRAERREN",
        "Frame Error Interrupt Enable.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PARERREN",
        "Parity Error Interrupt Enable.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTREN",
        "Data Terminal Ready Interrupt Enable.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPEC",
        "DTR/DSR Interrupt Edge Control.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UCR4.
static const field_t hw_uart_ucr4[] =
{
    {
        "DREN",
        "Receive Data Ready Interrupt Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OREN",
        "Receiver Overrun Interrupt Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BKEN",
        "BREAK Condition Detected Interrupt Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCEN",
        "Transmit Complete Interrupt Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBYP",
        "Low Power Bypass.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRSC",
        "IR Special Case.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDDMAEN",
        "DMA IDLE Condition Detected Interrupt Enable Enables/Disables the rece"
        "ive DMA request dma_req_rx for the IDLE interrupt (triggered with IDLE"
        " flag in USR2[12]).",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKEN",
        "WAKE Interrupt Enable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRI",
        "Serial Infrared Interrupt Enable.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVR",
        "Invert RXD input in RS-232/RS-485 Mode, determine RXD input logic leve"
        "l being sampled in In IrDA mode.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTSTL",
        "CTS Trigger Level.",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UFCR.
static const field_t hw_uart_ufcr[] =
{
    {
        "RXTL",
        "Receiver Trigger Level.",
        0, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCEDTE",
        "DCE/DTE mode select.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RFDIV",
        "Reference Frequency Divider.",
        7, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXTL",
        "Transmitter Trigger Level.",
        10, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_USR1.
static const field_t hw_uart_usr1[] =
{
    {
        "SAD",
        "RS-485 Slave Address Detected Interrupt Flag.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AWAKE",
        "Asynchronous WAKE Interrupt Flag.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AIRINT",
        "Asynchronous IR WAKE Interrupt Flag.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDS",
        "Receiver IDLE Interrupt Flag.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DTRD",
        "DTR Delta.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AGTIM",
        "Ageing Timer Interrupt Flag.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RRDY",
        "Receiver Ready Interrupt / DMA Flag.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "FRAMERR",
        "Frame Error Interrupt Flag.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ESCF",
        "Escape Sequence Interrupt Flag.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTSD",
        "RTS Delta.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TRDY",
        "Transmitter Ready Interrupt / DMA Flag.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTSS",
        "RTS_B Pin Status.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PARITYERR",
        "Parity Error Interrupt Flag.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_USR2.
static const field_t hw_uart_usr2[] =
{
    {
        "RDR",
        "Receive Data Ready-Indicates that at least 1 character is received and"
        " written to the RxFIFO.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ORE",
        "Overrun Error.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRCD",
        "BREAK Condition Detected.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXDC",
        "Transmitter Complete.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTSF",
        "RTS Edge Triggered Interrupt Flag.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCDIN",
        "Data Carrier Detect Input.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DCDDELT",
        "Data Carrier Detect Delta.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKE",
        "Wake.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IRINT",
        "Serial Infrared Interrupt Flag.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RIIN",
        "Ring Indicator Input.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RIDELT",
        "Ring Indicator Delta.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACST",
        "Autobaud Counter Stopped.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDLE",
        "Idle Condition.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTRF",
        "DTR edge triggered interrupt flag.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFE",
        "Transmit Buffer FIFO Empty.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADET",
        "Automatic Baud Rate Detect Complete.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UESC.
static const field_t hw_uart_uesc[] =
{
    {
        "ESC_CHAR",
        "UART Escape Character.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UTIM.
static const field_t hw_uart_utim[] =
{
    {
        "TIM",
        "UART Escape Timer.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UBIR.
static const field_t hw_uart_ubir[] =
{
    {
        "INC",
        "Incremental Numerator.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UBMR.
static const field_t hw_uart_ubmr[] =
{
    {
        "MOD",
        "Modulator Denominator.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UBRC.
static const field_t hw_uart_ubrc[] =
{
    {
        "BCNT",
        "Baud Rate Count Register.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_ONEMS.
static const field_t hw_uart_onems[] =
{
    {
        "ONEMS",
        "One Millisecond Register.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UTS.
static const field_t hw_uart_uts[] =
{
    {
        "SOFTRST",
        "Software Reset.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXFULL",
        "RxFIFO FULL.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFULL",
        "TxFIFO FULL.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXEMPTY",
        "RxFIFO Empty.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXEMPTY",
        "TxFIFO Empty.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXDBG",
        "RX_fifo_debug_mode.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOPIR",
        "Loop TX and RX for IR Test (LOOPIR).",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DBGEN",
        "debug_enable_B.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LOOP",
        "Loop TX and RX for Test.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRCPERR",
        "Force Parity Error.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register UART_UMCR.
static const field_t hw_uart_umcr[] =
{
    {
        "MDEN",
        "9-bit data or Multidrop Mode (RS-485) Enable.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLAM",
        "RS-485 Slave Address Detect Mode Selection.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXB8",
        "Transmit RS-485 bit 8 (the ninth bit or 9th bit).",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SADEN",
        "RS-485 Slave Address Detected Interrupt Enable.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLADDR",
        "RS-485 Slave Address Character.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a UART module.
static const reg_t hw_uart[] =
{
    {
        "URXD",
        "The UART will yield a transfer error on the peripheral bus when core i"
        "s reading URXD register with receive interface disabled (RXEN=0 or UAR"
        "TEN=0).",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_uart_urxd
    },
    {
        "UTXD",
        "The UART will yield a transfer error on the peripheral bus when core i"
        "s writing into UART_URXD register with transmit interface disabled (TX"
        "EN=0 or UARTEN=0).",
        4, // Width in bytes
        0x00000040, // Base address offset
        false, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_uart_utxd
    },
    {
        "UCR1",
        "",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_uart_ucr1
    },
    {
        "UCR2",
        "",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_uart_ucr2
    },
    {
        "UCR3",
        "",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_uart_ucr3
    },
    {
        "UCR4",
        "",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        11, // Number of bitfields
        hw_uart_ucr4
    },
    {
        "UFCR",
        "",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_uart_ufcr
    },
    {
        "USR1",
        "",
        4, // Width in bytes
        0x00000094, // Base address offset
        true, // Readable
        true, // Writable
        13, // Number of bitfields
        hw_uart_usr1
    },
    {
        "USR2",
        "",
        4, // Width in bytes
        0x00000098, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_uart_usr2
    },
    {
        "UESC",
        "",
        4, // Width in bytes
        0x0000009c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_uesc
    },
    {
        "UTIM",
        "",
        4, // Width in bytes
        0x000000a0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_utim
    },
    {
        "UBIR",
        "This register can be written by both software and hardware.",
        4, // Width in bytes
        0x000000a4, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_ubir
    },
    {
        "UBMR",
        "This register can be written by both software and hardware.",
        4, // Width in bytes
        0x000000a8, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_ubmr
    },
    {
        "UBRC",
        "",
        4, // Width in bytes
        0x000000ac, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_uart_ubrc
    },
    {
        "ONEMS",
        "This register has been expanded from 16 bits to 24 bits.",
        4, // Width in bytes
        0x000000b0, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_uart_onems
    },
    {
        "UTS",
        "",
        4, // Width in bytes
        0x000000b4, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_uart_uts
    },
    {
        "UMCR",
        "",
        4, // Width in bytes
        0x000000b8, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_uart_umcr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USB
#endif

// Bitfields in register USB_UOG1_ID.
static const field_t hw_usb_uog1_id[] =
{
    {
        "ID",
        "Configuration number.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NID",
        "Complement version of ID",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REVISION",
        "Revision number of the controller core.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_HWGENERAL.
static const field_t hw_usb_uog1_hwgeneral[] =
{
    {
        "PHYW",
        "Data width of the transciever connected to the controller core.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHYM",
        "Transciever type",
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SM",
        "Serial interface mode capability",
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_HWHOST.
static const field_t hw_usb_uog1_hwhost[] =
{
    {
        "HC",
        "Host Capable.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NPORT",
        "The Nmber of downstream ports supported by the host controller is (NPO"
        "RT+1).",
        1, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_HWDEVICE.
static const field_t hw_usb_uog1_hwdevice[] =
{
    {
        "DC",
        "Device Capable.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEVEP",
        "Device Endpoint Number",
        1, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_HWTXBUF.
static const field_t hw_usb_uog1_hwtxbuf[] =
{
    {
        "TXBURST",
        "Default burst size for memory to TX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXCHANADD",
        "TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_HWRXBUF.
static const field_t hw_usb_uog1_hwrxbuf[] =
{
    {
        "RXBURST",
        "Default burst size for memory to RX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXADD",
        "Buffer total size for all receive endpoints is (2^RXADD).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_GPTIMER0LD.
static const field_t hw_usb_uog1_gptimer0ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value These bit fields are loaded to GPTCNT"
        " bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_GPTIMER0CTRL.
static const field_t hw_usb_uog1_gptimer0ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode In one shot mode, the timer will count down"
        " to zero, generate an interrupt, and stop until the counter is reset b"
        "y software; In repeat mode, the timer will count down to zero, generat"
        "e an interrupt and automatically reload the counter value from GPTLD b"
        "its to start again.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run GPTCNT bits are not effected when setting or"
        " clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_GPTIMER1LD.
static const field_t hw_usb_uog1_gptimer1ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value These bit fields are loaded to GPTCNT"
        " bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_GPTIMER1CTRL.
static const field_t hw_usb_uog1_gptimer1ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode In one shot mode, the timer will count down"
        " to zero, generate an interrupt, and stop until the counter is reset b"
        "y software.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run GPTCNT bits are not effected when setting or"
        " clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_SBUSCFG.
static const field_t hw_usb_uog1_sbuscfg[] =
{
    {
        "AHBBRST",
        "AHB master interface Burst configuration These bits control AHB master"
        " transfer type sequence (or priority).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_CAPLENGTH.
static const field_t hw_usb_uog1_caplength[] =
{
    {
        "CAPLENGTH",
        "These bits are used as an offset to add to register base to find the b"
        "eginning of the Operational Register.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_HCIVERSION.
static const field_t hw_usb_uog1_hciversion[] =
{
    {
        "HCIVERSION",
        "Host Controller Interface Version Number Default value is '10h', which"
        " means EHCI rev1.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_HCSPARAMS.
static const field_t hw_usb_uog1_hcsparams[] =
{
    {
        "N_PORTS",
        "Number of downstream ports.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PPC",
        "Port Power Control This field indicates whether the host controller im"
        "plementation includes port power control.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PCC",
        "Number of Ports per Companion Controller This field indicates the numb"
        "er of ports supported per internal Companion Controller.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_CC",
        "Number of Companion Controller (N_CC).",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PI",
        "Port Indicators (P INDICATOR) This bit indicates whether the ports sup"
        "port port indicator control.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PTT",
        "Number of Ports per Transaction Translator (N_PTT).",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_TT",
        "Number of Transaction Translators (N_TT).",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_HCCPARAMS.
static const field_t hw_usb_uog1_hccparams[] =
{
    {
        "ADC",
        "64-bit Addressing Capability This bit is set '0b' in all controller co"
        "re, no 64-bit addressing capability is supported.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFL",
        "Programmable Frame List Flag If this bit is set to zero, then the syst"
        "em software must use a frame list length of 1024 elements with this ho"
        "st controller.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Capability If this bit is set to a one, the"
        "n the host controller supports the park feature for high-speed queue h"
        "eads in the Asynchronous Schedule.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IST",
        "Isochronous Scheduling Threshold.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EECP",
        "EHCI Extended Capabilities Pointer.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_DCIVERSION.
static const field_t hw_usb_uog1_dciversion[] =
{
    {
        "DCIVERSION",
        "Device Controller Interface Version Number Default value is '01h', whi"
        "ch means rev0.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_DCCPARAMS.
static const field_t hw_usb_uog1_dccparams[] =
{
    {
        "DEN",
        "Device Endpoint Number This field indicates the number of endpoints bu"
        "ilt into the device controller.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC",
        "Device Capable When this bit is 1, this controller is capable of opera"
        "ting as a USB 2.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HC",
        "Host Capable When this bit is 1, this controller is capable of operati"
        "ng as an EHCI compatible USB 2.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_USBCMD.
static const field_t hw_usb_uog1_usbcmd[] =
{
    {
        "RS",
        "Run/Stop (RS) - Read/Write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        "Controller Reset (RESET) - Read/Write.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS_1",
        "See description at bit 15",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSE",
        "Periodic Schedule Enable- Read/Write.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASE",
        "Asynchronous Schedule Enable - Read/Write.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IAA",
        "Interrupt on Async Advance Doorbell - Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Mode Count - Read/Write.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASPE",
        "Asynchronous Schedule Park Mode Enable - Read/Write.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDTW",
        "Add dTD TripWire - Read/Write.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUTW",
        "Setup TripWire - Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS_2",
        "See also bits 3-2 Frame List Size - (Read/Write or Read Only).",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ITC",
        "Interrupt Threshold Control -Read/Write.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_USBSTS.
static const field_t hw_usb_uog1_usbsts[] =
{
    {
        "UI",
        "USB Interrupt (USBINT) - R/WC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEI",
        "USB Error Interrupt (USBERRINT) - R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCI",
        "Port Change Detect - R/WC.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRI",
        "Frame List Rollover - R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEI",
        "System Error- R/WC.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAI",
        "Interrupt on Async Advance - R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URI",
        "USB Reset Received - R/WC.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRI",
        "SOF Received - R/WC.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLI",
        "DCSuspend - R/WC.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPII",
        "ULPI Interrupt - R/WC.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCH",
        "HCHaIted - Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCL",
        "Reclamation - Read Only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        "Periodic Schedule Status - Read Only.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AS",
        "Asynchronous Schedule Status - Read Only.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKI",
        "NAK Interrupt Bit--RO.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TI0",
        "General Purpose Timer Interrupt 0(GPTINT0)--R/WC.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TI1",
        "General Purpose Timer Interrupt 1(GPTINT1)--R/WC.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_USBINTR.
static const field_t hw_usb_uog1_usbintr[] =
{
    {
        "UE",
        "USB Interrupt Enalbe When this bit is one and the UI bit in n_USBSTS r"
        "egister is a one the controller will issue an interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEE",
        "USB Error Interrupt Enable When this bit is one and the UEI bit in n_U"
        "SBSTS register is a one the controller will issue an interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCE",
        "Port Change Detect Interrupt Enable When this bit is one and the PCI b"
        "it in n_USBSTS register is a one the controller will issue an interrup"
        "t.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRE",
        "Frame List Rollover Interrupt Enable When this bit is one and the FRI "
        "bit in n_USBSTS register is a one the controller will issue an interru"
        "pt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEE",
        "System Error Interrupt Enable When this bit is one and the SEI bit in "
        "n_USBSTS register is a one the controller will issue an interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAE",
        "Async Advance Interrupt Enable When this bit is one and the AAI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URE",
        "USB Reset Interrupt Enable When this bit is one and the URI bit in n_U"
        "SBSTS register is a one the controller will issue an interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "SOF Received Interrupt Enable When this bit is one and the SRI bit in "
        "n_USBSTS register is a one the controller will issue an interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLE",
        "Sleep Interrupt Enable When this bit is one and the SLI bit in n_n_USB"
        "STS register is a one the controller will issue an interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPIE",
        "ULPI Interrupt Enable When this bit is one and the UPLII bit in n_USBS"
        "TS register is a one the controller will issue an interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKE",
        "NAK Interrupt Enable When this bit is one and the NAKI bit in n_USBSTS"
        " register is a one the controller will issue an interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UAIE",
        "USB Host Asynchronous Interrupt Enable When this bit is one, and the U"
        "AI bit in the n_USBSTS register is one, host controller will issue an "
        "interrupt at the next interrupt threshold.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPIE",
        "USB Host Periodic Interrupt Enable When this bit is one, and the UPI b"
        "it in the n_USBSTS register is one, host controller will issue an inte"
        "rrupt at the next interrupt threshold.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE0",
        "General Purpose Timer #0 Interrupt Enable When this bit is one and the"
        " TI0 bit in n_USBSTS register is a one the controller will issue an in"
        "terrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE1",
        "General Purpose Timer #1 Interrupt Enable When this bit is one and the"
        " TI1 bit in n_USBSTS register is a one the controller will issue an in"
        "terrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_FRINDEX.
static const field_t hw_usb_uog1_frindex[] =
{
    {
        "FRINDEX",
        "Frame Index.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_PERIODICLISTBASE.
static const field_t hw_usb_uog1_periodiclistbase[] =
{
    {
        "BASEADR",
        "Base Address (Low).",
        12, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_DEVICEADDR.
static const field_t hw_usb_uog1_deviceaddr[] =
{
    {
        "USBADRA",
        "Device Address Advance.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USBADR",
        "Device Address.",
        25, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ASYNCLISTADDR.
static const field_t hw_usb_uog1_asynclistaddr[] =
{
    {
        "ASYBASE",
        "Link Pointer Low (LPL).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ENDPTLISTADDR.
static const field_t hw_usb_uog1_endptlistaddr[] =
{
    {
        "EPBASE",
        "Endpoint List Pointer(Low).",
        11, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_BURSTSIZE.
static const field_t hw_usb_uog1_burstsize[] =
{
    {
        "RXPBURST",
        "Programmable RX Burst Size.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPBURST",
        "Programmable TX Burst Size.",
        8, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_TXFILLTUNING.
static const field_t hw_usb_uog1_txfilltuning[] =
{
    {
        "TXSCHOH",
        "Scheduler Overhead.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSCHHEALTH",
        "Scheduler Health Counter.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOTHRES",
        "FIFO Burst Threshold.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ENDPTNAK.
static const field_t hw_usb_uog1_endptnak[] =
{
    {
        "EPRN",
        "RX Endpoint NAK - R/WC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPTN",
        "TX Endpoint NAK - R/WC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ENDPTNAKEN.
static const field_t hw_usb_uog1_endptnaken[] =
{
    {
        "EPRNE",
        "RX Endpoint NAK Enable - R/W.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPTNE",
        "TX Endpoint NAK Enable - R/W.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_CONFIGFLAG.
static const field_t hw_usb_uog1_configflag[] =
{
    {
        "CF",
        "Configure Flag Host software sets this bit as the last action in its p"
        "rocess of configuring the Host Controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_PORTSC1.
static const field_t hw_usb_uog1_portsc1[] =
{
    {
        "CCS",
        "Current Connect Status-Read Only.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSC",
        "Connect Status Change-R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Port Enabled/Disabled-Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEC",
        "Port Enable/Disable Change-R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCA",
        "Over-current Active-Read Only.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCC",
        "Over-current Change-R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPR",
        "Force Port Resume -Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSP",
        "Suspend - Read/Write or Read Only.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "Port Reset - Read/Write or Read Only.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSP",
        "High-Speed Port - Read Only.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LS",
        "Line Status-Read Only.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP",
        "Port Power (PP)-Read/Write or Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PO",
        "Port Owner-Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIC",
        "Port Indicator Control - Read/Write.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTC",
        "Port Test Control - Read/Write.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKCN",
        "Wake on Connect Enable (WKCNNT_E) - Read/Write.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKDC",
        "Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKOC",
        "Wake on Over-current Enable (WKOC_E) - Read/Write.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHCD",
        "PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFSC",
        "Port Force Full Speed Connect - Read/Write.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS_2",
        "See description at bits 31-30",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSPD",
        "Port Speed - Read Only.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTW",
        "Parallel Transceiver Width This bit has no effect if serial interface "
        "engine is used.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "Serial Transceiver Select 1 Serial Interface Engine is selected 0 Para"
        "llel Interface signals is selected Serial Interface Engine can be used"
        " in combination with UTMI+/ULPI physical interface to provide FS/LS si"
        "gnaling instead of the parallel interface signals.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS_1",
        "All USB port interface modes are listed in this field description, but"
        " not all are supported.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_OTGSC.
static const field_t hw_usb_uog1_otgsc[] =
{
    {
        "VD",
        "VBUS_Discharge - Read/Write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VC",
        "VBUS Charge - Read/Write.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OT",
        "OTG Termination - Read/Write.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP",
        "Data Pulsing - Read/Write.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDPU",
        "ID Pullup - Read/Write This bit provide control over the ID pull-up re"
        "sistor; 0 = off, 1 = on [default].",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ID",
        "USB ID - Read Only.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AVV",
        "A VBus Valid - Read Only.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASV",
        "A Session Valid - Read Only.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BSV",
        "B Session Valid - Read Only.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BSE",
        "B Session End - Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TOG_1MS",
        "1 millisecond timer toggle - Read Only.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPS",
        "Data Bus Pulsing Status - Read Only.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDIS",
        "USB ID Interrupt Status - Read/Write.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVVIS",
        "A VBus Valid Interrupt Status - Read/Write to Clear.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASVIS",
        "A Session Valid Interrupt Status - Read/Write to Clear.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSVIS",
        "B Session Valid Interrupt Status - Read/Write to Clear.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSEIS",
        "B Session End Interrupt Status - Read/Write to Clear.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATUS_1MS",
        "1 millisecond timer Interrupt Status - Read/Write to Clear.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPIS",
        "Data Pulse Interrupt Status - Read/Write to Clear.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDIE",
        "USB ID Interrupt Enable - Read/Write.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVVIE",
        "A VBus Valid Interrupt Enable - Read/Write.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASVIE",
        "A Session Valid Interrupt Enable - Read/Write.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSVIE",
        "B Session Valid Interrupt Enable - Read/Write.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSEIE",
        "B Session End Interrupt Enable - Read/Write.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_1MS",
        "1 millisecond timer Interrupt Enable - Read/Write",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPIE",
        "Data Pulse Interrupt Enable",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_USBMODE.
static const field_t hw_usb_uog1_usbmode[] =
{
    {
        "CM",
        "Controller Mode - R/WO.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ES",
        "Endian Select - Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOM",
        "Setup Lockout Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDIS",
        "Stream Disable Mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ENDPTSETUPSTAT.
static const field_t hw_usb_uog1_endptsetupstat[] =
{
    {
        "ENDPTSETUPSTAT",
        "Setup Endpoint Status.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ENDPTPRIME.
static const field_t hw_usb_uog1_endptprime[] =
{
    {
        "PERB",
        "Prime Endpoint Receive Buffer - R/WS.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PETB",
        "Prime Endpoint Transmit Buffer - R/WS.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ENDPTFLUSH.
static const field_t hw_usb_uog1_endptflush[] =
{
    {
        "FERB",
        "Flush Endpoint Receive Buffer - R/WS.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FETB",
        "Flush Endpoint Transmit Buffer - R/WS.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ENDPTSTAT.
static const field_t hw_usb_uog1_endptstat[] =
{
    {
        "ERBR",
        "Endpoint Receive Buffer Ready -- Read Only.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ETBR",
        "Endpoint Transmit Buffer Ready -- Read Only.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ENDPTCOMPLETE.
static const field_t hw_usb_uog1_endptcomplete[] =
{
    {
        "ERCE",
        "Endpoint Receive Complete Event - RW/C.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETCE",
        "Endpoint Transmit Complete Event - R/WC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ENDPTCTRL0.
static const field_t hw_usb_uog1_endptctrl0[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control Endpoint0 is fixed as a Contr"
        "ol End Point.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 1 Enabled Endpoint0 is always enabled.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK [Default] 1 End Point St"
        "alled Software can write a one to this bit to force the endpoint to re"
        "turn a STALL handshake to the Host.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 - Control Endpoint0 is fixed as a Con"
        "trol End Point.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 1 Enabled Endpoint0 is always enabled.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ENDPTCTRL1.
static const field_t hw_usb_uog1_endptctrl1[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ENDPTCTRL2.
static const field_t hw_usb_uog1_endptctrl2[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ENDPTCTRL3.
static const field_t hw_usb_uog1_endptctrl3[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ENDPTCTRL4.
static const field_t hw_usb_uog1_endptctrl4[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ENDPTCTRL5.
static const field_t hw_usb_uog1_endptctrl5[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ENDPTCTRL6.
static const field_t hw_usb_uog1_endptctrl6[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG1_ENDPTCTRL7.
static const field_t hw_usb_uog1_endptctrl7[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ID.
static const field_t hw_usb_uog2_id[] =
{
    {
        "ID",
        "Configuration number.",
        0, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NID",
        "Complement version of ID",
        8, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "REVISION",
        "Revision number of the controller core.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_HWGENERAL.
static const field_t hw_usb_uog2_hwgeneral[] =
{
    {
        "PHYW",
        "Data width of the transciever connected to the controller core.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PHYM",
        "Transciever type",
        6, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SM",
        "Serial interface mode capability",
        9, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_HWHOST.
static const field_t hw_usb_uog2_hwhost[] =
{
    {
        "HC",
        "Host Capable.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "NPORT",
        "The Nmber of downstream ports supported by the host controller is (NPO"
        "RT+1).",
        1, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_HWDEVICE.
static const field_t hw_usb_uog2_hwdevice[] =
{
    {
        "DC",
        "Device Capable.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEVEP",
        "Device Endpoint Number",
        1, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_HWTXBUF.
static const field_t hw_usb_uog2_hwtxbuf[] =
{
    {
        "TXBURST",
        "Default burst size for memory to TX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXCHANADD",
        "TX FIFO Buffer size is: (2^TXCHANADD) * 4 Bytes.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_HWRXBUF.
static const field_t hw_usb_uog2_hwrxbuf[] =
{
    {
        "RXBURST",
        "Default burst size for memory to RX buffer transfer.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXADD",
        "Buffer total size for all receive endpoints is (2^RXADD).",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_GPTIMER0LD.
static const field_t hw_usb_uog2_gptimer0ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value These bit fields are loaded to GPTCNT"
        " bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_GPTIMER0CTRL.
static const field_t hw_usb_uog2_gptimer0ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode In one shot mode, the timer will count down"
        " to zero, generate an interrupt, and stop until the counter is reset b"
        "y software; In repeat mode, the timer will count down to zero, generat"
        "e an interrupt and automatically reload the counter value from GPTLD b"
        "its to start again.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run GPTCNT bits are not effected when setting or"
        " clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_GPTIMER1LD.
static const field_t hw_usb_uog2_gptimer1ld[] =
{
    {
        "GPTLD",
        "General Purpose Timer Load Value These bit fields are loaded to GPTCNT"
        " bits when GPTRST bit is set '1b'.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_GPTIMER1CTRL.
static const field_t hw_usb_uog2_gptimer1ctrl[] =
{
    {
        "GPTCNT",
        "General Purpose Timer Counter.",
        0, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTMODE",
        "General Purpose Timer Mode In one shot mode, the timer will count down"
        " to zero, generate an interrupt, and stop until the counter is reset b"
        "y software.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRST",
        "General Purpose Timer Reset",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPTRUN",
        "General Purpose Timer Run GPTCNT bits are not effected when setting or"
        " clearing this bit.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_SBUSCFG.
static const field_t hw_usb_uog2_sbuscfg[] =
{
    {
        "AHBBRST",
        "AHB master interface Burst configuration These bits control AHB master"
        " transfer type sequence (or priority).",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_CAPLENGTH.
static const field_t hw_usb_uog2_caplength[] =
{
    {
        "CAPLENGTH",
        "These bits are used as an offset to add to register base to find the b"
        "eginning of the Operational Register.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_HCIVERSION.
static const field_t hw_usb_uog2_hciversion[] =
{
    {
        "HCIVERSION",
        "Host Controller Interface Version Number Default value is '10h', which"
        " means EHCI rev1.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_HCSPARAMS.
static const field_t hw_usb_uog2_hcsparams[] =
{
    {
        "N_PORTS",
        "Number of downstream ports.",
        0, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PPC",
        "Port Power Control This field indicates whether the host controller im"
        "plementation includes port power control.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PCC",
        "Number of Ports per Companion Controller This field indicates the numb"
        "er of ports supported per internal Companion Controller.",
        8, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_CC",
        "Number of Companion Controller (N_CC).",
        12, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PI",
        "Port Indicators (P INDICATOR) This bit indicates whether the ports sup"
        "port port indicator control.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_PTT",
        "Number of Ports per Transaction Translator (N_PTT).",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "N_TT",
        "Number of Transaction Translators (N_TT).",
        24, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_HCCPARAMS.
static const field_t hw_usb_uog2_hccparams[] =
{
    {
        "ADC",
        "64-bit Addressing Capability This bit is set '0b' in all controller co"
        "re, no 64-bit addressing capability is supported.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PFL",
        "Programmable Frame List Flag If this bit is set to zero, then the syst"
        "em software must use a frame list length of 1024 elements with this ho"
        "st controller.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Capability If this bit is set to a one, the"
        "n the host controller supports the park feature for high-speed queue h"
        "eads in the Asynchronous Schedule.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IST",
        "Isochronous Scheduling Threshold.",
        4, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EECP",
        "EHCI Extended Capabilities Pointer.",
        8, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_DCIVERSION.
static const field_t hw_usb_uog2_dciversion[] =
{
    {
        "DCIVERSION",
        "Device Controller Interface Version Number Default value is '01h', whi"
        "ch means rev0.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_DCCPARAMS.
static const field_t hw_usb_uog2_dccparams[] =
{
    {
        "DEN",
        "Device Endpoint Number This field indicates the number of endpoints bu"
        "ilt into the device controller.",
        0, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DC",
        "Device Capable When this bit is 1, this controller is capable of opera"
        "ting as a USB 2.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HC",
        "Host Capable When this bit is 1, this controller is capable of operati"
        "ng as an EHCI compatible USB 2.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_USBCMD.
static const field_t hw_usb_uog2_usbcmd[] =
{
    {
        "RS",
        "Run/Stop (RS) - Read/Write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RST",
        "Controller Reset (RESET) - Read/Write.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS_1",
        "See description at bit 15",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSE",
        "Periodic Schedule Enable- Read/Write.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASE",
        "Asynchronous Schedule Enable - Read/Write.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IAA",
        "Interrupt on Async Advance Doorbell - Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASP",
        "Asynchronous Schedule Park Mode Count - Read/Write.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASPE",
        "Asynchronous Schedule Park Mode Enable - Read/Write.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ATDTW",
        "Add dTD TripWire - Read/Write.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUTW",
        "Setup TripWire - Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FS_2",
        "See also bits 3-2 Frame List Size - (Read/Write or Read Only).",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ITC",
        "Interrupt Threshold Control -Read/Write.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_USBSTS.
static const field_t hw_usb_uog2_usbsts[] =
{
    {
        "UI",
        "USB Interrupt (USBINT) - R/WC.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEI",
        "USB Error Interrupt (USBERRINT) - R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCI",
        "Port Change Detect - R/WC.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRI",
        "Frame List Rollover - R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEI",
        "System Error- R/WC.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAI",
        "Interrupt on Async Advance - R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URI",
        "USB Reset Received - R/WC.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRI",
        "SOF Received - R/WC.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLI",
        "DCSuspend - R/WC.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPII",
        "ULPI Interrupt - R/WC.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCH",
        "HCHaIted - Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCL",
        "Reclamation - Read Only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PS",
        "Periodic Schedule Status - Read Only.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AS",
        "Asynchronous Schedule Status - Read Only.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKI",
        "NAK Interrupt Bit--RO.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TI0",
        "General Purpose Timer Interrupt 0(GPTINT0)--R/WC.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TI1",
        "General Purpose Timer Interrupt 1(GPTINT1)--R/WC.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_USBINTR.
static const field_t hw_usb_uog2_usbintr[] =
{
    {
        "UE",
        "USB Interrupt Enalbe When this bit is one and the UI bit in n_USBSTS r"
        "egister is a one the controller will issue an interrupt.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UEE",
        "USB Error Interrupt Enable When this bit is one and the UEI bit in n_U"
        "SBSTS register is a one the controller will issue an interrupt.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PCE",
        "Port Change Detect Interrupt Enable When this bit is one and the PCI b"
        "it in n_USBSTS register is a one the controller will issue an interrup"
        "t.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRE",
        "Frame List Rollover Interrupt Enable When this bit is one and the FRI "
        "bit in n_USBSTS register is a one the controller will issue an interru"
        "pt.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SEE",
        "System Error Interrupt Enable When this bit is one and the SEI bit in "
        "n_USBSTS register is a one the controller will issue an interrupt.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AAE",
        "Async Advance Interrupt Enable When this bit is one and the AAI bit in"
        " n_USBSTS register is a one the controller will issue an interrupt.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "URE",
        "USB Reset Interrupt Enable When this bit is one and the URI bit in n_U"
        "SBSTS register is a one the controller will issue an interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "SOF Received Interrupt Enable When this bit is one and the SRI bit in "
        "n_USBSTS register is a one the controller will issue an interrupt.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLE",
        "Sleep Interrupt Enable When this bit is one and the SLI bit in n_n_USB"
        "STS register is a one the controller will issue an interrupt.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ULPIE",
        "ULPI Interrupt Enable When this bit is one and the UPLII bit in n_USBS"
        "TS register is a one the controller will issue an interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NAKE",
        "NAK Interrupt Enable When this bit is one and the NAKI bit in n_USBSTS"
        " register is a one the controller will issue an interrupt.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UAIE",
        "USB Host Asynchronous Interrupt Enable When this bit is one, and the U"
        "AI bit in the n_USBSTS register is one, host controller will issue an "
        "interrupt at the next interrupt threshold.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UPIE",
        "USB Host Periodic Interrupt Enable When this bit is one, and the UPI b"
        "it in the n_USBSTS register is one, host controller will issue an inte"
        "rrupt at the next interrupt threshold.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE0",
        "General Purpose Timer #0 Interrupt Enable When this bit is one and the"
        " TI0 bit in n_USBSTS register is a one the controller will issue an in"
        "terrupt.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TIE1",
        "General Purpose Timer #1 Interrupt Enable When this bit is one and the"
        " TI1 bit in n_USBSTS register is a one the controller will issue an in"
        "terrupt.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_FRINDEX.
static const field_t hw_usb_uog2_frindex[] =
{
    {
        "FRINDEX",
        "Frame Index.",
        0, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_PERIODICLISTBASE.
static const field_t hw_usb_uog2_periodiclistbase[] =
{
    {
        "BASEADR",
        "Base Address (Low).",
        12, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_DEVICEADDR.
static const field_t hw_usb_uog2_deviceaddr[] =
{
    {
        "USBADRA",
        "Device Address Advance.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USBADR",
        "Device Address.",
        25, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ASYNCLISTADDR.
static const field_t hw_usb_uog2_asynclistaddr[] =
{
    {
        "ASYBASE",
        "Link Pointer Low (LPL).",
        5, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ENDPTLISTADDR.
static const field_t hw_usb_uog2_endptlistaddr[] =
{
    {
        "EPBASE",
        "Endpoint List Pointer(Low).",
        11, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_BURSTSIZE.
static const field_t hw_usb_uog2_burstsize[] =
{
    {
        "RXPBURST",
        "Programmable RX Burst Size.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPBURST",
        "Programmable TX Burst Size.",
        8, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_TXFILLTUNING.
static const field_t hw_usb_uog2_txfilltuning[] =
{
    {
        "TXSCHOH",
        "Scheduler Overhead.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXSCHHEALTH",
        "Scheduler Health Counter.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXFIFOTHRES",
        "FIFO Burst Threshold.",
        16, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ENDPTNAK.
static const field_t hw_usb_uog2_endptnak[] =
{
    {
        "EPRN",
        "RX Endpoint NAK - R/WC.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPTN",
        "TX Endpoint NAK - R/WC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ENDPTNAKEN.
static const field_t hw_usb_uog2_endptnaken[] =
{
    {
        "EPRNE",
        "RX Endpoint NAK Enable - R/W.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EPTNE",
        "TX Endpoint NAK Enable - R/W.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_CONFIGFLAG.
static const field_t hw_usb_uog2_configflag[] =
{
    {
        "CF",
        "Configure Flag Host software sets this bit as the last action in its p"
        "rocess of configuring the Host Controller.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_PORTSC1.
static const field_t hw_usb_uog2_portsc1[] =
{
    {
        "CCS",
        "Current Connect Status-Read Only.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CSC",
        "Connect Status Change-R/WC.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PE",
        "Port Enabled/Disabled-Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PEC",
        "Port Enable/Disable Change-R/WC.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OCA",
        "Over-current Active-Read Only.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OCC",
        "Over-current Change-R/WC.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FPR",
        "Force Port Resume -Read/Write.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SUSP",
        "Suspend - Read/Write or Read Only.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PR",
        "Port Reset - Read/Write or Read Only.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSP",
        "High-Speed Port - Read Only.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "LS",
        "Line Status-Read Only.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PP",
        "Port Power (PP)-Read/Write or Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PO",
        "Port Owner-Read/Write.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PIC",
        "Port Indicator Control - Read/Write.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTC",
        "Port Test Control - Read/Write.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKCN",
        "Wake on Connect Enable (WKCNNT_E) - Read/Write.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKDC",
        "Wake on Disconnect Enable (WKDSCNNT_E) - Read/Write.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKOC",
        "Wake on Over-current Enable (WKOC_E) - Read/Write.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PHCD",
        "PHY Low Power Suspend - Clock Disable (PLPSCD) - Read/Write.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PFSC",
        "Port Force Full Speed Connect - Read/Write.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS_2",
        "See description at bits 31-30",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PSPD",
        "Port Speed - Read Only.",
        26, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTW",
        "Parallel Transceiver Width This bit has no effect if serial interface "
        "engine is used.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STS",
        "Serial Transceiver Select 1 Serial Interface Engine is selected 0 Para"
        "llel Interface signals is selected Serial Interface Engine can be used"
        " in combination with UTMI+/ULPI physical interface to provide FS/LS si"
        "gnaling instead of the parallel interface signals.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PTS_1",
        "All USB port interface modes are listed in this field description, but"
        " not all are supported.",
        30, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_OTGSC.
static const field_t hw_usb_uog2_otgsc[] =
{
    {
        "VD",
        "VBUS_Discharge - Read/Write.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VC",
        "VBUS Charge - Read/Write.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OT",
        "OTG Termination - Read/Write.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DP",
        "Data Pulsing - Read/Write.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDPU",
        "ID Pullup - Read/Write This bit provide control over the ID pull-up re"
        "sistor; 0 = off, 1 = on [default].",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ID",
        "USB ID - Read Only.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AVV",
        "A VBus Valid - Read Only.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ASV",
        "A Session Valid - Read Only.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BSV",
        "B Session Valid - Read Only.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BSE",
        "B Session End - Read Only.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TOG_1MS",
        "1 millisecond timer toggle - Read Only.",
        13, // LSB
        13, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DPS",
        "Data Bus Pulsing Status - Read Only.",
        14, // LSB
        14, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IDIS",
        "USB ID Interrupt Status - Read/Write.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVVIS",
        "A VBus Valid Interrupt Status - Read/Write to Clear.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASVIS",
        "A Session Valid Interrupt Status - Read/Write to Clear.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSVIS",
        "B Session Valid Interrupt Status - Read/Write to Clear.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSEIS",
        "B Session End Interrupt Status - Read/Write to Clear.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STATUS_1MS",
        "1 millisecond timer Interrupt Status - Read/Write to Clear.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPIS",
        "Data Pulse Interrupt Status - Read/Write to Clear.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IDIE",
        "USB ID Interrupt Enable - Read/Write.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AVVIE",
        "A VBus Valid Interrupt Enable - Read/Write.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ASVIE",
        "A Session Valid Interrupt Enable - Read/Write.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSVIE",
        "B Session Valid Interrupt Enable - Read/Write.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BSEIE",
        "B Session End Interrupt Enable - Read/Write.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EN_1MS",
        "1 millisecond timer Interrupt Enable - Read/Write",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPIE",
        "Data Pulse Interrupt Enable",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_USBMODE.
static const field_t hw_usb_uog2_usbmode[] =
{
    {
        "CM",
        "Controller Mode - R/WO.",
        0, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ES",
        "Endian Select - Read/Write.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SLOM",
        "Setup Lockout Mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDIS",
        "Stream Disable Mode.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ENDPTSETUPSTAT.
static const field_t hw_usb_uog2_endptsetupstat[] =
{
    {
        "ENDPTSETUPSTAT",
        "Setup Endpoint Status.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ENDPTPRIME.
static const field_t hw_usb_uog2_endptprime[] =
{
    {
        "PERB",
        "Prime Endpoint Receive Buffer - R/WS.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PETB",
        "Prime Endpoint Transmit Buffer - R/WS.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ENDPTFLUSH.
static const field_t hw_usb_uog2_endptflush[] =
{
    {
        "FERB",
        "Flush Endpoint Receive Buffer - R/WS.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FETB",
        "Flush Endpoint Transmit Buffer - R/WS.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ENDPTSTAT.
static const field_t hw_usb_uog2_endptstat[] =
{
    {
        "ERBR",
        "Endpoint Receive Buffer Ready -- Read Only.",
        0, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ETBR",
        "Endpoint Transmit Buffer Ready -- Read Only.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ENDPTCOMPLETE.
static const field_t hw_usb_uog2_endptcomplete[] =
{
    {
        "ERCE",
        "Endpoint Receive Complete Event - RW/C.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ETCE",
        "Endpoint Transmit Complete Event - R/WC.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ENDPTCTRL0.
static const field_t hw_usb_uog2_endptctrl0[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control Endpoint0 is fixed as a Contr"
        "ol End Point.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 1 Enabled Endpoint0 is always enabled.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK [Default] 1 End Point St"
        "alled Software can write a one to this bit to force the endpoint to re"
        "turn a STALL handshake to the Host.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 - Control Endpoint0 is fixed as a Con"
        "trol End Point.",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 1 Enabled Endpoint0 is always enabled.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ENDPTCTRL1.
static const field_t hw_usb_uog2_endptctrl1[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ENDPTCTRL2.
static const field_t hw_usb_uog2_endptctrl2[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ENDPTCTRL3.
static const field_t hw_usb_uog2_endptctrl3[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ENDPTCTRL4.
static const field_t hw_usb_uog2_endptctrl4[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ENDPTCTRL5.
static const field_t hw_usb_uog2_endptctrl5[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ENDPTCTRL6.
static const field_t hw_usb_uog2_endptctrl6[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USB_UOG2_ENDPTCTRL7.
static const field_t hw_usb_uog2_endptctrl7[] =
{
    {
        "RXS",
        "RX Endpoint Stall - Read/Write 0 End Point OK.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXD",
        "RX Endpoint Data Sink - Read/Write - TBD 0 Dual Port Memory Buffer/DMA"
        " Engine [Default] Should always be written as zero.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXT",
        "RX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXI",
        "RX Data Toggle Inhibit 0 Disabled [Default] 1 Enabled This bit is only"
        " used for test and should always be written as zero.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXR",
        "RX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the host"
        " and device.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXE",
        "RX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXS",
        "TX Endpoint Stall - Read/Write 0 End Point OK 1 End Point Stalled This"
        " bit will be cleared automatically upon receipt of a SETUP request if "
        "this Endpoint is configured as a Control Endpoint and this bit will co"
        "ntinue to be cleared by hardware until the associated ENDPTSETUPSTAT b"
        "it is cleared.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXD",
        "TX Endpoint Data Source - Read/Write 0 Dual Port Memory Buffer/DMA Eng"
        "ine [DEFAULT] Should always be written as 0.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXT",
        "TX Endpoint Type - Read/Write 00 Control 01 Isochronous 10 Bulk 11 Int"
        "errupt",
        18, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXI",
        "TX Data Toggle Inhibit 0 PID Sequencing Enabled.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXR",
        "TX Data Toggle Reset (WS) Write 1 - Reset PID Sequence Whenever a conf"
        "iguration event is received for this Endpoint, software must write a o"
        "ne to this bit in order to synchronize the data PID's between the Host"
        " and device.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXE",
        "TX Endpoint Enable 0 Disabled [Default] 1 Enabled An Endpoint should b"
        "e enabled only after it has been configured.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a USB module.
static const reg_t hw_usb[] =
{
    {
        "UOG1_ID",
        "The ID register identifies the USB 2.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usb_uog1_id
    },
    {
        "UOG1_HWGENERAL",
        "General hardware parameters as defined in System Level Issues and Core"
        " Configuration.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usb_uog1_hwgeneral
    },
    {
        "UOG1_HWHOST",
        "",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_uog1_hwhost
    },
    {
        "UOG1_HWDEVICE",
        "",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_uog1_hwdevice
    },
    {
        "UOG1_HWTXBUF",
        "",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_uog1_hwtxbuf
    },
    {
        "UOG1_HWRXBUF",
        "",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_uog1_hwrxbuf
    },
    {
        "UOG1_GPTIMER0LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER0CTRL.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_uog1_gptimer0ld
    },
    {
        "UOG1_GPTIMER0CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x00000084, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_uog1_gptimer0ctrl
    },
    {
        "UOG1_GPTIMER1LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER1CTRL.",
        4, // Width in bytes
        0x00000088, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_uog1_gptimer1ld
    },
    {
        "UOG1_GPTIMER1CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x0000008c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_uog1_gptimer1ctrl
    },
    {
        "UOG1_SBUSCFG",
        "",
        4, // Width in bytes
        0x00000090, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_uog1_sbuscfg
    },
    {
        "UOG1_CAPLENGTH",
        "The Capability Registers Length register contains the address offset t"
        "o the Operational registers relative to the CAPLENGTH register.",
        1, // Width in bytes
        0x00000100, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usb_uog1_caplength
    },
    {
        "UOG1_HCIVERSION",
        "This is a 2-byte register containing a BCD encoding of the EHCI revisi"
        "on number supported by this host controller.",
        2, // Width in bytes
        0x00000102, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usb_uog1_hciversion
    },
    {
        "UOG1_HCSPARAMS",
        "The following figure shows the port steering logic capabilities of Hos"
        "t Control Structural Parameters (n_HCSPARAMS).",
        4, // Width in bytes
        0x00000104, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_usb_uog1_hcsparams
    },
    {
        "UOG1_HCCPARAMS",
        "This register identifies multiple mode control (time-base bit function"
        "ality), addressing capability.",
        4, // Width in bytes
        0x00000108, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_usb_uog1_hccparams
    },
    {
        "UOG1_DCIVERSION",
        "This register indicates the two-byte BCD encoding of the device contro"
        "ller interface version number.",
        2, // Width in bytes
        0x00000120, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usb_uog1_dciversion
    },
    {
        "UOG1_DCCPARAMS",
        "These fields describe the overall device capability of the controller.",
        4, // Width in bytes
        0x00000124, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usb_uog1_dccparams
    },
    {
        "UOG1_USBCMD",
        "The Command Register indicates the command to be executed by the seria"
        "l bus host/device controller.",
        4, // Width in bytes
        0x00000140, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_uog1_usbcmd
    },
    {
        "UOG1_USBSTS",
        "This register indicates various states of the Host/Device Controller a"
        "nd any pending interrupts.",
        4, // Width in bytes
        0x00000144, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usb_uog1_usbsts
    },
    {
        "UOG1_USBINTR",
        "The interrupts to software are enabled with this register.",
        4, // Width in bytes
        0x00000148, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usb_uog1_usbintr
    },
    {
        "UOG1_FRINDEX",
        "This register is used by the host controller to index the periodic fra"
        "me list.",
        4, // Width in bytes
        0x0000014c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_uog1_frindex
    },
    {
        "UOG1_PERIODICLISTBASE",
        "Host Controller only This 32-bit register contains the beginning addre"
        "ss of the Periodic Frame List in the system memory.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_uog1_periodiclistbase
    },
    {
        "UOG1_DEVICEADDR",
        "Device Controller only The upper seven bits of this register represent"
        " the device address.",
        4, // Width in bytes
        0x00000154, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_uog1_deviceaddr
    },
    {
        "UOG1_ASYNCLISTADDR",
        "Host Controller only This 32-bit register contains the address of the "
        "next asynchronous queue head to be executed by the host.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_uog1_asynclistaddr
    },
    {
        "UOG1_ENDPTLISTADDR",
        "Device Controller only In device mode, this register contains the addr"
        "ess of the top of the endpoint list in system memory.",
        4, // Width in bytes
        0x00000158, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_uog1_endptlistaddr
    },
    {
        "UOG1_BURSTSIZE",
        "This register is used to control the burst size used during data movem"
        "ent on the AHB master interface.",
        4, // Width in bytes
        0x00000160, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_uog1_burstsize
    },
    {
        "UOG1_TXFILLTUNING",
        "The fields in this register control performance tuning associated with"
        " how the host controller posts data to the TX latency FIFO before movi"
        "ng the data onto the USB bus.",
        4, // Width in bytes
        0x00000164, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_uog1_txfilltuning
    },
    {
        "UOG1_ENDPTNAK",
        "",
        4, // Width in bytes
        0x00000178, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_uog1_endptnak
    },
    {
        "UOG1_ENDPTNAKEN",
        "",
        4, // Width in bytes
        0x0000017c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_uog1_endptnaken
    },
    {
        "UOG1_CONFIGFLAG",
        "",
        4, // Width in bytes
        0x00000180, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usb_uog1_configflag
    },
    {
        "UOG1_PORTSC1",
        "Host Controller A host controller could implement one to eight port st"
        "atus and control registers.",
        4, // Width in bytes
        0x00000184, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_usb_uog1_portsc1
    },
    {
        "UOG1_OTGSC",
        "This register is availabe only in OTG controller core.",
        4, // Width in bytes
        0x000001a4, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_usb_uog1_otgsc
    },
    {
        "UOG1_USBMODE",
        "",
        4, // Width in bytes
        0x000001a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_uog1_usbmode
    },
    {
        "UOG1_ENDPTSETUPSTAT",
        "",
        4, // Width in bytes
        0x000001ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_uog1_endptsetupstat
    },
    {
        "UOG1_ENDPTPRIME",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000001b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_uog1_endptprime
    },
    {
        "UOG1_ENDPTFLUSH",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000001b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_uog1_endptflush
    },
    {
        "UOG1_ENDPTSTAT",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000001b8, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_uog1_endptstat
    },
    {
        "UOG1_ENDPTCOMPLETE",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000001bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_uog1_endptcomplete
    },
    {
        "UOG1_ENDPTCTRL0",
        "Every Device implements Endpoint 0 as a control endpoint.",
        4, // Width in bytes
        0x000001c0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usb_uog1_endptctrl0
    },
    {
        "UOG1_ENDPTCTRL1",
        "This is endpoint control register for endpoint 1 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001c4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_uog1_endptctrl1
    },
    {
        "UOG1_ENDPTCTRL2",
        "This is endpoint control register for endpoint 2 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001c8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_uog1_endptctrl2
    },
    {
        "UOG1_ENDPTCTRL3",
        "This is endpoint control register for endpoint 3 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001cc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_uog1_endptctrl3
    },
    {
        "UOG1_ENDPTCTRL4",
        "This is endpoint control register for endpoint 4 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001d0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_uog1_endptctrl4
    },
    {
        "UOG1_ENDPTCTRL5",
        "This is endpoint control register for endpoint 5 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001d4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_uog1_endptctrl5
    },
    {
        "UOG1_ENDPTCTRL6",
        "This is endpoint control register for endpoint 6 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001d8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_uog1_endptctrl6
    },
    {
        "UOG1_ENDPTCTRL7",
        "This is endpoint control register for endpoint 7 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000001dc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_uog1_endptctrl7
    },
    {
        "UOG2_ID",
        "The ID register identifies the USB 2.",
        4, // Width in bytes
        0x00000200, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usb_uog2_id
    },
    {
        "UOG2_HWGENERAL",
        "General hardware parameters as defined in System Level Issues and Core"
        " Configuration.",
        4, // Width in bytes
        0x00000204, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usb_uog2_hwgeneral
    },
    {
        "UOG2_HWHOST",
        "",
        4, // Width in bytes
        0x00000208, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_uog2_hwhost
    },
    {
        "UOG2_HWDEVICE",
        "",
        4, // Width in bytes
        0x0000020c, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_uog2_hwdevice
    },
    {
        "UOG2_HWTXBUF",
        "",
        4, // Width in bytes
        0x00000210, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_uog2_hwtxbuf
    },
    {
        "UOG2_HWRXBUF",
        "",
        4, // Width in bytes
        0x00000214, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_uog2_hwrxbuf
    },
    {
        "UOG2_GPTIMER0LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER0CTRL.",
        4, // Width in bytes
        0x00000280, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_uog2_gptimer0ld
    },
    {
        "UOG2_GPTIMER0CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x00000284, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_uog2_gptimer0ctrl
    },
    {
        "UOG2_GPTIMER1LD",
        "This register controls load value of the count timer in register n_GPT"
        "IMER1CTRL.",
        4, // Width in bytes
        0x00000288, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_uog2_gptimer1ld
    },
    {
        "UOG2_GPTIMER1CTRL",
        "This register contains the control for this countdown timer and a data"
        " field can be queried to determine the running count value.",
        4, // Width in bytes
        0x0000028c, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_uog2_gptimer1ctrl
    },
    {
        "UOG2_SBUSCFG",
        "",
        4, // Width in bytes
        0x00000290, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_uog2_sbuscfg
    },
    {
        "UOG2_CAPLENGTH",
        "The Capability Registers Length register contains the address offset t"
        "o the Operational registers relative to the CAPLENGTH register.",
        1, // Width in bytes
        0x00000300, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usb_uog2_caplength
    },
    {
        "UOG2_HCIVERSION",
        "This is a 2-byte register containing a BCD encoding of the EHCI revisi"
        "on number supported by this host controller.",
        2, // Width in bytes
        0x00000302, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usb_uog2_hciversion
    },
    {
        "UOG2_HCSPARAMS",
        "The following figure shows the port steering logic capabilities of Hos"
        "t Control Structural Parameters (n_HCSPARAMS).",
        4, // Width in bytes
        0x00000304, // Base address offset
        true, // Readable
        false, // Writable
        7, // Number of bitfields
        hw_usb_uog2_hcsparams
    },
    {
        "UOG2_HCCPARAMS",
        "This register identifies multiple mode control (time-base bit function"
        "ality), addressing capability.",
        4, // Width in bytes
        0x00000308, // Base address offset
        true, // Readable
        false, // Writable
        5, // Number of bitfields
        hw_usb_uog2_hccparams
    },
    {
        "UOG2_DCIVERSION",
        "This register indicates the two-byte BCD encoding of the device contro"
        "ller interface version number.",
        2, // Width in bytes
        0x00000320, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usb_uog2_dciversion
    },
    {
        "UOG2_DCCPARAMS",
        "These fields describe the overall device capability of the controller.",
        4, // Width in bytes
        0x00000324, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usb_uog2_dccparams
    },
    {
        "UOG2_USBCMD",
        "The Command Register indicates the command to be executed by the seria"
        "l bus host/device controller.",
        4, // Width in bytes
        0x00000340, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_uog2_usbcmd
    },
    {
        "UOG2_USBSTS",
        "This register indicates various states of the Host/Device Controller a"
        "nd any pending interrupts.",
        4, // Width in bytes
        0x00000344, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usb_uog2_usbsts
    },
    {
        "UOG2_USBINTR",
        "The interrupts to software are enabled with this register.",
        4, // Width in bytes
        0x00000348, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usb_uog2_usbintr
    },
    {
        "UOG2_FRINDEX",
        "This register is used by the host controller to index the periodic fra"
        "me list.",
        4, // Width in bytes
        0x0000034c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_uog2_frindex
    },
    {
        "UOG2_PERIODICLISTBASE",
        "Host Controller only This 32-bit register contains the beginning addre"
        "ss of the Periodic Frame List in the system memory.",
        4, // Width in bytes
        0x00000354, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_uog2_periodiclistbase
    },
    {
        "UOG2_DEVICEADDR",
        "Device Controller only The upper seven bits of this register represent"
        " the device address.",
        4, // Width in bytes
        0x00000354, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_uog2_deviceaddr
    },
    {
        "UOG2_ASYNCLISTADDR",
        "Host Controller only This 32-bit register contains the address of the "
        "next asynchronous queue head to be executed by the host.",
        4, // Width in bytes
        0x00000358, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_uog2_asynclistaddr
    },
    {
        "UOG2_ENDPTLISTADDR",
        "Device Controller only In device mode, this register contains the addr"
        "ess of the top of the endpoint list in system memory.",
        4, // Width in bytes
        0x00000358, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_uog2_endptlistaddr
    },
    {
        "UOG2_BURSTSIZE",
        "This register is used to control the burst size used during data movem"
        "ent on the AHB master interface.",
        4, // Width in bytes
        0x00000360, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_uog2_burstsize
    },
    {
        "UOG2_TXFILLTUNING",
        "The fields in this register control performance tuning associated with"
        " how the host controller posts data to the TX latency FIFO before movi"
        "ng the data onto the USB bus.",
        4, // Width in bytes
        0x00000364, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usb_uog2_txfilltuning
    },
    {
        "UOG2_ENDPTNAK",
        "",
        4, // Width in bytes
        0x00000378, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_uog2_endptnak
    },
    {
        "UOG2_ENDPTNAKEN",
        "",
        4, // Width in bytes
        0x0000037c, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_uog2_endptnaken
    },
    {
        "UOG2_CONFIGFLAG",
        "",
        4, // Width in bytes
        0x00000380, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usb_uog2_configflag
    },
    {
        "UOG2_PORTSC1",
        "Host Controller A host controller could implement one to eight port st"
        "atus and control registers.",
        4, // Width in bytes
        0x00000384, // Base address offset
        true, // Readable
        true, // Writable
        25, // Number of bitfields
        hw_usb_uog2_portsc1
    },
    {
        "UOG2_OTGSC",
        "This register is availabe only in OTG controller core.",
        4, // Width in bytes
        0x000003a4, // Base address offset
        true, // Readable
        true, // Writable
        26, // Number of bitfields
        hw_usb_uog2_otgsc
    },
    {
        "UOG2_USBMODE",
        "",
        4, // Width in bytes
        0x000003a8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usb_uog2_usbmode
    },
    {
        "UOG2_ENDPTSETUPSTAT",
        "",
        4, // Width in bytes
        0x000003ac, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usb_uog2_endptsetupstat
    },
    {
        "UOG2_ENDPTPRIME",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000003b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_uog2_endptprime
    },
    {
        "UOG2_ENDPTFLUSH",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000003b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_uog2_endptflush
    },
    {
        "UOG2_ENDPTSTAT",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000003b8, // Base address offset
        true, // Readable
        false, // Writable
        2, // Number of bitfields
        hw_usb_uog2_endptstat
    },
    {
        "UOG2_ENDPTCOMPLETE",
        "This register is only used in device mode.",
        4, // Width in bytes
        0x000003bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usb_uog2_endptcomplete
    },
    {
        "UOG2_ENDPTCTRL0",
        "Every Device implements Endpoint 0 as a control endpoint.",
        4, // Width in bytes
        0x000003c0, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usb_uog2_endptctrl0
    },
    {
        "UOG2_ENDPTCTRL1",
        "This is endpoint control register for endpoint 1 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000003c4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_uog2_endptctrl1
    },
    {
        "UOG2_ENDPTCTRL2",
        "This is endpoint control register for endpoint 2 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000003c8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_uog2_endptctrl2
    },
    {
        "UOG2_ENDPTCTRL3",
        "This is endpoint control register for endpoint 3 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000003cc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_uog2_endptctrl3
    },
    {
        "UOG2_ENDPTCTRL4",
        "This is endpoint control register for endpoint 4 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000003d0, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_uog2_endptctrl4
    },
    {
        "UOG2_ENDPTCTRL5",
        "This is endpoint control register for endpoint 5 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000003d4, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_uog2_endptctrl5
    },
    {
        "UOG2_ENDPTCTRL6",
        "This is endpoint control register for endpoint 6 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000003d8, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_uog2_endptctrl6
    },
    {
        "UOG2_ENDPTCTRL7",
        "This is endpoint control register for endpoint 7 in device operation m"
        "ode.",
        4, // Width in bytes
        0x000003dc, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usb_uog2_endptctrl7
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USBNC
#endif

// Bitfields in register USBNC_USB_OTG1_CTRL.
static const field_t hw_usbnc_usb_otg1_ctrl[] =
{
    {
        "OVER_CUR_DIS",
        "Disable OTG1 Overcurrent Detection",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVER_CUR_POL",
        "OTG1 Polarity of Overcurrent The polarity of OTG1 port overcurrent eve"
        "nt",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWR_POL",
        "OTG1 Power Polarity This bit should be set according to PMIC Power Pin"
        " polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIE",
        "OTG1 Wake-up Interrupt Enable This bit enables or disables the OTG1 wa"
        "ke-up interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW_EN",
        "OTG1 Software Wake-up Enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW",
        "OTG1 Software Wake-up",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_ID_EN",
        "OTG1 Wake-up on ID change enable",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_VBUS_EN",
        "OTG1 wake-up on VBUS change enable",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIR",
        "OTG1 Wake-up Interrupt Request This bit indicates that a wake-up inter"
        "rupt request is received on the OTG1 port.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_OTG2_CTRL.
static const field_t hw_usbnc_usb_otg2_ctrl[] =
{
    {
        "OVER_CUR_DIS",
        "Disable OTG2 Overcurrent Detection",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OVER_CUR_POL",
        "OTG2 Polarity of Overcurrent The polarity of OTG2 port overcurrent eve"
        "nt",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "PWR_POL",
        "OTG2 Power Polarity This bit should be set according to PMIC Power Pin"
        " polarity.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIE",
        "OTG2 Wake-up Interrupt Enable This bit enables or disables the OTG2 wa"
        "ke-up interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW_EN",
        "OTG2 Software Wake-up Enable",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_SW",
        "OTG2 Software Wake-up",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_ID_EN",
        "OTG2 Wake-up on ID change enable",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WKUP_VBUS_EN",
        "OTG2 wake-up on VBUS change enable",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIR",
        "OTG2 Wake-up Interrupt Request This bit indicates that a wake-up inter"
        "rupt request is received on the OTG port.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_OTG1_PHY_CTRL_0.
static const field_t hw_usbnc_usb_otg1_phy_ctrl_0[] =
{
    {
        "UTMI_CLK_VLD",
        "Indicating whether OTG1 UTMI PHY clock is valid",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBNC_USB_OTG2_PHY_CTRL_0.
static const field_t hw_usbnc_usb_otg2_phy_ctrl_0[] =
{
    {
        "UTMI_CLK_VLD",
        "Indicating whether OTG2 UTMI PHY clock is valid",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a USBNC module.
static const reg_t hw_usbnc[] =
{
    {
        "USB_OTG1_CTRL",
        "The USB OTG1 control register controls the integration specific featur"
        "es of the USB OTG1 module.",
        4, // Width in bytes
        0x00000800, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usbnc_usb_otg1_ctrl
    },
    {
        "USB_OTG2_CTRL",
        "The USB OTG2 control register controls the integration specific featur"
        "es of the USB OTG2 module.",
        4, // Width in bytes
        0x00000804, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usbnc_usb_otg2_ctrl
    },
    {
        "USB_OTG1_PHY_CTRL_0",
        "USB OTG1 UTMI PHY control register 0 is used to control the on-chip OT"
        "G1 UTMI PHY.",
        4, // Width in bytes
        0x00000818, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbnc_usb_otg1_phy_ctrl_0
    },
    {
        "USB_OTG2_PHY_CTRL_0",
        "USB OTG2 UTMI PHY Control Register 0 are used to control the on-chip O"
        "TG2 UTMI PHY.",
        4, // Width in bytes
        0x0000081c, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usbnc_usb_otg2_phy_ctrl_0
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark USBPHY
#endif

// Bitfields in register USBPHY_PWD.
static const field_t hw_usbphy_pwd[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXPWDFS",
        "0 = Normal operation.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDIBIAS",
        "0 = Normal operation.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDV2I",
        "0 = Normal operation.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        13, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXPWDENV",
        "0 = Normal operation.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWD1PT1",
        "0 = Normal operation.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDDIFF",
        "0 = Normal operation.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDRX",
        "0 = Normal operation.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        21, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_PWD_SET.
static const field_t hw_usbphy_pwd_set[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXPWDFS",
        "0 = Normal operation.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDIBIAS",
        "0 = Normal operation.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDV2I",
        "0 = Normal operation.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        13, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXPWDENV",
        "0 = Normal operation.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWD1PT1",
        "0 = Normal operation.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDDIFF",
        "0 = Normal operation.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDRX",
        "0 = Normal operation.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        21, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_PWD_CLR.
static const field_t hw_usbphy_pwd_clr[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXPWDFS",
        "0 = Normal operation.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDIBIAS",
        "0 = Normal operation.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDV2I",
        "0 = Normal operation.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        13, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXPWDENV",
        "0 = Normal operation.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWD1PT1",
        "0 = Normal operation.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDDIFF",
        "0 = Normal operation.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDRX",
        "0 = Normal operation.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        21, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_PWD_TOG.
static const field_t hw_usbphy_pwd_tog[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TXPWDFS",
        "0 = Normal operation.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDIBIAS",
        "0 = Normal operation.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXPWDV2I",
        "0 = Normal operation.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        13, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXPWDENV",
        "0 = Normal operation.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWD1PT1",
        "0 = Normal operation.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDDIFF",
        "0 = Normal operation.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RXPWDRX",
        "0 = Normal operation.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        21, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TX.
static const field_t hw_usbphy_tx[] =
{
    {
        "D_CAL",
        "Resistor Trimming Code: 0000 = 0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DN",
        "Decode to select a 45-Ohm resistance to the USB_DN output pin.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DP",
        "Decode to select a 45-Ohm resistance to the USB_DP output pin.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        20, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "USBPHY_TX_EDGECTRL",
        "Controls the edge-rate of the current sensing transistors used in HS t"
        "ransmit.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "Reserved.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TX_SET.
static const field_t hw_usbphy_tx_set[] =
{
    {
        "D_CAL",
        "Resistor Trimming Code: 0000 = 0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DN",
        "Decode to select a 45-Ohm resistance to the USB_DN output pin.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DP",
        "Decode to select a 45-Ohm resistance to the USB_DP output pin.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        20, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "USBPHY_TX_EDGECTRL",
        "Controls the edge-rate of the current sensing transistors used in HS t"
        "ransmit.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "Reserved.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TX_CLR.
static const field_t hw_usbphy_tx_clr[] =
{
    {
        "D_CAL",
        "Resistor Trimming Code: 0000 = 0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DN",
        "Decode to select a 45-Ohm resistance to the USB_DN output pin.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DP",
        "Decode to select a 45-Ohm resistance to the USB_DP output pin.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        20, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "USBPHY_TX_EDGECTRL",
        "Controls the edge-rate of the current sensing transistors used in HS t"
        "ransmit.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "Reserved.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_TX_TOG.
static const field_t hw_usbphy_tx_tog[] =
{
    {
        "D_CAL",
        "Resistor Trimming Code: 0000 = 0.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DN",
        "Decode to select a 45-Ohm resistance to the USB_DN output pin.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TXCAL45DP",
        "Decode to select a 45-Ohm resistance to the USB_DP output pin.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        20, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "USBPHY_TX_EDGECTRL",
        "Controls the edge-rate of the current sensing transistors used in HS t"
        "ransmit.",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD5",
        "Reserved.",
        29, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_RX.
static const field_t hw_usbphy_rx[] =
{
    {
        "ENVADJ",
        "The ENVADJ field adjusts the trip point for the envelope detector.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DISCONADJ",
        "The DISCONADJ field adjusts the trip point for the disconnect detector"
        ": 000 = Trip-Level Voltage is 0.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        7, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXDBYPASS",
        "0 = Normal operation.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        23, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_RX_SET.
static const field_t hw_usbphy_rx_set[] =
{
    {
        "ENVADJ",
        "The ENVADJ field adjusts the trip point for the envelope detector.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DISCONADJ",
        "The DISCONADJ field adjusts the trip point for the disconnect detector"
        ": 000 = Trip-Level Voltage is 0.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        7, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXDBYPASS",
        "0 = Normal operation.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        23, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_RX_CLR.
static const field_t hw_usbphy_rx_clr[] =
{
    {
        "ENVADJ",
        "The ENVADJ field adjusts the trip point for the envelope detector.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DISCONADJ",
        "The DISCONADJ field adjusts the trip point for the disconnect detector"
        ": 000 = Trip-Level Voltage is 0.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        7, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXDBYPASS",
        "0 = Normal operation.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        23, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_RX_TOG.
static const field_t hw_usbphy_rx_tog[] =
{
    {
        "ENVADJ",
        "The ENVADJ field adjusts the trip point for the envelope detector.",
        0, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DISCONADJ",
        "The DISCONADJ field adjusts the trip point for the disconnect detector"
        ": 000 = Trip-Level Voltage is 0.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        7, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RXDBYPASS",
        "0 = Normal operation.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        23, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_CTRL.
static const field_t hw_usbphy_ctrl[] =
{
    {
        "ENOTG_ID_CHG_IRQ",
        "Enable OTG_ID_CHG_IRQ.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHOSTDISCONDETECT",
        "For host mode, enables high-speed disconnect detector.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQHOSTDISCON",
        "Enables interrupt for detection of disconnection to Device when in hig"
        "h-speed host mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOSTDISCONDETECT_IRQ",
        "Indicates that the device has disconnected in high-speed mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDEVPLUGINDETECT",
        "For device mode, enables 200-KOhm pullups for detecting connectivity t"
        "o the host.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_POLARITY",
        "For device mode, if this bit is cleared to 0, then it trips the interr"
        "upt if the device is plugged in.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTG_ID_CHG_IRQ",
        "OTG ID change interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENOTGIDDETECT",
        "Enables circuit to detect resistance of MiniAB ID pin.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUMEIRQSTICKY",
        "Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it"
        ".",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQRESUMEDETECT",
        "Enables interrupt for detection of a non-J state on the USB line.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUME_IRQ",
        "Indicates that the host is sending a wake-up after suspend.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQDEVPLUGIN",
        "Enables interrupt for the detection of connectivity to the USB line.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_IRQ",
        "Indicates that the device is connected.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_ON_LRADC",
        "Enables the LRADC to monitor USB_DP and USB_DM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL2",
        "Enables UTMI+ Level2.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL3",
        "Enables UTMI+ Level3.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQWAKEUP",
        "Enables interrupt for the wakeup events.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP_IRQ",
        "Indicates that there is a wakeup event.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENAUTOCLR_CLKGATE",
        "Enables the feature to auto-clear the CLKGATE bit if there is wakeup e"
        "vent while USB is suspended.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_PHY_PWD",
        "Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD"
        " if there is wakeup event while USB is suspended.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDPDMCHG_WKUP",
        "Enables the feature to wakeup USB if DP/DM is toggled when USB is susp"
        "ended.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIDCHG_WKUP",
        "Enables the feature to wakeup USB if ID is toggled when USB is suspend"
        "ed.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENVBUSCHG_WKUP",
        "Enables the feature to wakeup USB if VBUS is toggled when USB is suspe"
        "nded.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLL_RST_EN",
        "Enables the feature to reset the FSDLL lock detection logic at the end"
        " of each TX packet.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        25, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTG_ID_VALUE",
        "Almost same as OTGID_STATUS in USBPHYx_STATUS Register.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOST_FORCE_LS_SE0",
        "Forces the next FS packet that is transmitted to have a EOP with LS ti"
        "ming.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_SUSPENDM",
        "Used by the PHY to indicate a powered-down state.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "Gate UTMI Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, U"
        "SBPHYx_RX, and USBPHYx_CTRL registers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_CTRL_SET.
static const field_t hw_usbphy_ctrl_set[] =
{
    {
        "ENOTG_ID_CHG_IRQ",
        "Enable OTG_ID_CHG_IRQ.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHOSTDISCONDETECT",
        "For host mode, enables high-speed disconnect detector.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQHOSTDISCON",
        "Enables interrupt for detection of disconnection to Device when in hig"
        "h-speed host mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOSTDISCONDETECT_IRQ",
        "Indicates that the device has disconnected in high-speed mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDEVPLUGINDETECT",
        "For device mode, enables 200-KOhm pullups for detecting connectivity t"
        "o the host.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_POLARITY",
        "For device mode, if this bit is cleared to 0, then it trips the interr"
        "upt if the device is plugged in.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTG_ID_CHG_IRQ",
        "OTG ID change interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENOTGIDDETECT",
        "Enables circuit to detect resistance of MiniAB ID pin.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUMEIRQSTICKY",
        "Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it"
        ".",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQRESUMEDETECT",
        "Enables interrupt for detection of a non-J state on the USB line.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUME_IRQ",
        "Indicates that the host is sending a wake-up after suspend.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQDEVPLUGIN",
        "Enables interrupt for the detection of connectivity to the USB line.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_IRQ",
        "Indicates that the device is connected.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_ON_LRADC",
        "Enables the LRADC to monitor USB_DP and USB_DM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL2",
        "Enables UTMI+ Level2.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL3",
        "Enables UTMI+ Level3.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQWAKEUP",
        "Enables interrupt for the wakeup events.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP_IRQ",
        "Indicates that there is a wakeup event.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENAUTOCLR_CLKGATE",
        "Enables the feature to auto-clear the CLKGATE bit if there is wakeup e"
        "vent while USB is suspended.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_PHY_PWD",
        "Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD"
        " if there is wakeup event while USB is suspended.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDPDMCHG_WKUP",
        "Enables the feature to wakeup USB if DP/DM is toggled when USB is susp"
        "ended.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIDCHG_WKUP",
        "Enables the feature to wakeup USB if ID is toggled when USB is suspend"
        "ed.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENVBUSCHG_WKUP",
        "Enables the feature to wakeup USB if VBUS is toggled when USB is suspe"
        "nded.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLL_RST_EN",
        "Enables the feature to reset the FSDLL lock detection logic at the end"
        " of each TX packet.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        25, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTG_ID_VALUE",
        "Almost same as OTGID_STATUS in USBPHYx_STATUS Register.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOST_FORCE_LS_SE0",
        "Forces the next FS packet that is transmitted to have a EOP with LS ti"
        "ming.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_SUSPENDM",
        "Used by the PHY to indicate a powered-down state.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "Gate UTMI Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, U"
        "SBPHYx_RX, and USBPHYx_CTRL registers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_CTRL_CLR.
static const field_t hw_usbphy_ctrl_clr[] =
{
    {
        "ENOTG_ID_CHG_IRQ",
        "Enable OTG_ID_CHG_IRQ.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHOSTDISCONDETECT",
        "For host mode, enables high-speed disconnect detector.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQHOSTDISCON",
        "Enables interrupt for detection of disconnection to Device when in hig"
        "h-speed host mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOSTDISCONDETECT_IRQ",
        "Indicates that the device has disconnected in high-speed mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDEVPLUGINDETECT",
        "For device mode, enables 200-KOhm pullups for detecting connectivity t"
        "o the host.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_POLARITY",
        "For device mode, if this bit is cleared to 0, then it trips the interr"
        "upt if the device is plugged in.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTG_ID_CHG_IRQ",
        "OTG ID change interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENOTGIDDETECT",
        "Enables circuit to detect resistance of MiniAB ID pin.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUMEIRQSTICKY",
        "Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it"
        ".",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQRESUMEDETECT",
        "Enables interrupt for detection of a non-J state on the USB line.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUME_IRQ",
        "Indicates that the host is sending a wake-up after suspend.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQDEVPLUGIN",
        "Enables interrupt for the detection of connectivity to the USB line.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_IRQ",
        "Indicates that the device is connected.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_ON_LRADC",
        "Enables the LRADC to monitor USB_DP and USB_DM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL2",
        "Enables UTMI+ Level2.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL3",
        "Enables UTMI+ Level3.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQWAKEUP",
        "Enables interrupt for the wakeup events.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP_IRQ",
        "Indicates that there is a wakeup event.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENAUTOCLR_CLKGATE",
        "Enables the feature to auto-clear the CLKGATE bit if there is wakeup e"
        "vent while USB is suspended.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_PHY_PWD",
        "Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD"
        " if there is wakeup event while USB is suspended.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDPDMCHG_WKUP",
        "Enables the feature to wakeup USB if DP/DM is toggled when USB is susp"
        "ended.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIDCHG_WKUP",
        "Enables the feature to wakeup USB if ID is toggled when USB is suspend"
        "ed.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENVBUSCHG_WKUP",
        "Enables the feature to wakeup USB if VBUS is toggled when USB is suspe"
        "nded.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLL_RST_EN",
        "Enables the feature to reset the FSDLL lock detection logic at the end"
        " of each TX packet.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        25, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTG_ID_VALUE",
        "Almost same as OTGID_STATUS in USBPHYx_STATUS Register.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOST_FORCE_LS_SE0",
        "Forces the next FS packet that is transmitted to have a EOP with LS ti"
        "ming.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_SUSPENDM",
        "Used by the PHY to indicate a powered-down state.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "Gate UTMI Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, U"
        "SBPHYx_RX, and USBPHYx_CTRL registers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_CTRL_TOG.
static const field_t hw_usbphy_ctrl_tog[] =
{
    {
        "ENOTG_ID_CHG_IRQ",
        "Enable OTG_ID_CHG_IRQ.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHOSTDISCONDETECT",
        "For host mode, enables high-speed disconnect detector.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQHOSTDISCON",
        "Enables interrupt for detection of disconnection to Device when in hig"
        "h-speed host mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOSTDISCONDETECT_IRQ",
        "Indicates that the device has disconnected in high-speed mode.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDEVPLUGINDETECT",
        "For device mode, enables 200-KOhm pullups for detecting connectivity t"
        "o the host.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_POLARITY",
        "For device mode, if this bit is cleared to 0, then it trips the interr"
        "upt if the device is plugged in.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OTG_ID_CHG_IRQ",
        "OTG ID change interrupt.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENOTGIDDETECT",
        "Enables circuit to detect resistance of MiniAB ID pin.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUMEIRQSTICKY",
        "Set to 1 will make RESUME_IRQ bit a sticky bit until software clear it"
        ".",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQRESUMEDETECT",
        "Enables interrupt for detection of a non-J state on the USB line.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RESUME_IRQ",
        "Indicates that the host is sending a wake-up after suspend.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQDEVPLUGIN",
        "Enables interrupt for the detection of connectivity to the USB line.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEVPLUGIN_IRQ",
        "Indicates that the device is connected.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DATA_ON_LRADC",
        "Enables the LRADC to monitor USB_DP and USB_DM.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL2",
        "Enables UTMI+ Level2.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENUTMILEVEL3",
        "Enables UTMI+ Level3.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIRQWAKEUP",
        "Enables interrupt for the wakeup events.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WAKEUP_IRQ",
        "Indicates that there is a wakeup event.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENAUTOCLR_CLKGATE",
        "Enables the feature to auto-clear the CLKGATE bit if there is wakeup e"
        "vent while USB is suspended.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENAUTOCLR_PHY_PWD",
        "Enables the feature to auto-clear the PWD register bits in USBPHYx_PWD"
        " if there is wakeup event while USB is suspended.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENDPDMCHG_WKUP",
        "Enables the feature to wakeup USB if DP/DM is toggled when USB is susp"
        "ended.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENIDCHG_WKUP",
        "Enables the feature to wakeup USB if ID is toggled when USB is suspend"
        "ed.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENVBUSCHG_WKUP",
        "Enables the feature to wakeup USB if VBUS is toggled when USB is suspe"
        "nded.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FSDLL_RST_EN",
        "Enables the feature to reset the FSDLL lock detection logic at the end"
        " of each TX packet.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        25, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTG_ID_VALUE",
        "Almost same as OTGID_STATUS in USBPHYx_STATUS Register.",
        27, // LSB
        27, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOST_FORCE_LS_SE0",
        "Forces the next FS packet that is transmitted to have a EOP with LS ti"
        "ming.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "UTMI_SUSPENDM",
        "Used by the PHY to indicate a powered-down state.",
        29, // LSB
        29, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLKGATE",
        "Gate UTMI Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SFTRST",
        "Writing a 1 to this bit will soft-reset the USBPHYx_PWD, USBPHYx_TX, U"
        "SBPHYx_RX, and USBPHYx_CTRL registers.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_STATUS.
static const field_t hw_usbphy_status[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HOSTDISCONDETECT_STATUS",
        "Indicates that the device has disconnected while in high-speed host mo"
        "de.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        4, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DEVPLUGIN_STATUS",
        "Indicates that the device has been connected on the USB_DP and USB_DM "
        "lines.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OTGID_STATUS",
        "Indicates the results of ID pin on MiniAB plug.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RESUME_STATUS",
        "Indicates that the host is sending a wake-up after suspend and has tri"
        "ggered an interrupt.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RSVD4",
        "Reserved.",
        11, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG.
static const field_t hw_usbphy_debug[] =
{
    {
        "OTGIDPIOLOCK",
        "Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the val"
        "ue.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_INTERFACE_HOLD",
        "Use holding registers to assist in timing for external UTMI interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSTPULLDOWN",
        "Set bit 3 to 1 to pull down 15-KOhm on USB_DP line.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHSTPULLDOWN",
        "Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX2RXCOUNT",
        "Delay in between the end of transmit to the beginning of receive.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTX2RXCOUNT",
        "Set this bit to allow a countdown to transition in between TX and RX.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SQUELCHRESETCOUNT",
        "Delay in between the detection of squelch to the reset of high-speed R"
        "X.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENSQUELCHRESET",
        "Set bit to allow squelch to reset high-speed receive.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETLENGTH",
        "Duration of RESET in terms of the number of 480-MHz cycles.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOST_RESUME_DEBUG",
        "Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UT"
        "MI_SUSPEND = 1.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Gate Test Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG_SET.
static const field_t hw_usbphy_debug_set[] =
{
    {
        "OTGIDPIOLOCK",
        "Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the val"
        "ue.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_INTERFACE_HOLD",
        "Use holding registers to assist in timing for external UTMI interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSTPULLDOWN",
        "Set bit 3 to 1 to pull down 15-KOhm on USB_DP line.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHSTPULLDOWN",
        "Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX2RXCOUNT",
        "Delay in between the end of transmit to the beginning of receive.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTX2RXCOUNT",
        "Set this bit to allow a countdown to transition in between TX and RX.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SQUELCHRESETCOUNT",
        "Delay in between the detection of squelch to the reset of high-speed R"
        "X.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENSQUELCHRESET",
        "Set bit to allow squelch to reset high-speed receive.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETLENGTH",
        "Duration of RESET in terms of the number of 480-MHz cycles.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOST_RESUME_DEBUG",
        "Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UT"
        "MI_SUSPEND = 1.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Gate Test Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG_CLR.
static const field_t hw_usbphy_debug_clr[] =
{
    {
        "OTGIDPIOLOCK",
        "Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the val"
        "ue.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_INTERFACE_HOLD",
        "Use holding registers to assist in timing for external UTMI interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSTPULLDOWN",
        "Set bit 3 to 1 to pull down 15-KOhm on USB_DP line.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHSTPULLDOWN",
        "Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX2RXCOUNT",
        "Delay in between the end of transmit to the beginning of receive.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTX2RXCOUNT",
        "Set this bit to allow a countdown to transition in between TX and RX.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SQUELCHRESETCOUNT",
        "Delay in between the detection of squelch to the reset of high-speed R"
        "X.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENSQUELCHRESET",
        "Set bit to allow squelch to reset high-speed receive.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETLENGTH",
        "Duration of RESET in terms of the number of 480-MHz cycles.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOST_RESUME_DEBUG",
        "Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UT"
        "MI_SUSPEND = 1.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Gate Test Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG_TOG.
static const field_t hw_usbphy_debug_tog[] =
{
    {
        "OTGIDPIOLOCK",
        "Once OTG ID from USBPHYx_STATUS_OTGID_STATUS, use this to hold the val"
        "ue.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBUG_INTERFACE_HOLD",
        "Use holding registers to assist in timing for external UTMI interface.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HSTPULLDOWN",
        "Set bit 3 to 1 to pull down 15-KOhm on USB_DP line.",
        2, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENHSTPULLDOWN",
        "Set bit 5 to 1 to override the control of the USB_DP 15-KOhm pulldown.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD0",
        "Reserved.",
        6, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TX2RXCOUNT",
        "Delay in between the end of transmit to the beginning of receive.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTX2RXCOUNT",
        "Set this bit to allow a countdown to transition in between TX and RX.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        13, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SQUELCHRESETCOUNT",
        "Delay in between the detection of squelch to the reset of high-speed R"
        "X.",
        16, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD2",
        "Reserved.",
        21, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ENSQUELCHRESET",
        "Set bit to allow squelch to reset high-speed receive.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SQUELCHRESETLENGTH",
        "Duration of RESET in terms of the number of 480-MHz cycles.",
        25, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HOST_RESUME_DEBUG",
        "Choose to trigger the host resume SE0 with HOST_FORCE_LS_SE0 = 0 or UT"
        "MI_SUSPEND = 1.",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE",
        "Gate Test Clocks.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD3",
        "Reserved.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG0_STATUS.
static const field_t hw_usbphy_debug0_status[] =
{
    {
        "LOOP_BACK_FAIL_COUNT",
        "Running count of the failed pseudo-random generator loopback.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "UTMI_RXERROR_FAIL_COUNT",
        "Running count of the UTMI_RXERROR.",
        16, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SQUELCH_COUNT",
        "Running count of the squelch reset instead of normal end for HS RX.",
        26, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG1.
static const field_t hw_usbphy_debug1[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTAILADJVD",
        "Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Del"
        "ay is +20% 10 = Delay is -20% 11 = Delay is -40%",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        15, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG1_SET.
static const field_t hw_usbphy_debug1_set[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTAILADJVD",
        "Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Del"
        "ay is +20% 10 = Delay is -20% 11 = Delay is -40%",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        15, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG1_CLR.
static const field_t hw_usbphy_debug1_clr[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTAILADJVD",
        "Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Del"
        "ay is +20% 10 = Delay is -20% 11 = Delay is -40%",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        15, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_DEBUG1_TOG.
static const field_t hw_usbphy_debug1_tog[] =
{
    {
        "RSVD0",
        "Reserved.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENTAILADJVD",
        "Delay increment of the rise of squelch: 00 = Delay is nominal 01 = Del"
        "ay is +20% 10 = Delay is -20% 11 = Delay is -40%",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSVD1",
        "Reserved.",
        15, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register USBPHY_VERSION.
static const field_t hw_usbphy_version[] =
{
    {
        "STEP",
        "Fixed read-only value reflecting the stepping of the RTL version.",
        0, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MINOR",
        "Fixed read-only value reflecting the MINOR field of the RTL version.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MAJOR",
        "Fixed read-only value reflecting the MAJOR field of the RTL version.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Registers in a USBPHY module.
static const reg_t hw_usbphy[] =
{
    {
        "PWD",
        "The USB PHY Power-Down Register provides overall control of the PHY po"
        "wer state.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_usbphy_pwd
    },
    {
        "PWD_SET",
        "The USB PHY Power-Down Register provides overall control of the PHY po"
        "wer state.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_usbphy_pwd_set
    },
    {
        "PWD_CLR",
        "The USB PHY Power-Down Register provides overall control of the PHY po"
        "wer state.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_usbphy_pwd_clr
    },
    {
        "PWD_TOG",
        "The USB PHY Power-Down Register provides overall control of the PHY po"
        "wer state.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_usbphy_pwd_tog
    },
    {
        "TX",
        "The USB PHY Transmitter Control Register handles the transmit controls"
        ".",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usbphy_tx
    },
    {
        "TX_SET",
        "The USB PHY Transmitter Control Register handles the transmit controls"
        ".",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usbphy_tx_set
    },
    {
        "TX_CLR",
        "The USB PHY Transmitter Control Register handles the transmit controls"
        ".",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usbphy_tx_clr
    },
    {
        "TX_TOG",
        "The USB PHY Transmitter Control Register handles the transmit controls"
        ".",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usbphy_tx_tog
    },
    {
        "RX",
        "The USB PHY Receiver Control Register handles receive path controls.",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usbphy_rx
    },
    {
        "RX_SET",
        "The USB PHY Receiver Control Register handles receive path controls.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usbphy_rx_set
    },
    {
        "RX_CLR",
        "The USB PHY Receiver Control Register handles receive path controls.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usbphy_rx_clr
    },
    {
        "RX_TOG",
        "The USB PHY Receiver Control Register handles receive path controls.",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usbphy_rx_tog
    },
    {
        "CTRL",
        "The USB PHY General Control Register handles OTG and Host controls.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        31, // Number of bitfields
        hw_usbphy_ctrl
    },
    {
        "CTRL_SET",
        "The USB PHY General Control Register handles OTG and Host controls.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        31, // Number of bitfields
        hw_usbphy_ctrl_set
    },
    {
        "CTRL_CLR",
        "The USB PHY General Control Register handles OTG and Host controls.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        31, // Number of bitfields
        hw_usbphy_ctrl_clr
    },
    {
        "CTRL_TOG",
        "The USB PHY General Control Register handles OTG and Host controls.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        31, // Number of bitfields
        hw_usbphy_ctrl_tog
    },
    {
        "STATUS",
        "The USB PHY Status Register holds results of IRQ and other detects.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usbphy_status
    },
    {
        "DEBUG",
        "This register is used to debug the USB PHY.",
        4, // Width in bytes
        0x00000050, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbphy_debug
    },
    {
        "DEBUG_SET",
        "This register is used to debug the USB PHY.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbphy_debug_set
    },
    {
        "DEBUG_CLR",
        "This register is used to debug the USB PHY.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbphy_debug_clr
    },
    {
        "DEBUG_TOG",
        "This register is used to debug the USB PHY.",
        4, // Width in bytes
        0x0000005c, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_usbphy_debug_tog
    },
    {
        "DEBUG0_STATUS",
        "The UTMI Debug Status Register 0 holds multiple views for counters and"
        " status of state machines.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbphy_debug0_status
    },
    {
        "DEBUG1",
        "Chooses the muxing of the debug register to be shown in USBPHYx_DEBUG0"
        "_STATUS.",
        4, // Width in bytes
        0x00000070, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_debug1
    },
    {
        "DEBUG1_SET",
        "Chooses the muxing of the debug register to be shown in USBPHYx_DEBUG0"
        "_STATUS.",
        4, // Width in bytes
        0x00000074, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_debug1_set
    },
    {
        "DEBUG1_CLR",
        "Chooses the muxing of the debug register to be shown in USBPHYx_DEBUG0"
        "_STATUS.",
        4, // Width in bytes
        0x00000078, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_debug1_clr
    },
    {
        "DEBUG1_TOG",
        "Chooses the muxing of the debug register to be shown in USBPHYx_DEBUG0"
        "_STATUS.",
        4, // Width in bytes
        0x0000007c, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_usbphy_debug1_tog
    },
    {
        "VERSION",
        "Fields for RTL Version.",
        4, // Width in bytes
        0x00000080, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usbphy_version
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark uSDHC
#endif

// Bitfields in register uSDHC_DS_ADDR.
static const field_t hw_usdhc_ds_addr[] =
{
    {
        "DS_ADDR",
        "DMA System Address / Argument 2 When ACMD23_ARGU2_EN is set to 0, SDMA"
        " uses this register as system address and supports only 32-bit address"
        "ing mode.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_BLK_ATT.
static const field_t hw_usdhc_blk_att[] =
{
    {
        "BLKSIZE",
        "Transfer Block Size: This register specifies the block size for block "
        "data transfers.",
        0, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BLKCNT",
        "Blocks Count For Current Transfer: This register is enabled when the B"
        "lock Count Enable bit in the Transfer Mode register is set to 1 and is"
        " valid only for multiple block transfers.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_CMD_ARG.
static const field_t hw_usdhc_cmd_arg[] =
{
    {
        "CMDARG",
        "The SD / MMC Command Argument is specified as bits 39-8 of the Command"
        " Format in the SD or MMC Specification.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_CMD_XFR_TYP.
static const field_t hw_usdhc_cmd_xfr_typ[] =
{
    {
        "RSPTYP",
        "",
        16, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCCEN",
        "If this bit is set to 1, the uSDHC shall check the CRC field in the re"
        "sponse.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CICEN",
        "If this bit is set to 1, the uSDHC will check the Index field in the r"
        "esponse to see if it has the same value as the command index.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DPSEL",
        "This bit is set to 1 to indicate that data is present and shall be tra"
        "nsferred using the DATA line.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMDTYP",
        "There are three types of special commands: Suspend, Resume and Abort.",
        22, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CMDINX",
        "These bits shall be set to the command number that is specified in bit"
        "s 45-40 of the Command-Format in the SD Memory Card Physical Layer Spe"
        "cification and SDIO Card Specification.",
        24, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_CMD_RSP0.
static const field_t hw_usdhc_cmd_rsp0[] =
{
    {
        "CMDRSP0",
        "Refer to CMD_RSP3Command Response3 for the mapping of command response"
        "s from the SD Bus to this register for each response type.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_CMD_RSP1.
static const field_t hw_usdhc_cmd_rsp1[] =
{
    {
        "CMDRSP1",
        "Refer to CMD_RSP3Command Response3 for the mapping of command response"
        "s from the SD Bus to this register for each response type.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_CMD_RSP2.
static const field_t hw_usdhc_cmd_rsp2[] =
{
    {
        "CMDRSP2",
        "Refer to CMD_RSP3Command Response3 for the mapping of command response"
        "s from the SD Bus to this register for each response type.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_CMD_RSP3.
static const field_t hw_usdhc_cmd_rsp3[] =
{
    {
        "CMDRSP3",
        "Refer to CMD_RSP3Command Response3 for the mapping of command response"
        "s from the SD Bus to this register for each response type.",
        0, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_DATA_BUFF_ACC_PORT.
static const field_t hw_usdhc_data_buff_acc_port[] =
{
    {
        "DATCONT",
        "The Buffer Data Port register is for 32-bit data access by the ARM pla"
        "tform or the external DMA.",
        0, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_PRES_STATE.
static const field_t hw_usdhc_pres_state[] =
{
    {
        "CIHB",
        "If this status bit is 0, it indicates that the CMD line is not in use "
        "and the uSDHC can issue a SD / MMC Command using the CMD line.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CDIHB",
        "This status bit is generated if either the DAT Line Active or the Read"
        " Transfer Active is set to 1.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLA",
        "This status bit indicates whether one of the DATA lines on the SD Bus "
        "is in use.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDSTB",
        "This status bit indicates that the internal card clock is stable.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "IPGOFF",
        "This status bit indicates that the ipg_clk is internally gated off.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HCKOFF",
        "This status bit indicates that the HCLK is internally gated off.",
        5, // LSB
        5, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PEROFF",
        "This status bit indicates that the IPG_PERCLK is internally gated off.",
        6, // LSB
        6, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDOFF",
        "This status bit indicates that the SD Clock is internally gated off, b"
        "ecause of buffer over / under-run or read pause without read wait asse"
        "rtion, or the driver set FRC_SDCLK_ON bit is 0 to stop the SD clock in"
        " idle status.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WTA",
        "This status bit indicates a write transfer is active.",
        8, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTA",
        "This status bit is used for detecting completion of a read transfer.",
        9, // LSB
        9, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BWEN",
        "This status bit is used for non-DMA write transfers.",
        10, // LSB
        10, // MSB
        true, // Readable
        false // Writable
    },
    {
        "BREN",
        "This status bit is used for non-DMA read transfers.",
        11, // LSB
        11, // MSB
        true, // Readable
        false // Writable
    },
    {
        "RTR",
        "Host Controller may request Host Driver to execute re-tuning sequence "
        "by setting this bit when the data window is shifted by temperature dri"
        "ft and a tuned sampling point does not have a good margin to receive c"
        "orrect data.",
        12, // LSB
        12, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TSCD",
        "This bit indicates the dealy setting is effective after write CLK_TUNE"
        "_CTRL_STATUS register.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CINST",
        "This bit indicates whether a card has been inserted.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CDPL",
        "This bit reflects the inverse value of the CD_B pin for the card socke"
        "t.",
        18, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "WPSPL",
        "The Write Protect Switch is supported for memory and combo cards.This "
        "bit reflects the inverted value of the WP pin of the card socket.",
        19, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CLSL",
        "This status is used to check the CMD line level to recover from errors"
        ", and for debugging.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLSL",
        "This status is used to check the DATA line level to recover from error"
        "s, and for debugging.This is especially useful in detecting the busy s"
        "ignal level from DATA0.",
        24, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_PROT_CTRL.
static const field_t hw_usdhc_prot_ctrl[] =
{
    {
        "LCTL",
        "This bit, fully controlled by the Host Driver, is used to caution the "
        "user not to remove the card while the card is being accessed.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTW",
        "This bit selects the data width of the SD bus for a data transfer.",
        1, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "D3CD",
        "If this bit is set, DATA3 should be pulled down to act as a card detec"
        "tion pin.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EMODE",
        "The uSDHC supports all three endian modes in data transfer.",
        4, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CDTL",
        "This is bit is enabled while the Card Detection Signal Selection is se"
        "t to 1 and it indicates card insertion.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CDSS",
        "This bit selects the source for the card detection.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMASEL",
        "This field is valid while DMA (SDMA or ADMA) is enabled and selects th"
        "e DMA operation.",
        8, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SABGREQ",
        "This bit is used to stop executing a transaction at the next block gap"
        " for both DMA and non-DMA transfers.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CREQ",
        "This bit is used to restart a transaction which was stopped using the "
        "Stop At Block Gap Request.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RWCTL",
        "The read wait function is optional for SDIO cards.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IABG",
        "This bit is valid only in 4-bit mode, of the SDIO card, and selects a "
        "sample point in the interrupt cycle.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_DONE_NO_8CLK",
        "Read done no 8 clock: According to the SD/MMC spec, for read data tran"
        "saction, 8 clocks are needed after the end bit of the last data block.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WECINT",
        "This bit enables a wakeup event, via a Card Interrupt, in the Interrup"
        "t Status register.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WECINS",
        "This bit enables a wakeup event, via a Card Insertion, in the Interrup"
        "t Status register.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WECRM",
        "This bit enables a wakeup event, via a Card Removal, in the Interrupt "
        "Status register.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BURST_LEN_EN",
        "This is used to enable / disable the burst length for the external AHB"
        "2AXI bridge.",
        27, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NON_EXACT_BLK_RD",
        "Current block read is non-exact block read.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_SYS_CTRL.
static const field_t hw_usdhc_sys_ctrl[] =
{
    {
        "DVS",
        "This register is used to provide a more exact divisor to generate the "
        "desired SD clock frequency.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDCLKFS",
        "This register is used to select the frequency of the SDCLK pin.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOCV",
        "This value determines the interval by which DAT line timeouts are dete"
        "cted.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPP_RST_N",
        "This register's value will be output to CARD from pad directly for har"
        "dware reset of the card if the card supports this feature.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTA",
        "This reset effects the entire Host Controller except for the card dete"
        "ction circuit.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTC",
        "Only part of the command circuit is reset.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTD",
        "Only part of the data circuit is reset.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INITA",
        "When this bit is set, 80 SD-Clocks are sent to the card.",
        27, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RSTT",
        "When set this bit to 1, it will reset tuning circuit.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_INT_STATUS.
static const field_t hw_usdhc_int_status[] =
{
    {
        "CC",
        "This bit is set when you receive the end bit of the command response ("
        "except Auto CMD12).",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TC",
        "This bit is set when a read or write transfer is completed.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGE",
        "If the Stop At Block Gap Request bit in the Protocol Control register "
        "is set, this bit is set when a read or write transaction is stopped at"
        " a block gap.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DINT",
        "Occurs only when the internal DMA finishes the data transfer successfu"
        "lly.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWR",
        "This status bit is set if the Buffer Write Enable bit, in the Present "
        "State register, changes from 0 to 1.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRR",
        "This status bit is set if the Buffer Read Enable bit, in the Present S"
        "tate register, changes from 0 to 1.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINS",
        "This status bit is set if the Card Inserted bit in the Present State r"
        "egister changes from 0 to 1.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRM",
        "This status bit is set if the Card Inserted bit in the Present State r"
        "egister changes from 1 to 0.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINT",
        "This status bit is set when an interrupt signal is detected from the e"
        "xternal card.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTE",
        "This status is set if Re-Tuning Request in the Present State register "
        "changes from 0 to 1.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TP",
        "Current CMD19 transfer is done successfully.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTOE",
        "Occurs only if no response is returned within 64 SDCLK cycles from the"
        " end bit of the command.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCE",
        "Command CRC Error is generated in two cases.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEBE",
        "Occurs when detecting that the end bit of a command response is 0.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIE",
        "Occurs if a Command Index error occurs in the command response.",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOE",
        "Occurs when detecting one of following time-out conditions.",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCE",
        "Occurs when detecting a CRC error when transferring read data, which u"
        "ses the DATA line, or when detecting the Write CRC status having a val"
        "ue other than 010.",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBE",
        "Occurs either when detecting 0 at the end bit position of read data, w"
        "hich uses the DATA line, or at the end bit position of the CRC.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12E",
        "Occurs when detecting that one of the bits in the Auto CMD12 Error Sta"
        "tus register has changed from 0 to 1.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNE",
        "This bit is set when an unrecoverable error is detected in a tuning ci"
        "rcuit.",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAE",
        "Occurs when an Internal DMA transfer has failed.",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_INT_STATUS_EN.
static const field_t hw_usdhc_int_status_en[] =
{
    {
        "CCSEN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCSEN",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGESEN",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DINTSEN",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWRSEN",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRRSEN",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINSSEN",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRMSEN",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINTSEN",
        "If this bit is set to 0, the uSDHC will clear the interrupt request to"
        " the system.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTESEN",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPSEN",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTOESEN",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCESEN",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEBESEN",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIESEN",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOESEN",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCESEN",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBESEN",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12ESEN",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNESEN",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAESEN",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_INT_SIGNAL_EN.
static const field_t hw_usdhc_int_signal_en[] =
{
    {
        "CCIEN",
        "",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TCIEN",
        "",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BGEIEN",
        "",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DINTIEN",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BWRIEN",
        "",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BRRIEN",
        "",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINSIEN",
        "",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRMIEN",
        "",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CINTIEN",
        "",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTEIEN",
        "",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TPIEN",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CTOEIEN",
        "",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CCEIEN",
        "",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CEBEIEN",
        "",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CIEIEN",
        "",
        19, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTOEIEN",
        "",
        20, // LSB
        20, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DCEIEN",
        "",
        21, // LSB
        21, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DEBEIEN",
        "",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12EIEN",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TNEIEN",
        "",
        26, // LSB
        26, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DMAEIEN",
        "",
        28, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_AUTOCMD12_ERR_STATUS.
static const field_t hw_usdhc_autocmd12_err_status[] =
{
    {
        "AC12NE",
        "If memory multiple block data transfer is not started, due to a comman"
        "d error, this bit is not set because it is not necessary to issue an A"
        "uto CMD12.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12TOE",
        "Occurs if no response is returned within 64 SDCLK cycles from the end "
        "bit of the command.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12EBE",
        "Occurs when detecting that the end bit of command response is 0 which "
        "should be 1.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12CE",
        "Occurs when detecting a CRC error in the command response.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    {
        "AC12IE",
        "Occurs if the Command Index error occurs in response to a command.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CNIBAC12E",
        "Setting this bit to 1 means CMD_wo_DAT is not executed due to an Auto "
        "CMD12 Error (D04-D01) in this register.",
        7, // LSB
        7, // MSB
        true, // Readable
        false // Writable
    },
    {
        "EXECUTE_TUNING",
        "When std_tuning_en bit is set, this bit is used to start tuning proced"
        "ure.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMP_CLK_SEL",
        "When std_tuning_en bit is set, this bit is used to select sampling clo"
        "ck to receive CMD and DATA.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_HOST_CTRL_CAP.
static const field_t hw_usdhc_host_ctrl_cap[] =
{
    {
        "SDR50_SUPPORT",
        "This bit indicates support of SDR50 mode.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SDR104_SUPPORT",
        "This bit indicates support of SDR104 mode.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DDR50_SUPPORT",
        "This bit indicates support of DDR50 mode.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TIME_COUNT_RETUNING",
        "This bit indicates an initial value of the Retuning Timer for Re-Tunin"
        "g Mode1 and 3.",
        8, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "USE_TUNING_SDR50",
        "This bit is set to 1.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RETUNING_MODE",
        "This bit selects retuning method.",
        14, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MBL",
        "This value indicates the maximum block size that the Host Driver can r"
        "ead and write to the buffer in the uSDHC.",
        16, // LSB
        18, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADMAS",
        "This bit indicates whether the uSDHC supports the ADMA feature.",
        20, // LSB
        20, // MSB
        true, // Readable
        false // Writable
    },
    {
        "HSS",
        "This bit indicates whether the uSDHC supports High Speed mode and the "
        "Host System can supply a SD Clock frequency from 25 MHz to 50 MHz.",
        21, // LSB
        21, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DMAS",
        "This bit indicates whether the uSDHC is capable of using the internal "
        "DMA to transfer data between system memory and the data buffer directl"
        "y.",
        22, // LSB
        22, // MSB
        true, // Readable
        false // Writable
    },
    {
        "SRS",
        "This bit indicates whether the uSDHC supports Suspend / Resume functio"
        "nality.",
        23, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VS33",
        "This bit shall depend on the Host System ability.",
        24, // LSB
        24, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VS30",
        "This bit shall depend on the Host System ability.",
        25, // LSB
        25, // MSB
        true, // Readable
        false // Writable
    },
    {
        "VS18",
        "This bit shall depend on the Host System ability.",
        26, // LSB
        26, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_WTMK_LVL.
static const field_t hw_usdhc_wtmk_lvl[] =
{
    {
        "RD_WML",
        "The number of words used as the watermark level (FIFO threshold) in a "
        "DMA read operation.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RD_BRST_LEN",
        "The number of words the uSDHC reads in a single burst.",
        8, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_WML",
        "The number of words used as the watermark level (FIFO threshold) in a "
        "DMA write operation.",
        16, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WR_BRST_LEN",
        "The number of words the uSDHC writes in a single burst.",
        24, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_MIX_CTRL.
static const field_t hw_usdhc_mix_ctrl[] =
{
    {
        "DMAEN",
        "This bit enables DMA functionality.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BCEN",
        "This bit is used to enable the Block Count register, which is only rel"
        "evant for multiple block transfers.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12EN",
        "Multiple block transfers for memory require a CMD12 to stop the transa"
        "ction.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DDR_EN",
        "",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DTDSEL",
        "This bit defines the direction of DATA line data transfers.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MSBSEL",
        "This bit enables multiple block DATA line data transfers.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NIBBLE_POS",
        "In DDR 4-bit mode nibble position indictation.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC23EN",
        "When this bit is set to 1, the Host Controller issues a CMD23 automati"
        "cally before issuing a command specified in the Command Register.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "EXE_TUNE",
        "When STD_TUNING_EN is 0, this bit is set to 1 to indicate the Host Dri"
        "ver is starting tuning procedure.",
        22, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SMP_CLK_SEL",
        "When STD_TUNING_EN is 0, this bit is used to select Tuned clock or Fix"
        "ed clock to sample data / cmd (Only used for SD3.",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTO_TUNE_EN",
        "",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FBCLK_SEL",
        "",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_FORCE_EVENT.
static const field_t hw_usdhc_force_event[] =
{
    {
        "FEVTAC12NE",
        "Forces the AC12NE bit in the Auto Command12 Error Status Register to b"
        "e set.",
        0, // LSB
        0, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTAC12TOE",
        "Forces the AC12TOE bit in the Auto Command12 Error Status Register to "
        "be set.",
        1, // LSB
        1, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTAC12CE",
        "Forces the AC12CE bit in the Auto Command12 Error Status Register to b"
        "e set.",
        2, // LSB
        2, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTAC12EBE",
        "Forces the AC12EBE bit in the Auto Command12 Error Status Register to "
        "be set.",
        3, // LSB
        3, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTAC12IE",
        "Forces the AC12IE bit in the Auto Command12 Error Status Register to b"
        "e set.",
        4, // LSB
        4, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCNIBAC12E",
        "Forces the CNIBAC12E bit in the Auto Command12 Error Status Register t"
        "o be set.",
        7, // LSB
        7, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCTOE",
        "Forces the CTOE bit of Interrupt Status Register to be set.",
        16, // LSB
        16, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCCE",
        "Forces the CCE bit of Interrupt Status Register to be set.",
        17, // LSB
        17, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCEBE",
        "Forces the CEBE bit of Interrupt Status Register to be set.",
        18, // LSB
        18, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCIE",
        "Forces the CCE bit of Interrupt Status Register to be set.",
        19, // LSB
        19, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTDTOE",
        "Force the DTOE bit of Interrupt Status Register to be set.",
        20, // LSB
        20, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTDCE",
        "Forces the DCE bit of Interrupt Status Register to be set.",
        21, // LSB
        21, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTDEBE",
        "Forces the DEBE bit of Interrupt Status Register to be set.",
        22, // LSB
        22, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTAC12E",
        "Forces the AC12E bit of Interrupt Status Register to be set.",
        24, // LSB
        24, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTTNE",
        "Forces the TNE bit of Interrupt Status Register to be set.",
        26, // LSB
        26, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTDMAE",
        "Forces the DMAE bit of Interrupt Status Register to be set.",
        28, // LSB
        28, // MSB
        false, // Readable
        false // Writable
    },
    {
        "FEVTCINT",
        "Writing 1 to this bit generates a short low-level pulse on the interna"
        "l DATA1 line, as if a self clearing interrupt was received from the ex"
        "ternal card.",
        31, // LSB
        31, // MSB
        false, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_ADMA_ERR_STATUS.
static const field_t hw_usdhc_adma_err_status[] =
{
    {
        "ADMAES",
        "This field indicates the state of the ADMA when an error has occurred "
        "during an ADMA data transfer.",
        0, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADMALME",
        "This error occurs in the following 2 cases: While the Block Count Enab"
        "le is being set, the total data length specified by the Descriptor tab"
        "le is different from that specified by the Block Count and Block Lengt"
        "h.",
        2, // LSB
        2, // MSB
        true, // Readable
        false // Writable
    },
    {
        "ADMADCE",
        "This error occurs when invalid descriptor fetched by ADMA.",
        3, // LSB
        3, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_ADMA_SYS_ADDR.
static const field_t hw_usdhc_adma_sys_addr[] =
{
    {
        "ADS_ADDR",
        "This register holds the word address of the executing command in the D"
        "escriptor table.",
        2, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_DLL_CTRL.
static const field_t hw_usdhc_dll_ctrl[] =
{
    {
        "DLL_CTRL_ENABLE",
        "Set this bit to 1 to enable the DLL and delay chain; otherwise; set to"
        " 0 to bypasses DLL.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_RESET",
        "Setting this bit to 1 force a reset on DLL.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_FORCE_UPD",
        "Setting this bit to 1, forces the slave delay line to update to the DL"
        "L calibrated value immediately.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_DLY_TARGET0",
        "The delay target for the uSDHC loopback read clock can be programmed i"
        "n 1/16th increments of an ref_clock half-period.",
        3, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_GATE_UPDATE",
        "Set this bit to 1 to prevent the DLL from updating (since when clock_i"
        "n exists, glitches may appear during DLL updates).",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OVERRIDE",
        "Set this bit to 1 to Enable manual override for slave delay chain usin"
        "g SLV_OVERRIDE_VAL; to set 0 to disable manual override.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_OVERRIDE_VAL",
        "When SLV_OVERRIDE = 1 This field is used to select 1 of 128 physical t"
        "aps manually.",
        9, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_DLY_TARGET1",
        "Refer to DLL_CTRL_SLV_DLY_TARGET0 below.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_SLV_UPDATE_INT",
        "Slave delay line update interval.",
        20, // LSB
        27, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLL_CTRL_REF_UPDATE_INT",
        "DLL control loop update interval.",
        28, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_DLL_STATUS.
static const field_t hw_usdhc_dll_status[] =
{
    {
        "DLL_STS_SLV_LOCK",
        "Slave delay-line lock status.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLL_STS_REF_LOCK",
        "Reference DLL lock status.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLL_STS_SLV_SEL",
        "Slave delay line select status.",
        2, // LSB
        8, // MSB
        true, // Readable
        false // Writable
    },
    {
        "DLL_STS_REF_SEL",
        "Reference delay line select taps.",
        9, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_CLK_TUNE_CTRL_STATUS.
static const field_t hw_usdhc_clk_tune_ctrl_status[] =
{
    {
        "DLY_CELL_SET_POST",
        "Set the number of delay cells on the feedback clock between CLK_OUT an"
        "d CLK_POST.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLY_CELL_SET_OUT",
        "Set the number of delay cells on the feedback clock between CLK_PRE an"
        "d CLK_OUT.",
        4, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DLY_CELL_SET_PRE",
        "Set the number of delay cells on the feedback clock between the feedba"
        "ck clock and CLK_PRE.",
        8, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "NXT_ERR",
        "NXT error which means the number of delay cells added on the feedback "
        "clock is too large.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAP_SEL_POST",
        "Reflect the number of delay cells added on the feedback clock between "
        "CLK_OUT and CLK_POST.",
        16, // LSB
        19, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAP_SEL_OUT",
        "Reflect the number of delay cells added on the feedback clock between "
        "CLK_PRE and CLK_OUT.",
        20, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TAP_SEL_PRE",
        "Reflects the number of delay cells added on the feedback clock between"
        " the feedback clock and CLK_PRE.",
        24, // LSB
        30, // MSB
        true, // Readable
        false // Writable
    },
    {
        "PRE_ERR",
        "PRE error which means the number of delay cells added on the feedback "
        "clock is too small.",
        31, // LSB
        31, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_VEND_SPEC.
static const field_t hw_usdhc_vend_spec[] =
{
    {
        "EXT_DMA_EN",
        "Enable the request to external DMA.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VSELECT",
        "Change the value of output signal VSELECT, to control the voltage on p"
        "ads for external card.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CONFLICT_CHK_EN",
        "It is not implemented in uSDHC IP.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AC12_WR_CHKBUSY_EN",
        "Check busy enable after auto CMD12 for write data packet",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DAT3_CD_POL",
        "Only for debug.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CD_POL",
        "Only for debug.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WP_POL",
        "Only for debug.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKONJ_IN_ABORT",
        "Only for debug.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "FRC_SDCLK_ON",
        "Force CLK output active",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPG_CLK_SOFT_EN",
        "",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HCLK_SOFT_EN",
        "Hardware auto-enables the AHB clock when the internal DMA is enabled e"
        "ven if HCLK_SOFT_EN is 0.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "IPG_PERCLK_SOFT_EN",
        "",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CARD_CLK_SOFT_EN",
        "",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CRC_CHK_DIS",
        "",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INT_ST_VAL",
        "Internal state value, reflecting the corresponding state value selecte"
        "d by Debug Select field.",
        16, // LSB
        23, // MSB
        true, // Readable
        false // Writable
    },
    {
        "CMD_BYTE_EN",
        "Byte access",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_MMC_BOOT.
static const field_t hw_usdhc_mmc_boot[] =
{
    {
        "DTOCV_ACK",
        "Boot ACK time out counter value.",
        0, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_ACK",
        "Boot ACK mode select",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_MODE",
        "Boot mode select",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_EN",
        "Boot mode enable",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "AUTO_SABG_EN",
        "During boot, enable auto stop at block gap function.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISABLE_TIME_OUT",
        "When this bit is set, there is no timeout check no matter whether BOOT"
        "_EN is set or not.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BOOT_BLK_CNT",
        "The value defines the Stop At Block Gap value of automatic mode.",
        16, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_VEND_SPEC2.
static const field_t hw_usdhc_vend_spec2[] =
{
    {
        "SDR104_TIMING_DIS",
        "Timeout counter test.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDR104_OE_DIS",
        "CMD_OE / DATA_OE logic generation test.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SDR104_NSD_DIS",
        "Interrupt window after abort command is sent.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CARD_INT_D3_TEST",
        "This bit only uses for debugging.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_8BIT_EN",
        "Enable the auto tuning circuit to check the DATA[7:0].",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_1BIT_EN",
        "Enable the auto tuning circuit to check the DATA0 only.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_CMD_EN",
        "Enable the auto tuning circuit to check the CMD line.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CARD_INT_AUTO_CLR_DIS",
        "Disable the feature to clear the Card interrupt status bit when Card I"
        "nterrupt status enable bit is cleared.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ACMD23_ARGU2_EN",
        "",
        23, // LSB
        23, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register uSDHC_TUNING_CTRL.
static const field_t hw_usdhc_tuning_ctrl[] =
{
    {
        "TUNING_START_TAP",
        "The start dealy cell point when send first CMD19 in tuning procedure.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_COUNTER",
        "The MAX repeat CMD19 times in tuning procedure.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_STEP",
        "The increasing delay cell steps in tuning procedure.",
        16, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    {
        "TUNING_WINDOW",
        "Select data window value for auto tuning",
        20, // LSB
        22, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STD_TUNING_EN",
        "Standard tuning circuit and procedure enable: This bit is used to enab"
        "le standard tuning circuit and procedure.",
        24, // LSB
        24, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a USDHC module.
static const reg_t hw_usdhc[] =
{
    {
        "DS_ADDR",
        "This register contains the physical system memory address used for DMA"
        " transfers.",
        4, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_ds_addr
    },
    {
        "BLK_ATT",
        "This register is used to configure the number of data blocks and the n"
        "umber of bytes in each block.",
        4, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_usdhc_blk_att
    },
    {
        "CMD_ARG",
        "This register contains the SD / MMC Command Argument.",
        4, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_arg
    },
    {
        "CMD_XFR_TYP",
        "This register is used to control the operation of data transfers.",
        4, // Width in bytes
        0x0000000c, // Base address offset
        true, // Readable
        true, // Writable
        6, // Number of bitfields
        hw_usdhc_cmd_xfr_typ
    },
    {
        "CMD_RSP0",
        "This register is used to store part 0 of the response bits from the ca"
        "rd.",
        4, // Width in bytes
        0x00000010, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp0
    },
    {
        "CMD_RSP1",
        "This register is used to store part 1 of the response bits from the ca"
        "rd.",
        4, // Width in bytes
        0x00000014, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp1
    },
    {
        "CMD_RSP2",
        "This register is used to store part 2 of the response bits from the ca"
        "rd.",
        4, // Width in bytes
        0x00000018, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp2
    },
    {
        "CMD_RSP3",
        "This register is used to store part 3 of the response bits from the ca"
        "rd.",
        4, // Width in bytes
        0x0000001c, // Base address offset
        true, // Readable
        false, // Writable
        1, // Number of bitfields
        hw_usdhc_cmd_rsp3
    },
    {
        "DATA_BUFF_ACC_PORT",
        "This is a 32-bit data port register used to access the internal buffer"
        ".",
        4, // Width in bytes
        0x00000020, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_data_buff_acc_port
    },
    {
        "PRES_STATE",
        "The Host Driver can get status of the uSDHC from this 32-bit read only"
        " register.",
        4, // Width in bytes
        0x00000024, // Base address offset
        true, // Readable
        false, // Writable
        19, // Number of bitfields
        hw_usdhc_pres_state
    },
    {
        "PROT_CTRL",
        "There are three cases to restart the transfer after stop at the block "
        "gap.",
        4, // Width in bytes
        0x00000028, // Base address offset
        true, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usdhc_prot_ctrl
    },
    {
        "SYS_CTRL",
        "",
        4, // Width in bytes
        0x0000002c, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usdhc_sys_ctrl
    },
    {
        "INT_STATUS",
        "An interrupt is generated when the Normal Interrupt Signal Enable is e"
        "nabled and at least one of the status bits is set to 1.",
        4, // Width in bytes
        0x00000030, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_usdhc_int_status
    },
    {
        "INT_STATUS_EN",
        "Setting the bits in this register to 1 enables the corresponding Inter"
        "rupt Status to be set by the specified event.",
        4, // Width in bytes
        0x00000034, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_usdhc_int_status_en
    },
    {
        "INT_SIGNAL_EN",
        "This register is used to select which interrupt status is indicated to"
        " the Host System as the interrupt.",
        4, // Width in bytes
        0x00000038, // Base address offset
        true, // Readable
        true, // Writable
        21, // Number of bitfields
        hw_usdhc_int_signal_en
    },
    {
        "AUTOCMD12_ERR_STATUS",
        "When the Auto CMD12 Error Status bit in the Status register is set, th"
        "e Host Driver shall check this register to identify what kind of error"
        " the Auto CMD12 / CMD 23 indicated.",
        4, // Width in bytes
        0x0000003c, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usdhc_autocmd12_err_status
    },
    {
        "HOST_CTRL_CAP",
        "This register provides the Host Driver with information specific to th"
        "e uSDHC implementation.",
        4, // Width in bytes
        0x00000040, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_usdhc_host_ctrl_cap
    },
    {
        "WTMK_LVL",
        "Both write and read watermark levels (FIFO threshold) are configurable"
        ".",
        4, // Width in bytes
        0x00000044, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_usdhc_wtmk_lvl
    },
    {
        "MIX_CTRL",
        "This register is used to DMA and data transfer.",
        4, // Width in bytes
        0x00000048, // Base address offset
        true, // Readable
        true, // Writable
        12, // Number of bitfields
        hw_usdhc_mix_ctrl
    },
    {
        "FORCE_EVENT",
        "The Force Event Register is not a physically implemented register.",
        4, // Width in bytes
        0x00000050, // Base address offset
        false, // Readable
        true, // Writable
        17, // Number of bitfields
        hw_usdhc_force_event
    },
    {
        "ADMA_ERR_STATUS",
        "When an ADMA Error Interrupt has occurred, the ADMA Error States field"
        " in this register holds the ADMA state and the ADMA System Address reg"
        "ister holds the address around the error descriptor.",
        4, // Width in bytes
        0x00000054, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_usdhc_adma_err_status
    },
    {
        "ADMA_SYS_ADDR",
        "This register contains the physical system memory address used for ADM"
        "A transfers.",
        4, // Width in bytes
        0x00000058, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_usdhc_adma_sys_addr
    },
    {
        "DLL_CTRL",
        "This register contains control bits for DLL.",
        4, // Width in bytes
        0x00000060, // Base address offset
        true, // Readable
        true, // Writable
        10, // Number of bitfields
        hw_usdhc_dll_ctrl
    },
    {
        "DLL_STATUS",
        "This register contains the DLL status information.",
        4, // Width in bytes
        0x00000064, // Base address offset
        true, // Readable
        false, // Writable
        4, // Number of bitfields
        hw_usdhc_dll_status
    },
    {
        "CLK_TUNE_CTRL_STATUS",
        "This register contains the Clock Tuning Control status information.",
        4, // Width in bytes
        0x00000068, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_usdhc_clk_tune_ctrl_status
    },
    {
        "VEND_SPEC",
        "This register contains the vendor specific control / status register.",
        4, // Width in bytes
        0x000000c0, // Base address offset
        true, // Readable
        true, // Writable
        16, // Number of bitfields
        hw_usdhc_vend_spec
    },
    {
        "MMC_BOOT",
        "This register contains the MMC Fast Boot control register.",
        4, // Width in bytes
        0x000000c4, // Base address offset
        true, // Readable
        true, // Writable
        7, // Number of bitfields
        hw_usdhc_mmc_boot
    },
    {
        "VEND_SPEC2",
        "This register contains the vendor specific control 2 register.",
        4, // Width in bytes
        0x000000c8, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_usdhc_vend_spec2
    },
    {
        "TUNING_CTRL",
        "The register contains configuration of tunning circuit.",
        4, // Width in bytes
        0x000000cc, // Base address offset
        true, // Readable
        true, // Writable
        5, // Number of bitfields
        hw_usdhc_tuning_ctrl
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark WDOG
#endif

// Bitfields in register WDOG_WCR.
static const field_t hw_wdog_wcr[] =
{
    {
        "WDZST",
        "Watchdog Low Power.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDBG",
        "Watchdog DEBUG Enable.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDE",
        "Watchdog Enable.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDT",
        "WDOG_B Time-out assertion.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRS",
        "Software Reset Signal.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDA",
        "WDOG_B assertion.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "SRE",
        "adopt a new way to generate a more robust software reset.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WDW",
        "Watchdog Disable for Wait.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WT",
        "Watchdog Time-out Field.",
        8, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WSR.
static const field_t hw_wdog_wsr[] =
{
    {
        "WSR",
        "Watchdog Service Register.",
        0, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WRSR.
static const field_t hw_wdog_wrsr[] =
{
    {
        "SFTW",
        "Software Reset.",
        0, // LSB
        0, // MSB
        true, // Readable
        false // Writable
    },
    {
        "TOUT",
        "Timeout.",
        1, // LSB
        1, // MSB
        true, // Readable
        false // Writable
    },
    {
        "POR",
        "Power On Reset.",
        4, // LSB
        4, // MSB
        true, // Readable
        false // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WICR.
static const field_t hw_wdog_wicr[] =
{
    {
        "WICT",
        "Watchdog Interrupt Count Time-out (WICT) field determines, how long be"
        "fore the counter time-out must the interrupt occur.",
        0, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WTIS",
        "Watchdog TImer Interrupt Status bit will reflect the timer interrupt s"
        "tatus, whether interrupt has occurred or not.",
        14, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "WIE",
        "Watchdog Timer Interrupt enable bit.",
        15, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register WDOG_WMCR.
static const field_t hw_wdog_wmcr[] =
{
    {
        "PDE",
        "Power Down Enable bit.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a WDOG module.
static const reg_t hw_wdog[] =
{
    {
        "WCR",
        "The Watchdog Control Register (WDOG_WCR) controls the WDOG operation.",
        2, // Width in bytes
        0x00000000, // Base address offset
        true, // Readable
        true, // Writable
        9, // Number of bitfields
        hw_wdog_wcr
    },
    {
        "WSR",
        "When enabled, the WDOG requires that a service sequence be written to "
        "the Watchdog Service Register (WSR) to prevent the timeout condition.",
        2, // Width in bytes
        0x00000002, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_wdog_wsr
    },
    {
        "WRSR",
        "The WRSR is a read-only register that records the source of the output"
        " reset assertion.",
        2, // Width in bytes
        0x00000004, // Base address offset
        true, // Readable
        false, // Writable
        3, // Number of bitfields
        hw_wdog_wrsr
    },
    {
        "WICR",
        "The WDOG_WICR controls the WDOG interrupt generation.",
        2, // Width in bytes
        0x00000006, // Base address offset
        true, // Readable
        true, // Writable
        3, // Number of bitfields
        hw_wdog_wicr
    },
    {
        "WMCR",
        "WDOG_WMCR Controls the Power Down counter operation.",
        2, // Width in bytes
        0x00000008, // Base address offset
        true, // Readable
        true, // Writable
        1, // Number of bitfields
        hw_wdog_wmcr
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark XTALOSC24M
#endif

// Bitfields in register XTALOSC24M_MISC0.
static const field_t hw_xtalosc24m_misc0[] =
{
    {
        "REFTOP_PWD",
        "Control bit to power-down the analog bandgap reference circuitry.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_SELFBIASOFF",
        "Control bit to disable the self-bias circuit in the analog bandgap.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGADJ",
        "Not related to oscillator.",
        4, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_VBGUP",
        "Status bit that signals the analog bandgap voltage is up and stable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "STOP_MODE_CONFIG",
        "Configure the analog behavior in stop mode.",
        10, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISCON_HIGH_SNVS",
        "This bit controls a switch from VDD_HIGH_IN to VDD_SNVS_IN.",
        12, // LSB
        12, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_I",
        "This field determines the bias current in the 24MHz oscillator.",
        13, // LSB
        14, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_XTALOK",
        "Status bit that signals that the output of the 24-MHz crystal oscillat"
        "or is stable.",
        15, // LSB
        15, // MSB
        true, // Readable
        false // Writable
    },
    {
        "OSC_XTALOK_EN",
        "This bit enables the detector that signals when the 24MHz crystal osci"
        "llator is stable.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_CTRL",
        "This bit allows disabling the clock gate (always ungated) for the xtal"
        " 24MHz clock that clocks the digital logic in the analog block.",
        25, // LSB
        25, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLKGATE_DELAY",
        "This field specifies the delay between powering up the XTAL 24MHz cloc"
        "k and releasing the clock to the digital logic inside the analog block"
        ".",
        26, // LSB
        28, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RTC_XTAL_SOURCE",
        "This field indicates which chip source is being used for the rtc clock"
        ".",
        29, // LSB
        29, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTAL_24M_PWD",
        "This field powers down the 24M crystal oscillator if set true.",
        30, // LSB
        30, // MSB
        true, // Readable
        true // Writable
    },
    {
        "VID_PLL_PREDIV",
        "Predivider for the source clock of the PLL's.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_LOWPWR_CTRL.
static const field_t hw_xtalosc24m_lowpwr_ctrl[] =
{
    {
        "RC_OSC_EN",
        "RC Osc.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_SEL",
        "Select the source for the 24MHz clock.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_SEL",
        "Bandgap select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_TEST",
        "Low power bandgap test bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_IBIAS_OFF",
        "Low power reftop ibias disable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1_PWRGATE",
        "L1 power gate control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PWRGATE",
        "L2 power gate control.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPU_PWRGATE",
        "CPU power gate control.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PWRGATE",
        "Display logic power gate control.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCOSC_CG_OVERRIDE",
        "For debug purposes only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_DELAY",
        "Specifies the time delay between when the 24MHz xtal is powered up unt"
        "il it is stable and ready to use.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_STAT",
        "Status of the 24MHz xtal oscillator.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIX_PWRGATE",
        "Display power gate control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_PWRGATE",
        "GPU power gate control.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_LOWPWR_CTRL_SET.
static const field_t hw_xtalosc24m_lowpwr_ctrl_set[] =
{
    {
        "RC_OSC_EN",
        "RC Osc.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_SEL",
        "Select the source for the 24MHz clock.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_SEL",
        "Bandgap select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_TEST",
        "Low power bandgap test bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_IBIAS_OFF",
        "Low power reftop ibias disable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1_PWRGATE",
        "L1 power gate control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PWRGATE",
        "L2 power gate control.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPU_PWRGATE",
        "CPU power gate control.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PWRGATE",
        "Display logic power gate control.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCOSC_CG_OVERRIDE",
        "For debug purposes only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_DELAY",
        "Specifies the time delay between when the 24MHz xtal is powered up unt"
        "il it is stable and ready to use.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_STAT",
        "Status of the 24MHz xtal oscillator.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIX_PWRGATE",
        "Display power gate control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_PWRGATE",
        "GPU power gate control.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_LOWPWR_CTRL_CLR.
static const field_t hw_xtalosc24m_lowpwr_ctrl_clr[] =
{
    {
        "RC_OSC_EN",
        "RC Osc.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_SEL",
        "Select the source for the 24MHz clock.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_SEL",
        "Bandgap select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_TEST",
        "Low power bandgap test bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_IBIAS_OFF",
        "Low power reftop ibias disable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1_PWRGATE",
        "L1 power gate control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PWRGATE",
        "L2 power gate control.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPU_PWRGATE",
        "CPU power gate control.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PWRGATE",
        "Display logic power gate control.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCOSC_CG_OVERRIDE",
        "For debug purposes only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_DELAY",
        "Specifies the time delay between when the 24MHz xtal is powered up unt"
        "il it is stable and ready to use.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_STAT",
        "Status of the 24MHz xtal oscillator.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIX_PWRGATE",
        "Display power gate control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_PWRGATE",
        "GPU power gate control.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_LOWPWR_CTRL_TOG.
static const field_t hw_xtalosc24m_lowpwr_ctrl_tog[] =
{
    {
        "RC_OSC_EN",
        "RC Osc.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        1, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "OSC_SEL",
        "Select the source for the 24MHz clock.",
        4, // LSB
        4, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_SEL",
        "Bandgap select.",
        5, // LSB
        5, // MSB
        true, // Readable
        true // Writable
    },
    {
        "LPBG_TEST",
        "Low power bandgap test bit.",
        6, // LSB
        6, // MSB
        true, // Readable
        true // Writable
    },
    {
        "REFTOP_IBIAS_OFF",
        "Low power reftop ibias disable.",
        7, // LSB
        7, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L1_PWRGATE",
        "L1 power gate control.",
        8, // LSB
        8, // MSB
        true, // Readable
        true // Writable
    },
    {
        "L2_PWRGATE",
        "L2 power gate control.",
        9, // LSB
        9, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CPU_PWRGATE",
        "CPU power gate control.",
        10, // LSB
        10, // MSB
        true, // Readable
        true // Writable
    },
    {
        "DISPLAY_PWRGATE",
        "Display logic power gate control.",
        11, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RCOSC_CG_OVERRIDE",
        "For debug purposes only.",
        13, // LSB
        13, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_DELAY",
        "Specifies the time delay between when the 24MHz xtal is powered up unt"
        "il it is stable and ready to use.",
        14, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "XTALOSC_PWRUP_STAT",
        "Status of the 24MHz xtal oscillator.",
        16, // LSB
        16, // MSB
        true, // Readable
        false // Writable
    },
    {
        "MIX_PWRGATE",
        "Display power gate control.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "GPU_PWRGATE",
        "GPU power gate control.",
        18, // LSB
        18, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG0.
static const field_t hw_xtalosc24m_osc_config0[] =
{
    {
        "START",
        "Start/stop bit for the RC tuning calculation logic.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enables the tuning logic to calculate new RC tuning values.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypasses any calculated RC tuning value and uses the programmed regist"
        "er value.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERT",
        "Invert the stepping of the calculated RC tuning value.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        4, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYST_PLUS",
        "Positive hysteresis value.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYST_MINUS",
        "Negative hysteresis value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG_CUR",
        "The current tuning value in use.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG0_SET.
static const field_t hw_xtalosc24m_osc_config0_set[] =
{
    {
        "START",
        "Start/stop bit for the RC tuning calculation logic.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enables the tuning logic to calculate new RC tuning values.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypasses any calculated RC tuning value and uses the programmed regist"
        "er value.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERT",
        "Invert the stepping of the calculated RC tuning value.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        4, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYST_PLUS",
        "Positive hysteresis value.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYST_MINUS",
        "Negative hysteresis value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG_CUR",
        "The current tuning value in use.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG0_CLR.
static const field_t hw_xtalosc24m_osc_config0_clr[] =
{
    {
        "START",
        "Start/stop bit for the RC tuning calculation logic.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enables the tuning logic to calculate new RC tuning values.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypasses any calculated RC tuning value and uses the programmed regist"
        "er value.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERT",
        "Invert the stepping of the calculated RC tuning value.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        4, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYST_PLUS",
        "Positive hysteresis value.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYST_MINUS",
        "Negative hysteresis value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG_CUR",
        "The current tuning value in use.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG0_TOG.
static const field_t hw_xtalosc24m_osc_config0_tog[] =
{
    {
        "START",
        "Start/stop bit for the RC tuning calculation logic.",
        0, // LSB
        0, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE",
        "Enables the tuning logic to calculate new RC tuning values.",
        1, // LSB
        1, // MSB
        true, // Readable
        true // Writable
    },
    {
        "BYPASS",
        "Bypasses any calculated RC tuning value and uses the programmed regist"
        "er value.",
        2, // LSB
        2, // MSB
        true, // Readable
        true // Writable
    },
    {
        "INVERT",
        "Invert the stepping of the calculated RC tuning value.",
        3, // LSB
        3, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG",
        "RC osc.",
        4, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYST_PLUS",
        "Positive hysteresis value.",
        12, // LSB
        15, // MSB
        true, // Readable
        true // Writable
    },
    {
        "HYST_MINUS",
        "Negative hysteresis value.",
        16, // LSB
        19, // MSB
        true, // Readable
        true // Writable
    },
    {
        "RC_OSC_PROG_CUR",
        "The current tuning value in use.",
        24, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG1.
static const field_t hw_xtalosc24m_osc_config1[] =
{
    {
        "COUNT_RC_TRG",
        "The target count used to tune the RC OSC frequency.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COUNT_RC_CUR",
        "The current tuning value in use.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG1_SET.
static const field_t hw_xtalosc24m_osc_config1_set[] =
{
    {
        "COUNT_RC_TRG",
        "The target count used to tune the RC OSC frequency.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COUNT_RC_CUR",
        "The current tuning value in use.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG1_CLR.
static const field_t hw_xtalosc24m_osc_config1_clr[] =
{
    {
        "COUNT_RC_TRG",
        "The target count used to tune the RC OSC frequency.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COUNT_RC_CUR",
        "The current tuning value in use.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG1_TOG.
static const field_t hw_xtalosc24m_osc_config1_tog[] =
{
    {
        "COUNT_RC_TRG",
        "The target count used to tune the RC OSC frequency.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "COUNT_RC_CUR",
        "The current tuning value in use.",
        20, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG2.
static const field_t hw_xtalosc24m_osc_config2[] =
{
    {
        "COUNT_1M_TRG",
        "The target count used to tune the RC OSC frequency.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_1M",
        "Enable the 1MHz clock output.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_1M",
        "Mux the corrected or uncorrected 1MHz clock to the output.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_1M_ERR_FL",
        "Flag indicates that the count_1m count wasn't reached within 1 32KHz p"
        "eriod.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG2_SET.
static const field_t hw_xtalosc24m_osc_config2_set[] =
{
    {
        "COUNT_1M_TRG",
        "The target count used to tune the RC OSC frequency.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_1M",
        "Enable the 1MHz clock output.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_1M",
        "Mux the corrected or uncorrected 1MHz clock to the output.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_1M_ERR_FL",
        "Flag indicates that the count_1m count wasn't reached within 1 32KHz p"
        "eriod.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG2_CLR.
static const field_t hw_xtalosc24m_osc_config2_clr[] =
{
    {
        "COUNT_1M_TRG",
        "The target count used to tune the RC OSC frequency.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_1M",
        "Enable the 1MHz clock output.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_1M",
        "Mux the corrected or uncorrected 1MHz clock to the output.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_1M_ERR_FL",
        "Flag indicates that the count_1m count wasn't reached within 1 32KHz p"
        "eriod.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Bitfields in register XTALOSC24M_OSC_CONFIG2_TOG.
static const field_t hw_xtalosc24m_osc_config2_tog[] =
{
    {
        "COUNT_1M_TRG",
        "The target count used to tune the RC OSC frequency.",
        0, // LSB
        11, // MSB
        true, // Readable
        true // Writable
    },
    {
        "ENABLE_1M",
        "Enable the 1MHz clock output.",
        16, // LSB
        16, // MSB
        true, // Readable
        true // Writable
    },
    {
        "MUX_1M",
        "Mux the corrected or uncorrected 1MHz clock to the output.",
        17, // LSB
        17, // MSB
        true, // Readable
        true // Writable
    },
    {
        "CLK_1M_ERR_FL",
        "Flag indicates that the count_1m count wasn't reached within 1 32KHz p"
        "eriod.",
        31, // LSB
        31, // MSB
        true, // Readable
        true // Writable
    },
    { 0 } // Terminator
};

// Registers in a XTALOSC24M module.
static const reg_t hw_xtalosc24m[] =
{
    {
        "MISC0",
        "This register defines the control and status bits for miscellaneous an"
        "alog blocks.",
        4, // Width in bytes
        0x00000150, // Base address offset
        true, // Readable
        true, // Writable
        14, // Number of bitfields
        hw_xtalosc24m_misc0
    },
    {
        "LOWPWR_CTRL",
        "This register defines xtal osc and low power configuration.",
        4, // Width in bytes
        0x00000270, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_xtalosc24m_lowpwr_ctrl
    },
    {
        "LOWPWR_CTRL_SET",
        "This register defines xtal osc and low power configuration.",
        4, // Width in bytes
        0x00000274, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_xtalosc24m_lowpwr_ctrl_set
    },
    {
        "LOWPWR_CTRL_CLR",
        "This register defines xtal osc and low power configuration.",
        4, // Width in bytes
        0x00000278, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_xtalosc24m_lowpwr_ctrl_clr
    },
    {
        "LOWPWR_CTRL_TOG",
        "This register defines xtal osc and low power configuration.",
        4, // Width in bytes
        0x0000027c, // Base address offset
        true, // Readable
        true, // Writable
        15, // Number of bitfields
        hw_xtalosc24m_lowpwr_ctrl_tog
    },
    {
        "OSC_CONFIG0",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002a0, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xtalosc24m_osc_config0
    },
    {
        "OSC_CONFIG0_SET",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002a4, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xtalosc24m_osc_config0_set
    },
    {
        "OSC_CONFIG0_CLR",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002a8, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xtalosc24m_osc_config0_clr
    },
    {
        "OSC_CONFIG0_TOG",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002ac, // Base address offset
        true, // Readable
        true, // Writable
        8, // Number of bitfields
        hw_xtalosc24m_osc_config0_tog
    },
    {
        "OSC_CONFIG1",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002b0, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xtalosc24m_osc_config1
    },
    {
        "OSC_CONFIG1_SET",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002b4, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xtalosc24m_osc_config1_set
    },
    {
        "OSC_CONFIG1_CLR",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002b8, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xtalosc24m_osc_config1_clr
    },
    {
        "OSC_CONFIG1_TOG",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002bc, // Base address offset
        true, // Readable
        true, // Writable
        2, // Number of bitfields
        hw_xtalosc24m_osc_config1_tog
    },
    {
        "OSC_CONFIG2",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002c0, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_xtalosc24m_osc_config2
    },
    {
        "OSC_CONFIG2_SET",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002c4, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_xtalosc24m_osc_config2_set
    },
    {
        "OSC_CONFIG2_CLR",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002c8, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_xtalosc24m_osc_config2_clr
    },
    {
        "OSC_CONFIG2_TOG",
        "This register is used to configure the 24MHz RC oscillator.",
        4, // Width in bytes
        0x000002cc, // Base address offset
        true, // Readable
        true, // Writable
        4, // Number of bitfields
        hw_xtalosc24m_osc_config2_tog
    },
    { 0 } // Terminator
};

//------------------------------------------------------------------------------
#if __nonexistant__
#pragma mark mx6
#endif

const module_t mx6ul[] =
{
    // Module name, instance number, base address, register count, register definitions
    { "ADC1",           1, 0x02198000, 11,   hw_adc },
    { "ADC2",           2, 0x0219c000, 11,   hw_adc },
    { "APBH",           1, 0x01804000, 132,  hw_apbh },
    { "ASRC",           1, 0x02034000, 38,   hw_asrc },
    { "BCH",            1, 0x01808000, 92,   hw_bch },
    { "CCM",            1, 0x020c4000, 31,   hw_ccm },
    { "CCM_ANALOG",     1, 0x020c8000, 55,   hw_ccm_analog },
    { "CSI",            1, 0x021c4000, 14,   hw_csi },
    { "ECSPI1",         1, 0x02008000, 10,   hw_ecspi },
    { "ECSPI2",         2, 0x0200c000, 10,   hw_ecspi },
    { "ECSPI3",         3, 0x02010000, 10,   hw_ecspi },
    { "ECSPI4",         4, 0x02014000, 10,   hw_ecspi },
    { "EIM",            1, 0x021b8000, 37,   hw_eim },
    { "EMVSIM1",        1, 0x0218c000, 19,   hw_emvsim },
    { "EMVSIM2",        2, 0x021b4000, 19,   hw_emvsim },
    { "ENET1",          1, 0x02188000, 104,  hw_enet },
    { "ENET2",          2, 0x020b4000, 104,  hw_enet },
    { "EPIT1",          1, 0x020d0000, 5,    hw_epit },
    { "EPIT2",          2, 0x020d4000, 5,    hw_epit },
    { "FLEXCAN1",       1, 0x02090000, 19,   hw_flexcan },
    { "FLEXCAN2",       2, 0x02094000, 19,   hw_flexcan },
    { "GPC",            1, 0x020dc000, 10,   hw_gpc },
    { "GPIO1",          1, 0x0209c000, 8,    hw_gpio },
    { "GPIO2",          2, 0x020a0000, 8,    hw_gpio },
    { "GPIO3",          3, 0x020a4000, 8,    hw_gpio },
    { "GPIO4",          4, 0x020a8000, 8,    hw_gpio },
    { "GPIO5",          5, 0x020ac000, 8,    hw_gpio },
    { "GPMI",           1, 0x01806000, 29,   hw_gpmi },
    { "GPT1",           1, 0x02098000, 10,   hw_gpt },
    { "GPT2",           2, 0x020e8000, 10,   hw_gpt },
    { "I2C1",           1, 0x021a0000, 5,    hw_i2c },
    { "I2C2",           2, 0x021a4000, 5,    hw_i2c },
    { "I2C3",           3, 0x021a8000, 5,    hw_i2c },
    { "I2C4",           4, 0x021f8000, 5,    hw_i2c },
    { "I2S1",           1, 0x02028000, 18,   hw_i2s },
    { "I2S2",           2, 0x0202c000, 18,   hw_i2s },
    { "I2S3",           3, 0x02030000, 18,   hw_i2s },
    { "IOMUXC",         1, 0x020e0000, 419,  hw_iomuxc },
    { "IOMUXC_GPR",     1, 0x020e4000, 9,    hw_iomuxc_gpr },
    { "KPP",            1, 0x020b8000, 4,    hw_kpp },
    { "LCDIF",          1, 0x021c8000, 54,   hw_lcdif },
    { "MMDC",           1, 0x021b0000, 69,   hw_mmdc },
    { "OCOTP",          1, 0x021bc000, 144,  hw_ocotp },
    { "PMU",            1, 0x020c8000, 16,   hw_pmu },
    { "PWM1",           1, 0x02080000, 6,    hw_pwm },
    { "PWM2",           2, 0x02084000, 6,    hw_pwm },
    { "PWM3",           3, 0x02088000, 6,    hw_pwm },
    { "PWM4",           4, 0x0208c000, 6,    hw_pwm },
    { "PWM5",           5, 0x020f0000, 6,    hw_pwm },
    { "PWM6",           6, 0x020f4000, 6,    hw_pwm },
    { "PWM7",           7, 0x020f8000, 6,    hw_pwm },
    { "PWM8",           8, 0x020fc000, 6,    hw_pwm },
    { "PXP",            1, 0x021cc000, 52,   hw_pxp },
    { "QUADSPI",        1, 0x021e0000, 124,  hw_quadspi },
    { "ROMC",           1, 0x021ac000, 28,   hw_romc },
    { "SDMAARM",        1, 0x020ec000, 106,  hw_sdmaarm },
    { "SDMABP",         1, 0x020ec000, 7,    hw_sdmabp },
    { "SDMACORE",       1, 0x020ec000, 21,   hw_sdmacore },
    { "SJC",            1, 0x00000000, 7,    hw_sjc },
    { "SNVS",           1, 0x020cc000, 16,   hw_snvs },
    { "SPBA",           1, 0x0203c000, 32,   hw_spba },
    { "SPDIF",          1, 0x02004000, 18,   hw_spdif },
    { "SRC",            1, 0x020d8000, 15,   hw_src },
    { "TEMPMON",        1, 0x020c8000, 12,   hw_tempmon },
    { "TSC",            1, 0x02040000, 9,    hw_tsc },
    { "UART1",          1, 0x02020000, 17,   hw_uart },
    { "UART2",          2, 0x021e8000, 17,   hw_uart },
    { "UART3",          3, 0x021ec000, 17,   hw_uart },
    { "UART4",          4, 0x021f0000, 17,   hw_uart },
    { "UART5",          5, 0x021f4000, 17,   hw_uart },
    { "UART6",          6, 0x021fc000, 17,   hw_uart },
    { "UART7",          7, 0x02018000, 17,   hw_uart },
    { "UART8",          8, 0x02024000, 17,   hw_uart },
    { "USB",            1, 0x02184000, 92,   hw_usb },
    { "USBNC",          1, 0x02184000, 4,    hw_usbnc },
    { "USBPHY1",        1, 0x020c9000, 27,   hw_usbphy },
    { "USBPHY2",        2, 0x020ca000, 27,   hw_usbphy },
    { "USDHC1",         1, 0x02190000, 29,   hw_usdhc },
    { "USDHC2",         2, 0x02194000, 29,   hw_usdhc },
    { "WDOG1",          1, 0x020bc000, 5,    hw_wdog },
    { "WDOG2",          2, 0x020c0000, 5,    hw_wdog },
    { "WDOG3",          3, 0x021e4000, 5,    hw_wdog },
    { "XTALOSC24M",     1, 0x020c8000, 17,   hw_xtalosc24m },
    { 0 } // Terminator
};

////////////////////////////////////////////////////////////////////////////////
